<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>线程池 on l1nker4&#39;s Blog</title>
    <link>http://localhost:1313/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
    <description>Recent content in 线程池 on l1nker4&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Nov 2020 14:05:34 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解析线程池ThreadPoolExecutor</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/%E8%A7%A3%E6%9E%90%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor/</link>
      <pubDate>Thu, 26 Nov 2020 14:05:34 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/%E8%A7%A3%E6%9E%90%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor/</guid>
      <description>&lt;h1 id=&#34;什么是线程池&#34;&gt;什么是线程池&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;Thread Pool&lt;/code&gt;是一种基于池化思想管理线程的工具，经常出现在多线程程序中。&lt;/p&gt;&#xA;&lt;p&gt;线程池的优点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;降低资源消耗：通过池化技术重复利用已创建线程。&lt;/li&gt;&#xA;&lt;li&gt;提高响应速度：任务到达时，无需等待进程创建即可执行。&lt;/li&gt;&#xA;&lt;li&gt;提高线程的可管理性：使用线程池进行统一的分配、调优和监控。&lt;/li&gt;&#xA;&lt;li&gt;提供更多强大的功能：线程池具备可扩展性，允许开发人员向其中增加更多功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;为什么用线程池&#34;&gt;为什么用线程池&lt;/h1&gt;&#xA;&lt;p&gt;直接创建线程存在性能开销：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Java中线程是基于内核线程实现的，线程的创建和销毁需要进行系统调用，性能开销较高。&lt;/li&gt;&#xA;&lt;li&gt;Java8中，每个&lt;code&gt;Thread&lt;/code&gt;都需要有一个内核线程的支持，这意味着每个&lt;code&gt;Thread&lt;/code&gt;都需要消耗一定的内核资源。Java8中每个线程栈大小是1M，Java11中，对创建线程操作进行优化，创建一个线程只需要40KB左右。&lt;/li&gt;&#xA;&lt;li&gt;线程切换引起&lt;code&gt;context switch&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;​&#x9;&#x9;使用线程池解决的核心问题就是&lt;strong&gt;资源管理问题&lt;/strong&gt;，多线程环境下，不确定性会带来一些问题：频繁申请/销毁线程会带来额外的开销、存在资源耗尽的风险等。&lt;/p&gt;&#xA;&lt;p&gt;​&#x9;&#x9;使用池化思想将资源统一在一起管理的一种思想，可以最大化收益最小化风险，&lt;/p&gt;&#xA;&lt;h1 id=&#34;threadpoolexecutor&#34;&gt;ThreadPoolExecutor&lt;/h1&gt;&#xA;&lt;h2 id=&#34;继承关系&#34;&gt;继承关系&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类的继承关系如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/pool/ThreadPoolExecutor.jpg&#34; alt=&#34;ThreadPoolExecutor继承关系&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Executor：顶层的&lt;code&gt;Executor&lt;/code&gt;仅提供一个&lt;code&gt;execute()&lt;/code&gt;接口，实现了提交任务与执行任务的解耦。&lt;/li&gt;&#xA;&lt;li&gt;ExecutorService：继承自&lt;code&gt;Executor&lt;/code&gt;，实现了添加了其他接口，例如：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为一个或一批异步任务生成Future的方法&lt;/li&gt;&#xA;&lt;li&gt;提供了管控线程池的方法，例如停止线程池运行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AbstractExecutorService：实现了&lt;code&gt;ExecutorService&lt;/code&gt;，实现了除&lt;code&gt;execute()&lt;/code&gt;以外的所有方法，将最重要的&lt;code&gt;execute()&lt;/code&gt;交给&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;运行机制&#34;&gt;运行机制&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的基本运行机制如下图所示（图片来源：美团技术团队）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/pool/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png&#34; alt=&#34;ThreadPoolExecutor&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;线程池内部相当于一个生产者消费者模型，将线程池分成两个部分：任务管理、线程管理。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;任务管理相当于生产者，任务提交后，线程池判断该任务的后续操作。&#xA;&lt;ol&gt;&#xA;&lt;li&gt;直接申请线程执行该任务&lt;/li&gt;&#xA;&lt;li&gt;存放到阻塞队列中等待&lt;/li&gt;&#xA;&lt;li&gt;拒绝该任务。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;线程管理部分是消费者，根据任务请求进行线程分配工作，当线程执行完任务后会继续获取新的任务去执行，最终当线程获取不到任务时，线程会进行回收。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;构造方法&#34;&gt;构造方法&lt;/h2&gt;&#xA;&lt;p&gt;核心的构造方法如下，主要参数有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;：核心线程数量&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;maximumPoolSize&lt;/strong&gt;：最大线程数量&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;workQueue&lt;/strong&gt;：BlockingQueue类型，保存等待执行任务的阻塞队列，当提交一个新的任务到线程池时，线程池根据当前状态决定后续处理。可选择以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ArrayBlockingQueue&lt;/li&gt;&#xA;&lt;li&gt;LinkedBlockingQueue：Executors.newFixedThreadPool使用该队列&lt;/li&gt;&#xA;&lt;li&gt;SynchronousQueue：同步队列，容量为0，put必须等待take，take等待put，Executors.newCachedThreadPool使用该队列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;keepAliveTime&lt;/strong&gt;：线程池维护线程所允许的时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;threadFactory&lt;/strong&gt;：它是&lt;code&gt;ThreadFactory&lt;/code&gt;类型的变量，用来创建新线程。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;handler&lt;/strong&gt;：&lt;code&gt;RejectedExecutionHandler&lt;/code&gt;类型，表示线程池的拒绝策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadPoolExecutor&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; corePoolSize,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                              &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maximumPoolSize,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                              &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; keepAliveTime,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                              TimeUnit unit,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                              BlockingQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Runnable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; workQueue,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                              ThreadFactory threadFactory,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                              RejectedExecutionHandler handler) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (corePoolSize &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            maximumPoolSize &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            maximumPoolSize &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; corePoolSize &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            keepAliveTime &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IllegalArgumentException();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (workQueue &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; threadFactory &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; handler &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NullPointerException();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;acc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; System.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSecurityManager&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; :&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                AccessController.&lt;span style=&#34;color:#a6e22e&#34;&gt;getContext&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;corePoolSize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; corePoolSize;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;maximumPoolSize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; maximumPoolSize;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;workQueue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; workQueue;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;keepAliveTime&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unit.&lt;span style=&#34;color:#a6e22e&#34;&gt;toNanos&lt;/span&gt;(keepAliveTime);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;threadFactory&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; threadFactory;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; handler;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;线程池的状态&#34;&gt;线程池的状态&lt;/h2&gt;&#xA;&lt;p&gt;线程池的运行状态，由&lt;code&gt;AtomicInteger ctl&lt;/code&gt;维护，其中分为两个参数：&lt;code&gt;runState&lt;/code&gt;和&lt;code&gt;workerCount&lt;/code&gt;，高3位存储&lt;code&gt;runState&lt;/code&gt;，低29位存储&lt;code&gt;workerCount&lt;/code&gt;，提供了位运算的方法来获取对应的参数。线程池的运行状态，通过内部进行调整。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
