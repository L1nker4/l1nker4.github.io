<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发 on l1nker4&#39;s Blog</title>
    <link>http://localhost:1313/tags/%E5%B9%B6%E5%8F%91/</link>
    <description>Recent content in 并发 on l1nker4&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 03 Dec 2020 11:17:38 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ThreadLocal解析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java-threadlocal/</link>
      <pubDate>Thu, 03 Dec 2020 11:17:38 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java-threadlocal/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; method) has its own, independently initialized copy of the variable. &lt;code&gt;ThreadLocal&lt;/code&gt; instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;简而言之，&lt;code&gt;ThreadLocal&lt;/code&gt;可以创建一个只能被当前线程访问或修改的变量。&lt;/p&gt;&#xA;&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何实现线程隔离？&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;使用&lt;code&gt;Thread&lt;/code&gt;对象中的&lt;code&gt;ThreadLocalMap&lt;/code&gt;进行数据存储。也就是&lt;code&gt;ThreadLocal&lt;/code&gt;将数据存储到当前的线程对象中，通过&lt;code&gt;Thread.currentThread()&lt;/code&gt;来获取线程，再通过&lt;code&gt;getMap(t)&lt;/code&gt;来获取&lt;code&gt;ThreadLocalMap&lt;/code&gt;。具体内容通过阅读源码来逐步分析。&lt;/p&gt;&#xA;&lt;h2 id=&#34;get&#34;&gt;get&lt;/h2&gt;&#xA;&lt;p&gt;返回当前线程存储的&lt;code&gt;ThreadLocal&lt;/code&gt;值，如果不存在，会进行初始化并返回。通过&lt;code&gt;map.getEntry(this)&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Returns the value in the current thread&amp;#39;s copy of this&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * thread-local variable.  If the variable has no value for the&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * current thread, it is first initialized to the value returned&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * by an invocation of the {@link #initialValue} method.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @return the current thread&amp;#39;s value of this thread-local&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; T &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//获取当前对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//通过getMap获取ThreadLocalMap&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ThreadLocalMap map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getMap(t);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (map &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//获取entry&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ThreadLocalMap.&lt;span style=&#34;color:#a6e22e&#34;&gt;Entry&lt;/span&gt; e &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map.&lt;span style=&#34;color:#a6e22e&#34;&gt;getEntry&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (e &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unchecked&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            T result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (T)e.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//不存在则进行初始化&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; setInitialValue();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;getmap&#34;&gt;getMap&lt;/h2&gt;&#xA;&lt;p&gt;返回指定线程的&lt;code&gt;ThreadLocalMap&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>几个Java并发工具类解析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/%E5%87%A0%E4%B8%AAjava%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 29 Nov 2020 22:40:17 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/%E5%87%A0%E4%B8%AAjava%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;countdownlatch&#34;&gt;CountDownLatch&lt;/h1&gt;&#xA;&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;只有当N个线程执行完毕，并且进行&lt;code&gt;countDown&lt;/code&gt;操作时，才允许&lt;code&gt;await&lt;/code&gt;的线程继续执行。否则该线程挂起。&lt;/p&gt;&#xA;&lt;p&gt;适用情况：一个线程需要等待其他N个线程执行完毕，再继续执行，是join的替代。&lt;/p&gt;&#xA;&lt;h2 id=&#34;构造方法&#34;&gt;构造方法&lt;/h2&gt;&#xA;&lt;p&gt;参数&lt;code&gt;count&lt;/code&gt;为计数值，传入&lt;code&gt;AQS&lt;/code&gt;的实现类&lt;code&gt;Sync&lt;/code&gt;设置成AQS的&lt;code&gt;state&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CountDownLatch&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; count) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (count &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0) &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;count &amp;lt; 0&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Sync(count);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;sync&#34;&gt;Sync&lt;/h2&gt;&#xA;&lt;p&gt;通过继承&lt;code&gt;AQS&lt;/code&gt;从而完成同步的核心功能。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Sync&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; AbstractQueuedSynchronizer {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; serialVersionUID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 4982264981922014374L;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//构造方法&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Sync(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; count) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            setState(count);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getCount&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; getState();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tryAcquireShared&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; acquires) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (getState() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; 1 : &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tryReleaseShared&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; releases) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// Decrement count; signal when transition to zero&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (;;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getState();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; nextc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (compareAndSetState(c, nextc))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; nextc &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;核心方法&#34;&gt;核心方法&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;countDown&lt;/strong&gt;：将count值减1&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;await&lt;/strong&gt;：调用&lt;strong&gt;await&lt;/strong&gt;的线程会被挂起，直到&lt;code&gt;count&lt;/code&gt;为0才继续执行，允许中断&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sync.&lt;span style=&#34;color:#a6e22e&#34;&gt;acquireSharedInterruptibly&lt;/span&gt;(1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sync.&lt;span style=&#34;color:#a6e22e&#34;&gt;releaseShared&lt;/span&gt;(1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sync.&lt;span style=&#34;color:#a6e22e&#34;&gt;tryAcquireSharedNanos&lt;/span&gt;(1, unit.&lt;span style=&#34;color:#a6e22e&#34;&gt;toNanos&lt;/span&gt;(timeout));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;使用案例&#34;&gt;使用案例&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Driver&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// ...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     CountDownLatch startSignal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CountDownLatch(1);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     CountDownLatch doneSignal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CountDownLatch(N);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) &lt;span style=&#34;color:#75715e&#34;&gt;// create and start threads&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Worker(startSignal, doneSignal)).&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     doSomethingElse();            &lt;span style=&#34;color:#75715e&#34;&gt;// don&amp;#39;t let run yet&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     startSignal.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();      &lt;span style=&#34;color:#75715e&#34;&gt;// let all threads proceed&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     doSomethingElse();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     doneSignal.&lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt;();           &lt;span style=&#34;color:#75715e&#34;&gt;// wait for all to finish&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Worker&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Runnable {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; CountDownLatch startSignal;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; CountDownLatch doneSignal;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;startSignal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; startSignal;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;doneSignal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; doneSignal;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        startSignal.&lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        doWork();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        doneSignal.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (InterruptedException ex) {} &lt;span style=&#34;color:#75715e&#34;&gt;// return;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;doWork&lt;/span&gt;() { ... }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;cyclicbarrier&#34;&gt;CyclicBarrier&lt;/h1&gt;&#xA;&lt;h2 id=&#34;简介-1&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called &lt;em&gt;cyclic&lt;/em&gt; because it can be re-used after the waiting threads are released.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ReentrantReadWriteLock源码分析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/reentrantreadwritelock/</link>
      <pubDate>Sun, 22 Nov 2020 17:00:43 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/reentrantreadwritelock/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;ReentrantReadWriteLock分为读锁和写锁两个实例，读锁是共享锁，可被多个读线程同时使用，写锁是独占锁。持有写锁的线程可以继续获取读锁，反之不行。&lt;/p&gt;&#xA;&lt;p&gt;Doug Lea 将持有写锁的线程，去获取读锁，之后释放读锁，最后释放写锁，从写锁降级为读锁的过程称为&lt;strong&gt;锁降级（Lock downgrading）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;但是，&lt;strong&gt;锁升级&lt;/strong&gt;是不可以的。线程持有读锁的话，在没释放的情况下不能去获取写锁，因为会发生&lt;strong&gt;死锁&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h1 id=&#34;类的继承关系&#34;&gt;类的继承关系&lt;/h1&gt;&#xA;&lt;p&gt;ReentrantReadWriteLock实现了ReadWriteLock接口，该接口定义了两个方法，分别返回读锁和写锁。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReentrantReadWriteLock&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; ReadWriteLock, java.&lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Serializable&lt;/span&gt; {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadWriteLock&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * Returns the lock used for reading.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return the lock used for reading&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Lock &lt;span style=&#34;color:#a6e22e&#34;&gt;readLock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * Returns the lock used for writing.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return the lock used for writing&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Lock &lt;span style=&#34;color:#a6e22e&#34;&gt;writeLock&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;类成员属性&#34;&gt;类成员属性&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//读锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; ReentrantReadWriteLock.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadLock&lt;/span&gt; readerLock;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//写锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; ReentrantReadWriteLock.&lt;span style=&#34;color:#a6e22e&#34;&gt;WriteLock&lt;/span&gt; writerLock;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//Sync是AQS的实现类&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Sync sync;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//Unsafe实例&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; sun.&lt;span style=&#34;color:#a6e22e&#34;&gt;misc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unsafe&lt;/span&gt; UNSAFE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//获取Thread.tid的内存偏移值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; TID_OFFSET;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            UNSAFE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sun.&lt;span style=&#34;color:#a6e22e&#34;&gt;misc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getUnsafe&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Class&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; tk &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            TID_OFFSET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; UNSAFE.&lt;span style=&#34;color:#a6e22e&#34;&gt;objectFieldOffset&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                (tk.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDeclaredField&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tid&amp;#34;&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception e) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Error(e);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;构造方法&#34;&gt;构造方法&lt;/h1&gt;&#xA;&lt;p&gt;默认的构造方法创建非公平策略的&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;，传入&lt;code&gt;true&lt;/code&gt;则可以创建公平策略的&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ReentrantLock源码分析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/reentrantlock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 20 Nov 2020 12:40:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/reentrantlock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;相对于&lt;code&gt;synchronized&lt;/code&gt;关键字，&lt;code&gt;ReentrantLock&lt;/code&gt;具备以下特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可中断&lt;/li&gt;&#xA;&lt;li&gt;可设置超时时间&lt;/li&gt;&#xA;&lt;li&gt;可设置为公平锁&lt;/li&gt;&#xA;&lt;li&gt;支持多个条件变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;源码实现&#34;&gt;源码实现&lt;/h1&gt;&#xA;&lt;p&gt;可重入锁的实现上，主要关注两点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重入线程的再次获取锁的处理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重入锁的释放机制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类的继承关系&#34;&gt;类的继承关系&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;实现了&lt;code&gt;Lock&lt;/code&gt;接口，&lt;code&gt;Lock&lt;/code&gt;接口定义了锁的通用方法。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReentrantLock&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Lock, java.&lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Serializable&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;成员变量&#34;&gt;成员变量&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;sync&lt;/code&gt;代表当前&lt;code&gt;ReentrantLock&lt;/code&gt;使用的获取策略。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Sync sync;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; serialVersionUID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 7373984872572414699L;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;构造方法&#34;&gt;构造方法&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无参构造方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;默认是非公平策略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;有参构造方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传入&lt;code&gt;true&lt;/code&gt;使用公平策略。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * Creates an instance of {@code ReentrantLock}.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * This is equivalent to using {@code ReentrantLock(false)}.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReentrantLock&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sync &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NonfairSync();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * Creates an instance of {@code ReentrantLock} with the&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * given fairness policy.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @param fair {@code true} if this lock should use a fair ordering policy&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReentrantLock&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; fair) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sync &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fair &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FairSync() : &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NonfairSync();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;获取锁的策略&#34;&gt;获取锁的策略&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;内部有三个内部类，其中&lt;code&gt;Sync&lt;/code&gt;是其它两个类&lt;code&gt;NonfairSync&lt;/code&gt;和&lt;code&gt;FairSync&lt;/code&gt;的父类，分别代表着非公平策略和公平策略。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LockSupport源码分析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/locksupport%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 08 Nov 2020 12:46:28 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/locksupport%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Basic thread blocking primitives for creating locks and other synchronization classes.   &amp;ndash; Java Doc&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;LockSupport&lt;/code&gt;是用来创建锁和其它同步类的基本线程阻塞原语。底层依赖&lt;code&gt;Unsafe&lt;/code&gt;实现，我们可以在其它的并发同步工具类的实现中看到该类的使用。&lt;code&gt;LockSupport&lt;/code&gt;提供了&lt;code&gt;park()&lt;/code&gt;和&lt;code&gt;unpark()&lt;/code&gt;方法来分别实现阻塞线程和唤醒线程，每个使用&lt;code&gt;LockSupport&lt;/code&gt;的线程都有一个&lt;code&gt;permit&lt;/code&gt;，该值默认为0，取值0,1。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;unpark()&lt;/code&gt;：如果&lt;code&gt;permit&lt;/code&gt;当前值为0，将其自增1。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;park()&lt;/code&gt;：如果当前&lt;code&gt;permit&lt;/code&gt;为1，将其自减1并立即返回，如果为0，直接阻塞。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这两个方法不会有&lt;code&gt;Thread.suspend&lt;/code&gt; 和&lt;code&gt;Thread.resume&lt;/code&gt;所可能引发的死锁问题，因为&lt;code&gt;permit&lt;/code&gt;存在，调用 &lt;code&gt;park &lt;/code&gt;的线程和另一个试图将其 &lt;code&gt;unpark &lt;/code&gt;的线程之间的竞争将保持活性。&lt;/p&gt;&#xA;&lt;p&gt;如果调用线程被中断，那么&lt;code&gt;park&lt;/code&gt;将会返回。&lt;code&gt;park&lt;/code&gt;方法可能在任何时间&lt;strong&gt;no reason&lt;/strong&gt;地返回，因此通常在重新检查返回条件地循环里调用此方法。在某种意义上，&lt;code&gt;park&lt;/code&gt;是&lt;strong&gt;busy wait&lt;/strong&gt;（忙则等待）的一种优化，减少了自旋对性能的消耗。当时必须与&lt;code&gt;unpark&lt;/code&gt;配合使用才会更加高效。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;park&lt;/code&gt;还提供了支持&lt;code&gt;blocker&lt;/code&gt;参数的方法，&lt;code&gt;blocker&lt;/code&gt;对象在线程受阻塞时被记录，用于允许监视和诊断工具确定线程被阻塞的原因。提供了&lt;code&gt;getBlocker(Thread t)&lt;/code&gt;来访问&lt;code&gt;blocker&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;下面是&lt;code&gt;Java Docs&lt;/code&gt;中的示例用法：一个先进先出非重入锁类的基本框架：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FIFOMutex&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; AtomicBoolean locked &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; AtomicBoolean(&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Queue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Thread&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; waiters&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ConcurrentLinkedQueue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Thread&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; wasInterrupted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      Thread current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      waiters.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(current);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Block while not first in queue or cannot acquire lock&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (waiters.&lt;span style=&#34;color:#a6e22e&#34;&gt;peek&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; current &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;locked.&lt;span style=&#34;color:#a6e22e&#34;&gt;compareAndSet&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        LockSupport.&lt;span style=&#34;color:#a6e22e&#34;&gt;park&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;interrupted&lt;/span&gt;()) &lt;span style=&#34;color:#75715e&#34;&gt;// ignore interrupts while waiting&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          wasInterrupted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      waiters.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wasInterrupted)          &lt;span style=&#34;color:#75715e&#34;&gt;// reassert interrupt status on exit&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        current.&lt;span style=&#34;color:#a6e22e&#34;&gt;interrupt&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      locked.&lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      LockSupport.&lt;span style=&#34;color:#a6e22e&#34;&gt;unpark&lt;/span&gt;(waiters.&lt;span style=&#34;color:#a6e22e&#34;&gt;peek&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;源码解读&#34;&gt;源码解读&lt;/h2&gt;&#xA;&lt;h3 id=&#34;成员变量&#34;&gt;成员变量&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UNSAFE：用于进行内存级别操作的工具类。&lt;/li&gt;&#xA;&lt;li&gt;parkBlockerOffset：存储&lt;code&gt;Thread.parkBlocker&lt;/code&gt;的内存偏移地址，记录线程被谁阻塞的。用于线程监控和分析工具用来定位原因的。可以通过&lt;code&gt;getBlocker&lt;/code&gt;获取到阻塞的对象。&lt;/li&gt;&#xA;&lt;li&gt;SEED：存储&lt;code&gt;Thread.threadLocalRandomSeed&lt;/code&gt;的内存偏移地址&lt;/li&gt;&#xA;&lt;li&gt;PROBE：存储&lt;code&gt;Thread.threadLocalRandomProbe&lt;/code&gt;的内存偏移地址&lt;/li&gt;&#xA;&lt;li&gt;SECONDARY：存储&lt;code&gt;Thread.threadLocalRandomSecondarySeed&lt;/code&gt;的内存偏移地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; sun.&lt;span style=&#34;color:#a6e22e&#34;&gt;misc&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unsafe&lt;/span&gt; UNSAFE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; parkBlockerOffset;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; SEED;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; PROBE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; SECONDARY;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;构造方法&#34;&gt;构造方法&lt;/h3&gt;&#xA;&lt;p&gt;不允许实例化，只能通过调用静态方法来完成操作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java原子类的使用与实现</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 29 Oct 2020 19:39:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;通常情况下，在Java中，&lt;code&gt;++i&lt;/code&gt;这类自增/自减运算符在并发环境中不能保证并发安全。需要通过加锁才能解决并发环境下的原子性问题。Atomic原子类通过CAS方式来解决线程安全问题，CAS是一种无锁算法（乐观锁），乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。&lt;/p&gt;&#xA;&lt;p&gt;Atomic原子类分为以下几类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本类型：AtomicInteger，AtomicLong，AtomicBoolean&lt;/li&gt;&#xA;&lt;li&gt;数组类型：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray&lt;/li&gt;&#xA;&lt;li&gt;引用类型：AtomicReference，AtomicStampedRerence，AtomicMarkableReference&lt;/li&gt;&#xA;&lt;li&gt;更新字段类：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater&lt;/li&gt;&#xA;&lt;li&gt;Java8 新增类：DoubleAccumulator，DoubleAdder，LongAccumulator，LongAdder&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;&#xA;&lt;h3 id=&#34;原子基本类型&#34;&gt;原子基本类型&lt;/h3&gt;&#xA;&lt;p&gt;使用原子的方式更新基本类型。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AtomicBoolean: 原子布尔类型。&lt;/li&gt;&#xA;&lt;li&gt;AtomicInteger: 原子整型。&lt;/li&gt;&#xA;&lt;li&gt;AtomicLong: 原子长整型。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以下以&lt;code&gt;AtomInteger&lt;/code&gt;举例：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//以原子方式将给定值与当前值相加，线程安全的i = i + delta&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addAndGet&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; delta);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//如果当前值== except，则以原子方式将当前值设置为update，成功返回true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;compareAndSet&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; expect, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; update);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//以原子方式将当前值减1，相当于线程安全的i--&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decrementAndGet&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//以原子方式将当前值加1，相当于线程安全的i++&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;incrementAndGet&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Unsafe unsafe &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Unsafe.&lt;span style=&#34;color:#a6e22e&#34;&gt;getUnsafe&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; valueOffset;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            valueOffset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unsafe.&lt;span style=&#34;color:#a6e22e&#34;&gt;objectFieldOffset&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                (AtomicInteger.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDeclaredField&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (Exception ex) { &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Error(ex); }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * Atomically increments by one the current value.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return the updated value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;incrementAndGet&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; unsafe.&lt;span style=&#34;color:#a6e22e&#34;&gt;getAndAddInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, valueOffset, 1) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * Atomically decrements by one the current value.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * @return the updated value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decrementAndGet&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; unsafe.&lt;span style=&#34;color:#a6e22e&#34;&gt;getAndAddInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, valueOffset, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面代码可以看出，AtomicInteger底层使用&lt;code&gt;volatile&lt;/code&gt;关键字和CAS来保证线程安全。其中：&lt;/p&gt;</description>
    </item>
    <item>
      <title>volatile关键字剖析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</link>
      <pubDate>Sat, 24 Oct 2020 21:59:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The Java programming language allows threads to access shared variables (§17.1).As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.The Java programming language provides a second mechanism, volatile fields,that is more convenient than locking for some purposes.A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable (§17.4).&lt;/p&gt;</description>
    </item>
    <item>
      <title>synchronized关键字剖析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</link>
      <pubDate>Sun, 11 Oct 2020 22:59:39 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;&#xA;&lt;p&gt;在使用&lt;code&gt;Synchronized&lt;/code&gt;关键字需要把握以下注意点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一把锁只能同时被一个线程获取，没有获得锁的线程只能等待。&lt;/li&gt;&#xA;&lt;li&gt;每一个实例都有自己的一个锁资源，存放于对象头中（2bit表示锁信息）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;对象锁&#34;&gt;对象锁&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步代码块锁（可以指定锁定对象）&lt;/li&gt;&#xA;&lt;li&gt;方法锁（默认锁定对象为this（当前实例对象））&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (obj){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;类锁&#34;&gt;类锁&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;修饰静态方法或指定锁对象为Class对象。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//do something&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt;(ObjectDemo.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;理论基础&#34;&gt;理论基础&lt;/h2&gt;&#xA;&lt;p&gt;在操作系统进程管理中，对进程并发问题主要提供了两种解决方法：信号量和管程。在Java 1.5之前，提供的唯一并发原语就是管程，Java 1.5之后提供的JUC包也是以管程技术为基础的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;管程定义&#34;&gt;管程定义&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;通俗而言：管程（Monitor）是管理共享变量以及对共享变量的操作过程，让他们支持并发。在OS领域一般称为管程，Java中可以称为&lt;strong&gt;监视器&lt;/strong&gt;（monitor）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;mesa模型&#34;&gt;MESA模型&lt;/h3&gt;&#xA;&lt;p&gt;MESA模型是当今广泛使用的MESA模型，Java管程的实现参考的也是MESA模型。并对其进行了精简。Java内置的管程只有一个条件变量。&lt;/p&gt;&#xA;&lt;p&gt;如下图所示：管程X将共享变量queue、入队操作于出队操作封装起来。如果线程A和线程B访问共享变量queue，只能通过调用管程提供的&lt;code&gt;enq()&lt;/code&gt;和&lt;code&gt;deq()&lt;/code&gt;来实现。两个方法保证互斥性，，只允许一个线程进入管程并操作。该模型能实现并发编程中的互斥问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/concurrent/sync/MESA.jpg&#34; alt=&#34;管程&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;下图为MESA管程模型示意图，框中即是封装的管程，所有线程通过入口等待队列进入管程。管程还引入了条件变量的概念，&lt;strong&gt;每一个条件变量都对应一个等待队列&lt;/strong&gt;。管程的同步主要通过&lt;code&gt;Condition&lt;/code&gt;（条件变量）实现。&lt;code&gt;Condition&lt;/code&gt;可以执行&lt;code&gt;wait()&lt;/code&gt;和&lt;code&gt;signal()&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;假设线程T1执行出队操作，同时有个前提条件：队列不为空，这是条件变量。如果T1进入管程发现队列为空，则会在条件变量的等待队列进行等待。调用&lt;code&gt;wait()&lt;/code&gt;实现。此刻允许其它线程进入管程。&lt;/p&gt;&#xA;&lt;p&gt;此时线程T2执行入队操作，入队成功后，队列不空条件对于T1已经满足，T2调用&lt;code&gt;notify()&lt;/code&gt;来通知T1。通知他条件已满足。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/concurrent/sync/MESA1.jpg&#34; alt=&#34;MESA管程模型&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;两个操作&#34;&gt;两个操作&lt;/h3&gt;&#xA;&lt;h4 id=&#34;wait&#34;&gt;wait&lt;/h4&gt;&#xA;&lt;p&gt;MESA模型提供了一个特有的编程范式，通过循环检查条件调用&lt;code&gt;wait()&lt;/code&gt;。管程模型中：条件满足后，如何通知相关线程。管程要求同一时刻只能有一个线程能执行，那么上述问题中T1，T2谁执行呢？&lt;/p&gt;&#xA;&lt;p&gt;在MESA中，T2通过&lt;code&gt;notify()&lt;/code&gt;通知完后，继续执行，T1从条件变量的等待队列进入入口等待队列中。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(条件不满足) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;wait();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;signal&#34;&gt;signal&lt;/h4&gt;&#xA;&lt;p&gt;尽量使用&lt;code&gt;notifyAll()&lt;/code&gt;，如果满足以下三个条件则可以使用&lt;code&gt;notify()&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有等待线程拥有相同的等待条件&lt;/li&gt;&#xA;&lt;li&gt;所有等待线程被唤醒后，执行相同的操作&lt;/li&gt;&#xA;&lt;li&gt;只需要唤醒一个线程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;jvm字节码层面&#34;&gt;JVM字节码层面&lt;/h3&gt;&#xA;&lt;p&gt;从JVM层面来看，主要通过两个字节码指令实现，&lt;code&gt;monitorenter&lt;/code&gt;与&lt;code&gt;monitorexit&lt;/code&gt;。这两个字节码需要指定一个对象引用作为参数。这个对象引用就是monitor object。它就是synchronized传入的对象实例，该对象充当着维护了mutex以及顶层父类&lt;code&gt;Object&lt;/code&gt;提供的&lt;code&gt;wait/notify&lt;/code&gt;机制。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wang&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;l1n&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;volatile1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Demo02&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; wang.&lt;span style=&#34;color:#a6e22e&#34;&gt;l1n&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;volatile1&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Demo02&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Code:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       0: aload_0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       1: invokespecial &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;1                  &lt;span style=&#34;color:#75715e&#34;&gt;// Method java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       4: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(java.&lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Code:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       0: getstatic     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;2                  &lt;span style=&#34;color:#75715e&#34;&gt;// Field object:Ljava/lang/Object;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       3: dup&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       4: astore_1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       5: monitorenter&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       6: getstatic     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;3                  &lt;span style=&#34;color:#75715e&#34;&gt;// Field java/lang/System.out:Ljava/io/PrintStream;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       9: ldc           &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;4                  &lt;span style=&#34;color:#75715e&#34;&gt;// String hello world&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      11: invokevirtual &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;5                  &lt;span style=&#34;color:#75715e&#34;&gt;// Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      14: aload_1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      15: monitorexit&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      16: &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt;          24&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      19: astore_2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      20: aload_1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      21: monitorexit&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      22: aload_2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      23: athrow&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      24: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Exception table:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       from    to  target type&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           6    16    19   any&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          19    22    19   any&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; {};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Code:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       0: &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;           &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;6                  &lt;span style=&#34;color:#75715e&#34;&gt;// class java/lang/Object&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       3: dup&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       4: invokespecial &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;1                  &lt;span style=&#34;color:#75715e&#34;&gt;// Method java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       7: putstatic     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;2                  &lt;span style=&#34;color:#75715e&#34;&gt;// Field object:Ljava/lang/Object;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      10: &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;jvm实现层面&#34;&gt;JVM实现层面&lt;/h3&gt;&#xA;&lt;p&gt;每个Java对象都关联一个Monitor对象，如果使用&lt;code&gt;synchronized&lt;/code&gt;给对象上锁，该对象的&lt;code&gt;MarkWord&lt;/code&gt;中就被设置指向Monitor对象的指针。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ThreadLocalRondom原理剖析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/threadlocal-rondom/</link>
      <pubDate>Tue, 28 Apr 2020 17:31:07 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/threadlocal-rondom/</guid>
      <description>&lt;p&gt;ThreadLocalRondom是JDK 7在并发包中新增的随机数生成器，该类弥补了Random类在并发环境下的缺陷。&lt;/p&gt;&#xA;&lt;h2 id=&#34;random的局限性&#34;&gt;Random的局限性&lt;/h2&gt;&#xA;&lt;p&gt;Random生成随机数的方法如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nextInt&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; bound) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//参数校验&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (bound &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; 0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IllegalArgumentException(BadBound);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//根据老的种子生成新的种子&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next(31);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bound &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//根据新种子计算随机数&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((bound &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; m) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)((bound &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;)r) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; 31);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 u &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; (r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; bound) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next(31))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                ;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;next方法通过计算生成新的种子。用原子变量来存放种子，多线程的情况下，CAS操作会保证只有一个线程可以更新老的种子为新种子，更新失败的线程进行自旋，这降低了并发性能，所以产生了ThreadLocalRandom。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; bits) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; oldseed, nextseed;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        AtomicLong seed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;seed&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            oldseed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; seed.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;//seed计算公式，通过CAS操作进行更新&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            nextseed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (oldseed &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; multiplier &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; addend) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; mask;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;seed.&lt;span style=&#34;color:#a6e22e&#34;&gt;compareAndSet&lt;/span&gt;(oldseed, nextseed));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//将得到的值进行逻辑右移&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)(nextseed &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; (48 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; bits));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;threadlocalrandom简介&#34;&gt;ThreadLocalRandom简介&lt;/h2&gt;&#xA;&lt;p&gt;ThreadLocalRandom和ThreadLocal的原理相似，ThreadLocalRandom使得每个线程都维护自己独有的种子变量，这样就不存在竞争问题，大大提高并发性能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>AQS原理与源码分析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/aqs/</link>
      <pubDate>Mon, 13 Apr 2020 15:07:10 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/aqs/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组键的基础框架，它使用了一个int成员变量&lt;strong&gt;state&lt;/strong&gt;表示同步状态，通过CLH队列完成获取资源的线程排队工作。&lt;/p&gt;&#xA;&lt;p&gt;AQS的主要使用方式是继承，字类通过继承同步器并实现它的抽象方法来管理同步状态。AQS本身只是定义若干同步状态获取和释放的方法提供给字类来实现。&lt;/p&gt;&#xA;&lt;p&gt;锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节。AQS是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理，线程的排队，等待与唤醒等底层操作。&lt;/p&gt;&#xA;&lt;p&gt;AQS定义了两种资源共享的方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Exclusive（独占）：只有一个线程能执行，如ReentrantLock，其中又可分为公平锁和非公平锁：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;公平锁：线程按照队列的顺序获取锁&lt;/li&gt;&#xA;&lt;li&gt;非公平锁：线程无视顺序，去抢锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;AQS的设计是基于模板方法模式的，使用者继承AbstractQueuedSynchronizer并重写指定方法，重写的方法是对同步状态&lt;code&gt;state&lt;/code&gt;的获取释放等操作。&lt;/p&gt;&#xA;&lt;p&gt;可重写方法如下，arg参数为获取锁的次数。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;名称&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;protected boolean tryAcquire(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;独占方式，尝试获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后通过CAS设置同步状态，成功返回true，失败返回false&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;protected boolean tryRelease(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;独占方式，尝试释放同步状态，成功返回true，失败则返回false&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;protected int tryAcquireShared(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;共享方式，尝试获取同步状态，返回0表示成功，但是没有剩余可用资源，负数表示失败，正数表示成功，并且有剩余资源。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;protected boolean tryReleaseShared(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;共享方式，尝试释放同步状态，成功返回true，失败返回false&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;protected boolean isHeldExclusively()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;判断当前线程是否正在独占资源&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;模板方法：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;方法名称&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;void acquire(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;独占锁获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法会调用重写的tryAcquire()方法&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;void acquireInterruptibly(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;与acquire相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列，如果当前线程被中断，该方法会抛出&lt;code&gt;InterruptedException&lt;/code&gt;并返回。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;boolean tryAcquireNanos(int arg, long nanosTimeout)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;在acquireInterruptibly的基础上增加了超时限制，如果当前线程在超时时间之内没有获取同步状态，那么将会返回false，获取到了返回true&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;void acquireShared(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占锁获取的主要区别式同一时刻可以有多个线程获取同步状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;void acquireSharedInterruptibly(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;与acquireShared相同，响应中断&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;boolean tryAcquireSharedNanos(int arg, long nanosTimeout)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;加了超时限制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;boolean release(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中的第一个节点线程唤醒&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;boolean releaseShared(int arg)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;共享式的释放同步状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Collection&lt;!-- raw HTML omitted --&gt; getQueuedThreads()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;获取等待在同步队列上的线程集合&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;模板方法基本分成3类：独占式获取与释放，共享式获取与释放，查询同步队列中的情况。&lt;/p&gt;</description>
    </item>
    <item>
      <title>解析Java中的锁</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java-lock/</link>
      <pubDate>Fri, 10 Apr 2020 12:07:01 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java-lock/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;锁是用来控制多个线程访问共享资源的方式，在Lock接口出现之前，Java是靠synchronized关键字实现锁功能的。而Java 1.5之后，并发包中新增了Lock接口与其实现类用来实现锁功能，只是需要手动获取释放锁，虽然它缺少了同步关键字隐式获取释放的便捷性，但却拥有了可操作性，可中断的获取锁以及超时获取锁等功能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;&#xA;&lt;p&gt;Java中会按照是否有某一特性来定义锁，下图通过各种特性对锁进行分类：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/lock/Java%E7%9A%84%E9%94%81.png&#34; alt=&#34;Java中的锁&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;悲观锁--乐观锁&#34;&gt;悲观锁 / 乐观锁&lt;/h3&gt;&#xA;&lt;p&gt;这两种锁不是具体类型的锁，体现了看待线程同步的角度，再Java和数据库中都有此概念对应的实际应用。&lt;/p&gt;&#xA;&lt;p&gt;对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，在Java中，synchronized关键字和Lock的实现类都是悲观锁。&lt;/p&gt;&#xA;&lt;p&gt;而乐观锁认为自己在使用数据的时候，不会有其他线程修改数据，所以不会添加锁，只是在更新数据的时候，去判断之前有没有别的线程更新了数据，如果没有被更新，当前线程将自己修改的数据成功写入。如果数据已被其他线程更新。则根据不同的实现方式执行不同的操作（报错或自动重试）。&lt;/p&gt;&#xA;&lt;p&gt;乐观锁在Java中是通过无锁编程来实现，最常采用是CAS算法，Java原子类中的递增就是通过CAS自旋来实现的。&lt;/p&gt;&#xA;&lt;p&gt;悲观锁适合写操作多的场景，先加锁可以保证数据准确性。&lt;/p&gt;&#xA;&lt;p&gt;乐观锁适合读操作多的场景，不加锁能够提高性能。&lt;/p&gt;&#xA;&lt;h3 id=&#34;自旋锁--适应性自旋锁&#34;&gt;自旋锁 / 适应性自旋锁&lt;/h3&gt;&#xA;&lt;p&gt;在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而实采用循环的方式去获取锁，这样做的好处是减少线程上下文切换的消耗。&lt;/p&gt;&#xA;&lt;p&gt;但是自旋锁本身是有缺点的，它不能代替阻塞，自旋虽然避免了上下文切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待的效果很好，但是如果锁占用时间过长，自旋只会白白浪费处理器资源。所以自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，通过**-XX:PreBlockSpin**修改）没有成功获得锁，就挂起线程，停止自旋。&lt;/p&gt;&#xA;&lt;p&gt;自旋锁的实现原理是CAS算法。自旋锁在JDK 1.4.2引入，使用**-XX:UseSpinning**开启，JDK 6开始默认开启，并且引入了自适应的自旋锁。&lt;/p&gt;&#xA;&lt;p&gt;自适应意味着自旋的时间不再固定，而实由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么JVM会认为这次自选也是很有可能再次成功，进而它将自旋等待持续更长的时间。如果某个锁自旋很少成功获得，那么就会直接省略掉自旋过程，直接阻塞线程。&lt;/p&gt;&#xA;&lt;p&gt;在自旋锁中，有三种常见的锁形式：TicketLock、CLHlock、MCSlock&lt;/p&gt;&#xA;&lt;h3 id=&#34;无锁--偏向锁--轻量级锁--重量级锁&#34;&gt;无锁 / 偏向锁 / 轻量级锁 / 重量级锁&lt;/h3&gt;&#xA;&lt;p&gt;这四种指锁的状态，并且是针对&lt;code&gt;Synchronized&lt;/code&gt;关键字，是通过&lt;code&gt;Mark Word&lt;/code&gt;中的字段表明的。&lt;/p&gt;&#xA;&lt;h4 id=&#34;无锁&#34;&gt;无锁&lt;/h4&gt;&#xA;&lt;p&gt;无锁没有对资源进行锁定，所有线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。&lt;/p&gt;&#xA;&lt;p&gt;无锁的特点是修改操作在循环内进行，线程会不断尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。CAS原理就是无锁的实现。&lt;/p&gt;&#xA;&lt;h4 id=&#34;偏向锁&#34;&gt;偏向锁&lt;/h4&gt;&#xA;&lt;p&gt;偏向锁是指一段同步代码一直被一个线程所访问，那么该线程就会自动获得锁，降低获得锁的代价。&lt;/p&gt;&#xA;&lt;p&gt;当一个线程通过同步代码块获得锁的时候，会在&lt;code&gt;Mark Word&lt;/code&gt;中存储锁偏向的线程ID。在线程进入或退出同步代码块时不再通过CAS操作来加锁解锁，而是检查&lt;code&gt;Mark Word&lt;/code&gt;中是否存储着指向当前线程的偏向锁，引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁的执行，因为轻量级锁较偏向锁消耗性能。&lt;/p&gt;&#xA;&lt;p&gt;偏向锁只有遇到其他线程竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动释放偏向锁。&lt;/p&gt;&#xA;&lt;p&gt;偏向锁在JDK 6以后是默认启用的，可以通过&lt;code&gt;-XX:UseBiasedLocking=false&lt;/code&gt;关闭，关闭之后，程序默认进入轻量级锁状态。&lt;/p&gt;&#xA;&lt;h4 id=&#34;轻量级锁&#34;&gt;轻量级锁&lt;/h4&gt;&#xA;&lt;p&gt;轻量级锁是指当锁是偏向锁的时候，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程通过自旋的方式尝试获取锁，不会阻塞。从而提高性能。&lt;/p&gt;&#xA;&lt;h4 id=&#34;重量级锁&#34;&gt;重量级锁&lt;/h4&gt;&#xA;&lt;p&gt;若当前只有一个等待线程，则该线程通过自旋进行等待，但是当自旋超过一定次数，或是一个线程在持有锁，一个在自旋，又有第三个线程访问时，轻量级锁升级为重量级锁。&lt;/p&gt;&#xA;&lt;p&gt;综上，偏向锁通过对比&lt;code&gt;Mark Word&lt;/code&gt;解决加锁问题，避免执行CAS操作，而轻量级锁通过CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒影响性能。重量级锁将除了拥有锁的线程以外所有线程都阻塞。&lt;/p&gt;&#xA;&lt;h3 id=&#34;公平锁--非公平锁&#34;&gt;公平锁 / 非公平锁&lt;/h3&gt;&#xA;&lt;p&gt;公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列进行排序，队列中第一个线程才能获得锁。&lt;/p&gt;&#xA;&lt;p&gt;公平锁的优点时等待的线程不会饿死，缺点是整体吞吐效率相对非公平锁较低，等待队列中除第一个线程以外所有线程都阻塞，CPU唤醒阻塞线程的开销较非公平锁大。&lt;/p&gt;&#xA;&lt;p&gt;非公平锁是多个线程加锁时直接尝试获得锁，获得不到才会进入等待队列中等待。如果此时锁刚好可用，那么线程可以无需阻塞直接获取到锁。非公平锁的优点是可以减少唤醒线程的开销，整体吞吐效率高，因为线程有几率不阻塞直接获得锁，缺点是处于等待队列的线程可能会饿死，或者等待很久才能获得锁。&lt;/p&gt;&#xA;&lt;h3 id=&#34;可重入锁&#34;&gt;可重入锁&lt;/h3&gt;&#xA;&lt;p&gt;可重入锁又称为递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自当获得锁（前提是锁对象是同一个对象），不会因为之前获取过还没释放而阻塞，Java中&lt;code&gt;ReentrantLock&lt;/code&gt;和&lt;code&gt;Synchronized&lt;/code&gt;都是可重入锁，可重入锁的一个优点就是可一定程度避免死锁。&lt;/p&gt;&#xA;&lt;p&gt;下面是一个可重入锁的一个案例。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setA&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(1000);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;setB();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setB&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(1000);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;独享锁--共享锁&#34;&gt;独享锁 / 共享锁&lt;/h4&gt;&#xA;&lt;p&gt;独享锁也叫排他锁，是指该锁一次只能被一个线程所持有，如果线程T对数据A加上独享锁之后，则其他线程不再对A加任何类型的锁，获得独享锁的数据即能读数据又能修改数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java内存模型解析</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 09 Apr 2020 13:16:52 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;&#xA;&lt;p&gt;并发编程中，需要处理两个关键问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程之间如何通信&lt;/li&gt;&#xA;&lt;li&gt;线程之间如何同步&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;通信指线程之间以何种机制来交换信息，线程之间的通信机制有两种：&lt;strong&gt;共享内存&lt;/strong&gt;和&lt;strong&gt;消息传递&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;同步指程序中用于控制不同线程间操作发生相对顺序的机制。&lt;/p&gt;&#xA;&lt;p&gt;Java采用的是共享内存模型，Java线程之间的通信由Java内存模型（JMM）控制。Java内存模型的主要目的是定义程序中各种变量的访问规则。&lt;/p&gt;&#xA;&lt;h2 id=&#34;主内存和本地内存&#34;&gt;主内存和本地内存&lt;/h2&gt;&#xA;&lt;p&gt;JMM规定了线程之间共享变量存储在主内存中，每个线程都有私有的本地内存，本地内存存储了共享变量的副本，Java内存模型的示意图如图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/JMM/IMG_0043.PNG&#34; alt=&#34;Java内存模型抽象结构&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从图来看，线程A和线程B之间要通信的话，会进行以下操作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程A把本地内存中更新过的共享变量刷新到主内存中。&lt;/li&gt;&#xA;&lt;li&gt;线程B去主内存中读取线程A之前更新的变量。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;内存间的交互操作&#34;&gt;内存间的交互操作&lt;/h3&gt;&#xA;&lt;p&gt;关于如何将一个变量从主内存拷贝到本地内存中，JMM定义了以下八种操作来完成，JVM必须保证每种操作是原子性的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;lock：作用于主内存的变量，将一个变量标识为一个线程独占状态。&lt;/li&gt;&#xA;&lt;li&gt;unlock：作用于主内存的变量，将处于线程独占状态的变量释放出来。&lt;/li&gt;&#xA;&lt;li&gt;read：作用于主内存的变量，将一个变量的值从主内存传输到线程的本地内存中。&lt;/li&gt;&#xA;&lt;li&gt;load：作用于本地内存的变量，将read操作得到的变量放入本地内存的变量副本中。&lt;/li&gt;&#xA;&lt;li&gt;use：作用于本地内存的变量，将本地内存的一个变量值传递给执行引擎。&lt;/li&gt;&#xA;&lt;li&gt;assign：作用于本地内存的变量，它把一个从执行引擎接收到的值赋值给本地内存中的变量。&lt;/li&gt;&#xA;&lt;li&gt;store：作用于本地内存的变量，将本地内存的值传送到主内存中&lt;/li&gt;&#xA;&lt;li&gt;write：作用于主内存的变量，将store操作得到的变量值放入主内存的变量中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;重排序&#34;&gt;重排序&lt;/h2&gt;&#xA;&lt;p&gt;重排序时指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，重排序分为三种类型：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;编译器优化的重排序&lt;/li&gt;&#xA;&lt;li&gt;指令并行的重排序，处理器使用指令级并行技术来将多条指令重叠执行。&lt;/li&gt;&#xA;&lt;li&gt;内存系统的重排序，由于处理器使用了缓存技术和读/写缓冲区技术。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;重排序会导致多线程程序出现内存可见性问题，对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器，JMM要求编译器生成指令序列的时候，插入内存屏障指令来禁止重排序。&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据依赖性&#34;&gt;数据依赖性&lt;/h3&gt;&#xA;&lt;p&gt;如果两个操作访问同一个变量，且两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖性分三种类型，如下表所示：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;名称&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;代码实例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;写后读&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;a = 1; b = a;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;写后写&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;a = 1; a = 2;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;读后写&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;a = b; b = 1;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;上述现象如果执行顺序发生改变，执行结果就会被改变。&lt;/p&gt;&#xA;&lt;p&gt;编译器和处理器在重排序时，会遵守数据依赖性原则，不会改变存在依赖关系的两个操作的执行顺序。&lt;/p&gt;&#xA;&lt;h2 id=&#34;happens-before&#34;&gt;Happens-Before&lt;/h2&gt;&#xA;&lt;p&gt;JSR-133使用&lt;code&gt;Happens-Before&lt;/code&gt;的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在&lt;code&gt;Happens-Before&lt;/code&gt;关系。A &lt;code&gt;Happens-Before&lt;/code&gt; B 意味着：&lt;strong&gt;A操作的结果对B是可见的&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;通俗而言，即：A运行完成后数据结果，B都能读取到。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Happens-Before&lt;/code&gt;原则如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序顺序规则：在一个线程内，在程序前面的操作先行发生于后面的操作。&lt;/li&gt;&#xA;&lt;li&gt;管程锁规则：一个&lt;code&gt;unlock&lt;/code&gt;操作先行发生于后面对同一个锁的&lt;code&gt;lock&lt;/code&gt;操作。&lt;/li&gt;&#xA;&lt;li&gt;volatile变量规则：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读。&lt;/li&gt;&#xA;&lt;li&gt;传递性&lt;/li&gt;&#xA;&lt;li&gt;线程&lt;code&gt;start()&lt;/code&gt;规则：&lt;code&gt;start()&lt;/code&gt;方法调用先行发生于此线程的每一个动作。&lt;/li&gt;&#xA;&lt;li&gt;线程&lt;code&gt;join()&lt;/code&gt;规则：线程的结束先行发生于&lt;code&gt;join()&lt;/code&gt;方法返回。&lt;/li&gt;&#xA;&lt;li&gt;线程&lt;code&gt;interrupt()&lt;/code&gt;规则：对线程的&lt;code&gt;interrupt()&lt;/code&gt;方法的调用先行发生于被中断线程代码检测到中断事件的发生&lt;/li&gt;&#xA;&lt;li&gt;对象终结规则：一个对象的初始化完成先行发生于它的&lt;code&gt;finalize()&lt;/code&gt;方法的开始。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;线程安全&#34;&gt;线程安全&lt;/h2&gt;&#xA;&lt;p&gt;共享资源的安全程度按照强弱顺序分为以下五类：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java并发机制底层实现原理</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java-concurrency-implementation-principle/</link>
      <pubDate>Tue, 07 Apr 2020 17:09:22 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java-concurrency-implementation-principle/</guid>
      <description>&lt;h2 id=&#34;volatile&#34;&gt;Volatile&lt;/h2&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;p&gt;Java语言规范第3版中对volatile的定义如下：Java编程语言允许线程访问共享变量，为了能确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获取这个变量。Java语言提供了volatile关键字，在某些情况下比锁要更加方便，如果一个变量被声明成volatile，Java线程内存模型确保所有线程看到的这个变量的值是一致的。&lt;/p&gt;&#xA;&lt;h4 id=&#34;实现原理&#34;&gt;实现原理&lt;/h4&gt;&#xA;&lt;p&gt;先看下面的CPU术语定义：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;术语&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;内存屏障&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;是一组处理器指令，用于实现对内存操作的顺序限制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;缓冲行&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;缓存这两个可以分配的最小存储单位，处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;原子操作&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;不可中断的一个或一系列操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;缓存行填充&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;当处理器识别到内存中读取操作数是可缓存的，处理器读取整个缓存行到合适的缓存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;缓存命中&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;写命中&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;当处理器将操作数写回到一个内存缓存中的区域中，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数回写到缓存，而不是回写到内存，这个操作数被称为写命中&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;写缺失&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;一个有效的缓存行被写入到不存在的内存区域&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @author ：L1nker4&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @date ： 创建于  2020/4/7 20:34&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @description： volatile测试&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Demo01&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; stop &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        stop &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过添加VM options打印程序汇编代码：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation -XX:+PrintAssembly -Xcomp -XX:CompileCommand=dontinline,*Demo01.main -XX:CompileCommand=compileonly,*Demo01.main&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果提示以下内容，需要将&lt;code&gt;hedis-amd64.dll&lt;/code&gt;放在&lt;code&gt;jre/bin/server&lt;/code&gt;目录下。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;截取部分的汇编代码&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java线程基础知识</title>
      <link>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Fri, 03 Apr 2020 20:27:03 +0000</pubDate>
      <guid>http://localhost:1313/posts/java%E5%B9%B6%E5%8F%91/java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h2 id=&#34;进程与线程&#34;&gt;进程与线程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是进程&#34;&gt;什么是进程&lt;/h3&gt;&#xA;&lt;p&gt;操作系统在运行一个程序时，会为其创建一个进程，操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，多个线程共享进程的堆和方法区两块内存空间。&lt;/p&gt;&#xA;&lt;h4 id=&#34;进程和线程的区别&#34;&gt;进程和线程的区别&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h4&gt;&#xA;&lt;p&gt;上下文切换是指CPU从一个进程（线程）切换到另一个进程（线程）。&lt;strong&gt;上下文是指某一个时间点CPU寄存器和PC的数据&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;并发和并行&#34;&gt;并发和并行&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;并发：同一时刻有多个任务在运行。&lt;/li&gt;&#xA;&lt;li&gt;并行：同一时间有多个任务在运行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;线程的创建&#34;&gt;线程的创建&lt;/h3&gt;&#xA;&lt;p&gt;线程创建方式争议较多，在Oracle官方文档给出的创建方式为两种，分别是继承Thread类和实现Runnable接口。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;There are two ways to create a new thread of execution. One is to declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This subclass should override the &lt;code&gt;run&lt;/code&gt; method of class &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be allocated and started.&lt;/p&gt;&#xA;&lt;p&gt;The other way to create a thread is to declare a class that implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can then be allocated, passed as an argument when creating &lt;code&gt;Thread&lt;/code&gt;, and started.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
