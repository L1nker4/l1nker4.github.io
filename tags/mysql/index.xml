<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on l1nker4&#39;s Blog</title>
    <link>http://localhost:1313/tags/mysql/</link>
    <description>Recent content in MySQL on l1nker4&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Mar 2022 12:23:36 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL调优总结</title>
      <link>http://localhost:1313/posts/mysql/mysql%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 01 Mar 2022 12:23:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql/mysql%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;数据库调优的几个维度：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;建立索引&lt;/li&gt;&#xA;&lt;li&gt;SQL语句优化&lt;/li&gt;&#xA;&lt;li&gt;服务器参数调优：包括缓冲区、线程数等&lt;/li&gt;&#xA;&lt;li&gt;分库分表、集群模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;调优目标：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尽可能节省系统资源，以提高系统吞吐量。&lt;/li&gt;&#xA;&lt;li&gt;合理的结构设计和参数调整，以提高用户操作响应的速度。&lt;/li&gt;&#xA;&lt;li&gt;减少系统的瓶颈，提高MySQL整体性能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如何定位调优问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户反馈&lt;/li&gt;&#xA;&lt;li&gt;日志分析&lt;/li&gt;&#xA;&lt;li&gt;服务器资源监控&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;调优维度：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;选择合适的DBMS&lt;/li&gt;&#xA;&lt;li&gt;优化表设计&#xA;&lt;ol&gt;&#xA;&lt;li&gt;遵循三范式的原则&lt;/li&gt;&#xA;&lt;li&gt;多表联查可以考虑反范式化&lt;/li&gt;&#xA;&lt;li&gt;表字段的数据类型选择&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;优化SQL查询（逻辑）&lt;/li&gt;&#xA;&lt;li&gt;使用索引（物理）&lt;/li&gt;&#xA;&lt;li&gt;使用缓存&lt;/li&gt;&#xA;&lt;li&gt;库级优化&#xA;&lt;ol&gt;&#xA;&lt;li&gt;读写分离&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一主一从&lt;/li&gt;&#xA;&lt;li&gt;双主双从&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;数据分片：对数据库进行分库分表。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;mysql服务器优化&#34;&gt;MySQL服务器优化&lt;/h1&gt;&#xA;&lt;p&gt;两个方面：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;硬件优化&lt;/li&gt;&#xA;&lt;li&gt;MySQL服务的参数优化&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;硬件调优&#34;&gt;硬件调优&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配置较大的内存，增加缓冲区容量，减少磁盘IO。&lt;/li&gt;&#xA;&lt;li&gt;配置高速磁盘系统，减少磁盘IO的时间。&lt;/li&gt;&#xA;&lt;li&gt;合理分布磁盘IO，将磁盘IO分布在多个设备上，减少竞争。&lt;/li&gt;&#xA;&lt;li&gt;配置多处理器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;参数调优&#34;&gt;参数调优&lt;/h2&gt;&#xA;&lt;p&gt;通过优化MySQL可以提高资源利用率，从而提高MySQL服务器性能。&lt;/p&gt;&#xA;&lt;p&gt;几个重要的参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;innodb_buffer_pool_size：表和索引的缓存区大小。&lt;/li&gt;&#xA;&lt;li&gt;key_buffer_size：索引缓冲区大小，所有线程共享，值太大也会导致OS频繁换页。&lt;/li&gt;&#xA;&lt;li&gt;table_cache：同时打开的表的个数。&lt;/li&gt;&#xA;&lt;li&gt;query_cache_size：&lt;strong&gt;查询缓冲区&lt;/strong&gt;大小，与query_cache_type配合使用。&lt;/li&gt;&#xA;&lt;li&gt;query_cache_type：0代表所有查询不使用查询缓冲区，1表示所有都使用，当查询语句指定&lt;code&gt;SQL_NO_CACHE&lt;/code&gt;则不使用。&lt;/li&gt;&#xA;&lt;li&gt;sort_buffer_size：每个需要进行&lt;strong&gt;排序&lt;/strong&gt;的线程分配的缓冲区大小，增加这个参数的值可以提高&lt;code&gt;ORDER BY&lt;/code&gt;或&lt;code&gt;GROUP BY&lt;/code&gt;操作的速度。&lt;/li&gt;&#xA;&lt;li&gt;join_buffer_size：每个需要&lt;strong&gt;联合查询&lt;/strong&gt;的线程所使用的缓冲区大小。&lt;/li&gt;&#xA;&lt;li&gt;read_buffer_size：每个线程&lt;strong&gt;连续扫描时&lt;/strong&gt;为扫描的每个表分配的缓冲区的大小。&lt;/li&gt;&#xA;&lt;li&gt;innodb_flush_log_at_trx_commit：**何时将redo log buffer的数据写入redo log file，并将日志文件写入磁盘中。**默认为1。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：redo log buffer每隔一秒将其数据刷入page cache，该模式下事务提交不会触发刷盘操作。&lt;/li&gt;&#xA;&lt;li&gt;1：每次事务提交都会将将redo log buffer中数据刷入page cache，并立刻刷入磁盘。效率较低也为安全。&lt;/li&gt;&#xA;&lt;li&gt;2：每次事务提交都会将redo log buffer中数据刷入page cache，由OS同步到磁盘。（每秒一次）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;mysql进程崩溃不会有数据丢失，当时OS宕机会有数据丢失。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;innodb_log_buffer_size：InnoDB存储引擎的&lt;strong&gt;事务日志缓冲区&lt;/strong&gt;，为了提升性能，也是先将信息写入 &lt;code&gt;Innodb Log Buffer&lt;/code&gt; 中，当满足 &lt;code&gt;innodb_flush_log_trx_commit&lt;/code&gt; 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。&lt;/li&gt;&#xA;&lt;li&gt;max_connections：允许连接到MySQL数据库的最大数量。如果&lt;code&gt;connection_errors_max_connections&lt;/code&gt;不为0，并且一直增长，说明不断有连接因为数据库连接数已到最大值而失败，此时考虑增大&lt;code&gt;max_connections&lt;/code&gt;的值。&lt;/li&gt;&#xA;&lt;li&gt;back_log：用于&lt;strong&gt;控制MySQL监听TCP端口时设置的积压请求栈大小。&lt;/strong&gt; 连接数达到&lt;code&gt;max_connections&lt;/code&gt;，新来的请求将会被存在堆栈中，以等待某一连接释放资源，如果等待连接的数量超过back_log，将会报错。&lt;/li&gt;&#xA;&lt;li&gt;thread_cache_size：线程池缓存线程数量的大小，当客户端断开连接后将当前线程缓存起来， 当在接到新的连接请求时快速响应无需创建新的线程 。这对于短链接的应用程序十分有用。&lt;/li&gt;&#xA;&lt;li&gt;wait_timeout：一个连接的最大连接时间。&lt;/li&gt;&#xA;&lt;li&gt;interactive_timeout：服务器在关闭连接前等待行动的秒数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;优化数据库结构&#34;&gt;优化数据库结构&lt;/h1&gt;&#xA;&lt;p&gt;几个策略：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL体系结构和存储引擎</title>
      <link>http://localhost:1313/posts/mysql/mysql-structure-and-engine/</link>
      <pubDate>Sat, 11 Jul 2020 16:25:46 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql/mysql-structure-and-engine/</guid>
      <description>&lt;h2 id=&#34;体系结构&#34;&gt;体系结构&lt;/h2&gt;&#xA;&lt;p&gt;MySQL体系结构如图所示：&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png&#34; alt=&#34;MySQL体系结构&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;分别由Client Connectors层、MySQL Server层以及存储引擎层组成。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Client Connectors层：负责处理客户端的连接请求，与客户端创建连接。&lt;/li&gt;&#xA;&lt;li&gt;MySQL Server层：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Connection Pool：负责处理和存储数据库与客户端创建的连接，一个线程负责管理一个连接，包括了用户认证模块，就是用户登录身份的认证和鉴权以及安全管理&lt;/li&gt;&#xA;&lt;li&gt;Service &amp;amp; utilities：管理服务&amp;amp;工具集，包括备份恢复、安全管理、集群管理、工具&lt;/li&gt;&#xA;&lt;li&gt;SQL interface：负责接受客户端发送的各种语句&lt;/li&gt;&#xA;&lt;li&gt;Parser：对SQL语句进行语法解析生成解析树&lt;/li&gt;&#xA;&lt;li&gt;Optimizer：查询优化器会根据解析树生成执行计划，并选择合适的索引，然后按照执行计划执行SQL并与各个存储引擎交互&lt;/li&gt;&#xA;&lt;li&gt;Caches：包括各个存储引擎的缓存部分，例如InnoDB的Buffer Pool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;存储引擎层：包括InnoDB，MyISAM以及支持归档的Archive和内存的Memory&lt;/li&gt;&#xA;&lt;li&gt;存储引擎底部是物理存储层，包括二进制日志，数据文件，错误日志，慢查询日志，全日志，redo/undo日志&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一条SQL语句的执行过程可以参照如下图示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/SQL%20process.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;与MySQL建立连接。&lt;/li&gt;&#xA;&lt;li&gt;查询缓存，如果开启了Query。 Cache并且查询缓存中存在该查询语句，则直接将结果返回到客户端，没有开启或缓存未命中则由解析器进行语法语义解析，并生成解析树。&lt;/li&gt;&#xA;&lt;li&gt;预处理器生成新的解析树。&lt;/li&gt;&#xA;&lt;li&gt;查询优化器进行优化。&lt;/li&gt;&#xA;&lt;li&gt;查询执行引擎执行SQL，通过API接口查询物理存储层的数据，并返回结果。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;其中，查询缓存于MySQL 8.0中移除，具体原因：查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的所有的查询缓存都会被清空。&lt;/p&gt;&#xA;&lt;p&gt;MySQL官方博客关于该技术移除的解释&lt;a href=&#34;https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/&#34;&gt;https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png&#34; alt=&#34;MySQL存储引擎&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 MySQL 5.6 版本之前，默认的存储引擎都是 MyISAM，但 5.6 版本以后默认的存储引擎就是 InnoDB。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/InnoDB%E7%BB%93%E6%9E%84.png&#34; alt=&#34;InnoDB结构&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;InnoDB上半部分是实例层，位于内存中，下半部分是物理层，位于文件系统中。&#xA;其中实例层分为线程和内存，InnoDB中重要的线程有Master Thread（主线程），其优先级最高，主要负责调度其他线程，其内部有几个循环：主循环，后台循环，刷新循环，暂停循环，Master Thread 会根据其内部运行的相关状态在各循环间进行切换。&lt;/p&gt;&#xA;&lt;p&gt;大部分操作在主循环中完成，其包含1s和10s两种操作：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1s操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日志缓冲刷新到磁盘（即使事务未提交，也被执行）&lt;/li&gt;&#xA;&lt;li&gt;最多可以刷100个新脏页到磁盘&lt;/li&gt;&#xA;&lt;li&gt;执行并改变缓冲的操作&lt;/li&gt;&#xA;&lt;li&gt;若当前没有用户活动，可以切换到后台循环&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;10s操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最多可以刷新100个脏页到磁盘&lt;/li&gt;&#xA;&lt;li&gt;合并至多5个被改变的缓冲&lt;/li&gt;&#xA;&lt;li&gt;日志缓冲刷新到磁盘&lt;/li&gt;&#xA;&lt;li&gt;删除无用的Undo页&lt;/li&gt;&#xA;&lt;li&gt;刷新100个或10个脏页到磁盘，产生一个检查点&lt;/li&gt;&#xA;&lt;li&gt;buf_dump_thread 负责将 buffer pool 中的内容 dump 到物理文件中，以便再次启动 MySQL 时，可以快速加热数据。&lt;/li&gt;&#xA;&lt;li&gt;page_cleaner_thread 负责将 buffer pool 中的脏页刷新到磁盘，在 5.6 版本之前没有这个线程，刷新操作都是由主线程完成的，所以在刷新脏页时会非常影响 MySQL 的处理能力，在5.7 版本之后可以通过参数设置开启多个 page_cleaner_thread。&lt;/li&gt;&#xA;&lt;li&gt;purge_thread 负责将不再使用的 Undo 日志进行回收。&lt;/li&gt;&#xA;&lt;li&gt;read_thread 处理用户的读请求，并负责将数据页从磁盘上读取出来，可以通过参数设置线程数量。&lt;/li&gt;&#xA;&lt;li&gt;write_thread 负责将数据页从缓冲区写入磁盘，也可以通过参数设置线程数量，page_cleaner 线程发起刷脏页操作后 write_thread 就开始工作了。&lt;/li&gt;&#xA;&lt;li&gt;redo_log_thread 负责把日志缓冲中的内容刷新到 Redo log 文件中。&lt;/li&gt;&#xA;&lt;li&gt;insert_buffer_thread 负责把 Insert Buffer 中的内容刷新到磁盘。实例层的内存部分主要包含 InnoDB Buffer Pool，这里包含 InnoDB 最重要的缓存内容。数据和索引页、undo 页、insert buffer 页、自适应 Hash 索引页、数据字典页和锁信息等。additional memory pool 后续已不再使用。Redo buffer 里存储数据修改所产生的 Redo log。double write buffer 是 double write 所需的 buffer，主要解决由于宕机引起的物理写入操作中断，数据页不完整的问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;物理层在逻辑上分为系统表空间、用户表空间和Redo日志。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入MySQL索引细节</title>
      <link>http://localhost:1313/posts/mysql/mysql%E7%B4%A2%E5%BC%95%E7%BB%86%E8%8A%82/</link>
      <pubDate>Fri, 01 May 2020 11:23:33 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql/mysql%E7%B4%A2%E5%BC%95%E7%BB%86%E8%8A%82/</guid>
      <description>&lt;h2 id=&#34;索引基本概念&#34;&gt;索引基本概念&lt;/h2&gt;&#xA;&lt;p&gt;维基百科对索引的定义：数据库索引是一种数据结构，它以额外的写入和存储空间为代价来提高数据库表上数据索引操作的速度。&lt;/p&gt;&#xA;&lt;p&gt;MySQL官方对索引的定义是用于快速查找记录的一种数据结构。&lt;/p&gt;&#xA;&lt;p&gt;索引是一个以空间换时间的经典案例。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引是物理数据页，数据页大小决定了一个页可以存储多少个索引行，以及需要多少页来存储指定大小的索引。&lt;/li&gt;&#xA;&lt;li&gt;索引可以加快检索速度，也可以降低索引列插入、删除、更新的速度，索引维护需要代价。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;有两种基本的索引类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;顺序索引：基于值的顺序排序&lt;/li&gt;&#xA;&lt;li&gt;散列索引：基于将值平均分布到若干bucket中，一个值所属的bucket是由一个散列函数决定。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;索引的数据结构&#34;&gt;索引的数据结构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;b-tree&#34;&gt;B Tree&lt;/h3&gt;&#xA;&lt;p&gt;查询的时间主要依赖于磁盘I/O的次数，每次节点访问需要进行一次磁盘IO操作。&#xA;B Tree取代平衡二叉树主要是降低了树的高度，减少了磁盘IO的次数。其基本结构如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/index/B%20Tree.jpg&#34; alt=&#34;B Tree&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;B Tree别称平衡的多路搜索树，每个节点最多包括M个子节点，M称为B树的阶。&lt;/p&gt;&#xA;&lt;p&gt;M阶的B树（M &amp;gt; 2）有以下的特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根节点的儿子数的范围是 [2,M]。&lt;/li&gt;&#xA;&lt;li&gt;每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。&lt;/li&gt;&#xA;&lt;li&gt;叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。&lt;/li&gt;&#xA;&lt;li&gt;假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&amp;lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。&lt;/li&gt;&#xA;&lt;li&gt;所有叶子节点位于同一层。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;b-tree-1&#34;&gt;B+ Tree&lt;/h3&gt;&#xA;&lt;p&gt;B+ Tree与B Tree的差异主要有以下几点：&lt;/p&gt;</description>
    </item>
    <item>
      <title>探索MySQL的事务与锁机制</title>
      <link>http://localhost:1313/posts/mysql/%E6%8E%A2%E7%B4%A2mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 29 Apr 2020 09:47:16 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql/%E6%8E%A2%E7%B4%A2mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;事务概念&#34;&gt;事务概念&lt;/h1&gt;&#xA;&lt;p&gt;简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。MySQL中事务支持是在存储引擎层实现的。事务拥有四个重要的特性：原子性、一致性、隔离性、持久性，简称为ACID特性，下文将逐一解释。&lt;/p&gt;&#xA;&lt;h2 id=&#34;acid特性&#34;&gt;ACID特性&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原子性（Atomicity）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务开始后所有操作步骤，要么全部完成，要么全部不做，不存在只执行一部分的情况。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一致性（Consistency）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务执行前后，数据从一个合法性状态变换到另一个合法性状态。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A、B转账业务，总金额不变。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分为数据一致性和约束一致性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;隔离性（Isolation）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在一个事务未执行完毕时，其它事务无法读取该事务的数据。&lt;/li&gt;&#xA;&lt;li&gt;MySQL通过锁机制来保证事务的隔离性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;持久性（Durability）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务一旦提交，数据将被保存下来，即使发生宕机等故障，数据库也能将数据恢复。&lt;/li&gt;&#xA;&lt;li&gt;MySQL使用&lt;code&gt;redo log&lt;/code&gt;来保证事务的持久性。当通过事务对数据进行修改时，首先会将操作记录到&lt;code&gt;redo log&lt;/code&gt;中，然后对数据库对应行进行修改，这样即使数据库宕机，也能通过&lt;code&gt;redo log&lt;/code&gt;进行恢复。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ACID关系如下图所示：&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png&#34; alt=&#34;ACID关系&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;显式事务&#34;&gt;显式事务&lt;/h2&gt;&#xA;&lt;p&gt;开始事务：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt;;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;或&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;START&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TRANSACTION&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;两者区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;START TRANSACTION&lt;/code&gt;后面可以跟随几个修饰符：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;READ ONLY：标识为只读事务，该事务只能读取数据。&lt;/li&gt;&#xA;&lt;li&gt;READ WRITE：标识为读写事务，该事务可以读写数据。&lt;/li&gt;&#xA;&lt;li&gt;WITH CONSISTENT SNAPSHOT ：启动一致性读。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;完成事务：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;提交事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COMMIT&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;回滚事务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ROLLBACK&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;将事务回滚到某个保存点。&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ROLLBACK&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TO&lt;/span&gt; [SAVEPOINT]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;隐式事务&#34;&gt;隐式事务&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; VARIABLES &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;autocommit&amp;#39;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;隐式提交数据的情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据定义语言：CREATE、ALTER、DROP&lt;/li&gt;&#xA;&lt;li&gt;隐式修改mysql数据库中的表&lt;/li&gt;&#xA;&lt;li&gt;事务控制（连续两次BEGIN，第一个BEGIN后面的语句会自动提交）或关于锁定的语句&lt;/li&gt;&#xA;&lt;li&gt;加载数据的语句&lt;/li&gt;&#xA;&lt;li&gt;MySQL复制的语句&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;completion_type&#34;&gt;completion_type&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;@@&lt;/span&gt;completion_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该变量有三种取值：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：默认值，当我们执行COMMIT时会提交事务，再执行下一个事务时，还需要使用BEGIN来开启。&lt;/li&gt;&#xA;&lt;li&gt;1：提交事务后，相当于执行了&lt;code&gt;COMMIT AND CHAIN&lt;/code&gt;，开启链式事务，当我们提交事务后会开启一个相同隔离级别的事务。&lt;/li&gt;&#xA;&lt;li&gt;2：相当于&lt;code&gt;COMMIT AND RELEASE&lt;/code&gt;，提交事务后，与服务器断开连接。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务分类&#34;&gt;事务分类&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;扁平事务：最简单的一种，使用BEGIN开启，由COMMIT或ROLLBACK结束。&lt;/li&gt;&#xA;&lt;li&gt;带有保存点的扁平事务：支持回滚到指定保存点的事务。&lt;/li&gt;&#xA;&lt;li&gt;链式事务：一个事务由多个子事务构成，提交前一个事务，触发下一个事务。&lt;/li&gt;&#xA;&lt;li&gt;嵌套事务：由顶层事务控制下面各个层次的事务。&lt;/li&gt;&#xA;&lt;li&gt;分布式事务：分布式系统中的扁平事务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;并发事务问题&#34;&gt;并发事务问题&lt;/h1&gt;&#xA;&lt;h2 id=&#34;脏写&#34;&gt;脏写&lt;/h2&gt;&#xA;&lt;p&gt;事务A覆盖了事务B未提交的更新数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL数据存储结构</title>
      <link>http://localhost:1313/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 17 Apr 2020 13:25:04 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql/mysql%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h2 id=&#34;索引组织表&#34;&gt;索引组织表&lt;/h2&gt;&#xA;&lt;p&gt;在InnoDB存储引擎中，表是根据主键顺序组织存放的，这种存储方式的表称为索引组织表，每张表都有一个主键，如果创建时没有显式定义主键，InnoDB存储引擎会按照如下方式进行创建主键：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;判断表中是否有非空的唯一索引，如果有，则该列为主键。&lt;/li&gt;&#xA;&lt;li&gt;如果不符合上列条件，InnoDB存储引擎会自动创建一个6字节大小的指针。&lt;/li&gt;&#xA;&lt;li&gt;当表中有多个非空唯一索引，InnoDB会选择第一个定义的非空唯一索引作为主键。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;innodb逻辑存储结构&#34;&gt;InnoDB逻辑存储结构&lt;/h2&gt;&#xA;&lt;p&gt;所有的数据被逻辑存放在表空间，表空间又由段，区，页（块）组成。存储结构如图所示：&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0064.PNG&#34; alt=&#34;InnoDB逻辑存储结构&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;表空间&#34;&gt;表空间&lt;/h3&gt;&#xA;&lt;p&gt;表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。如果开启了&lt;code&gt;innodb_file_per_table&lt;/code&gt;，每张表的数据可以单独放到一个表空间中。但是每张表的表空间存放的只是数据、索引和插入缓冲Bitmap页。其他类的数据，例如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等还是存放在原来的共享表空间中。&lt;/p&gt;&#xA;&lt;h3 id=&#34;段&#34;&gt;段&lt;/h3&gt;&#xA;&lt;p&gt;表空间由各个段构成，常见的段有：数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据，数据段即为B+树的叶子节点，索引段即为B+树的非索引节点。在InnoDB存储引擎中，对段的管理都是由引擎自身完成，DBA不能也没有必要对其进行控制。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;引入段的目的&lt;/strong&gt;：对于范围查询，会对B+ Tree节点进行顺序扫描，如果不区分叶子节点和非叶子节点，如果将两者放到同一个区当中，查询效率大打折扣，因此引入段来区分不同类型的页面。&lt;/p&gt;&#xA;&lt;h3 id=&#34;区&#34;&gt;区&lt;/h3&gt;&#xA;&lt;p&gt;区是由连续页组成的空间，在任何情况下每个区的大小都为1MB，为了保证区的连续性，InnoDB一次从磁盘申请4~5个区，在默认情况下，页的大小为16KB，即一个区中共有64个连续页。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;引入区的目的&lt;/strong&gt;：B+ Tree底层通过页存储数据，相邻的两个页物理地址可能离得非常远（产生随机IO），因此分配空间时，直接按区进行分配，这样会将相邻的页在物理上也是连续的，可以消除很多次随机IO，同时会造成空间浪费，整体利远大于弊。&lt;/p&gt;&#xA;&lt;p&gt;为了考虑以完整的区为单位分配给某个段对于&lt;strong&gt;数据量较小&lt;/strong&gt;的表而浪费存储空间的情况，InnoDB提出了&lt;strong&gt;碎片区&lt;/strong&gt;的概念，碎片区中的页属于不同段。&lt;/p&gt;&#xA;&lt;h3 id=&#34;页&#34;&gt;页&lt;/h3&gt;&#xA;&lt;p&gt;页是InnoDB磁盘管理的最小单位，默认每个页大小为16KB，可以通过参数&lt;code&gt;innodb_page_size&lt;/code&gt;将页的大小设置为4K，8K、16K。&lt;/p&gt;&#xA;&lt;p&gt;常见的页类型有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据页&lt;/li&gt;&#xA;&lt;li&gt;undo页&lt;/li&gt;&#xA;&lt;li&gt;系统页&lt;/li&gt;&#xA;&lt;li&gt;事务数据页&lt;/li&gt;&#xA;&lt;li&gt;插入缓冲位图页&lt;/li&gt;&#xA;&lt;li&gt;插入缓冲空闲列表页&lt;/li&gt;&#xA;&lt;li&gt;未压缩的二进制大对象页&lt;/li&gt;&#xA;&lt;li&gt;压缩的二进制大对象页&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;行&#34;&gt;行&lt;/h3&gt;&#xA;&lt;p&gt;InnoDB存储引擎是面向行（row-oriented）的，每个页最多存放16K/2~200行的记录（7992行）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;innodb行记录格式&#34;&gt;InnoDB行记录格式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;compact行记录格式&#34;&gt;Compact行记录格式&lt;/h3&gt;&#xA;&lt;p&gt;该格式在MySQL5.0中引入，其设计目的是高效地存储数据。简单说，一个页存放的行数据越多，其性能就越高。它的存储方式如图所示：&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0065%2820200416-174412%29.PNG&#34; alt=&#34;Compact行记录格式&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;变长字段长度列表：对于变长字段的真实数据占用的字节长度都存放这里。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;逆序排放，非NULL&lt;/li&gt;&#xA;&lt;li&gt;如果变长列的长度小于255 bytes，则用1 byte表示，否则用2 byte表示。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;NULL标志位：如果该数据行存在NULL值，使用1表示，该部分占用1 byte。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;头信息固定5字节（40位），每位的含义如下：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;设置&lt;code&gt;deleted_flag&lt;/code&gt;的原因：如果物理删除的话，记录在磁盘上需要重新排列，导致性能消耗，被删除掉的记录会形成一个&lt;strong&gt;垃圾链表（可重用空间）&lt;/strong&gt;，如果之后有新纪录插入到表中，这部分空间将被覆盖掉。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0066.PNG&#34; alt=&#34;Compact记录头信息&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;最后的部分就是实际存储每个列的数据，&lt;strong&gt;NULL不占用任何空间&lt;/strong&gt;，除了之前的标志位，每行数据除了用户定义的列之外，还有两个隐藏列，&lt;strong&gt;事务ID列（6字节）&lt;strong&gt;和&lt;/strong&gt;回滚指针列（7字节）&lt;/strong&gt;。如果没有定义主键，还会增加一个&lt;strong&gt;rowid&lt;/strong&gt;列做为主键（6字节）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;行溢出&#34;&gt;行溢出&lt;/h3&gt;&#xA;&lt;p&gt;行溢出概念：在Compact行格式中，当列长度（例如varchar、BLOB等）达到768 byte后，会将该列的前768byte当作prefix存放在行中，多出来的数据溢出存放到溢出页中，然后通过一个偏移量指针将两者关联起来。&lt;/p&gt;&#xA;&lt;p&gt;Dynamic和Compressed行格式不会存储prefix数据，直接全部溢出，只存储页地址。&lt;/p&gt;&#xA;&lt;h2 id=&#34;innodb数据页结构&#34;&gt;InnoDB数据页结构&lt;/h2&gt;&#xA;&lt;p&gt;InnoDB数据页由以下七个部分构成，如图所示：&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0067.PNG&#34; alt=&#34;数据页结构&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其中&lt;code&gt;File Header、Page Header、File Trailer&lt;/code&gt;的大小是固定的，这些空间是用来标记该页的一些信息，如Checksum，数据页所在的B+树索引的层数。&lt;/p&gt;&#xA;&lt;h3 id=&#34;file-header&#34;&gt;File Header&lt;/h3&gt;&#xA;&lt;p&gt;该部分用来记录各种页的通用信息，共由八个部分组成，占用38字节。&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0068.PNG&#34; alt=&#34;File Header组成部分&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;page-header&#34;&gt;Page Header&lt;/h3&gt;&#xA;&lt;p&gt;该部分用来记录数据页的状态信息，由14个部分组成，占用56字节，如图所示：&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0069.PNG&#34; alt=&#34;Page Header组成部分&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;infimun和supremum-records&#34;&gt;Infimun和Supremum Records&lt;/h3&gt;&#xA;&lt;p&gt;Infimun用来记录是比该页中任何主键值都要小的值，Supremum Records指比任何值都大的值。这两个值在页创建时被建立。&lt;/p&gt;&#xA;&lt;h3 id=&#34;user-record和free-space&#34;&gt;User Record和Free Space&lt;/h3&gt;&#xA;&lt;p&gt;User Record是实际存储行记录的内容。Free Space指的是空闲空间（暂未被使用的空间），是一个链表数据结构，在一条记录被删除后，该空间会被加入到空闲链表中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL文件种类分析</title>
      <link>http://localhost:1313/posts/mysql/mysql-file/</link>
      <pubDate>Wed, 15 Apr 2020 18:48:38 +0000</pubDate>
      <guid>http://localhost:1313/posts/mysql/mysql-file/</guid>
      <description>&lt;h2 id=&#34;参数文件&#34;&gt;参数文件&lt;/h2&gt;&#xA;&lt;p&gt;当MySQL实例启动，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及部分初始化参数。&lt;/p&gt;&#xA;&lt;p&gt;可以通过&lt;code&gt;SHOW VARIABLES&lt;/code&gt;查看数据库中所有参数，可以通过&lt;code&gt;LIKE&lt;/code&gt;过滤参数名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;参数类型&#34;&gt;参数类型&lt;/h3&gt;&#xA;&lt;p&gt;MySQL中参数分为两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;动态参数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在MySQL实例运行中进行更改。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;静态参数&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在实例的整个生命周期内都不得进行更改。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以通过set命令对动态参数进行修改，例如&lt;code&gt;SET read_buffer_size=524288&lt;/code&gt;。&#xA;对变量的修改，在这次的实例生命周期内有效，下次此洞MySQL实例还是会读取参数文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;&#xA;&lt;h3 id=&#34;错误日志&#34;&gt;错误日志&lt;/h3&gt;&#xA;&lt;p&gt;错误日志对MySQL的启动、运行、关闭过程进行了记录，该文件不仅记录了所有的错误信息，也记录了一些警告信息或正确的信息。&lt;/p&gt;&#xA;&lt;p&gt;可以在配置文件中设置存储位置：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[mysqld]&#xA;log-error=[path/[filename]]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或通过查询变量来获取错误日志信息：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; VARIABLES &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log_err%&amp;#39;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;2020-04-13T03:04:23.391925Z 75 [Note] Aborted connection 75 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:04:23.391954Z 76 [Note] Aborted connection 76 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.802373Z 77 [Note] Aborted connection 77 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.802390Z 82 [Note] Aborted connection 82 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.809111Z 79 [Note] Aborted connection 79 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.809298Z 81 [Note] Aborted connection 81 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.809495Z 80 [Note] Aborted connection 80 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.809647Z 83 [Note] Aborted connection 83 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.818503Z 84 [Note] Aborted connection 84 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.820436Z 85 [Note] Aborted connection 85 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.822052Z 86 [Note] Aborted connection 86 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:08:39.809996Z 78 [Note] Aborted connection 78 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.627802Z 87 [Note] Aborted connection 87 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.627848Z 88 [Note] Aborted connection 88 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.627864Z 89 [Note] Aborted connection 89 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.627891Z 90 [Note] Aborted connection 90 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.627917Z 91 [Note] Aborted connection 91 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.627949Z 92 [Note] Aborted connection 92 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.627994Z 93 [Note] Aborted connection 93 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.628018Z 94 [Note] Aborted connection 94 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.628034Z 95 [Note] Aborted connection 95 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T03:17:12.628055Z 96 [Note] Aborted connection 96 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T05:29:24.573237Z 34 [Note] Aborted connection 34 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T05:29:24.573406Z 35 [Note] Aborted connection 35 to db: &amp;#39;dev&amp;#39; user: &amp;#39;root&amp;#39; host: &amp;#39;localhost&amp;#39; (Got an error reading communication packets)&#xA;2020-04-13T09:49:37.346162Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 4528ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)&#xA;2020-04-14T01:35:39.190069Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 43183898ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)&#xA;2020-04-14T07:30:03.500507Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 9873804ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)&#xA;2020-04-15T02:39:20.019686Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 46274005ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;慢查询日志&#34;&gt;慢查询日志&lt;/h3&gt;&#xA;&lt;p&gt;慢查询日志可以帮助DBA定位存在查询较慢的SQL语句，从而实现SQL语句层面的优化。可以通过&lt;code&gt;long_query_time&lt;/code&gt;来设置慢查询阈值。默认值为10s.&#xA;默认情况下，MySQL不开启慢查询日志，需要手动将&lt;code&gt;log_slow_queries&lt;/code&gt;设置为ON。另一个和慢查询相关的参数&lt;code&gt;log_queries_not_using_indexes&lt;/code&gt;，这个参数如果是ON，就会将运行的SQL语句没有使用索引的，记录到慢查询日志中。&#xA;MySQL 5.6.5中新增一个参数&lt;code&gt;log_throttle_queries_not_using_indexes&lt;/code&gt;，用来表示每分钟允许记录到慢查询日志且未使用索引的SQL语句次数。默认为0，表示没有限制。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
