<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on L1nker4&#39;s Blog | 格木观云</title>
    <link>http://localhost:1313/tags/jvm/</link>
    <description>Recent content in JVM on L1nker4&#39;s Blog | 格木观云</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 03 Mar 2024 21:34:49 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM内存问题排查流程</title>
      <link>http://localhost:1313/posts/jvm/jvm%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 03 Mar 2024 21:34:49 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;确认问题现象&#34;&gt;确认问题现象&lt;/h2&gt;&#xA;&lt;p&gt;可以通过服务状态，监控面板、日志信息、监控工具（VisualVM）等，确认问题类型：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内存使用率居高不下、内存缓慢增加、OOM等&lt;/li&gt;&#xA;&lt;li&gt;频繁GC：Full GC等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;发现问题不建议重启，留存状态。&lt;/p&gt;&#xA;&lt;h2 id=&#34;保留数据&#34;&gt;保留数据&lt;/h2&gt;&#xA;&lt;h3 id=&#34;heapdump文件&#34;&gt;heapdump文件&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#arthas导出方式&#xA;heapdump /tmp/dump.hprof&#xA;&#xA;#jmap命令保存整个Java堆&#xA;jmap -dump:format=b,file=heap.bin &amp;lt;pid&amp;gt; &#xA;&#xA;#jmap命令只保存Java堆中的存活对象, 包含live选项，会在堆转储前执行一次Full GC&#xA;jmap -dump:live,format=b,file=heap.bin &amp;lt;pid&amp;gt;&#xA;&#xA;#jcmd命令保存整个Java堆,Jdk1.7后有效&#xA;jcmd &amp;lt;pid&amp;gt; GC.heap_dump filename=heap.bin&#xA;&#xA;#在出现OutOfMemoryError的时候JVM自动生成（推荐）节点剩余内存不足heapdump会生成失败&#xA;-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heap.bin&#xA;&#xA;#编程的方式生成&#xA;使用HotSpotDiagnosticMXBean.dumpHeap()方法&#xA;&#xA;#在出现Full GC前后JVM自动生成，本地快速调试可用&#xA;-XX:+HeapDumpBeforeFullGC或 -XX:+HeapDumpAfterFullGC&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JVM参数：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-XX:printGCDetails -XX:+UseConcMarkSweepGC -XX:+HeapDumpOnOutOfMemoryError &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;gc日志&#34;&gt;GC日志&lt;/h3&gt;&#xA;&lt;p&gt;JVM启动参数如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Java8及以下&#xA;-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:&amp;lt;path&amp;gt;&#xA;&#xA;# Java9及以上&#xA;-Xlog:gc*:&amp;lt;path&amp;gt;:time&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过EasyGC进行日志分析。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务日志&#34;&gt;服务日志&lt;/h3&gt;&#xA;&lt;p&gt;通常由日志组件（Promtail &amp;amp; loki）进行采集、存储、展示。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实际问题&#34;&gt;实际问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;堆内存溢出&#34;&gt;堆内存溢出&lt;/h3&gt;&#xA;&lt;p&gt;问题现象：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;OutOfMemoryError&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;直接内存溢出&#34;&gt;直接内存溢出&lt;/h3&gt;&#xA;&lt;p&gt;问题现象：top指令中相关Java进程占用的RES超过了-Xmx的大小，并且内存占用不断上升。&lt;/p&gt;&#xA;&lt;p&gt;问题定位方法：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可通过开启NMT（&lt;strong&gt;-XX:NativeMemoryTracking=detail&lt;/strong&gt;）定位问题&lt;/li&gt;&#xA;&lt;li&gt;jcmd查看直接内存情况：jcmd pid VM.native_memory detail&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;NIO、Netty等常用直接内存，Netty可以通过&lt;code&gt;-Dio.netty.leakDetectionLevel&lt;/code&gt;开启&lt;/p&gt;&#xA;&lt;h3 id=&#34;栈空间溢出&#34;&gt;栈空间溢出&lt;/h3&gt;&#xA;&lt;p&gt;问题现象：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;StackOverflow&lt;/li&gt;&#xA;&lt;li&gt;OutOfMemoryError：unable to create new native thread&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;问题定位方法：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之字节码执行引擎（九）</title>
      <link>http://localhost:1313/posts/jvm/jvm09-bytecode-engine/</link>
      <pubDate>Fri, 03 Apr 2020 19:56:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm09-bytecode-engine/</guid>
      <description>&lt;h2 id=&#34;字节码执行引擎&#34;&gt;字节码执行引擎&lt;/h2&gt;&#xA;&lt;p&gt;执行引擎是JVM核心的组成部分之一，虚拟机是一个相对于物理机的概念，物理机的执行引擎是直接建立在存储器、缓存、指令集和操作系统上的，而虚拟机的执行引擎完全由软件自行实现。因此可以不受物理条件制约地定制指令集与执行引擎地结构体系。&lt;/p&gt;&#xA;&lt;p&gt;执行引擎在执行字节码地时候，通常会有解释执行和编译执行两种选择。&lt;/p&gt;&#xA;&lt;h2 id=&#34;运行时栈帧结构&#34;&gt;运行时栈帧结构&lt;/h2&gt;&#xA;&lt;p&gt;JVM以方法为最基本地执行单元，栈帧是用于支持JVM进行方法调用和方法执行背后地数据结构，它是JVM运行时数据区中虚拟机栈地栈元素，每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面的入栈到出栈的过程。&lt;/p&gt;&#xA;&lt;p&gt;对于执行引擎来说，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是在运行的，被称为&lt;strong&gt;当前栈帧&lt;/strong&gt;，与这个栈帧相关联的方法被称为&lt;strong&gt;当前方法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;局部变量表&#34;&gt;局部变量表&lt;/h3&gt;&#xA;&lt;p&gt;局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽为最小单位。&lt;/p&gt;&#xA;&lt;p&gt;当一个方法被调用时，JVM会使用局部变量表完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过&lt;strong&gt;this&lt;/strong&gt;来访问到这个参数，其余参数按照参数表顺序排列，占用从1开始的局部变量槽。&lt;/p&gt;&#xA;&lt;h3 id=&#34;操作数栈&#34;&gt;操作数栈&lt;/h3&gt;&#xA;&lt;p&gt;操作数栈也被称为操作栈，它是一个后入先出栈，操作数栈的最大深度在编译时写入到Code属性的max_stacks数据项之中，操作数栈的每一个元素都可以是包括long和double在内的任何Java数据类型，32位数据类型所占的栈容量为1，64位数据类型栈容量为2.&lt;/p&gt;&#xA;&lt;p&gt;当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。&lt;/p&gt;&#xA;&lt;p&gt;操作数栈中的数据类型必须与字节码指令的序列严格匹配，在编译程序代码时，编译器需要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。&lt;/p&gt;&#xA;&lt;p&gt;在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但在大多数JVM实现里会进行一些优化操作，令两个栈帧出现一部分重叠，让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起。不仅可以节约空间，更重要的是在方法调用时可以直接共用一部分数据，无需进行额外的参数复制传递了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;方法返回地址&#34;&gt;方法返回地址&lt;/h3&gt;&#xA;&lt;p&gt;当一个方法开始执行后，只有两种方式退出这个方法，第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时可能会有返回值传递给上层的方法调用者，方法是否有返回之以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为&lt;strong&gt;正常调用完成&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;另一种方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是JVM内部异常，还是代码中使用了&lt;code&gt;athrow&lt;/code&gt;指令产生的异常，只要在笨方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为&lt;strong&gt;异常调用完成&lt;/strong&gt;，异常调用完成的方式退出，不会给它的调用者提供任何返回值。&lt;/p&gt;&#xA;&lt;p&gt;方法退出的过程实际上等同于当前栈帧出栈，因此退出时可能执行饿操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈，调整PC计数器的值以指向方法调用指令后面的一条指令等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;方法调用&#34;&gt;方法调用&lt;/h2&gt;&#xA;&lt;p&gt;一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。&lt;/p&gt;&#xA;&lt;h3 id=&#34;解析&#34;&gt;解析&lt;/h3&gt;&#xA;&lt;p&gt;在类加载的解析阶段，会将其中的一部分符号引用转换成直接引用，这种解析能成立的前提是：方法在程序运行之前就有一个可确定的调用版本，并且方法的调用版本在运行期不可改变的。&lt;/p&gt;&#xA;&lt;p&gt;在Java语言中符合“编译期可知，运行期不可知”的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问。这两种方法各自的特点决定了都不可能通过继承或别的方式重写出其他版本，因此都适合在类加载阶段进行解析。&lt;/p&gt;&#xA;&lt;p&gt;调用不同种类的方法有不同的字节码指令，分别是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;invokestatic：调用静态方法&lt;/li&gt;&#xA;&lt;li&gt;invokespecial：用于调用实例构造器&lt;init&gt;()方法、私有方法和父类中的方法&lt;/li&gt;&#xA;&lt;li&gt;invokevirtual：用于调用所有的虚方法&lt;/li&gt;&#xA;&lt;li&gt;invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象&lt;/li&gt;&#xA;&lt;li&gt;invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后执行该方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言中符合这个条件的有静态方法、私有方法、实例构造器、父类方法，被final修饰的方法，这五种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为&lt;strong&gt;非虚方法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分派&#34;&gt;分派&lt;/h3&gt;&#xA;&lt;p&gt;另一种主要的方法调用形式：分派调用则复杂许多，他可能是静态的，可能是动态的，按照分派依据的宗量数可分为单分派和多分派，这两种分派方式两两组合可以得到四种分派组合情况。&lt;/p&gt;&#xA;&lt;h4 id=&#34;静态分派&#34;&gt;静态分派&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StaticDispatch&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Human&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Man&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Human{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Woman&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Human{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sayHello&lt;/span&gt;(Human guy){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello,guy!&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sayHello&lt;/span&gt;(Man guy){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello,gentlemen!&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sayHello&lt;/span&gt;(Woman guy){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello,lady!&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;Human man&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Man();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;Human woman&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Woman();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;sayHello(man);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;sayHello(woman);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果为：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之类加载机制（八）</title>
      <link>http://localhost:1313/posts/jvm/jvm08-class-load/</link>
      <pubDate>Sat, 28 Mar 2020 19:51:37 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm08-class-load/</guid>
      <description>&lt;h2 id=&#34;类加载机制&#34;&gt;类加载机制&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;JVM把Class描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为类加载机制。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;类加载的时机&#34;&gt;类加载的时机&lt;/h3&gt;&#xA;&lt;p&gt;类加载机制的整个生命周期将经历：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加载&lt;/li&gt;&#xA;&lt;li&gt;验证&lt;/li&gt;&#xA;&lt;li&gt;准备&lt;/li&gt;&#xA;&lt;li&gt;解析&lt;/li&gt;&#xA;&lt;li&gt;初始化&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;/li&gt;&#xA;&lt;li&gt;卸载&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其中验证，准备，解析三部分统称为连接。&#xA;加载，验证，准备，初始化，卸载这五个阶段的顺序是确定的，而解析阶段则不一定，他在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或者晚期绑定）。&lt;/p&gt;&#xA;&lt;p&gt;关于在什么情况下进行类加载的第一个过程，JVM规范并没有强制约束，这点交给虚拟机的具体实现来自由把握，但是对于初始化阶段，JVM严格规定了有且仅有六种情况必须立即对类进行初始化（加载验证准备自然在此之前）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;遇到new，getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则需要先出发其初始化阶段，主要场景有：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用new关键字实例化对象的时候&lt;/li&gt;&#xA;&lt;li&gt;读取或设置一个类型的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）&lt;/li&gt;&#xA;&lt;li&gt;调用一个类型的静态方法的时候&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;code&gt;java.lang.reflect&lt;/code&gt;包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要触发初始化&lt;/li&gt;&#xA;&lt;li&gt;当初始化类的时候，如果发现其父类没有进行初始化，则需要先对父类进行初始化&lt;/li&gt;&#xA;&lt;li&gt;当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类&lt;/li&gt;&#xA;&lt;li&gt;当使用JDK 7新加入的动态语言支持时，如果使用一个&lt;code&gt;java.lang.invoke.MethodHandle&lt;/code&gt;实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。&lt;/li&gt;&#xA;&lt;li&gt;当一个接口定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那么该接口要在其之前被初始化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这六种场景中的行为被称为&lt;strong&gt;对一个类型的主动引用&lt;/strong&gt;，除此之外，所有引用类型的方式不会触发初始化，称为&lt;strong&gt;被动引用&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;被动引用的demo&#34;&gt;被动引用的Demo&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * 被动引用 Demo1:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * 通过子类引用父类的静态字段，不会导致子类初始化。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SuperClass&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SuperClass init!&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 123;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SubClass&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; SuperClass {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SubClass init!&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NotInitialization&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(SubClass.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// SuperClass init!&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之字节码指令（七）</title>
      <link>http://localhost:1313/posts/jvm/jvm07-bytecode/</link>
      <pubDate>Fri, 27 Mar 2020 13:32:16 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm07-bytecode/</guid>
      <description>&lt;h2 id=&#34;字节码指令&#34;&gt;字节码指令&lt;/h2&gt;&#xA;&lt;p&gt;Java虚拟机的指令是由一个字节长度的，代表某种特定操作含义的数字（称为操作码，Opcode），以及跟随其后的零至多个代表此操作的参数，称为操作数（Operand）构成。由于Java虚拟机面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码。指令参数存放在操作数栈中。&lt;/p&gt;&#xA;&lt;p&gt;由于Java虚拟机操作码的长度为一个字节（0-255），这意味着指令集的操作码总数不能超过256条。&lt;/p&gt;&#xA;&lt;h3 id=&#34;加载和存储指令&#34;&gt;加载和存储指令&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将一个局部变量加载到操作数栈：iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、dload_&lt;n&gt;、aload、aload_&lt;n&gt;&lt;/li&gt;&#xA;&lt;li&gt;将一个数值从操作数栈存储到局部变量表：istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;&lt;/li&gt;&#xA;&lt;li&gt;将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;&lt;/li&gt;&#xA;&lt;li&gt;扩充局部变量表的访问索引的指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;运算指令&#34;&gt;运算指令&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;加法指令：iadd、ladd、fadd、dadd&lt;/li&gt;&#xA;&lt;li&gt;减法指令：isub、lsub、fsub、dsub&lt;/li&gt;&#xA;&lt;li&gt;乘法指令：imul、lmul、fmul、dmul&lt;/li&gt;&#xA;&lt;li&gt;除法指令：idiv、ldiv、fdiv、ddiv&lt;/li&gt;&#xA;&lt;li&gt;求余指令：irem、lrem、frem、drem&lt;/li&gt;&#xA;&lt;li&gt;取反指令：ineg、lneg、fneg、dneg&lt;/li&gt;&#xA;&lt;li&gt;位移指令：ishl、ishr、iushr、lshl、lshr、lushr&lt;/li&gt;&#xA;&lt;li&gt;按位或指令：ior、lor&lt;/li&gt;&#xA;&lt;li&gt;按位与指令：iand、land&lt;/li&gt;&#xA;&lt;li&gt;按位异或指令：ixor、lxor&lt;/li&gt;&#xA;&lt;li&gt;局部变量自增指令：iinc&lt;/li&gt;&#xA;&lt;li&gt;比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;类型转换指令&#34;&gt;类型转换指令&lt;/h3&gt;&#xA;&lt;p&gt;JVM直接支持小范围类型向大范围类型的安全转换：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;int -&amp;gt; long/float/double&lt;/li&gt;&#xA;&lt;li&gt;long -&amp;gt; float/double&lt;/li&gt;&#xA;&lt;li&gt;float -&amp;gt; double&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;处理窄化类型转换时，要用转换指令来完成。包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f.&lt;/p&gt;&#xA;&lt;p&gt;在将int或long类型窄化转换成整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度。这将可能导致转换结果与输入值的正负号不同。&lt;/p&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;对象创建与访问指令&#34;&gt;对象创建与访问指令&lt;/h3&gt;&#xA;&lt;p&gt;虽然类实例和数组都是对象，但是JVM对类实例和数组的创建使用不同的字节码指令，对象创建后，可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;创建类实例指令：new&lt;/li&gt;&#xA;&lt;li&gt;创建数组的指令：newarray，anewarray，multianewarray&lt;/li&gt;&#xA;&lt;li&gt;访问类字段（static字段）和实例字段（非static字段）的指令：getfield、putfield、getstatic、putstatic&lt;/li&gt;&#xA;&lt;li&gt;把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload&lt;/li&gt;&#xA;&lt;li&gt;将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore&lt;/li&gt;&#xA;&lt;li&gt;取数组长度的指令：arraylength&lt;/li&gt;&#xA;&lt;li&gt;检查类实例类型的指令：instanceof、checkcast&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;操作数栈管理指令&#34;&gt;操作数栈管理指令&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将操作数栈的栈顶一个或者两个元素出栈：pop、pop2&lt;/li&gt;&#xA;&lt;li&gt;复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2&lt;/li&gt;&#xA;&lt;li&gt;将栈最顶端的两个数值交换：swap&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;控制转移指令&#34;&gt;控制转移指令&lt;/h3&gt;&#xA;&lt;p&gt;可以认为控制指令就是在有条件或者无条件地修改PC寄存器地值，控制指令包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne&lt;/li&gt;&#xA;&lt;li&gt;复合条件分支：tableswitch、lookupswitch&lt;/li&gt;&#xA;&lt;li&gt;无条件分支：goto、goto_w、jsr、jsr_w，ret&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;方法调用和返回指令&#34;&gt;方法调用和返回指令&lt;/h3&gt;&#xA;&lt;p&gt;方法调用指令包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;invokevirtual：用于调用对象地实例方法，根据对象地实际类型进行分派&lt;/li&gt;&#xA;&lt;li&gt;invokeinterface：用于调用接口方法，他会在运行时搜索一个实现了这个接口地方法地对象，找出合适地方法进行调用&lt;/li&gt;&#xA;&lt;li&gt;invokespecial：用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法&lt;/li&gt;&#xA;&lt;li&gt;invokestatic：用于调用类静态方法&lt;/li&gt;&#xA;&lt;li&gt;invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;方法返回指令包括&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ireturn（返回值为Boolean，char，short，int时使用）&lt;/li&gt;&#xA;&lt;li&gt;lreturn&lt;/li&gt;&#xA;&lt;li&gt;freturn&lt;/li&gt;&#xA;&lt;li&gt;dreturn&lt;/li&gt;&#xA;&lt;li&gt;areturn&lt;/li&gt;&#xA;&lt;li&gt;return（void）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;异常处理指令&#34;&gt;异常处理指令&lt;/h3&gt;&#xA;&lt;p&gt;Java程序中显式抛出异常的操作（throw）都由athrow指令来实现。JVM规范规定许多运行时异常会在其他Java虚拟机指令检测到异常状态时自动抛出。&#xA;处理异常不是由字节码实现的，而是采用异常表实现的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;同步指令&#34;&gt;同步指令&lt;/h3&gt;&#xA;&lt;p&gt;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，也被称为锁）来实现的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之类文件结构（六）</title>
      <link>http://localhost:1313/posts/jvm/jvm06-class-file/</link>
      <pubDate>Thu, 26 Mar 2020 17:30:40 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm06-class-file/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;实现语言无关性的基础是虚拟机和字节码存储格式。Java虚拟机不与任何程序语言绑定，它只与Class文件这种特定的二进制文件格式所关联。Class文件中包含了Java虚拟机指令集，符号表以及若干其他辅助信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;class文件结构&#34;&gt;Class文件结构&lt;/h2&gt;&#xA;&lt;p&gt;任何一个Class文件对应着唯一的一个类或者接口的定义信息，Class文件是一组以八个字节为基础单位的&lt;strong&gt;二进制流&lt;/strong&gt;，各个数据项目严格按照顺序紧凑的排列，中间没有任何分隔符，Class文件只有两种类型：&lt;strong&gt;无符号数&lt;/strong&gt;、&lt;strong&gt;表&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无符号数属于基本数据类型，以u1,u2,u4,u8分别代表1/2/4/8个字节的无符号数，无符号数用来描述数字，索引引用，数量值。&lt;/li&gt;&#xA;&lt;li&gt;表：由多个无符号数或者其他表作为数据项构成的复合数据类型。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;魔数&#34;&gt;魔数&lt;/h3&gt;&#xA;&lt;p&gt;Class文件的头4个字节被称为魔数，它的唯一作用就是确定这个文件是否为一个能被JVM接受的Class文件，魔数的十六进制表示为&lt;code&gt;0xCAFEBABE&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;版本信息&#34;&gt;版本信息&lt;/h3&gt;&#xA;&lt;p&gt;紧接着魔数的4个字节的是版本信息，第5-6字节是次版本号，7-8字节是主版本号，表示Class文件使用的JDK版本。&#xA;高版本的JDK能向下兼容，但是不能向上兼容。&lt;/p&gt;&#xA;&lt;h3 id=&#34;常量池&#34;&gt;常量池&lt;/h3&gt;&#xA;&lt;p&gt;版本信息之后是常量池入口，常量池主要存放两大类常量：&lt;strong&gt;字面量&lt;/strong&gt;、&lt;strong&gt;符号引用&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;常量池中常量的数量是不固定的，所以在入口需要放置一项u2类型的数据，代表常量池容量计数值。&lt;/p&gt;&#xA;&lt;p&gt;字面量接近于常量概念，如字符串、被声明为final的值。&#xA;符号引用属于编译原理方面的概念：主要包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;被模块导出或开放的包&lt;/li&gt;&#xA;&lt;li&gt;类和接口的全限定名&lt;/li&gt;&#xA;&lt;li&gt;字段的名称和描述符&lt;/li&gt;&#xA;&lt;li&gt;方法的名称和描述符&lt;/li&gt;&#xA;&lt;li&gt;方法句柄和方法类型&lt;/li&gt;&#xA;&lt;li&gt;动态调用点和动态产量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;常量池的每个常量都是一个表，共有17钟不同类型的常量。表开始的第一位是个u1类型的标志位，代表当前常量属于哪种常量类型。&lt;/p&gt;&#xA;&lt;p&gt;17种常量类型：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;tag&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_utf8_info&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;UTF-8编码的字符串&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_Integer_info&lt;/td&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;整型字面量&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_Float_info&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;浮点型字面量&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_Long_info&lt;/td&gt;&#xA;          &lt;td&gt;5&lt;/td&gt;&#xA;          &lt;td&gt;长整型字面量&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_Double_info&lt;/td&gt;&#xA;          &lt;td&gt;6&lt;/td&gt;&#xA;          &lt;td&gt;双精度浮点型字面量&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_Class_info&lt;/td&gt;&#xA;          &lt;td&gt;7&lt;/td&gt;&#xA;          &lt;td&gt;类或接口的符号引用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_String_info&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;字符串类型字面量&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_Fieldref_info&lt;/td&gt;&#xA;          &lt;td&gt;9&lt;/td&gt;&#xA;          &lt;td&gt;字段的符号引用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_Methodref_info&lt;/td&gt;&#xA;          &lt;td&gt;10&lt;/td&gt;&#xA;          &lt;td&gt;类中方法的符号引用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_InterfaceMethodref_info&lt;/td&gt;&#xA;          &lt;td&gt;11&lt;/td&gt;&#xA;          &lt;td&gt;接口中方法的符号引用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_NameAndType_info&lt;/td&gt;&#xA;          &lt;td&gt;12&lt;/td&gt;&#xA;          &lt;td&gt;字段或方法的符号引用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_MethodHandle_info&lt;/td&gt;&#xA;          &lt;td&gt;15&lt;/td&gt;&#xA;          &lt;td&gt;表示方法句柄&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_MethodType_info&lt;/td&gt;&#xA;          &lt;td&gt;16&lt;/td&gt;&#xA;          &lt;td&gt;标识方法类型&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONSTANT_InvokeDynamic_info&lt;/td&gt;&#xA;          &lt;td&gt;18&lt;/td&gt;&#xA;          &lt;td&gt;表示一个动态方法调用点&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;br&gt;&#xA;对于 CONSTANT_Class_info（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下：&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;数量&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;u1&lt;/td&gt;&#xA;          &lt;td&gt;tag&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;u2&lt;/td&gt;&#xA;          &lt;td&gt;name_index&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;tag 是标志位，用于区分常量类型；name_index 是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为 0x0002，也即是指向了常量池中的第二项常量。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之内存分配策略（五）</title>
      <link>http://localhost:1313/posts/jvm/jvm05-memory-allocate/</link>
      <pubDate>Wed, 25 Mar 2020 19:53:08 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm05-memory-allocate/</guid>
      <description>&lt;h2 id=&#34;内存分配与回收策略&#34;&gt;内存分配与回收策略&lt;/h2&gt;&#xA;&lt;p&gt;Java技术体系的自动内存管理，最根本性的目标是自动化解决两个问题：自动给对象分配内存，以及自动回收分配给对象的内存。&lt;/p&gt;&#xA;&lt;p&gt;对象的内存分配，就是在堆上分配（也有可能经过JIT编译后被拆散为标量空间类型间接地在栈上分配），新生对象主要分配在新生代中，少数情况（大小超过阈值）会被分配在老年代，分配规则不固定，取决于当前使用的垃圾收集器与JVM参数设置。&lt;/p&gt;&#xA;&lt;h3 id=&#34;对象优先在eden分配&#34;&gt;对象优先在Eden分配&lt;/h3&gt;&#xA;&lt;p&gt;大多数情况下，对象在新生代Eden去中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。&lt;/li&gt;&#xA;&lt;li&gt;Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;大对象直接进入老年代&#34;&gt;大对象直接进入老年代&lt;/h3&gt;&#xA;&lt;p&gt;大对象就是需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串，或者元素数量很庞大的数组。&lt;/p&gt;&#xA;&lt;p&gt;JVM提供了一个&lt;code&gt;-XX:PretenureSizeThreshold&lt;/code&gt;，指定大于该设置值的对象直接在老年代分配，这样做的目的是避免在Eden区和两个Survivor区之间来回复制，产生大量内存复制操作。&lt;/p&gt;&#xA;&lt;h3 id=&#34;长期存活的对象进入老年代&#34;&gt;长期存活的对象进入老年代&lt;/h3&gt;&#xA;&lt;p&gt;为了决策哪些存活对象存储在新生代，哪些对象存储在老年代，，JVM给每个对象定义了一个对象年龄计数器，存储在对象头中，对象通常在Eden区诞生，如果经历一次Miror GC后仍然存活，并且能被Survivor容纳，该对象就会被移动到Survivor，并将该对象年龄设为1岁，对象每经历一次Miror GC，年龄就增加1岁，当年龄达到一定程度（默认15），就会被移动到老年代，对象年龄阈值可以通过&lt;code&gt;-XX:MaxTenuringThreshold&lt;/code&gt;设置。&lt;/p&gt;&#xA;&lt;h3 id=&#34;动态对象年龄判定&#34;&gt;动态对象年龄判定&lt;/h3&gt;&#xA;&lt;p&gt;如果当前新生代的Survivor中，相同年龄的所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象可以进入老年代，无需等到MaxTenuringThreshold 中要求的年龄。&lt;/p&gt;&#xA;&lt;h3 id=&#34;空间分配担保&#34;&gt;空间分配担保&lt;/h3&gt;&#xA;&lt;p&gt;JDK 6 Update 24 之前，在发生Miror GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次的Miror GC可以确保是安全的，如果不成立，则虚拟机会查看 HandlePromotionFailure 值是否设置为允许担保失败， 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那此时也要改为进行一次 Full GC。&lt;/p&gt;&#xA;&lt;p&gt;JDK 6 Update 24 之后的规则变为：&lt;br&gt;&#xA;只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之垃圾收集算法与垃圾收集器（四）</title>
      <link>http://localhost:1313/posts/jvm/jvm04-gc-algorithrms/</link>
      <pubDate>Tue, 24 Mar 2020 21:05:57 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm04-gc-algorithrms/</guid>
      <description>&lt;h2 id=&#34;垃圾收集算法&#34;&gt;垃圾收集算法&lt;/h2&gt;&#xA;&lt;p&gt;从如何判定对象消亡的角度出发，垃圾收集算法可以划分为&lt;strong&gt;引用计数式垃圾收集&lt;/strong&gt;和&lt;strong&gt;追踪式垃圾收集&lt;/strong&gt;，由于引用计数式垃圾收集在主流JVM并未涉及，所以追踪式垃圾收集为主。&lt;/p&gt;&#xA;&lt;p&gt;当前的JVM大多数遵循了&lt;strong&gt;分代收集&lt;/strong&gt;理论进行设计，它主要建立在两个分代假说上面：&lt;strong&gt;弱分代假说&lt;/strong&gt;和&lt;strong&gt;强分代假说&lt;/strong&gt;。分代假说奠定了收集器的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。&lt;/p&gt;&#xA;&lt;h3 id=&#34;标记-清除算法&#34;&gt;标记-清除算法&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;标记&lt;/strong&gt;过程：遍历所有的&lt;code&gt;GC Roots&lt;/code&gt;，然后将&lt;code&gt;GC Roots&lt;/code&gt;可达对象标记为存活的对象。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;清除&lt;/strong&gt;过程：将没有标记的对象全部清除。&lt;/p&gt;&#xA;&lt;p&gt;主要缺点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;执行效率不稳定&lt;/li&gt;&#xA;&lt;li&gt;内存空间碎片化问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;标记-复制算法&#34;&gt;标记-复制算法&lt;/h3&gt;&#xA;&lt;p&gt;也被简称为复制算法，它将可用内存划分成大小相等的两块，每次只使用其中的一块，当这一块的内存用完，就把还存活的对象复制到另外一块上面，然后再把这一块内存全部清除。这种算法有优有劣。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;优点：不会出现内存碎片的问题&lt;/li&gt;&#xA;&lt;li&gt;缺点：可用内存缩为原来的一半，浪费空间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了提高空间利用率的问题，可以将新生代分为一块较大的&lt;code&gt;Eden&lt;/code&gt;区，和两块较小的&lt;code&gt;Survivor&lt;/code&gt;区，比例为&lt;code&gt;8:1:1&lt;/code&gt;,每次 分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor区，然后清理掉Eden和已用过的Survivor区，这样只有10%的内存被浪费掉。&#xA;但是不能保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存区域（老年代）进行分配担保。&lt;/p&gt;&#xA;&lt;h3 id=&#34;标记-整理算法&#34;&gt;标记-整理算法&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;标记&lt;/strong&gt;过程：与&lt;strong&gt;标记-清除算法&lt;/strong&gt;一样，将存活的对象标记。&#xA;&lt;strong&gt;整理&lt;/strong&gt;过程：让所有存活的对象都向内存空间一端移动，然后直接清理掉边界之外的内存。&lt;/p&gt;&#xA;&lt;p&gt;这是一种老年代的垃圾收集算法，老年代对象的生命周期较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次效率很低。&lt;/p&gt;&#xA;&lt;h2 id=&#34;经典垃圾收集器&#34;&gt;经典垃圾收集器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;新生代垃圾收集器&#34;&gt;新生代垃圾收集器&lt;/h3&gt;&#xA;&lt;h4 id=&#34;serial收集器单线程&#34;&gt;Serial收集器（单线程）&lt;/h4&gt;&#xA;&lt;p&gt;Serial收集器是一个新生代垃圾收集器，它在垃圾收集时，必须暂停其它所有工作线程,知道它收集结束（Stop the World）。&#xA;对于内存资源受限的环境，它时所有收集器里面额外内存消耗最小的，对于单核处理器或者处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，壮美做垃圾收集自然可以获得最高的单线程手机效率。&lt;/p&gt;&#xA;&lt;h4 id=&#34;parnew收集器多线程&#34;&gt;ParNew收集器（多线程）&lt;/h4&gt;&#xA;&lt;p&gt;ParNew收集器实质上时Serial收集器的多线程并行版本，由多条GC线程并行的进行垃圾清理，清理过程仍需Stop The World。在多 CPU 环境下性能比 Serial 会有一定程度的提升；但&lt;strong&gt;线程切换需要额外的开销&lt;/strong&gt;，因此在单 CPU 环境中表现不如 Serial。&lt;/p&gt;&#xA;&lt;h4 id=&#34;parallel-scavenge收集器多线程&#34;&gt;Parallel Scavenge收集器（多线程）&lt;/h4&gt;&#xA;&lt;p&gt;Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。&lt;/li&gt;&#xA;&lt;li&gt;ParNew：追求降低用户停顿时间，适合交互式应用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)&lt;/p&gt;&#xA;&lt;h3 id=&#34;老年代垃圾收集器&#34;&gt;老年代垃圾收集器&lt;/h3&gt;&#xA;&lt;h4 id=&#34;serial-old收集器单线程&#34;&gt;Serial Old收集器（单线程）&lt;/h4&gt;&#xA;&lt;p&gt;Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用&lt;strong&gt;标记-整理&lt;/strong&gt;算法；Serial 工作在新生代，使用&lt;strong&gt;标记-复制&lt;/strong&gt;算法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之垃圾收集策略（三）</title>
      <link>http://localhost:1313/posts/jvm/jvm03-gc-strategy/</link>
      <pubDate>Mon, 23 Mar 2020 22:00:18 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm03-gc-strategy/</guid>
      <description>&lt;h2 id=&#34;垃圾收集策略&#34;&gt;垃圾收集策略&lt;/h2&gt;&#xA;&lt;p&gt;程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而执行入栈和出栈操作，每个栈帧分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的分配和回收具备确定性。在这几个区域不需要过多考虑如何回收的问题，当方法执行结束或者线程结束，内存自然就跟随着回收。&#xA;而Java堆和方法区，只有程序运行期间才知道会创建多少对象，这部分内存的分配和回收都是动态的，GC关注的正是这部分内存。&lt;/p&gt;&#xA;&lt;h3 id=&#34;判断对象是否存活&#34;&gt;判断对象是否存活&lt;/h3&gt;&#xA;&lt;p&gt;如果一个对象不被任何对象或变量引用，那么他就是无效对象，需要被回收。判断是存活主要有以下几种算法。&lt;/p&gt;&#xA;&lt;h4 id=&#34;引用计数算法&#34;&gt;引用计数算法&lt;/h4&gt;&#xA;&lt;p&gt;在对象中添加一个引用计数器，每当有一个对地方引用它时，计数器值就加一，当引用失效时，计数器值就减一，任何时刻计数器为零的对象就是不可能再被使用的。&#xA;引用计数原理简单，判定效率也高，但是主流的JVM并没有选用引用计数来管理内存，主要原因是这个算法有很多例外情况需要考虑，比如对象之间相互循环引用。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;可达性分析算法&#34;&gt;可达性分析算法&lt;/h4&gt;&#xA;&lt;p&gt;所有和 &lt;code&gt;GC Roots&lt;/code&gt; 直接或间接关联的对象都是有效对象，和 &lt;code&gt;GC Roots&lt;/code&gt; 没有关联的对象就是无效对象。&lt;/p&gt;&#xA;&lt;p&gt;从&lt;code&gt;GC Roots&lt;/code&gt;作为起始节点，根据引用关系向下搜索，搜索过程所走过的路径称为&lt;strong&gt;引用链&lt;/strong&gt;，如果某个对象到&lt;code&gt;GC Roots&lt;/code&gt;之间没有任何引用链相连，就证明此对象不可能在被使用的。&lt;/p&gt;&#xA;&lt;p&gt;在Java技术体系里面，固定可作为&lt;code&gt;GC Roots&lt;/code&gt;的对象包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在虚拟机栈（栈帧的本地变量表）中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等&lt;/li&gt;&#xA;&lt;li&gt;在方法区中常量引用的对象，比如字符串常量池里面的引用&lt;/li&gt;&#xA;&lt;li&gt;在本地方法栈中&lt;code&gt;JNI&lt;/code&gt;（Native）引用的对象&lt;/li&gt;&#xA;&lt;li&gt;Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，比如&lt;code&gt;NullPointerException&lt;/code&gt;，&lt;code&gt;OutofMemoryError&lt;/code&gt;等，还有系统类加载器&lt;/li&gt;&#xA;&lt;li&gt;所有被同步锁（synchronized）持有的对象&lt;/li&gt;&#xA;&lt;li&gt;反映Java虚拟机内部情况的&lt;code&gt;JMXBean&lt;/code&gt;，&lt;code&gt;JVMTI&lt;/code&gt;中注册的回调，本地代码缓存等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;引用&#34;&gt;引用&lt;/h3&gt;&#xA;&lt;p&gt;判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾手收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。&lt;/p&gt;&#xA;&lt;p&gt;在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态&lt;code&gt;reachable&lt;/code&gt;和垃圾收集的影响。&lt;/p&gt;&#xA;&lt;h4 id=&#34;强引用&#34;&gt;强引用&lt;/h4&gt;&#xA;&lt;p&gt;类似&lt;code&gt;Object object = new Object()&lt;/code&gt;这类的引用，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。&lt;/p&gt;&#xA;&lt;h4 id=&#34;软引用&#34;&gt;软引用&lt;/h4&gt;&#xA;&lt;p&gt;软引用是用来描述一些还有用，但非必须的对象，只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。即如果还有空闲内存，即暂时保存，当内存不足时清理掉。JDK1.2之后提供了&lt;code&gt;SoftReference&lt;/code&gt;来实现软引用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;弱引用&#34;&gt;弱引用&lt;/h4&gt;&#xA;&lt;p&gt;弱引用用来描述那些非必须对象，它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。JDK 1.2之后提供&lt;code&gt;WeakReference&lt;/code&gt;类来实现弱引用&lt;/p&gt;&#xA;&lt;h4 id=&#34;虚引用&#34;&gt;虚引用&lt;/h4&gt;&#xA;&lt;p&gt;虚引用也成为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存空间构成影响。也无法通过虚引用来获取一个对象实例，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知，在JDK1.2之后提供&lt;code&gt;PhantomReference&lt;/code&gt;类来实现虚引用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;回收过程&#34;&gt;回收过程&lt;/h3&gt;&#xA;&lt;p&gt;对于可达性分析中不可达的对象，那么它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行&lt;code&gt;finalize()&lt;/code&gt;方法，假如对象没有覆盖&lt;code&gt;finalize()&lt;/code&gt;方法，或者&lt;code&gt;finalize()&lt;/code&gt;方法已被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”，那么对象基本上就真的被回收了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之HotSpot VM对象（二）</title>
      <link>http://localhost:1313/posts/jvm/jvm02-java-object/</link>
      <pubDate>Sun, 22 Mar 2020 18:14:15 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm02-java-object/</guid>
      <description>&lt;h2 id=&#34;对象的创建过程&#34;&gt;对象的创建过程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;类加载检查&#34;&gt;类加载检查&lt;/h3&gt;&#xA;&lt;p&gt;当JVM遇到一条字节码new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那么先执行相应的类加载过程。&lt;/p&gt;&#xA;&lt;h3 id=&#34;为新生对象分配内存&#34;&gt;为新生对象分配内存&lt;/h3&gt;&#xA;&lt;p&gt;对象所需内存的大小再类加载完成后便可完全确定（对象的字段存储的时基本类型值，对象和数组的引用），接下来从Java堆中划分出对应大小的内存块给新的对象，分配方式有两种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;指针碰撞&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;假设Java堆中内存时绝对规整的，所有被使用的内存都被放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么所分配内存就仅仅是把那个指针向空闲空间方向挪动一段所需大小的距离。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;空闲列表&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果Java堆中内存并不是规整的，使用的内存和未使用的内存交错在一起，此时无法使用指针碰撞方法，JVM需要维护一个列表，记录哪些内存块空闲可用，再分配的时候，从列表中找出一块足够大的空间划分给对象实例，并更新列表上的记录。&lt;/p&gt;&#xA;&lt;p&gt;Java堆是否规整，取决于采用的垃圾收集器是否具有空间压缩整理（Compact）的能力决定。使用&lt;code&gt;Serial&lt;/code&gt;、&lt;code&gt;ParNew&lt;/code&gt;等收集器时，采取指针碰撞方法，当使用CMS这种基于清除（Sweep）算法的收集器时，采用较为复杂的空闲列表来分配内存。&lt;/p&gt;&#xA;&lt;p&gt;如何保证并发情况下的线程安全问题？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对分配内存空间的动作进行同步处理，实际上JVM是采用CAS配上失败重试的方式保证更新操作的原子性&lt;/li&gt;&#xA;&lt;li&gt;把内存分配的动作按照线程划分再不同的空间之中进行，即每个线程在Java堆预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程要分配内存，在哪个本地缓冲区进行分配。本地缓冲区用完了，分配新的缓存区才需要同步锁定。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;&#xA;&lt;p&gt;分配完内存之后，JVM将内存空间都初始化为零值，这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;设置信息&#34;&gt;设置信息&lt;/h3&gt;&#xA;&lt;p&gt;设置对象头信息：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对象是哪个类的实例&lt;/li&gt;&#xA;&lt;li&gt;如何才能找到类的元数据信息&lt;/li&gt;&#xA;&lt;li&gt;对象的哈希码（真正调用&lt;code&gt;Object::hashCode()&lt;/code&gt;时才计算）&lt;/li&gt;&#xA;&lt;li&gt;对象的GC分代年龄&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;执行构造函数&#34;&gt;执行构造函数&lt;/h3&gt;&#xA;&lt;p&gt;执行之前，对象的所有字段都为默认的零值，通过Class文件中的&lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt;完成对象的创建过程。&lt;/p&gt;&#xA;&lt;p&gt;虚拟机层面完成对象创建工作时，Java程序刚开始执行构造函数，此时别的线程读取该对象不为Null（引用存了地址），但是内部无值。如果在并发环境下，由于指令重排序的存在，可能还未读到初始化变量。可以使用&lt;code&gt;volitale&lt;/code&gt;配合&lt;code&gt;Double Check&lt;/code&gt;完成工作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;对象的内存布局&#34;&gt;对象的内存布局&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/jvm-object.png&#34; alt=&#34;对象的内存布局&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;对象头&#34;&gt;对象头&lt;/h3&gt;&#xA;&lt;p&gt;对象头存储两类信息，第一类用于存储对象自身的运行时数据，称为&lt;code&gt;Mark Word&lt;/code&gt;，包括以下信息：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;哈希码&lt;/li&gt;&#xA;&lt;li&gt;GC分代年龄&lt;/li&gt;&#xA;&lt;li&gt;锁状态标志&lt;/li&gt;&#xA;&lt;li&gt;线程持有的锁&lt;/li&gt;&#xA;&lt;li&gt;偏向线程ID&lt;/li&gt;&#xA;&lt;li&gt;偏向时间戳&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;Mark Word&lt;/code&gt;在32位，64位下分别为&lt;code&gt;32bit&lt;/code&gt;和&lt;code&gt;64bit&lt;/code&gt;，32位HotSpot虚拟机中，对象未被同步锁锁定的状态下，&lt;code&gt;Mark Word&lt;/code&gt;的&lt;code&gt;32bit&lt;/code&gt;中&lt;code&gt;25bit&lt;/code&gt;用于存储对象哈希码，&lt;code&gt;4bit&lt;/code&gt;用于存储对象分代年龄，&lt;code&gt;2bit&lt;/code&gt;用于存储锁标志位,&lt;code&gt;1bit&lt;/code&gt;固定为0。&lt;/p&gt;&#xA;&lt;p&gt;类型指针即对象指向它的类型元数据的指针，JVM通过这个指针来确定对象是哪个类的实例。但类型指针并不是一定存在的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;实例数据&#34;&gt;实例数据&lt;/h3&gt;&#xA;&lt;p&gt;实例数据部分是对象成员变量的值，包括父类继承下来的成员变量和本类的成员变量。&lt;/p&gt;&#xA;&lt;h3 id=&#34;对齐填充&#34;&gt;对齐填充&lt;/h3&gt;&#xA;&lt;p&gt;不是必然存在的，起到占位符的作用，因为HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头部分正好是整数倍，当实例数据部分没有对齐时，通过对齐填充来补全。&lt;/p&gt;&#xA;&lt;h2 id=&#34;对象的访问定位&#34;&gt;对象的访问定位&lt;/h2&gt;&#xA;&lt;p&gt;对象的存储空间在堆上分配，对象的引用在栈上分配，通过这个引用找到具体的对象，主流的访问方式有使用句柄和直接指针两种。&lt;/p&gt;&#xA;&lt;h3 id=&#34;句柄访问方式&#34;&gt;句柄访问方式&lt;/h3&gt;&#xA;&lt;p&gt;堆中需要划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。句柄访问的最大好处就是引用中存放的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/IMG_0038.PNG&#34; alt=&#34;通过句柄访问对象&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;直接指针访问方式&#34;&gt;直接指针访问方式&lt;/h3&gt;&#xA;&lt;p&gt;直接指针访问的最大好处就是速度更快，节省了一次指针定位的时间开销。&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/IMG_0037.PNG&#34; alt=&#34;直接指针访问对象&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM之Java内存结构（一）</title>
      <link>http://localhost:1313/posts/jvm/jvm01-java-memory-structure/</link>
      <pubDate>Sat, 21 Mar 2020 17:33:06 +0000</pubDate>
      <guid>http://localhost:1313/posts/jvm/jvm01-java-memory-structure/</guid>
      <description>&lt;h1 id=&#34;java运行时数据区域&#34;&gt;Java运行时数据区域&lt;/h1&gt;&#xA;&lt;p&gt;数据区域主要分为五个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序计数器&lt;/li&gt;&#xA;&lt;li&gt;虚拟机栈&lt;/li&gt;&#xA;&lt;li&gt;本地方法栈&lt;/li&gt;&#xA;&lt;li&gt;堆&lt;/li&gt;&#xA;&lt;li&gt;方法区&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其中所有线程共享区域有：方法区和堆。&lt;/p&gt;&#xA;&lt;p&gt;每个线程独享区域有：虚拟机栈，本地方法栈，程序计数器&#xA;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/java-memory.png&#34; alt=&#34;Java运行时数据区域&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;线程独享的区域&#34;&gt;线程独享的区域&lt;/h2&gt;&#xA;&lt;h3 id=&#34;程序计数器&#34;&gt;程序计数器&lt;/h3&gt;&#xA;&lt;p&gt;程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，如果当前线程执行的是一个本地方法，那么此时计数器的值为&lt;code&gt;undefined&lt;/code&gt;，是唯一一个不会出现&lt;code&gt;OutOfMemoryError&lt;/code&gt;的内存区域。&lt;/p&gt;&#xA;&lt;h3 id=&#34;java虚拟机栈&#34;&gt;Java虚拟机栈&lt;/h3&gt;&#xA;&lt;p&gt;虚拟机栈描述的是Java方法执行的线程内存模型，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存放以下内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;局部变量表&lt;/li&gt;&#xA;&lt;li&gt;操作数栈&lt;/li&gt;&#xA;&lt;li&gt;动态链接&lt;/li&gt;&#xA;&lt;li&gt;方法出口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其中局部变量表包括以下内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;八大基本数据类型&lt;/li&gt;&#xA;&lt;li&gt;对象引用&lt;/li&gt;&#xA;&lt;li&gt;returnAddress类型（保存的是return后要执行的字节码的指令地址）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这些数据类型在局部变量表中的存储空间以局部变量槽来表示，64位长度的&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;类型占用两个变量槽，其余的占用一个。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变局部变量表的大小。&lt;/p&gt;&#xA;&lt;p&gt;Java 虚拟机栈会出现两种异常：&lt;code&gt;StackOverFlowError&lt;/code&gt; 和 &lt;code&gt;OutOfMemoryError&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果线程请求的栈深度大于虚拟机所允许的深度，将抛出&lt;code&gt;StackOverFlowError&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;本地方法栈&#34;&gt;本地方法栈&lt;/h3&gt;&#xA;&lt;p&gt;本地方法栈是为JVM使用到的&lt;code&gt;Native&lt;/code&gt;方法准备的空间。&lt;/p&gt;&#xA;&lt;h2 id=&#34;线程共享的区域&#34;&gt;线程共享的区域&lt;/h2&gt;&#xA;&lt;h3 id=&#34;堆&#34;&gt;堆&lt;/h3&gt;&#xA;&lt;p&gt;主要特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;堆是被所有线程共享的一块内存区域&lt;/li&gt;&#xA;&lt;li&gt;在虚拟机启动时创建&lt;/li&gt;&#xA;&lt;li&gt;堆的唯一目的就是存放对象实例&lt;/li&gt;&#xA;&lt;li&gt;堆是垃圾回收管理的内存区域&lt;/li&gt;&#xA;&lt;li&gt;可分为新生代，老年代，永久代等（一部分垃圾收集器的共同特性或者设计风格，不是具体实现的固有内存布局）&lt;/li&gt;&#xA;&lt;li&gt;从分配内存的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（TLAB）以提升对象分配的效率，这样做可以更好地回收内存或者更快的分配内存。&lt;/li&gt;&#xA;&lt;li&gt;堆的大小可以通过&lt;code&gt;-Xmx&lt;/code&gt;和&lt;code&gt;-Xms&lt;/code&gt;设定。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;方法区&#34;&gt;方法区&lt;/h3&gt;&#xA;&lt;p&gt;Java 虚拟机规范中定义方法区是堆的一个逻辑部分。&#xA;用于存储以下内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;已被虚拟机加载的类信息&lt;/li&gt;&#xA;&lt;li&gt;常量&lt;/li&gt;&#xA;&lt;li&gt;静态变量&lt;/li&gt;&#xA;&lt;li&gt;即时编译器编译后的代码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;方法区内的主要回收目标是对常量池的回收和对类型的卸载。&lt;/p&gt;&#xA;&lt;h4 id=&#34;运行时常量池&#34;&gt;运行时常量池&lt;/h4&gt;&#xA;&lt;p&gt;运行时常量池是方法区的一部分。主要存放以下内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;类信息（版本，字段，方法，接口等描述信息）&lt;/li&gt;&#xA;&lt;li&gt;常量池表（用于存放编译期生成的各种字面量与符号引用）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Java并不要求常量一定在编译期间产生，并非Class文件中常量池的内容才能进入运行时常量池，运行期间产生的新的常量也能放入池中。比如&lt;code&gt;String&lt;/code&gt;类的&lt;code&gt;intern()&lt;/code&gt;方法。&#xA;当常量池无法再申请到内存会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;直接内存堆外内存&#34;&gt;直接内存（堆外内存）&lt;/h3&gt;&#xA;&lt;p&gt;直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是会被频繁地使用，也可能导致&lt;code&gt;OutOfMemoryError&lt;/code&gt;&#xA;直接内存的分配不受JVM控制，但是会受到本机总内存（物理内存，SWAP分区，分页文件）以及处理器寻址空间的限制。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
