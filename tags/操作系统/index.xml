<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>操作系统 on l1nker4&#39;s Blog</title>
    <link>http://localhost:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 操作系统 on l1nker4&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Feb 2022 10:44:13 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>网络IO模型总结</title>
      <link>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 22 Feb 2022 10:44:13 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h2 id=&#34;网络io流程&#34;&gt;网络IO流程&lt;/h2&gt;&#xA;&lt;p&gt;网络IO中的一次请求和响应的流程基本如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内核通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。数据从网卡到内核空间；&lt;/li&gt;&#xA;&lt;li&gt;从内核缓冲区读取数据到应用进程缓冲区。数据从内核空间到用户空间；&lt;/li&gt;&#xA;&lt;li&gt;服务端进程在自己的用户空间中，处理客户端的请求。数据在用户空间中被处理；&lt;/li&gt;&#xA;&lt;li&gt;处理完数据并构建好的响应之后，将数据从用户缓冲区写入内核缓冲区。&lt;/li&gt;&#xA;&lt;li&gt;内核将内核缓冲区中的响应写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;两组概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;同步&lt;/strong&gt;：请求被逐个地处理，无法并发执行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;异步&lt;/strong&gt;：多个请求可以并发执行，内核IO操作完成后会通知用户线程，或者调用用户进程的回调函数。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;阻塞&lt;/strong&gt;：请求发出后，由于该请求操作需要的条件不满足，请求操作一直阻塞，不会返回，直到条件满足。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;非阻塞&lt;/strong&gt;：请求发出后，若该请求需要的条件不满足，则立即返回一个标志信息告知条件不满足，而不会一直等待。一般需要通过循环判断请求条件是否满足来获取请求结果。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在《UNIX网络编程》中，将UNIX的IO模型分为了以下五种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阻塞式IO&lt;/li&gt;&#xA;&lt;li&gt;非阻塞式IO&lt;/li&gt;&#xA;&lt;li&gt;IO多路复用&lt;/li&gt;&#xA;&lt;li&gt;信号驱动式IO&lt;/li&gt;&#xA;&lt;li&gt;异步IO&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;阻塞式io&#34;&gt;阻塞式IO&lt;/h2&gt;&#xA;&lt;p&gt;该模型中，用户空间的应用程序通过执行read调用（底层是recvfrom系统调用）来从socket中读取数据，在应用程序发起read调用后，会一直阻塞，直到数据包到达网卡上并复制到内核空间中，随后从内核空间拷贝到用户空间之后才会返回。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/blocking-io.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;BIO在实现异步操作时，只能使用多线程进行处理，一个请求对应一个线程，该模型对于高并发环境，开销十分巨大，需要考虑其他的IO处理模型。&lt;/p&gt;&#xA;&lt;h2 id=&#34;非阻塞式io&#34;&gt;非阻塞式IO&lt;/h2&gt;&#xA;&lt;p&gt;应用程序发起系统调用，如果内核数据暂未准备好，进程可以做其他事，然后再次轮询内核获取请求结果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/nonblocking-io.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;简单的NIO需要不断的重复发起IO系统调用，这种不断地询问内核的操作，这将占用大量的 CPU 时间，并导致&lt;strong&gt;上下文切换&lt;/strong&gt;，系统资源利用率较低。&lt;/p&gt;&#xA;&lt;h2 id=&#34;io多路复用&#34;&gt;IO多路复用&lt;/h2&gt;&#xA;&lt;p&gt;IO多路复用模型通过一个&lt;strong&gt;监听线程&lt;/strong&gt;发起另一种形式的系统调用，由一个线程监听多个文件描述符（fd，linux系统把所有网络请求以一个fd来标识），一旦某个fd的操作就绪（一般是内核缓冲区可读/可写），该系统调用就会返回，随后监听线程可以通知程序对准备好了的fd进行对应的IO系统调用，比如通过recvfrom读取数据。&lt;/p&gt;&#xA;&lt;p&gt;在Linux中select、poll、epoll函数就是IO多路复用的具体实现。Java4新增的NIO包中引入的选择器Selector，使用的就是IO多路复用模型，通过它，只需要一个线程便可以管理多个客户端连接。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/multiplexing.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;信号驱动io&#34;&gt;信号驱动IO&lt;/h2&gt;&#xA;&lt;p&gt;应用程序通过sigaction系统调用安装一个信号处理函数，应用程序继续工作，当数据准备好后，内核给进程发送一个&lt;code&gt;SIGIO&lt;/code&gt;信号，应用程序开始&lt;strong&gt;执行系统调用&lt;/strong&gt;执行IO操作。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/signal-io.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这种模型的优势在于等待数据达到期间，进程不被阻塞。只需要等待信号处理函数的通知。&lt;/p&gt;&#xA;&lt;h2 id=&#34;异步io&#34;&gt;异步IO&lt;/h2&gt;&#xA;&lt;p&gt;AIO的基本流程是：用户线程通过系统调用，告知内核启动某个IO操作，用户线程随即返回。内核在整个IO操作（包括数据准备、数据复制）完成后，会通知用户程序，用户执行后续的业务操作。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/aio.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;与信号驱动式IO的区别：信号驱动模型是由内核通知我们&lt;strong&gt;何时可以启动一个IO操作&lt;/strong&gt;，而异步IO模型由内核通知我们&lt;strong&gt;IO操作何时完成&lt;/strong&gt;。信号驱动IO更像半异步IO。&lt;/p&gt;&#xA;&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;&#xA;&lt;p&gt;《UNIX网络编程》&lt;/p&gt;</description>
    </item>
    <item>
      <title>OSTEP阅读笔记-Persistence（三）</title>
      <link>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/os/ostep-persistence/</link>
      <pubDate>Tue, 22 Dec 2020 19:49:48 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/os/ostep-persistence/</guid>
      <description>&lt;h2 id=&#34;chapter-io设备&#34;&gt;Chapter I/O设备&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何将I/O集成进计算机系统中？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;361-系统架构&#34;&gt;36.1 系统架构&lt;/h3&gt;&#xA;&lt;p&gt;典型的系统架构如图所示：CPU通过&lt;strong&gt;memory bus&lt;/strong&gt;连接到系统内存。显卡或者其它高速I/O设备通过常规的IO总线（I/O bus，例如PCI）连接到系统。最后是外围总线（peripheral bus，例如SCSI、SATA、USB），他们将最慢的设备连接到系统，包括磁盘、鼠标等。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-36/36.1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;362-标准设备&#34;&gt;36.2 标准设备&lt;/h3&gt;&#xA;&lt;p&gt;标准设备包括两部分，分别是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;向系统其他部分展现的硬件/软件接口&lt;/li&gt;&#xA;&lt;li&gt;内部结构，包括设备相关的特定实现，负责具体实现设备展现给系统的抽象接口。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-36/36.2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;363-标准协议&#34;&gt;36.3 标准协议&lt;/h3&gt;&#xA;&lt;p&gt;一个简化的设备接口包括三个寄存器：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个状态（&lt;strong&gt;status&lt;/strong&gt;）寄存器：读取并查看设备的当前状态&lt;/li&gt;&#xA;&lt;li&gt;一个命令（&lt;strong&gt;command&lt;/strong&gt;）寄存器：用于通知设备执行某个具体任务。&lt;/li&gt;&#xA;&lt;li&gt;一个数据（&lt;strong&gt;data&lt;/strong&gt;）寄存器：将数据传给设备或从设备接收数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;通过读写这些寄存器，OS可以控制设备的行为。&lt;/p&gt;&#xA;&lt;p&gt;因此可以将操作步骤设置为如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;OS反复读取状态寄存器，等待设备进入可以接受命令的就绪状态。（轮询）&lt;/li&gt;&#xA;&lt;li&gt;OS将数据发送到数据寄存器。&lt;/li&gt;&#xA;&lt;li&gt;OS将命令写入命令寄存器。&lt;/li&gt;&#xA;&lt;li&gt;OS再次通过不断轮询设备，等待并判断设备是否执行完成命令。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何减少频繁轮询，从而降低管理设备的CPU的开销？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;364-利用中断减少cpu开销&#34;&gt;36.4 利用中断减少CPU开销&lt;/h3&gt;&#xA;&lt;p&gt;设备可以抛出一个硬件中断，引发CPU跳转执行OS预先定义好的中断服务例程（ISR）或者更为简单的中断处理程序（interrupt handler）。&lt;/p&gt;&#xA;&lt;p&gt;使用中断并非是最佳方案，假如有一个高性能的设备，在CPU第一次轮询时就可以返回结果，那么使用中断反而效率更低。如果设备的速度未知，可以考虑混合策略，先尝试轮询一小段事件，如果设备没有完成操作，此时再使用中断。&lt;/p&gt;&#xA;&lt;p&gt;如果是网络环境中，那么不要使用中断，因为每个数据包都会发生一次中断，那么可能导致OS发生活锁（一直处理中断程序而不处理用户的请求）。&lt;/p&gt;&#xA;&lt;p&gt;另一个基于中断的优化就是合并（coalescing），设备在抛出中断之前往往会等待一小段时间，在此期间如果有其他请求的中断，会将多次中断合并为一次中断抛出。从而降低处理中断的代价。&lt;/p&gt;&#xA;&lt;h3 id=&#34;365-dma方式&#34;&gt;36.5 DMA方式&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何减少Programming IO的开销？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;使用DMA（&lt;strong&gt;Direct Memory Access&lt;/strong&gt;）：DMA引擎是一种特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。&lt;/p&gt;&#xA;&lt;p&gt;工作过程如下：为了能够将数据传送给设备，OS通过programming告诉DMA引擎数据在内存的位置，要拷贝的大小以及拷贝到哪个设备。在此之后，OS就可以处理其他请求了。当DMA的任务完成后，DMA控制器会抛出一个中断来告诉OS自己完成了数据传输。&lt;/p&gt;&#xA;&lt;h3 id=&#34;366-设备交互的方法&#34;&gt;36.6 设备交互的方法&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何与设备通信？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用明确的I/O指令。&lt;/li&gt;&#xA;&lt;li&gt;内存映射I/O（memory-mapped I/O）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过这种方式，硬件将设备寄存器映射到指定的内存地址中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;367-纳入os设备驱动程序&#34;&gt;36.7 纳入OS：设备驱动程序&lt;/h3&gt;&#xA;&lt;p&gt;每个设备都有非常具体的接口，如何将它们纳入OS，而我们希望OS尽可能通用。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何实现一个设备无关的OS？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;操作系统将与IO设备交互的软件称为设备驱动程序。（封装，向上层展现接口即可）&lt;/p&gt;&#xA;&lt;h3 id=&#34;368-ide磁盘驱动程序&#34;&gt;36.8 IDE磁盘驱动程序&lt;/h3&gt;&#xA;&lt;p&gt;基本逻辑如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;等待驱动就绪&lt;/strong&gt;：当驱动READY，读取状态寄存器（0x1F7）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;向命令寄存器写入参数&lt;/strong&gt;：写入扇区数，待访问扇区对应的逻辑块地址（LBA），并将驱动编号（master= 0x00，slave = 0x10，因为IDE允许接入两个硬盘）写入命令寄存器（0x1F2- 0x1F6）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;开启I/O&lt;/strong&gt;：发送读写命令到命令寄存器。向命令寄存器（0x1F7）中写入&lt;code&gt;READ-WRITE&lt;/code&gt;命令。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据传送&lt;/strong&gt;（针对写请求）：等待直到驱动状态为&lt;code&gt;READY&lt;/code&gt;和&lt;code&gt;DRQ&lt;/code&gt;（驱动请求数据），向数据端口写入数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;中断处理&lt;/strong&gt;：每个扇区的数据传送结束后都会触发一次中断处理程序，可以合并中断。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;错误处理&lt;/strong&gt;：每次操作之后读取状态寄存器，如果ERROR位被置位。可以读取错误寄存器来获取详细信息。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-36/36.5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>OSTEP阅读笔记- Concurrency（二）</title>
      <link>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/os/ostep-concurrency/</link>
      <pubDate>Thu, 17 Dec 2020 16:57:51 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/os/ostep-concurrency/</guid>
      <description>&lt;h2 id=&#34;chapter-26-并发介绍&#34;&gt;Chapter 26 并发介绍&lt;/h2&gt;&#xA;&lt;p&gt;本章介绍为单个运行进程提供的新抽象：thread。线程共享地址空间。&lt;/p&gt;&#xA;&lt;p&gt;每个线程都有自己的PC与自己用于计算的&lt;code&gt;register&lt;/code&gt;。如果有两个线程运行在同一个处理器上，发生&lt;code&gt;context switch&lt;/code&gt;时，与进程不同的是，使用PCB保存进程状态，使用TCB保存线程状态。区别是：地址空间保持不变（不需要切换当前使用的页表）。&lt;/p&gt;&#xA;&lt;p&gt;另一个主要区别在于栈，传统进程只有一个栈，如图26.1所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-26/26.1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;多线程中，每个线程拥有自己的栈，位于栈上的变量、参数、返回值是无法共享的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;261-实例线程创建&#34;&gt;26.1 实例：线程创建&lt;/h3&gt;&#xA;&lt;p&gt;示例：使用&lt;code&gt;pthead_create()&lt;/code&gt;创建了两个线程，主程序调用&lt;code&gt;pthread_join()&lt;/code&gt;等待指定线程执行完成。&lt;/p&gt;&#xA;&lt;p&gt;线程的执行顺序取决于系统调度。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-26/26.2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;262-共享数据导致的问题&#34;&gt;26.2 共享数据导致的问题&lt;/h3&gt;&#xA;&lt;p&gt;多线程对共享数据进行操作会导致非预期结果。&lt;/p&gt;&#xA;&lt;h3 id=&#34;263-核心问题不可控的调度&#34;&gt;26.3 核心问题：不可控的调度&lt;/h3&gt;&#xA;&lt;p&gt;竞态条件（&lt;strong&gt;race condition&lt;/strong&gt;）：结果取决于代码的执行顺序。运气不好会导致错误的结果。&lt;/p&gt;&#xA;&lt;h3 id=&#34;264-原子性&#34;&gt;26.4 原子性&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何构建有用的同步原语？需要从硬件中获取那些支持？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;265-等待另一个线程&#34;&gt;26.5 等待另一个线程&lt;/h3&gt;&#xA;&lt;p&gt;需要研究多线程中的&lt;code&gt;wait/signal&lt;/code&gt;机制。&lt;/p&gt;&#xA;&lt;h2 id=&#34;chapter-27-线程api&#34;&gt;Chapter 27 线程API&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何创建和控制线程？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;271-pthread_create&#34;&gt;27.1 pthread_create&lt;/h3&gt;&#xA;&lt;p&gt;在POSIX中：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_create&lt;/span&gt;( &lt;span style=&#34;color:#66d9ef&#34;&gt;pthread_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;pthread_attr_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; attr,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;start_routine)(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;),&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; arg);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;thread&lt;/strong&gt;：指向pthread_t结构类型的指针，利用它与线程交互。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;attr&lt;/strong&gt;：用于指定该线程可能具有的任何属性，包括设置栈大小、调度优先级。属性通过调用&lt;code&gt;pthread_attr_init()&lt;/code&gt;初始化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;start_routine&lt;/strong&gt;：一个函数指针，指示线程应该在哪个函数上运行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;arg&lt;/strong&gt;：传递给线程的参数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;272-pthread_join&#34;&gt;27.2 pthread_join&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_join&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;pthread_t&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;retval);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;thread&lt;/strong&gt;：指定需要等待的线程&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;retval&lt;/strong&gt;：指向你希望得到的返回值，定义为一个指向void的指针。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;273-锁&#34;&gt;27.3 锁&lt;/h3&gt;&#xA;&lt;p&gt;互斥进入临界区：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_mutex_lock&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;pthread_mutex_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mutex);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_mutex_unlock&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;pthread_mutex_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mutex);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pthread_mutex_t&lt;/span&gt; lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PTHREAD_MUTEX_INITIALIZER;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_mutex_lock&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lock);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// or whatever your critical section is&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pthread_mutex_unlock&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;lock);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;274-条件变量&#34;&gt;27.4 条件变量&lt;/h3&gt;&#xA;&lt;p&gt;当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>OSTEP阅读笔记-Virtuallization（一）</title>
      <link>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/os/ostep-virtualization/</link>
      <pubDate>Sat, 05 Dec 2020 14:21:23 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/os/ostep-virtualization/</guid>
      <description>&lt;h1 id=&#34;进程虚拟化&#34;&gt;进程虚拟化&lt;/h1&gt;&#xA;&lt;h2 id=&#34;chapter-4-进程&#34;&gt;Chapter 4 进程&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何提供有许多CPU的假象？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;OS通过&lt;code&gt;Visualizing&lt;/code&gt;  CPU来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其它进程，这样就提供了存在多个虚拟CPU的假象。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;时分共享：典型的就是时间片划分，将一小段时间分配给不同的进程。&lt;/li&gt;&#xA;&lt;li&gt;空分共享：典型的就是磁盘空间，将空间分配给不同的文件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Qustions：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何实现&lt;code&gt;context switch&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;OS如何执行&lt;code&gt;scheduling policy&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;41-抽象进程&#34;&gt;4.1 抽象：进程&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;OS为正在运行的程序提供的抽象，就是所谓的进程。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;进程的&lt;code&gt;machine state&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程可访问的内存（&lt;code&gt;address space&lt;/code&gt;）：指令和数据存储在&lt;code&gt;address space&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;寄存器（&lt;code&gt;register&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;42-进程api&#34;&gt;4.2 进程API&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;create&lt;/li&gt;&#xA;&lt;li&gt;destroy&lt;/li&gt;&#xA;&lt;li&gt;wait&lt;/li&gt;&#xA;&lt;li&gt;miscellaneous control&lt;/li&gt;&#xA;&lt;li&gt;status&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;43-进程创建的细节&#34;&gt;4.3 进程创建的细节&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q: 程序如何转换为进程？换而言之，OS如何启动并运行一个程序？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;OS将代码和静态数据&lt;code&gt;load&lt;/code&gt;到内存中，加载到进程的&lt;code&gt;address space&lt;/code&gt;。如图4.1所示：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-4/program-to-process.jpg&#34; alt=&#34;从程序到进程&#34;&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;加载后，OS在运行前需要执行初始化操作。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为程序的**运行时栈（run-time stack）**分配一些内存。C程序使用栈存放局部变量，函数参数和返回地址。&lt;/li&gt;&#xA;&lt;li&gt;为**堆（heap）**分配一些内存，C程序中，堆用于显式请求的动态分配数据（&lt;code&gt;malloc &amp;amp; free&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;I/O&lt;/code&gt;相关的任务。UNIX中每个进程都会有三个打开的文件描述符（&lt;code&gt;file descriptor&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;44-进程状态&#34;&gt;4.4 进程状态&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行&lt;/li&gt;&#xA;&lt;li&gt;就绪&lt;/li&gt;&#xA;&lt;li&gt;阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;进程的状态转化图如图4.2所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-4/process-state.jpg&#34; alt=&#34;进程：状态转换&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;45-数据结构&#34;&gt;4.5 数据结构&lt;/h3&gt;&#xA;&lt;p&gt;对于停止的进程，上下文将保存寄存器的内容，通过上下文切换可以使OS恢复运行该进程。&lt;/p&gt;&#xA;&lt;p&gt;下图中的&lt;code&gt;context&lt;/code&gt;就是上下文的数据结构，&lt;code&gt;proc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-4/proc.jpg&#34; alt=&#34;xv6的proc结构&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;chapter-5-进程api&#34;&gt;Chapter 5 进程API&lt;/h2&gt;&#xA;&lt;p&gt;本章讨论在UNIX系统中的进程创建。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何创建并控制进程？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;fork-系统调用&#34;&gt;fork() 系统调用&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt;用于创建新进程，&lt;code&gt;fork&lt;/code&gt;的子进程从&lt;code&gt;fork&lt;/code&gt;处开始执行。示例代码如下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
