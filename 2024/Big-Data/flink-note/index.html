

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lin Wang">
  <meta name="keywords" content="l1nker4">
  
    <meta name="description" content="简介Apache Flink是一个用于有状态的并行数据流的分布式计算系统，同时支持流式处理和批量处理。 实际数据分析应用都是面向无限数据流，三类通常使用有状态流处理实现的应用程序：  事件驱动应用程序：使用特定的业务逻辑来提取事件流并处理事件。 实时推荐、行为模式检测、异常检测   数据管道应用程序：将数据从A组件复制到B组件的ETL流程，pipeline包括多个源（source）和接收器（sin">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink入门">
<meta property="og:url" content="https://l1n.wang/2024/Big-Data/flink-note/index.html">
<meta property="og:site_name" content="l1nker4&#39;s Blog">
<meta property="og:description" content="简介Apache Flink是一个用于有状态的并行数据流的分布式计算系统，同时支持流式处理和批量处理。 实际数据分析应用都是面向无限数据流，三类通常使用有状态流处理实现的应用程序：  事件驱动应用程序：使用特定的业务逻辑来提取事件流并处理事件。 实时推荐、行为模式检测、异常检测   数据管道应用程序：将数据从A组件复制到B组件的ETL流程，pipeline包括多个源（source）和接收器（sin">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-07T05:01:47.000Z">
<meta property="article:modified_time" content="2024-12-07T10:06:55.829Z">
<meta property="article:author" content="Lin Wang">
<meta property="article:tag" content="l1nker4">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Flink入门 - l1nker4&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"l1n.wang","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"612bbac3c11e86af5c472b8381f09fa7","google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?612bbac3c11e86af5c472b8381f09fa7";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>l1nker4&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://blog-1251613845.cos.ap-shanghai.myqcloud.com/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Flink入门"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-07 13:01" pubdate>
          2024年5月7日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          4.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          36 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Flink入门</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Flink是一个用于有状态的并行数据流的分布式计算系统，同时支持流式处理和批量处理。</p>
<p>实际数据分析应用都是面向无限数据流，三类通常使用有状态流处理实现的应用程序：</p>
<ol>
<li>事件驱动应用程序：使用特定的业务逻辑来提取事件流并处理事件。<ol>
<li>实时推荐、行为模式检测、异常检测</li>
</ol>
</li>
<li>数据管道应用程序：将数据从A组件复制到B组件的ETL流程，pipeline包括多个源（source）和接收器（sink）。<ol start="3">
<li>实时数据仓库：数据实时清洗、归并、结构化</li>
</ol>
</li>
<li>数据流式分析应用程序：连续地提取事件流数据，并计算出最新结果并存储，用于查询。<ol>
<li>用户行为等实时数据分析</li>
</ol>
</li>
</ol>
<p>常见的流式处理框架对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>Flink</th>
<th>Spark Streaming</th>
<th>Apache Storm</th>
</tr>
</thead>
<tbody><tr>
<td>架构</td>
<td>主从模式</td>
<td>主从模式，依赖Spark，每个Batch处理都依赖主节点</td>
<td>主从模式，依赖ZK</td>
</tr>
<tr>
<td>处理方式</td>
<td>Native</td>
<td>Micro-Batch</td>
<td>Native</td>
</tr>
<tr>
<td>容错</td>
<td>基于Chandy-Lamport distributed snapshots checkpoint机制</td>
<td>WAL与RDD机制</td>
<td>Record’s ACK</td>
</tr>
<tr>
<td>处理模式</td>
<td>单条事件处理、时间窗口划分的所有事件</td>
<td>时间窗口内的所有时间</td>
<td>单条事件处理</td>
</tr>
<tr>
<td>数据保证</td>
<td>exactly once</td>
<td>exactly once</td>
<td>at least once</td>
</tr>
<tr>
<td>API支持</td>
<td>high</td>
<td>high</td>
<td>low</td>
</tr>
<tr>
<td>社区活跃度</td>
<td>high</td>
<td>high</td>
<td>medium</td>
</tr>
<tr>
<td>部署性</td>
<td>部署简单，仅依赖JRE</td>
<td>部署简单，仅依赖JRE</td>
<td>依赖JRE和Zookeeper</td>
</tr>
</tbody></table>
<p>Flink优点：</p>
<ol>
<li>毫秒级延迟</li>
<li>统一数据处理组件栈，可以处理不同类型的数据需求</li>
<li>支持事件时间、接入时间、处理时间等概念</li>
<li>基于轻量级分布式快照实现的容错</li>
<li>支持有状态计算，灵活的state-backend（HDFS、内存、RocksDB）</li>
<li>满足Exactly-once需求</li>
<li>支持高度灵活的window操作</li>
<li>带反压的连续流模型</li>
<li>每秒千万级吞吐量</li>
<li>易用性：提供了SQL、Table API、Stream API等方式</li>
</ol>
<p>流式计算的时间窗口，涉及处理时间和事件时间，主要有以下区别：</p>
<ul>
<li>处理时间提供了低延迟，但不能保证准确性</li>
<li>事件时间保证了结果准确性，实时性较差</li>
</ul>
<p>结果保证：</p>
<ul>
<li>at-most-once：最多处理一次事件，事件可以被丢弃掉，也没有任何操作保证结果的正确性。</li>
<li>at-least-once：允许事件被多次处理，以此保证结果的正确性</li>
<li>exactly-once：恰好一次，最严格的保证，也最难实现，没有事件丢失，并且每个数据只处理一次。</li>
</ul>
<p>Flink相关概念：</p>
<ul>
<li>Task：一个阶段中，多个功能相同的subTask集合，一个Task就是一个可以链接的最小算子链，这样可以减少线程间切换导致的开销，提高整体的吞吐量。</li>
<li>SubTask：Flink任务最小执行单元（Java类），完成具体的计算逻辑。</li>
<li>Slot：对计算资源进行隔离的单元，一个Slot中可以运行多个subTask</li>
<li>State：运行过程中计算的中间结果</li>
<li>Source：数据源</li>
<li>Transformation：数据处理算子，包括map、filter、reduce</li>
<li>Sink：Flink作业的数据存放点，例如MySQL、Kafka</li>
<li>JobGraph：Flink运行任务的抽象图表达结构<ul>
<li>通过有向无环图DAG方式表达用户程序的执行流程</li>
<li>不同接口程序的统一抽象表达：DataStream API、Flink SQL、Table API等</li>
<li>转换流程：Application Code -&gt; StreamGraph -&gt; JobGraph</li>
</ul>
</li>
</ul>
<p>Task是概念上的任务，SubTask是实际提交给Task Slots的任务（单独的线程）。</p>
<p>部署模式：</p>
<ul>
<li>Session Mode（资源共享）：根据指定的资源初始化一个Flink集群，拥有固定数量的JobManager和TaskManager，所有Job在一个Runtime中运行。<ul>
<li>客户端通过RPC或者Rest API链接集群的管理节点</li>
<li>Deployer需要上传以来的Denpendences Jar</li>
<li>Deployer需要生成JobGraph，并提交到管理节点</li>
<li>JobManager的生命周期不受提交的Job影响。</li>
</ul>
</li>
<li>Per-Job Mode（deprecated）：基于资源协调框架为每一个提交的作业启动专属的Flink集群，作业完成后，资源将被关闭并清除，提供了良好的资源隔离能力。<ul>
<li><code>&gt; Per-job mode is only supported by YARN and has been deprecated in Flink 1.15. It will be dropped in [FLINK-26000](https://issues.apache.org/jira/browse/FLINK-26000). Please consider application mode to launch a dedicated cluster per-job on YARN.</code></li>
</ul>
</li>
<li>Application Mode<ul>
<li>运行在Cluster上，而不在客户端</li>
<li>每一个Application对应一个Runtime，Application中可以包含多个Job</li>
<li>客户端无需将Denpendencies上传到JobManager，仅负责提交Job</li>
<li>main方法运行在JobManager中，将JobGraph的生成放在Cluster中运行</li>
</ul>
</li>
</ul>
<p>当前支持以下资源管理器部署集群：</p>
<ul>
<li>Standalone</li>
<li>Hadoop Yarn</li>
<li>Apache Mesos</li>
<li>Docker</li>
<li>Kubernetes</li>
</ul>
<h1 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h1><p>Flink集群是类似于Master-Slave的结构，核心组件包括：</p>
<ul>
<li>JobManager：master节点，负责Flink作业的调度与执行，包括：Checkpoint Coordinator、jobGraph -&gt; Execution Graph、Task部署和调度、RPC通信(Actor System)、Job接收(Job Dispatch)、集群资源管理、TaskManager注册与管理<ul>
<li>ResourceManager：负责Flink集群中的资源提供、回收与分配。ResourceManager是Task Slot的管理者，slot是Flink定义的处理资源单元。接收到JobManager的资源请求时，会将存在空闲slot的TaskManager分配给JobManager执行任务。</li>
<li>Dispatcher：提供了Restful接口用于提交Flink程序，并为每个提交的作业启动一个新的JobMaster。</li>
<li>JobMaster：负责单个JobGraph的执行。</li>
</ul>
</li>
<li>TaskManager：worker节点，负责实际SubTask的执行，并且缓存数据流。每个TaskManager都拥有Task Slot，slot由ResourceManager统一管理。功能包括：<ul>
<li>Task Execution</li>
<li>Network Manager</li>
<li>Shuttle Environment manager</li>
<li>RPC system</li>
<li>Data Exchange</li>
<li>Offer Slots to JobManager</li>
</ul>
</li>
<li>Client：用户运行的main方法进程，包括以下功能：<ul>
<li>JobGraph Generate</li>
<li>Execution Environment manager</li>
<li>Job Submit</li>
<li>RPC with JobManager</li>
<li>Cluster Deploy</li>
</ul>
</li>
</ul>
<h1 id="Flink编程模型"><a href="#Flink编程模型" class="headerlink" title="Flink编程模型"></a>Flink编程模型</h1><ol>
<li>创建Flink程序执行环境</li>
<li>从数据源source读取一条或多条数据</li>
<li>使用算子实现业务逻辑（transformation）</li>
<li>将计算结果输出（sink）</li>
</ol>
<h1 id="Flink-API"><a href="#Flink-API" class="headerlink" title="Flink API"></a>Flink API</h1><p>Flink根据抽象程度，将API分为以下三类，分别适用不同的应用场景：</p>
<ul>
<li>SQL&#x2F; Table API</li>
<li>DataStream API</li>
<li>ProcessFuction</li>
</ul>
<h1 id="DataStream-API"><a href="#DataStream-API" class="headerlink" title="DataStream API"></a>DataStream API</h1><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>从文件读取数据：</p>
<div class="code-wrapper"><pre><code class="hljs java">DataStreamSource&lt;String&gt; source = env.readTextFile(<span class="hljs-string">&quot;/tmp/data&quot;</span>);</code></pre></div>


<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>从Socket读取数据：</p>
<div class="code-wrapper"><pre><code class="hljs java">DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8089</span>);</code></pre></div>

<p>可以通过nc等工具，本地调试验证。</p>
<h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><p>从变量读取数据：</p>
<div class="code-wrapper"><pre><code class="hljs java">DataStreamSource&lt;String&gt; source = env.fromCollection(collection);


DataStream&lt;SensorReading&gt; source = env.fromElements(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>())</code></pre></div>

<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>从Kafka读取数据：</p>
<p>存在Kafka Source、Kafka Consumer两种读取方式。</p>
<div class="code-wrapper"><pre><code class="hljs xml">
<span class="hljs-tag">&lt;<span class="hljs-name">flink.version</span>&gt;</span>1.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">flink.version</span>&gt;</span>


<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-runtime-web_$&#123;scala.binary.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>


<div class="code-wrapper"><pre><code class="hljs java">KafkaSource&lt;String&gt; kafkaSource = KafkaSource.&lt;String&gt;builder()  
        .setBootstrapServers(<span class="hljs-string">&quot;192.168.1.100:9092&quot;</span>)  
        .setTopics(<span class="hljs-string">&quot;test_topic&quot;</span>)  
        .setGroupId(<span class="hljs-string">&quot;flink-demo&quot;</span>)  
        .setStartingOffsets(OffsetsInitializer.earliest())  
        .setValueOnlyDeserializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleStringSchema</span>())  
        .build();  
  
DataStreamSource&lt;String&gt; source = env.fromSource(kafkaSource, WatermarkStrategy.noWatermarks(), <span class="hljs-string">&quot;Kafka Source&quot;</span>);</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">consumerProperties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  
consumerProperties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;192.168.1.100:9092&quot;</span>);  
consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="hljs-string">&quot;flink-demo&quot;</span>);  
DataStreamSource&lt;String&gt; source =  
        env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlinkKafkaConsumer</span>&lt;&gt;(<span class="hljs-string">&quot;test_topic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleStringSchema</span>(), consumerProperties));</code></pre></div>


<h3 id="自定义Source"><a href="#自定义Source" class="headerlink" title="自定义Source"></a>自定义Source</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction;

<span class="hljs-keyword">import</span> java.util.Calendar;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SensorSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RichParallelSourceFunction</span>&lt;SensorReading&gt; &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(SourceContext&lt;SensorReading&gt; srcCtx)</span> <span class="hljs-keyword">throws</span> Exception &#123;

        <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();

        String[] sensorIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];
        <span class="hljs-type">double</span>[] curFTemp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            sensorIds[i] = <span class="hljs-string">&quot;sensor_&quot;</span> + i;
            curFTemp[i] = <span class="hljs-number">65</span> + (rand.nextGaussian() * <span class="hljs-number">20</span>);
        &#125;

        <span class="hljs-keyword">while</span> (running) &#123;
            <span class="hljs-type">long</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> Calendar.getInstance().getTimeInMillis();
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                curFTemp[i] += rand.nextGaussian() * <span class="hljs-number">0.5</span>;
                srcCtx.collect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SensorReading</span>(sensorIds[i], curTime, curFTemp[i]));
            &#125;

            Thread.sleep(<span class="hljs-number">100</span>);
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-built_in">this</span>.running = <span class="hljs-literal">false</span>;
    &#125;
&#125;
</code></pre></div>


<div class="code-wrapper"><pre><code class="hljs java">DataStream&lt;SensorReading&gt; sensorData = env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SensorSource</span>());</code></pre></div>


<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><p>算子负责将一个或多个DataStream转换为新的DataStream,，转换算子可以分为以下四类：</p>
<ul>
<li>基本转换算子：作用在数据流中的每一条单独数据上。</li>
<li>KeyedStream转换算子，在数据有key的情况下，对数据应用转换算子。</li>
<li>多流转换算子：合并多条流为一条流，或者将一条流分割为多条流。</li>
<li>分布式转换算子：将重新组织流里面的事件。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Java Lambda Stream Map用法。</p>
<p>转换关系：将1个元素，转换为1个新元素。</p>
<p>Example：将输入元素自增1</p>
<div class="code-wrapper"><pre><code class="hljs java">source.map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapFunction</span>&lt;Integer, Integer&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">map</span><span class="hljs-params">(Integer value)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-keyword">return</span> value + <span class="hljs-number">1</span>;
    &#125;
&#125;);</code></pre></div>


<h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p>转换关系：将1个元素，转换为任意个元素。</p>
<p>Example：将输入的String，按照<code> </code>进行拆分</p>
<div class="code-wrapper"><pre><code class="hljs java">dataStream.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlatMapFunction</span>&lt;String, String&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatMap</span><span class="hljs-params">(String value, Collector&lt;String&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-keyword">for</span>(String word: value.split(<span class="hljs-string">&quot; &quot;</span>))&#123;
            out.collect(word);
        &#125;
    &#125;
&#125;);</code></pre></div>


<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>按照设置的条件过滤，筛选出符合条件的元素。</p>
<p>Example: 过滤空串</p>
<div class="code-wrapper"><pre><code class="hljs java">source.filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterFunction</span>&lt;String&gt;() &#123;  
	<span class="hljs-meta">@Override</span>  
	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception &#123;  
		<span class="hljs-keyword">return</span> StringUtils.isNotBlank(s);  
	&#125;
&#125;);</code></pre></div>


<h3 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h3><p>将DataStream转换为KeyedStream：将key值相同的记录分配到相同的分区，类似于SQL的group by。</p>
<div class="code-wrapper"><pre><code class="hljs java">source.keyBy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KeySelector</span>&lt;Tuple2&lt;String, Integer&gt;, String&gt;() &#123;  
    <span class="hljs-meta">@Override</span>  
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getKey</span><span class="hljs-params">(Tuple2&lt;String, Integer&gt; value)</span> <span class="hljs-keyword">throws</span> Exception &#123;  
        <span class="hljs-keyword">return</span> value.f0;  
    &#125;  
&#125;)</code></pre></div>


<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>将KeyedStream转换为DataStream：将数据流中的元素与上一个Reduce后的元素进行合并产生一个新值，一般作用于有界数据流。</p>
<div class="code-wrapper"><pre><code class="hljs java">keyedStream.reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReduceFunction</span>&lt;Integer&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">reduce</span><span class="hljs-params">(Integer value1, Integer value2)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-keyword">return</span> value1 + value2;
    &#125;
&#125;);</code></pre></div>


<h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>将两个以上的DataStream合并成一个。</p>
<div class="code-wrapper"><pre><code class="hljs java">dataStream.union(stream1, stream2...);</code></pre></div>

<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>连接两个DataStream，允许两个流之间共享数据，与union有所区别：</p>
<ol>
<li>union支持多个，connect仅支持两个</li>
<li>union要求流的数据类型一致，connect允许类型不一样。</li>
<li>connect允许两个流有不同的处理逻辑。</li>
</ol>
<h3 id="CoMap"><a href="#CoMap" class="headerlink" title="CoMap"></a>CoMap</h3><p>对被Connect后的ConnectedStream执行map</p>
<div class="code-wrapper"><pre><code class="hljs java">connectedStreams.map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CoMapFunction</span>&lt;Integer, String, Boolean&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">map1</span><span class="hljs-params">(Integer value)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">map2</span><span class="hljs-params">(String value)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;);
</code></pre></div>


<h3 id="CoFlatMap"><a href="#CoFlatMap" class="headerlink" title="CoFlatMap"></a>CoFlatMap</h3><p>对被Connect后的ConnectedStream执行FlatMap</p>
<div class="code-wrapper"><pre><code class="hljs java">connectedStreams.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CoFlatMapFunction</span>&lt;Integer, String, String&gt;() &#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatMap1</span><span class="hljs-params">(Integer value, Collector&lt;String&gt; out)</span> &#123;
       out.collect(value.toString());
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatMap2</span><span class="hljs-params">(String value, Collector&lt;String&gt; out)</span> &#123;
       <span class="hljs-keyword">for</span> (String word: value.split(<span class="hljs-string">&quot;,&quot;</span>)) &#123;
         out.collect(word);
       &#125;
   &#125;
&#125;);</code></pre></div>


<h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p>数据交换策略决定将输入流通过何种策略输出到下游算子的并行任务。</p>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>将数据随机分配到下游算子的并行任务中。</p>
<div class="code-wrapper"><pre><code class="hljs java">source.shuffle();</code></pre></div>


<h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>使用轮询方式将输入流平均分配到下游算子的并行任务中，它会与所有的下游算子联系，默认的交换策略。</p>
<div class="code-wrapper"><pre><code class="hljs java">source.rebalance();</code></pre></div>


<h3 id="Rescale"><a href="#Rescale" class="headerlink" title="Rescale"></a>Rescale</h3><p>将数据发送到一部分的下游算子的并行任务中。</p>
<div class="code-wrapper"><pre><code class="hljs java">source.rescale();</code></pre></div>


<h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><p>将数据发送到下游算子的所有并行任务中。</p>
<div class="code-wrapper"><pre><code class="hljs java">source.broadcast();</code></pre></div>


<h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><p>将数据发送到下游算子的第一个并行任务中。</p>
<div class="code-wrapper"><pre><code class="hljs java">source.global();</code></pre></div>


<h3 id="Custom"><a href="#Custom" class="headerlink" title="Custom"></a>Custom</h3><p>自定义分区策略，使用<code>partitionCustom()</code></p>
<h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>Sink负责对计算结果的输出，Flink支持的Sink组件包括：Kafka、ES、Redis等。</p>
<h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p>将数据输出到控制台，用于调试阶段。</p>
<div class="code-wrapper"><pre><code class="hljs java">dataStream.print();</code></pre></div>



<h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  
  
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 定义 kafka sink</span>
<span class="hljs-type">Properties</span> <span class="hljs-variable">produceProperties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
produceProperties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, KAFKA_BROKER_SERVERS);
FlinkKafkaProducer&lt;String&gt; kafkaProducer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlinkKafkaProducer</span>&lt;&gt;(
    <span class="hljs-string">&quot;test&quot;</span>,
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleStringSchema</span>(),
    produceProperties);

dataStream.addSink(kafkaProducer);</code></pre></div>



<h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><p>对于流式数据（无界），部分计算指标不存在实际意义，Window主要解决无界性问题，按照规则将其划分成有界数据，用于业务逻辑的处理。</p>
<p>Keyed vs Non-Keyed：定义Window时，需要确认数据流是否调用过keyBy()方法。</p>
<p>keyBy()后的Stream支持多个窗口并行计算，可以按照key拆分数据流并行计算，Non-Keyed Stream只支持并行度为1的计算。</p>
<p>模板：</p>
<div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">// Keyed Window</span>
stream
       .keyBy(...)               &lt;-  仅 keyed 窗口需要
       .window(...)              &lt;-  必填项：<span class="hljs-string">&quot;assigner&quot;</span>
      [.trigger(...)]            &lt;-  可选项：<span class="hljs-string">&quot;trigger&quot;</span> (省略则使用默认 trigger)
      [.evictor(...)]            &lt;-  可选项：<span class="hljs-string">&quot;evictor&quot;</span> (省略则不使用 evictor)
      [.allowedLateness(...)]    &lt;-  可选项：<span class="hljs-string">&quot;lateness&quot;</span> (省略则为 <span class="hljs-number">0</span>)
      [.sideOutputLateData(...)] &lt;-  可选项：<span class="hljs-string">&quot;output tag&quot;</span> (省略则不对迟到数据使用 side output)
       .reduce/aggregate/apply()      &lt;-  必填项：<span class="hljs-string">&quot;function&quot;</span>
      [.getSideOutput(...)]      &lt;-  可选项：<span class="hljs-string">&quot;output tag&quot;</span>

<span class="hljs-comment">// Non-Keyed Window</span>
stream
       .windowAll(...)           &lt;-  不分组，将数据流中的所有元素分配到相应的窗口中
      [.trigger(...)]            &lt;-  指定触发器Trigger（可选）
      [.evictor(...)]            &lt;-  指定清除器Evictor(可选)
       .reduce/aggregate/process()      &lt;-  窗口处理函数Window Function</code></pre></div>


<h2 id="Window-schema"><a href="#Window-schema" class="headerlink" title="Window schema"></a>Window schema</h2><p>决定数据流入窗口的策略</p>
<h3 id="Tumbling-Window"><a href="#Tumbling-Window" class="headerlink" title="Tumbling Window"></a>Tumbling Window</h3><p>滚动窗口：固定大小、不可重叠</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// tumbling event-time windows  </span>
input  
.keyBy(&lt;key selector&gt;)  
.window(TumblingEventTimeWindows.of(Time.seconds(<span class="hljs-number">5</span>)))  
.&lt;windowed transformation&gt;(&lt;window function&gt;);</code></pre></div>


<h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>滑动窗口：固定大小、允许重叠</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// sliding event-time windows  </span>
input  
.keyBy(&lt;key selector&gt;)  
.window(SlidingEventTimeWindows.of(Time.seconds(<span class="hljs-number">10</span>), Time.seconds(<span class="hljs-number">5</span>)))  
.&lt;windowed transformation&gt;(&lt;window function&gt;);</code></pre></div>


<h3 id="Session-Window"><a href="#Session-Window" class="headerlink" title="Session Window"></a>Session Window</h3><p>当一个窗口在大于session gap的时间内没有接收到新数据，就会被关闭<br>i<br>会话窗口：不会重叠，也没有固定的起始时间，关闭取决于session gap的触发。</p>
<h2 id="Window-Function"><a href="#Window-Function" class="headerlink" title="Window Function"></a>Window Function</h2><p>Stream指定窗口划分数据后，需要执行计算逻辑，通常包括以下三种。</p>
<h3 id="ReduceFunction"><a href="#ReduceFunction" class="headerlink" title="ReduceFunction"></a>ReduceFunction</h3><p>可以将输入流中前后两个元素进行合并操作，并输出类型相同的新元素。</p>
<h3 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h3><p>可以将输入元素进行增量聚合</p>
<p>AggregateFunction接口定义了以下4个方法：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PublicEvolving</span>  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AggregateFunction</span>&lt;IN, ACC, OUT&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>, Serializable &#123;  
	<span class="hljs-comment">//创建初始累加器</span>
    ACC <span class="hljs-title function_">createAccumulator</span><span class="hljs-params">()</span>;  

	<span class="hljs-comment">//累加输入元素到累加器</span>
    ACC <span class="hljs-title function_">add</span><span class="hljs-params">(IN value, ACC accumulator)</span>;  

	<span class="hljs-comment">//从累加器提取输出结果</span>
    OUT <span class="hljs-title function_">getResult</span><span class="hljs-params">(ACC accumulator)</span>;  

	<span class="hljs-comment">//合并累加器</span>
    ACC <span class="hljs-title function_">merge</span><span class="hljs-params">(ACC a, ACC b)</span>;  
&#125;</code></pre></div>


<p>计算一个窗口内的平均数：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AverageAccumulator</span> &#123;  
    <span class="hljs-type">long</span> count;  
    <span class="hljs-type">long</span> sum;  
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeightedAverage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AggregateFunction</span>&lt;Double, AverageAccumulator, Double&gt; &#123;  
  
    <span class="hljs-keyword">public</span> AverageAccumulator <span class="hljs-title function_">createAccumulator</span><span class="hljs-params">()</span> &#123;  
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AverageAccumulator</span>();  
    &#125;  
  
    <span class="hljs-keyword">public</span> AverageAccumulator <span class="hljs-title function_">merge</span><span class="hljs-params">(AverageAccumulator a, AverageAccumulator b)</span> &#123;  
        a.count += b.count;  
        a.sum += b.sum;  
        <span class="hljs-keyword">return</span> a;  
    &#125;  
  
    <span class="hljs-keyword">public</span> AverageAccumulator <span class="hljs-title function_">add</span><span class="hljs-params">(Double value, AverageAccumulator acc)</span> &#123;  
        acc.count += value;  
        acc.sum += value;  
        <span class="hljs-keyword">return</span> acc;  
    &#125;  
  
    <span class="hljs-keyword">public</span> Double <span class="hljs-title function_">getResult</span><span class="hljs-params">(AverageAccumulator acc)</span> &#123;  
        <span class="hljs-keyword">return</span> acc.sum / (<span class="hljs-type">double</span>) acc.count;  
    &#125;  
  
&#125;
</code></pre></div>



<h3 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h3><p>ProcessWindowFunction包含了以下内容：</p>
<ul>
<li>IN：输入元素类型</li>
<li>OUT：输出元素类型</li>
<li>KEY：用于分区字段的类型</li>
<li>W：可被使用的窗口函数类型</li>
</ul>
<p>使用起来更灵活，可以缓存窗口所有数据。</p>
<h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><p>决定Window Function启动时机和窗口数据清理时机。</p>
<h2 id="Evictor"><a href="#Evictor" class="headerlink" title="Evictor"></a>Evictor</h2><p>在Trigger触发后、调用Window Function之前或者之后从窗口中删除数据。</p>
<p>Flink内置三个Evictor：</p>
<ul>
<li>CountEvictor：仅记录用户指定数量的元素，一旦窗口元素超过指定值，多余元素从开头进行移除。</li>
<li>DeltaEvictor：接收指定的threshold参数，计算窗口内最后一个元素和其他所有元素的差值，并移除差值&gt;&#x3D; threshold的元素。</li>
<li>TimeEvictor：接收interval参数，找到窗口中元素最大的timestamp，并移除比max - interval小的所有元素。</li>
</ul>
<h1 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h1><p>数据乱序场景时，当新数据输入进来触发窗口关闭后，旧数据找不到对应窗口就会丢失。</p>
<p>Watermark是用来度量数据event-time进展的字段，表明在watermark之前时间的数据都已经接收。</p>
<p>Watermark（水位线）：一条特殊的数据记录，以长整型值保存了一个时间戳，有两个基本属性：</p>
<ol>
<li>必须单调递增，以确保任务的时间再向前推进</li>
<li>必须与数据的时间戳相关，后续的数据时间戳都必须大于它，可用于处理时间乱序数据流。</li>
</ol>
<h2 id="Watermark策略"><a href="#Watermark策略" class="headerlink" title="Watermark策略"></a>Watermark策略</h2><p>Flink需要从每个元素中提取可分配的时间戳，通常使用TimestampAssigner从元素某个字段提取出时间戳，同时通过指定WatermarkGenerator配置watermark生成策略。</p>
<p>Flink可以通过两种方式生成watermark：</p>
<ol>
<li>数据源source分配：通过SourceFunction分配watermark</li>
<li>设置WatermarkStrategy</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">StreamExecutionEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();

DataStream&lt;MyEvent&gt; stream = env.readFile(
        myFormat, myFilePath, FileProcessingMode.PROCESS_CONTINUOUSLY, <span class="hljs-number">100</span>,
        FilePathFilter.createDefaultFilter(), typeInfo);

DataStream&lt;MyEvent&gt; withTimestampsAndWatermarks = stream
        .filter( event -&gt; event.severity() == WARNING )
        .assignTimestampsAndWatermarks(&lt;watermark strategy&gt;);

withTimestampsAndWatermarks
        .keyBy( (event) -&gt; event.getGroup() )
        .window(TumblingEventTimeWindows.of(Time.seconds(<span class="hljs-number">10</span>)))
        .reduce( (a, b) -&gt; a.add(b) )
        .addSink(...);</code></pre></div>



<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><h2 id="Sate-Backend"><a href="#Sate-Backend" class="headerlink" title="Sate Backend"></a>Sate Backend</h2><p>State Backend是状态的管理组件，主要解决两个问题：</p>
<ol>
<li>管理本地状态，包括访问、存储和更新</li>
<li>checkpoint被激活时，决定状态同步的方式和位置</li>
</ol>
<h1 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h1><p>Flink作为一个分布式计算系统，需要有一套机制用于满足分区容错性，处理各类故障。</p>
<p>Flink主要提供了checkpoint与流重放相结合的机制来解决。</p>
<h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>Flink恢复机制的核心就是应用状态的一致检查点，checkpoint会每隔一段时间就保存一份snapshot，它包含了数据流中所有任务在某个时间点的状态信息。如果发生故障，使用最近的checkpoint恢复状态，并重启处理流程。</p>
<p>Flink基于Chandy-Lamport算法实现分布式快照的checkpoint的保存，该算法不会暂停整个应用程序，将保存流程和数据处理流程分离。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">StreamExecutionEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  
env.enableCheckpointing(<span class="hljs-number">5000</span>);</code></pre></div>



<p>TODO：算法细节</p>
<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>从checkpoint触发开始到checkpoint成功生成快照的过程中，如何判断哪些数据需要在当前checkpoint阶段进行保存，使用Barrier进行隔离。</p>
<p>特点：</p>
<ul>
<li>随数据流传递的数据字段</li>
<li>以广播的方式向下游传递</li>
</ul>
<h3 id="Storage-Location"><a href="#Storage-Location" class="headerlink" title="Storage Location"></a>Storage Location</h3><ul>
<li>JobManagerCheckpointStorage：状态保存在JobManager的内存堆<ul>
<li>通常用于本地开发测试</li>
</ul>
</li>
<li>FileSystemCheckpointStorage：状态保存到checkpointDirectory指向<ul>
<li>本地或远程</li>
</ul>
</li>
</ul>
<h3 id="保留模式"><a href="#保留模式" class="headerlink" title="保留模式"></a>保留模式</h3><p>作业取消后，checkpoint是否保留，提供了两个参数：</p>
<ul>
<li>DELETE_ON_CANCELLATION：Flink 作业取消后删除 checkpoint 文件</li>
<li>RETAIN_ON_CANCELLATION：Flink 作业取消后保留 checkpoint 文件</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">CheckpointConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> env.getCheckpointConfig();  
config.enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</code></pre></div>


<h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><p>作业出现故障后，Flink会停止数据流，将数据流重置到checkpoint最新生成的快照，包括两种恢复策略：</p>
<ul>
<li>Restart：决定了是否重启、何时重启作业</li>
<li>Failover：决定应该重启哪些任务</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/execution/task_failure_recovery/">https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/execution/task_failure_recovery/</a></p>
</blockquote>
<h2 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h2><p>允许应用程序从指定savepoint启动程序，创建savepoint的算法和checkpoint完全相同，可以认为是具有一些额外元数据的checkpoint，Flink不会自动创建，由外部程序触发创建操作。</p>
<h2 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h2><p>反压通常发生于的场景：短时间内系统接收数据的速率远高于处理数据的速率。因此需要对上游进行限速。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Big-Data/" class="category-chain-item">Big Data</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Flink入门</div>
      <div>https://l1n.wang/2024/Big-Data/flink-note/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lin Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/JVM/JVM%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B/" title="JVM内存问题排查流程">
                        <span class="hidden-mobile">JVM内存问题排查流程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'L1nker4/blog_comment');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       2018 - 2024 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/love.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
