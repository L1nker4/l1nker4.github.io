<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>系统设计 on l1nker4&#39;s Blog</title>
    <link>http://localhost:1313/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
    <description>Recent content in 系统设计 on l1nker4&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Jul 2022 14:29:01 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>短网址系统设计总结</title>
      <link>http://localhost:1313/posts/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 10 Jul 2022 14:29:01 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h2 id=&#34;需求评估&#34;&gt;需求评估&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入数据：一个长网址、过期时间和一个自定义的别名&lt;/li&gt;&#xA;&lt;li&gt;输出数据：自定义别名或者随机生成的短网址，过期时间之前访问都会被重定向到原始地址。&lt;/li&gt;&#xA;&lt;li&gt;读多写少&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;实现原理：将短网址redirect到长网址（301/302跳转）&lt;/p&gt;&#xA;&lt;p&gt;约束：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;过期即失效&lt;/li&gt;&#xA;&lt;li&gt;短网址唯一&lt;/li&gt;&#xA;&lt;li&gt;支持自定义短网址&lt;/li&gt;&#xA;&lt;li&gt;QPS要求、低延迟、可靠性、安全性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;系统设计&#34;&gt;系统设计&lt;/h2&gt;&#xA;&lt;h3 id=&#34;可行解&#34;&gt;可行解&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;写&#xA;&lt;ol&gt;&#xA;&lt;li&gt;输入长域名，判断是否存在&lt;/li&gt;&#xA;&lt;li&gt;生成一个未使用的短网址，并进行持久化&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;读&#xA;&lt;ol&gt;&#xA;&lt;li&gt;获取短网址，判断是否过期&lt;/li&gt;&#xA;&lt;li&gt;正常则返回短网址&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;其他方面：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用延迟删除策略清理过期数据&lt;/li&gt;&#xA;&lt;li&gt;读时消重：返回的时候过滤重复元素&lt;/li&gt;&#xA;&lt;li&gt;写时消重：写时判断以避免重复写入&lt;/li&gt;&#xA;&lt;li&gt;短网址生成算法：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;UUID：无法保证唯一性&lt;/li&gt;&#xA;&lt;li&gt;哈希：MurMurHash等方法，无法保证唯一性，考虑转为62进制&lt;/li&gt;&#xA;&lt;li&gt;ID：使用7位62进制，即长度为7，由大小写字母加数字共62个字符组成&lt;/li&gt;&#xA;&lt;li&gt;雪花算法：转为62进制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;用户自定义：记录正在使用的ID，写入时判断是否存在&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;MySQL表结构如下：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;id&lt;/th&gt;&#xA;          &lt;th&gt;long_url&lt;/th&gt;&#xA;          &lt;th&gt;short_url&lt;/th&gt;&#xA;          &lt;th&gt;expire_time&lt;/th&gt;&#xA;          &lt;th&gt;create_time&lt;/th&gt;&#xA;          &lt;th&gt;delete_time&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;Redis键值设计：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;k：长网址, v：短网址&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;吞吐量优化&#34;&gt;吞吐量优化&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;水平扩展&lt;/strong&gt;：使用Nginx做负载均衡&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;存储层&lt;/strong&gt;：MySQL替换为持久化KV存储，比如RocksDB，若存在数据分析的需求，可以添加数仓&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;索引优化&lt;/strong&gt;：两个方面&#xA;&lt;ol&gt;&#xA;&lt;li&gt;写入时判需要判断长网址是否存在&lt;/li&gt;&#xA;&lt;li&gt;读取时根据短网址查询长网址&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分片&lt;/strong&gt;：短网址进行一致性哈希等方式计算分片位置。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存层&lt;/strong&gt;：&lt;strong&gt;读多写少&lt;/strong&gt;的系统使用缓存优化QPS&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用bloom filter检查长网址是否存储，短网址是否分配&lt;/li&gt;&#xA;&lt;li&gt;直接在本地设计缓存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;业务层&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分布式ID生成需要考虑&lt;strong&gt;数据一致性&lt;/strong&gt;问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;网络层&lt;/strong&gt;：降低&lt;strong&gt;广域延迟&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;可靠性优化&#34;&gt;可靠性优化&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存储层：考虑主从副本机制，增加数据可靠性&lt;/li&gt;&#xA;&lt;li&gt;提供跨机房的数据冗余备份，通过log同步数据&lt;/li&gt;&#xA;&lt;li&gt;监控业务集群，实现熔断、限流、扩容缩容等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;安全性优化&#34;&gt;安全性优化&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免使用自增，防止逐个遍历&lt;/li&gt;&#xA;&lt;li&gt;防止DDos，对接口做限流，增加IP黑名单机制&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>秒杀系统设计总结</title>
      <link>http://localhost:1313/posts/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/seckill-summary/</link>
      <pubDate>Mon, 09 Nov 2020 13:29:50 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/seckill-summary/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;p&gt;秒杀从规模上可以分为以下两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大秒：类似双十一，商品数量规模大，价格低，流量超大的活动。&lt;/li&gt;&#xA;&lt;li&gt;小秒：商家自己配置的一些时段类型的活动，由商家自己指定时间上架。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;秒杀系统面对的问题&#34;&gt;秒杀系统面对的问题&lt;/h2&gt;&#xA;&lt;p&gt;秒杀系统本质上就是一个满足大并发、高性能和高可用的分布式系统。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高并发环境下的系统稳定性：如何保证系统在面对巨大的流量情况下，不被打崩？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两个问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;并发读&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心优化理念：减少用户到服务端来读数据。或者让他们读取更少的数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;并发写&#xA;&lt;ul&gt;&#xA;&lt;li&gt;核心优化理念：在数据库层面独立出来一个库，做特殊的处理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;大流量会产生以下实际待解决问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Redis缓存击穿/雪崩/穿透等问题&lt;/li&gt;&#xA;&lt;li&gt;关系型数据库性能问题，锁竞争对性能的消耗&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;保证数据的最终一致性：库存不能超卖。&lt;/li&gt;&#xA;&lt;li&gt;大数据分析功能：分析本次秒杀活动的商业效益。&lt;/li&gt;&#xA;&lt;li&gt;需要有一个兜底方案，以防最坏的情况发生。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;设计&#34;&gt;设计&lt;/h1&gt;&#xA;&lt;h2 id=&#34;架构原则-4要1不要&#34;&gt;架构原则： &amp;ldquo;4要1不要&amp;rdquo;&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;架构是一种平衡的艺术，最好的架构一旦脱离了它所适应的场景，一切都将是空谈。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据要尽量少&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户请求的数据能少就少，包括上传给系统的数据和系统返回给用户的数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;HTTP请求数尽量少&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;合并CSS，JS文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;路径要尽量短&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户发出请求到返回数据的过程中，经过的节点要尽量短&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常，每经过一个节点，都会产生一个新的Socket连接。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;会减少时延&lt;/li&gt;&#xA;&lt;li&gt;可以选择将多个相互强依赖的引用部署在一起，将RPC变成JVM内部的方法调用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;依赖要尽量少&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;完成一次用户请求必须依赖的系统或服务要少（指的是强依赖）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比如展示秒杀页面，它强依赖商品信息，用户信息，但是优惠券，成交列表等非必要模块是可以在紧急情况下去掉。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对系统模块进行分级，0级，1级，2级等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不要有单点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统中的单点是系统架构上的一个大忌，单点意味着没有备份，风险不可控。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何避免单点？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免将服务的状态和机器绑定（服务无状态化）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把服务的配置动态化（使用配置中心Nacos等）&lt;/li&gt;&#xA;&lt;li&gt;存储服务不好实现，因为数据持久化存储在机器的磁盘里面。文件存储可以通过冗余多个备份的方式来解决单点问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;流量过滤&#34;&gt;流量过滤&lt;/h2&gt;&#xA;&lt;p&gt;本质：逐级过滤掉无效的流量。基本有以下一些解决方案：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;活动开始前前端页面的Button无法点击，防止活动尚未开始时，用户进行点击产生流量。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同时后端需要做相关校验。避免用户直接请求秒杀接口。&lt;/li&gt;&#xA;&lt;li&gt;秒杀url实现动态化，可以选择进行md5加密随机字符串，然后通过另一个接口校验秒杀接口的合法性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;错峰：前端添加验证码或者答题，防止瞬间产生超高的流量，增加题目辨别难度，避免以图像识别等技术进行破解。&lt;/li&gt;&#xA;&lt;li&gt;校验：对参与活动的用户进行校验拦截。主要从以下几个方面进行判断&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户白名单&lt;/li&gt;&#xA;&lt;li&gt;用户终端校验：对用户终端类型进行判断&lt;/li&gt;&#xA;&lt;li&gt;IP、MAC、ID校验&lt;/li&gt;&#xA;&lt;li&gt;参与次数校验：避免多次参与活动&lt;/li&gt;&#xA;&lt;li&gt;用户黑名单：避免羊毛党等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;限流：通过接口限流策略判断请求是否放行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;令牌桶算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;性能优化&#34;&gt;性能优化&lt;/h2&gt;&#xA;&lt;p&gt;前面的流量过滤基本过滤掉大部分流量，但是系统性能还需进行优化，主要有以下的解决方案：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;动静分离&lt;/li&gt;&#xA;&lt;li&gt;活动预热：将参加活动的商品独立出来，不和普通的商品库存共享服务，提前将数据缓存到&lt;code&gt;Redis&lt;/code&gt;，查询全部走缓存，扣减库存视情况而定。&lt;/li&gt;&#xA;&lt;li&gt;选择&lt;code&gt;Nginx&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;采用微服务架构部署，提高部署量，均摊请求。&lt;/li&gt;&#xA;&lt;li&gt;秒杀是典型的读多写少的场景，考虑到单体redis的性能问题，可以考虑：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;集群&lt;/li&gt;&#xA;&lt;li&gt;主从同步&lt;/li&gt;&#xA;&lt;li&gt;读写分离&lt;/li&gt;&#xA;&lt;li&gt;如果使用&lt;code&gt;Redis&lt;/code&gt;集群，同时需要考虑保证多节点的数据一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;异步处理：采用消息队列&#xA;&lt;ul&gt;&#xA;&lt;li&gt;异步，削峰，解耦&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;动静分离&#34;&gt;动静分离&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
