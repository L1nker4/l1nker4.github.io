<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>中间件 on l1nker4&#39;s Blog</title>
    <link>http://localhost:59500/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
    <description>Recent content in 中间件 on l1nker4&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Jan 2023 18:41:32 +0000</lastBuildDate>
    <atom:link href="http://localhost:59500/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ShardingSphere-JDBC学习笔记</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/shardingsphere-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 11 Jan 2023 18:41:32 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/shardingsphere-jdbc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;基础概念&#34;&gt;基础概念&lt;/h2&gt;&#xA;&lt;p&gt;ShardingSphere-JDBC是Apache ShardingSphere项目中的一个子项目，Apache ShardingSphere是一款分布式的数据库生态系统，可以通过分片、弹性伸缩、加密等能力对原有数据库进行增强。&lt;/p&gt;&#xA;&lt;p&gt;ShardingSphere-JDBC定位是&lt;strong&gt;轻量级Java框架&lt;/strong&gt;，在JDBC层提供额外服务。它能尽量透明化水平分库分表所带来的影响，让业务方逻辑上感知到一个数据库节点和逻辑表，当收到SQL查询，主要做了以下工作：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SQL解析：词法解析和语法解析，提炼出解析上下文&lt;/li&gt;&#xA;&lt;li&gt;SQL路由：根据解析上下文匹配用户配置的库表的分片策略，并生成路由后的SQL（一条或多条）。&lt;/li&gt;&#xA;&lt;li&gt;SQL改写：将SQL改写为物理数据库能正常执行的语句（逻辑SQL -&amp;gt; 物理SQL）。&lt;/li&gt;&#xA;&lt;li&gt;SQL执行：通过多线程异步执行改写后的SQL语句。&lt;/li&gt;&#xA;&lt;li&gt;结果归并：将多个执行结果归并为统一的JDBC接口输出。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;几个概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;逻辑表：ORM框架的业务层面，表现为一张表，例如：t_order&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;物理表：数据库层面实际存在的表，例如：t_order_0、t_order_1&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;绑定表：分片规则一致的一组分片表，进行关联查询时，建议使用分片键进行关联，否则影响查询效率。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;广播表：数据源中都存在的表，且结构和数据都完全一致。适用于数据量不大且需要与其他大数据量表进行关联查询。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分片键：根据某个字段的计算结果（取模等）进行水平分片&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;路由：通过SQL语句中的信息，找到对应分片的过程&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分片算法&#34;&gt;分片算法&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;标准分片算法：单一键作为分片键。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;取模算法：根据一些字段，或多个字段hash求值再取模。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;范围限定算法，按照年份、实践等策略路由到目标数据库。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;复合分片算法：多键作为分片键，自行设计&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Hint分片算法：用于处理使用Hint行分片的场景（非数据库字段的分片方式）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分片策略&#34;&gt;分片策略&lt;/h3&gt;&#xA;&lt;p&gt;包含分片键和分片算法，ShardingSphere-JDBC提供了以下几种分片策略：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标准分片策略（StandardSharingStrategy）：使用精确分片算法或范围分片算法，支持单分片键。&lt;/li&gt;&#xA;&lt;li&gt;复合分片策略（ComplexShardingStrategy）：使用复合分片算法，支持多分片键。&lt;/li&gt;&#xA;&lt;li&gt;Hint分片策略（HintShardingStrategy）：使用Hint分片算法&lt;/li&gt;&#xA;&lt;li&gt;Inline分片策略（InlineShardingStrategy）：使用groovy表达式作为分片算法&lt;/li&gt;&#xA;&lt;li&gt;不分片策略（NoneShardingStrategy）：不使用分片算法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;&#xA;&lt;p&gt;pom.xml&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.1.4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.mysql&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mysql-connector-j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;runtime&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;8.0.32&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.projectlombok&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lombok&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;optional&amp;gt;&lt;/span&gt;true&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/optional&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.baomidou&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mybatis-plus-boot-starter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.2.0&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.alibaba&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;druid&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.2.15&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.shardingsphere&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;sharding-jdbc-spring-boot-starter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;4.0.0-RC1&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.shardingsphere&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;sharding-core-common&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;4.0.0-RC1&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ShardingSphere提供了多种配置方式：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Netty学习笔记(三)- 时间轮算法</title>
      <link>http://localhost:59500/posts/netty/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89--%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 03 Dec 2022 10:12:54 +0000</pubDate>
      <guid>http://localhost:59500/posts/netty/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89--%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;定时器理论&#34;&gt;定时器理论&lt;/h2&gt;&#xA;&lt;p&gt;实际的业务场景会遇到许多使用定时任务的场景，定时器主要有三种表现形式：固定周期定时执行、延迟一定时间执行，指定某个时刻执行。再实现层面，定时器需要考虑&lt;strong&gt;存储和调度&lt;/strong&gt;指定任务，内部通过轮询的方式检查任务是否到期并需要执行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;java定时器&#34;&gt;Java定时器&lt;/h2&gt;&#xA;&lt;p&gt;Java提供了三种常用的定时器实现方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Timer&lt;/li&gt;&#xA;&lt;li&gt;DelayQueue&lt;/li&gt;&#xA;&lt;li&gt;ScheduledThreadPoolExecutor&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;timer&#34;&gt;Timer&lt;/h3&gt;&#xA;&lt;p&gt;Timer使用的就是上述最原始的定时器实现方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;存储&lt;/strong&gt;：TaskQueue是数组实现的小根堆，deadline最近的任务位于堆顶端。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;调度&lt;/strong&gt;：TimerThread异步线程，定时轮询队列，如果堆顶任务的deadline已到，那么执行任务，如果是周期性任务，执行完计算下次deadline，并再次放入小根堆。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Timer&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; TaskQueue queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TaskQueue();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; TimerThread thread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TimerThread(queue);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Timer&lt;/span&gt;(String name) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;setName&lt;/span&gt;(name);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Timer存在几个缺陷：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;单线程模式，某个TimeTask阻塞，会影响其他的任务调度。&lt;/li&gt;&#xA;&lt;li&gt;Timer的任务调度基于系统时间的，系统时间不正确，可能出现问题。&lt;/li&gt;&#xA;&lt;li&gt;TimeTask执行出现异常，Timer不会捕获，线程终止后，其他任务都不能执行。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;使用案例：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Timer timer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Timer();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//设置一个10s后调度一个周期为1s的定时任务&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;timer.&lt;span style=&#34;color:#a6e22e&#34;&gt;scheduleAtFixedRate&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TimerTask() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// do something&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}, 10000, 1000);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;delayqueue&#34;&gt;DelayQueue&lt;/h3&gt;&#xA;&lt;p&gt;DelayQueue是一种可以延迟获取对象的阻塞队列，内部使用PriorityQueue存储任务，每个元素必须实现Delayed接口，并重写指定方法。DelayQueue提供了put和take两个阻塞方法。对象put进去后，通过compareTo进行优先级排序，getDelay计算出剩余时间，只有小于等于0时，对象才能从其中被取出。&lt;/p&gt;&#xA;&lt;p&gt;实际上只实现了存储定时任务的功能，还需要配合异步线程才能实现定时器。&lt;/p&gt;&#xA;&lt;h3 id=&#34;scheduledthreadpoolexecutor&#34;&gt;ScheduledThreadPoolExecutor&lt;/h3&gt;&#xA;&lt;p&gt;该线程池继承于ThreadPoolExecutor，提供了周期执行和延迟执行的功能，在ThreadPoolExecutor的基础上，重新设计了任务ScheduledFutureTask和阻塞队列DelayedWorkQueue。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Netty学习笔记(二)- 内部机制</title>
      <link>http://localhost:59500/posts/netty/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C--%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 19 Nov 2022 08:12:54 +0000</pubDate>
      <guid>http://localhost:59500/posts/netty/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C--%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;事件调度层&#34;&gt;事件调度层&lt;/h1&gt;&#xA;&lt;h2 id=&#34;reactor线程模型&#34;&gt;Reactor线程模型&lt;/h2&gt;&#xA;&lt;p&gt;Netty中三种Reactor线程模型来源于&lt;a href=&#34;https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf&#34;&gt;Scalable I/O in Java&lt;/a&gt;，主要有以下三种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单线程模型：所有IO操作（连接建立、读写、事件分发）都由一个线程完成。&lt;/li&gt;&#xA;&lt;li&gt;多线程模型：使用多线程处理任务。线程内部仍然是串行化。&lt;/li&gt;&#xA;&lt;li&gt;主从多线程模型：主线程只负责连接的Accept事件，从线程负责除连接外的事件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Reactor线程模型运行机制可以分为以下四个步骤：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注册连接：将Channel注册到Reactor线程中的Selector。&lt;/li&gt;&#xA;&lt;li&gt;事件轮询：轮询Selector中已注册的Channel的IO事件。&lt;/li&gt;&#xA;&lt;li&gt;事件分发：将连接的IO事件分发给worker线程。&lt;/li&gt;&#xA;&lt;li&gt;任务处理：Reactor线程负责队列中的非IO任务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;eventloop&#34;&gt;EventLoop&lt;/h2&gt;&#xA;&lt;p&gt;EventLoop是一种&lt;strong&gt;事件处理模型&lt;/strong&gt;，Netty中EventLoop运行机制如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221113182321659.png&#34; alt=&#34;EventLoop运行机制&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BossEventLoopGroup：负责监听客户端的Accept事件，触发时将事件注册到WorkerEventLoopGroup中的一个NioEventLoop，&lt;/li&gt;&#xA;&lt;li&gt;WorkerEventLoopGroup：每建立一个Channel，都选择一个NioEventLoop与其绑定，Channel的所有事件都是线程独立的。不会和其他线程发生交集。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;任务处理机制&#34;&gt;任务处理机制&lt;/h3&gt;&#xA;&lt;p&gt;NioEventLoop不仅负责处理IO事件，还要兼顾执行任务队列中的任务。任务队列遵守FIFO原则。任务基本可以分为三类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;普通任务：通过NioEventLoop的execute()方法向taskQueue中添加的。&lt;/li&gt;&#xA;&lt;li&gt;定时任务：通过NioEventLoop的schedule()方法向scheduledtaskQueue添加的定时任务，例如心跳消息可以通过该任务实现。&lt;/li&gt;&#xA;&lt;li&gt;尾部队列：执行完taskQueue中任务后会去获取尾部队列tailTasks中的任务去执行。主要做收尾工作，例如统计事件循环的执行时间等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;使用技巧&#34;&gt;使用技巧&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用Boss和Worker两个Group分别处理不同的事件，合理分担压力。&lt;/li&gt;&#xA;&lt;li&gt;对于耗时较长的ChannelHandler可以考虑维护一个业务线程池，将任务封装成Task进行异步处理。，避免ChannelHandler阻塞而造成EventLoop不可用。&lt;/li&gt;&#xA;&lt;li&gt;选用合理的ChannelHandler数量，明确业务和Netty的分层。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;服务编排层&#34;&gt;服务编排层&lt;/h1&gt;&#xA;&lt;h2 id=&#34;channelpipeline&#34;&gt;ChannelPipeline&lt;/h2&gt;&#xA;&lt;p&gt;Pipeline如同字面意思，原始的网络字节流流经pipeline，被逐层处理，最终得到成品数据并返回。Netty中的ChannelPipeline采取责任链模式，调用链路环环相扣。&lt;/p&gt;&#xA;&lt;p&gt;ChannelPipeline由一组ChannelHandlerContext组成，内部通过双向链表将ChannelHandlerContext连接起来，当IO事件触发时，依次调用Handler对数据进行处理。ChannelHandlerContext用于保存ChannelHandler的上下文，包含了其生命周期的所有事件：connect、bind、read等。&lt;/p&gt;&#xA;&lt;p&gt;根据数据流向，ChannelPipeline可以分为入站和出站两种处理器，对应&lt;strong&gt;ChannelInboundHandler&lt;/strong&gt;和&lt;strong&gt;ChannelOutboundHandler&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;&#xA;&lt;p&gt;ChannelHandler采用了责任链模式，如果前置的Handler抛出呢Exception，会传递到后置Handler，异常处理的最佳实践，就是在最后加上自定义的异常处理器。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExceptionHandler&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; ChannelDuplexHandler {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exceptionCaught&lt;/span&gt;(ChannelHandlerContext ctx, Throwable cause) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (cause &lt;span style=&#34;color:#66d9ef&#34;&gt;instanceof&lt;/span&gt; RuntimeException) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Handle Business Exception Success.&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;零拷贝&#34;&gt;零拷贝&lt;/h1&gt;&#xA;&lt;p&gt;Netty中面向用户态的数据操作优化，主要包含以下几个方面：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用堆外内存，避免JVM内存到堆外内存之间的数据拷贝&lt;/li&gt;&#xA;&lt;li&gt;使用CompositeByteBuf，可以组合多个Buffer，将其合并成逻辑上的一个对象，避免物理的内存拷贝。&lt;/li&gt;&#xA;&lt;li&gt;使用Unpooled.wrappedBuffer，将byte数组包装成ByteBuf对象，过程间不产生内存拷贝。&lt;/li&gt;&#xA;&lt;li&gt;ByteBuf.slice切分时不产生内存拷贝，底层共享一个byte数组。&lt;/li&gt;&#xA;&lt;li&gt;使用FileRegion实现文件传输，使用的FileChannel#transferTo()，直接将缓冲区数据输出到目标Channel，避免内核缓冲区和用户态缓冲区的数据拷贝。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>MinIO的分布式存储实践方案</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/minio%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88/</link>
      <pubDate>Fri, 19 Aug 2022 21:12:54 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/minio%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;MinIO是一个开源的分布式对象存储组件，它兼容Amazon S3 API，适合于存储大容量的非结构化数据，支持单个对象最大5TB。&lt;/p&gt;&#xA;&lt;p&gt;MinIO特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;部署简单，仅需要单独一个二进制文件&lt;/li&gt;&#xA;&lt;li&gt;支持纠删码机制，能恢复部分数据块丢失的情况。&lt;/li&gt;&#xA;&lt;li&gt;读写性能高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220924181123151.png&#34; alt=&#34;MinIO Benchmark&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;基础原理&#34;&gt;基础原理&lt;/h2&gt;&#xA;&lt;h3 id=&#34;纠删码&#34;&gt;纠删码&lt;/h3&gt;&#xA;&lt;p&gt;纠删码是分布式存储领域常见的一种冗余技术，与副本机制相对比，纠删码拥有更高的磁盘利用率。纠删码的基本原理：通过&lt;strong&gt;纠删码算法&lt;/strong&gt;对原始数据进行计算，得到冗余的编码数据，并将数据和冗余编码一起存储，如果未来存储介质发生故障，导致其中部分数据出错，此时可以通过对应的重构算法，&lt;strong&gt;解码&lt;/strong&gt;出完整的原始数据，以达到容错的目的。即&lt;strong&gt;总数据块 = 原始块 + 校验快&lt;/strong&gt;($n = k + m$)。纠删码技术的磁盘利用率为$k / (k + m)$，允许总数据块中任意m个数据块损坏。&lt;/p&gt;&#xA;&lt;p&gt;上面提到的n、m的比值，是衡量纠删码的核心参数，这个值被称为冗余度，冗余度越高（校验快越多），允许丢失的数据块可以越多，同时数据存储成本也就越高。k值决定数据分块的粒度，k越小，数据分散度越小、重建代价越大。k值越大，数据拷贝的负载越大。常见的公有云独享存储的冗余度一般在&lt;code&gt;1.2-1.4&lt;/code&gt;左右。&lt;/p&gt;&#xA;&lt;p&gt;目前常用的纠删码算法：&lt;code&gt;Reed-Solomon&lt;/code&gt;，它有两个参数n和m，记为$RS(n , m)$。n代表原始数据块个数。m代表校验块个数。&lt;/p&gt;&#xA;&lt;p&gt;下图中是使用16块磁盘作为存储设备的情况，假设此时MinIOn持有16个磁盘，MinIO会将其中8块作为数据盘，另外八块作为校验盘，数据盘存储对象的原始数据，校验盘存储对象的校验数据。纠删码默认配置是&lt;strong&gt;1:1&lt;/strong&gt;，也就是将所有磁盘中的一半作为数据盘，一半做为校验盘。同时MinIO使用HighwayHash编码计算数据块的hash值，获取文件时会计算hash值来校验文件的准确性。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/erasure-code1.jpg&#34; alt=&#34;纠删码的磁盘布局&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;纠删码缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要读取其他的数据块和校验块&lt;/li&gt;&#xA;&lt;li&gt;编码解码需要消耗CPU资源&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;纠删码优点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;副本机制对于大文件机极其消耗磁盘空间，纠删码可以通过较少的磁盘冗余，较为高效的解决数据丢失的问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;应用场景&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于不被长期访问的冷数据，采用纠删码技术，可以大大减少副本数量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;server-pool&#34;&gt;Server Pool&lt;/h3&gt;&#xA;&lt;p&gt;使用minio server指令创建的MinIO节点集合，提供对象存储和处理请求的功能。&lt;/p&gt;&#xA;&lt;p&gt;MinIO可以通过增加Server Pool的方式，实现集群的横向扩展。&lt;/p&gt;&#xA;&lt;p&gt;当有新的Server Pool加入Cluster，存储的元数据会进行同步，但是其他Server Pool已存储对象不会同步。&lt;/p&gt;&#xA;&lt;p&gt;举例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;minio server https://minio{1&amp;hellip;4}.example.net/mnt/disk{1&amp;hellip;4}代表一个Server Pool，其中有四个server节点各有4块磁盘。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;minio server https://minio{1&amp;hellip;4}.example.net/mnt/disk{1&amp;hellip;4} https://minio{5&amp;hellip;8}.example.net/mnt/disk{1&amp;hellip;4}代表有两个Server Pool。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;MinIO选择Server Pool策略；选择剩余空间最大的Server Pool进行存储。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221113153730493.png&#34; alt=&#34;MinIO选择策略&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;存储级别&#34;&gt;存储级别&lt;/h3&gt;&#xA;&lt;p&gt;MinIO目前支持两种存储级别：Reduced Redundancy和Standard，提供两种不同的级别来修改数据块和校验块的比例。MinIO使用&lt;strong&gt;EC:N&lt;/strong&gt;来表示EC Set中存储校验块的磁盘数量，N越大，容错能力越强，但占用磁盘空间越多。&lt;/p&gt;&#xA;&lt;p&gt;可以通过在S3 Put API中添加x-amz-storage-class参数来指定当前文件的存储级别。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Standard：默认使用的存储级别，EC:N参数与Set中磁盘数量有关。可通过环境变量MINIO_STORAGE_CLASS_STANDARD=EC:N来设置，N不能大于磁盘数量的一半。&lt;/li&gt;&#xA;&lt;li&gt;Reduced Redundancy：使用比Standard级别更少的磁盘数量存储校验块。通过环境变量MINIO_STORAGE_CLASS_RRS=EC:N来设置。默认参数为EC:2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221113154043570.png&#34; alt=&#34;存储级别设置&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Netty学习笔记(一)-概览</title>
      <link>http://localhost:59500/posts/netty/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%A6%82%E8%A7%88/</link>
      <pubDate>Sat, 06 Aug 2022 08:12:54 +0000</pubDate>
      <guid>http://localhost:59500/posts/netty/netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%A6%82%E8%A7%88/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;Netty是一个应用于网络编程领域的NIO网络框架，通过屏蔽底层Socket编程细节，封装了提供上层业务使用的API，简化了网络应用的开发过程。Netty需要关注以下几点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IO模型、线程模型&lt;/li&gt;&#xA;&lt;li&gt;事件处理机制&lt;/li&gt;&#xA;&lt;li&gt;API接口的使用&lt;/li&gt;&#xA;&lt;li&gt;数据协议、序列化的支持&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Netty的IO模型是基于非阻塞IO实现的，底层通过&lt;code&gt;JDK NIO&lt;/code&gt;中的&lt;code&gt;Selector&lt;/code&gt;实现，&lt;code&gt;Selector&lt;/code&gt;可以同时轮询多个&lt;code&gt;Channel&lt;/code&gt;，采用&lt;code&gt;epoll&lt;/code&gt;模式后只需要一个线程负责&lt;code&gt;Selector&lt;/code&gt;的轮询。&lt;/p&gt;&#xA;&lt;p&gt;IO多路复用的场景中，需要一个&lt;code&gt;Event Dispather&lt;/code&gt;负责将读写事件分发给对应的&lt;code&gt;Event Handler&lt;/code&gt;，事件分发器主要有两种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Reactor：采用同步IO，实现简单，适用于处理耗时短的场景，耗时长的IO操作容易出现阻塞。&lt;/li&gt;&#xA;&lt;li&gt;Proactor：采用异步IO，实现逻辑复杂，性能更高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Netty的优点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;易用：将NIO的API进一步封装，提供了开箱即用的工具&lt;/li&gt;&#xA;&lt;li&gt;稳定：修复了NIO的bug&lt;/li&gt;&#xA;&lt;li&gt;可扩展：可以通过启动参数选择Reactor线程模型&lt;/li&gt;&#xA;&lt;li&gt;低消耗：Netty性能优化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对象池复用&lt;/li&gt;&#xA;&lt;li&gt;零拷贝&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;nio基础&#34;&gt;NIO基础&lt;/h2&gt;&#xA;&lt;p&gt;NIO是一种同步非阻塞的IO模型，NIO与普通IO的最大区别就是非阻塞，通过每个线程通过Selector去监听多个Channel，并且读写数据是以块为单位，与BIO相比，大大提升了IO效率。&lt;/p&gt;&#xA;&lt;p&gt;BIO存在的问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;accept、read、write都是同步阻塞，处理IO时，线程阻塞。&lt;/li&gt;&#xA;&lt;li&gt;BIO模型严重依赖线程，线程资源比较宝贵。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Linux中用&lt;code&gt;task_struct&lt;/code&gt;管理，创建或销毁线程使用系统调用，开销大，并且进程切换也存在开销&lt;/li&gt;&#xA;&lt;li&gt;每个线程在JVM中占用1MB内存，连接数量大的时候，极易产生OOM&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Standard IO是对字节流进行读写，读写单位是字节，NIO将IO抽象成块，读写单位是块。&lt;/p&gt;&#xA;&lt;p&gt;基本概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Channel：对原IO包中流的模拟，可以通过它来读取和写入数据，数据流向是双向的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FileChannel：从文件中读取数据&lt;/li&gt;&#xA;&lt;li&gt;DatagramChannel：通过UDP读写网络数据&lt;/li&gt;&#xA;&lt;li&gt;SocketChannel：通过TCP读写网络数据&lt;/li&gt;&#xA;&lt;li&gt;ServerSocketChannel：监听新的TCP连接，对每个新连接都创建一个SocketChannel&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Buffer：Channel中的数据都需要通过Buffer进行传递，本质上是数组&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ByteBuffer、CharBuffer等&lt;/li&gt;&#xA;&lt;li&gt;Buffer的内部变量：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;capacity：最大容量&lt;/li&gt;&#xA;&lt;li&gt;position：当前读写处的下标位置&lt;/li&gt;&#xA;&lt;li&gt;limit：还可读写的下标位置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Selector：NIO采用的Reactor模型，一个线程使用一个Selector通过轮询的方式去监听多个Channel上面的事件，将Channel配置为非阻塞，那么Selector检测到当前Channel没有IO事件，就会轮询其他Channel。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;内存映射文件：是一种读写文件的方式，比常规基于流或者Channel的IO快。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//将文件的前1024字节映射到内存中，map()方法返回一个MappedByteBuffer&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MappedByteBuffer mbb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fc.&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;(FileChannel.&lt;span style=&#34;color:#a6e22e&#34;&gt;MapMode&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;READ_WRITE&lt;/span&gt;, 0, 1024);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SimpleServer&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         * ServerBootstrap：服务端启动器，负责组装、协调netty组件&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         * NioEventLoopGroup：thread + selector&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         * NioServerSocketChannel：对原生NIO的ServerSocketChannel封装&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         * ChannelInitializer：对channel进行初始化&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ServerBootstrap()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;group&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NioEventLoopGroup())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;channel&lt;/span&gt;(NioServerSocketChannel.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;childHandler&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ChannelInitializer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;NioSocketChannel&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;//连接建立后执行initChannel&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initChannel&lt;/span&gt;(NioSocketChannel ch) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;//StringDecoder：将Bytebuffer转为string&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        ch.&lt;span style=&#34;color:#a6e22e&#34;&gt;pipeline&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; StringDecoder());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;//自定义handler&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        ch.&lt;span style=&#34;color:#a6e22e&#34;&gt;pipeline&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ChannelInboundHandlerAdapter() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;channelRead&lt;/span&gt;(ChannelHandlerContext ctx, Object msg) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(msg);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                })&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;bind&lt;/span&gt;(8080);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SimpleClient&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; IOException, InterruptedException {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Bootstrap()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;group&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NioEventLoopGroup())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;channel&lt;/span&gt;(NioSocketChannel.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;handler&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ChannelInitializer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;NioSocketChannel&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initChannel&lt;/span&gt;(NioSocketChannel ch) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        ch.&lt;span style=&#34;color:#a6e22e&#34;&gt;pipeline&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; StringEncoder());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                })&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;connect&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; InetSocketAddress(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;, 8080))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;//阻塞直到连接建立&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;//代表连接对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;channel&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;//发送数据&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                .&lt;span style=&#34;color:#a6e22e&#34;&gt;writeAndFlush&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello world&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;netty组件&#34;&gt;Netty组件&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Core：提供了底层网络通信的抽象和实现，支持零拷贝的ByteBuffer、可扩展的事件模型、通信API。&lt;/li&gt;&#xA;&lt;li&gt;协议支持层：对主流协议的编解码实现，包括：HTTP、SSL、Protobuf等，还支持自定义应用层协议。&lt;/li&gt;&#xA;&lt;li&gt;传输服务层：提供了网络传输能力的抽象和实现，支持Socket、HTTP tunnel、VM pipe等方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/components.png&#34; alt=&#34;netty-components&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kafka学习笔记(四)-集群工作机制</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 06 Jul 2022 18:49:22 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B-%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;controller机制&#34;&gt;Controller机制&lt;/h2&gt;&#xA;&lt;p&gt;Controller主要作用是在Zookeeper的帮助下管理和协调整个Kafka集群（在zk中存储集群元数据）。Kafka集群中会有一个或多个Broker，其中一个Broker会被选举为Controller，它负责管理整个集群中所有分区和副本的状态，其工作职责包括以下内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Topic管理&lt;/strong&gt;：完成对Kafka的Topic的创建删除、分区增加等操作。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分区重分配&lt;/strong&gt;：新的Broker加入集群时，不会自动分担已有的topic负载，只会对后续的topic生效，此时如果需要对已有topic负载，需要用户手动进行&lt;strong&gt;分区重分配&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Leader选举&lt;/strong&gt;：负责Partition Leader选举的工作&lt;/li&gt;&#xA;&lt;li&gt;集群成员管理：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Kafka 使用Zookeeper的临时节点来选举Controller&lt;/li&gt;&#xA;&lt;li&gt;Zookeeper在Broker加入集群或退出集群时通知Controller&lt;/li&gt;&#xA;&lt;li&gt;Controller负责在Broker加入或离开集群时进行分区Leader选举&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;元数据管理：Controller负责管理集群中所有的元数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Controller选举流程：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个Broker启动时，都会尝试读取&lt;code&gt;/controller&lt;/code&gt;节点的brokerid的值，如果值不为-1，则表明已经有其他broker节点成为Controller，当前broker放弃选举&lt;/li&gt;&#xA;&lt;li&gt;如果不存在&lt;code&gt;/controller&lt;/code&gt;节点或节点数据异常，则主动创建节点并存储brokerid&lt;/li&gt;&#xA;&lt;li&gt;其他broker会将选举成功的Brokerid都在内存保存下来&lt;/li&gt;&#xA;&lt;li&gt;同时使用&lt;code&gt;/controller_epoch&lt;/code&gt;持久性节点来记录任期号，记录Controller发生变化的次数，类似于Raft中的任期。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始值为1，每个与Controller交互的请求都会携带&lt;code&gt;controller_epoch&lt;/code&gt;，如果请求的&lt;code&gt;controller_epoch&lt;/code&gt;大于内存中&lt;code&gt;controller_epoch&lt;/code&gt;，说明内存中的值过期了，目前已有新的Controller当选。&lt;/li&gt;&#xA;&lt;li&gt;由两部分组成：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;epoch：单调递增的版本号，leader发生变更，进行自增&lt;/li&gt;&#xA;&lt;li&gt;start offset：Leader副本在该Epoch值上写入的首条消息的位移。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;每个分区都缓存该值，并定期持久化到&lt;code&gt;checkpoint&lt;/code&gt;文件中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;partition-leader选举&#34;&gt;Partition Leader选举&lt;/h3&gt;&#xA;&lt;p&gt;Controller拥有选举分区Leader的功能，每个分区都会有一个Broker作为Leader，处理所有的读写请求，选举流程由Controller负责：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Controller从ZK中读取当前分区所有的ISR集合&lt;/li&gt;&#xA;&lt;li&gt;调用配置的分区选择算法选举分区的Leader&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;Partition Leader&lt;/code&gt;的定义如下：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Each partition has one server which acts as the &amp;ldquo;leader&amp;rdquo; and zero or more servers which act as &amp;ldquo;followers&amp;rdquo;. The leader handles all read and write requests for the partition while the followers passively replicate the leader. If the leader fails, one of the followers will automatically become the new leader. Each server acts as a leader for some of its partitions and a follower for others so load is well balanced within the cluster.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kafka学习笔记(三)-通信协议</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 03 Jul 2022 10:49:22 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;h2 id=&#34;协议设计&#34;&gt;协议设计&lt;/h2&gt;&#xA;&lt;p&gt;需要进行网络传输的中间件都会拥有自己的一套通信协议，这往往会成为该组件的性能瓶颈，需要考虑的优化点较多。Kafka自定义了基于TCP的二进制通信协议，Kafka2.0中，一共有43种协议类型，每个都有对应的请求和响应，与HTTP协议类似，它同样有&lt;code&gt;RequestHeader&lt;/code&gt;和&lt;code&gt;RequestBody&lt;/code&gt;。其中&lt;code&gt;RequestHeader&lt;/code&gt;结构如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;api_key：API标识，例如PRODUCE、FETCH等，用于分别请求的作用。&lt;/li&gt;&#xA;&lt;li&gt;api_version：API版本号&lt;/li&gt;&#xA;&lt;li&gt;correlation_id：客户端指定的唯一标识，服务端返回响应需要将该字段返回以此对应。&lt;/li&gt;&#xA;&lt;li&gt;client_id：客户端id&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Kafka除了提供基本数据类型，还提供了以下的特有类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;nullable_string：可为空的字符串类型，若为空用-1表示&lt;/li&gt;&#xA;&lt;li&gt;bytes：表示字节序列，开头是数据长度N（int32表示），后面是N个字节&lt;/li&gt;&#xA;&lt;li&gt;nullable_bytes：与上述string相同&lt;/li&gt;&#xA;&lt;li&gt;records：表示Kafka中的消息序列&lt;/li&gt;&#xA;&lt;li&gt;array：表示一个给定类型T的数组&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;RequestBody&lt;/code&gt;结构如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;transactional_id：事务id，不使用事务，此项为null&lt;/li&gt;&#xA;&lt;li&gt;acks：对应客户端的acks参数&lt;/li&gt;&#xA;&lt;li&gt;timeout：超时时间&lt;/li&gt;&#xA;&lt;li&gt;topic_data：要发送的数据集合，array类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;topic：主题&lt;/li&gt;&#xA;&lt;li&gt;data：数据，array类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;partition：分区编号&lt;/li&gt;&#xA;&lt;li&gt;record_set：数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;Response&lt;/code&gt;结构如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ResponseHeader&#xA;&lt;ul&gt;&#xA;&lt;li&gt;correlation_id：与请求相对应&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ResponseBody&#xA;&lt;ul&gt;&#xA;&lt;li&gt;responses：array类型，返回的响应结果&#xA;&lt;ul&gt;&#xA;&lt;li&gt;topic：主题&lt;/li&gt;&#xA;&lt;li&gt;partition_responses：返回结果，array类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;partition：分区编号&lt;/li&gt;&#xA;&lt;li&gt;error_code：错误码，用来标识错误类型&lt;/li&gt;&#xA;&lt;li&gt;base_offset：消息集的起始偏移量&lt;/li&gt;&#xA;&lt;li&gt;log_append_time：消息写入broker的时间&lt;/li&gt;&#xA;&lt;li&gt;log_start_offset：所在分区起始偏移量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Kafka学习笔记(二)-存储架构</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 29 Jun 2022 20:06:22 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;kafka存储架构&#34;&gt;Kafka存储架构&lt;/h1&gt;&#xA;&lt;p&gt;Kafka是为了解决大数据量的实时日志流而产生的，日志流主要特点包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据实时存储&lt;/li&gt;&#xA;&lt;li&gt;海量数据存储与处理&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Kafka需要保证以下几点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存储的主要是消息流&lt;/li&gt;&#xA;&lt;li&gt;要保证海量数据的高效存储&lt;/li&gt;&#xA;&lt;li&gt;要支持海量数据的高效检索&lt;/li&gt;&#xA;&lt;li&gt;要保证数据的安全性和稳定性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Kafka使用的存储方案是：磁盘顺序写 + 稀疏哈希索引。&lt;/p&gt;&#xA;&lt;h2 id=&#34;日志目录布局&#34;&gt;日志目录布局&lt;/h2&gt;&#xA;&lt;p&gt;Kafka中消息以Topic为单位归类，各个Topic下面分为多个分区，分区中每条消息都会被分配一个唯一的序列号（offset）。日志命名方式为：&lt;code&gt;&amp;lt;topic&amp;gt;-&amp;lt;partition&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;在不考虑多副本的情况下，一个分区对应一个Log，为了防止Log过大，Kafka引入&lt;code&gt;LogSegment&lt;/code&gt;，将Log切分为多个&lt;code&gt;LogSegment&lt;/code&gt;。其结构如下所示：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Log&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LogSegment：每个 LogSegment 都有一个基准偏移量 baseOffset，用来表示当前 LogSegment中第一条消息的offset。只有最后一个LogSegment才能写入。下述文件根据&lt;code&gt;baseOffset&lt;/code&gt;命名，长度固定为20位数字，没有达到的位数用0填充。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.log：日志文件&lt;/li&gt;&#xA;&lt;li&gt;.index：偏移量索引文件&lt;/li&gt;&#xA;&lt;li&gt;.timeindex：时间戳索引文件&lt;/li&gt;&#xA;&lt;li&gt;.snapshot：快照索引文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;消息格式&#34;&gt;消息格式&lt;/h2&gt;&#xA;&lt;p&gt;消息格式关系到存储性能，比如冗余字段会增加分区的存储空间、网络传输的开销较大。&lt;/p&gt;&#xA;&lt;p&gt;Kafka3.0中将&lt;code&gt;BatchRecords&lt;/code&gt;作为磁盘中的存储单元，一个&lt;code&gt;BatchRecords&lt;/code&gt;中包含多个&lt;code&gt;Record&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;BatchRecords&lt;/code&gt;的格式如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;baseOffset: int64&#xA;batchLength: int32&#xA;partitionLeaderEpoch: int32&#xA;magic: int8 (current magic value is 2)&#xA;crc: int32&#xA;attributes: int16&#xA;    bit 0~2:&#xA;        0: no compression&#xA;        1: gzip&#xA;        2: snappy&#xA;        3: lz4&#xA;        4: zstd&#xA;    bit 3: timestampType&#xA;    bit 4: isTransactional (0 means not transactional)&#xA;    bit 5: isControlBatch (0 means not a control batch)&#xA;    bit 6: hasDeleteHorizonMs (0 means baseTimestamp is not set as the delete horizon for compaction)&#xA;    bit 7~15: unused&#xA;lastOffsetDelta: int32&#xA;baseTimestamp: int64&#xA;maxTimestamp: int64&#xA;producerId: int64&#xA;producerEpoch: int16&#xA;baseSequence: int32&#xA;records: [Record]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字段解释如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用Prometheus &#43; Grafana 构建监控可视化系统</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/prometheus/%E4%BD%BF%E7%94%A8prometheus-&#43;-grafana-%E6%9E%84%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 11 Jun 2022 13:02:34 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/prometheus/%E4%BD%BF%E7%94%A8prometheus-&#43;-grafana-%E6%9E%84%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h1 id=&#34;监控系统简介&#34;&gt;监控系统简介&lt;/h1&gt;&#xA;&lt;p&gt;业务监控系统通常包含以下一些组件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;采集&lt;/strong&gt;：信息源来自log、metrics等。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以通过定期外围探测、AOP手动织入、字节码自动织入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;上报&lt;/strong&gt;：通过http或者tcp&lt;/li&gt;&#xA;&lt;li&gt;聚合&lt;/li&gt;&#xA;&lt;li&gt;存储&lt;/li&gt;&#xA;&lt;li&gt;可视化、告警&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;业务监控系统解决了什么问题？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;趋势分析：收集长期监控数据，对监控指标进行趋势分析，例如：分析磁盘空间增长率，预测何时进行磁盘扩容。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对照分析：分析不同版本在运行时资源使用情况差异。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;告警：当服务出现故障时，监控可以迅速反应并告警。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;故障分析与定位：故障发生时，可以通过分析历史数据去定位问题。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据可视化：通过采集的数据，生成可视化仪表盘。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于运维：监控CPU、内存、硬盘等使用情况。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于研发：监控某个异常指标的变化情况，来保证业务的稳定性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于产品或运营：关注产品层面：某个活动参加人数的增长情况等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;监控系统分为以下五层：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;端监控：对网站、APP、小程序等进行端监控，采集页面打开速度、稳定性、外部服务调用成功率等参数。&lt;/li&gt;&#xA;&lt;li&gt;业务层监控：对业务模块进行监控，采集QPS、DAU、业务接口访问数量等。&lt;/li&gt;&#xA;&lt;li&gt;应用层监控：对分布式应用进行管理和监控&lt;/li&gt;&#xA;&lt;li&gt;中间件监控：对中间件进行监控，主要判断组件是否存活。&lt;/li&gt;&#xA;&lt;li&gt;系统层监控：对操作系统监控，主要包括：CPU、磁盘I/O、网络连接等参数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;prometheus简介&#34;&gt;Prometheus简介&lt;/h1&gt;&#xA;&lt;p&gt;当前监控系统主要有集中式日志解决方案（ELK）和时序数据库解决方案。监控三要素如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Metrics：可聚合，带有时间戳的数据。&lt;/li&gt;&#xA;&lt;li&gt;Logging：离散日志，分为有结构和无结构。&lt;/li&gt;&#xA;&lt;li&gt;Tracing：请求域内的调用链。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;prometheus架构&#34;&gt;Prometheus架构&lt;/h2&gt;&#xA;&lt;p&gt;Prometheus的架构图如下所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/prometheus/Prometheus-framework.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其中各组件功能如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Prometheus Server：核心部分，负责实现对监控数据的获取，存储以及查询。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Retrieval：定时去配置文件中指定target抓取指标数据。（Pull）&lt;/li&gt;&#xA;&lt;li&gt;TSDB：Prometheus内置了时序数据库，存储抓取的指标数据。&lt;/li&gt;&#xA;&lt;li&gt;HTTP Server：提供了HTTP接口进行操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Jobs/exporters：exporter将监控数据通过HTTP服务的形式暴露给Prometheus Server，其定时进行Pull。&lt;/li&gt;&#xA;&lt;li&gt;Pushgateway：临时性的Job可以将监控数据push到这，Prometheus从Pushgateway拉取数据。&lt;/li&gt;&#xA;&lt;li&gt;AlertManager：告警处理中心。Prometheus支持基于PromQL创建告警规则。&lt;/li&gt;&#xA;&lt;li&gt;Data Visualization：数据可视化，其中Prometheus自带的web UI可以通过PromQL进行查询，通过Grafana可以展示丰富的图表数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;从上述组件可以看出：Prometheus提供了&lt;strong&gt;收集数据-&amp;gt;存储数据-&amp;gt;处理数据-&amp;gt;展示数据&lt;/strong&gt;这一系列功能，完全适用上述的应用场景。&lt;/p&gt;&#xA;&lt;h2 id=&#34;获取监控数据的两种方式&#34;&gt;获取监控数据的两种方式&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Pull：从监控的target通过轮询获取监控信息。主要是HTTP API。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;告警可以按照策略分片，可以做到数据的冷热分离。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;主要流程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Prometheus根据配置定期去targets拉取数据。&lt;/li&gt;&#xA;&lt;li&gt;当拉取数据大于配置的内存缓冲区时，Prometheus会将数据持久化到磁盘或云端。&lt;/li&gt;&#xA;&lt;li&gt;Prometheus通过PromQL、API等方式获取数据，同时可以配置rules，当触发条件时，将alert推送到配置的alertmanager。&lt;/li&gt;&#xA;&lt;li&gt;alertmanager收到告警时，会执行相应的策略。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Push：程序主动将数据推送到监控系统中，Prometheus采用gateway实现该方式。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实时性好&lt;/li&gt;&#xA;&lt;li&gt;由于推送时机的不可预知性，监控系统无法掌握主动性，可能会导致对监控进程产生影响。&lt;/li&gt;&#xA;&lt;li&gt;增加gateway组件，增加了系统的复杂度。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;优缺点&#34;&gt;优缺点&lt;/h2&gt;&#xA;&lt;p&gt;优点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Golang编写，支持云原生，二进制文件直接启动，也支持容器化部署。&lt;/li&gt;&#xA;&lt;li&gt;支持多种语言的客户端。&lt;/li&gt;&#xA;&lt;li&gt;支持本地存储和云端存储，单机性能强。&lt;/li&gt;&#xA;&lt;li&gt;可扩展，使用联邦集群启动多个Prometheus实例来分布式处理。&lt;/li&gt;&#xA;&lt;li&gt;支持静态文件配置和动态发现等机制。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缺点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不适用Logging、Tracing等监控。&lt;/li&gt;&#xA;&lt;li&gt;Prometheus数据默认保留15天，适用于追踪近期数据。&lt;/li&gt;&#xA;&lt;li&gt;本地存储有限，需要考虑第三方存储。&lt;/li&gt;&#xA;&lt;li&gt;联邦集群没有提供统一的全局视图。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;grafana简介&#34;&gt;Grafana简介&lt;/h1&gt;&#xA;&lt;p&gt;Grafana是一个可以通过各种图形方式对数据进行可视化的一个开源软件，官网简介如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kafka学习笔记(一)-基础入门</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 06 May 2022 15:08:22 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;Kafka是由LinkedIn使用Scala语言开发的分布式消息引擎系统，目前已被捐献给Apache基金会，它以高吞吐量、可持久化、流数据处理等特性而被广泛使用。它主要有以下三种主要功能：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;消息中间件：具备常见的消息队列功能：系统解耦、冗余存储、流量削峰填谷、缓冲、异步通信，同时具备消息顺序性保障、回溯消费等功能。&lt;/li&gt;&#xA;&lt;li&gt;数据存储系统：使用Kafka存储各种服务的log，然后统一输出，ELK可使用Kafka进行数据中转。&lt;/li&gt;&#xA;&lt;li&gt;流数据处理平台：与flink、spark、storm等组件整合，提供实时计算。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Kafka支持两种常见消息传输模型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;点对点模型&lt;/strong&gt;：也称为消息队列模型，系统A发送的消息只能被系统B接收，其它系统读取不到。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;发布/订阅模型&lt;/strong&gt;：使用&lt;code&gt;Topic&lt;/code&gt;接收消息，&lt;code&gt;Publisher&lt;/code&gt;和&lt;code&gt;Subscriber&lt;/code&gt;都可以有多个，可以同时向Topic发送接收消息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Kafka体系结构：一个Kafka集群包括若干Producer、Customer、Broker，以及一个Zookeeper集群。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Broker：服务端由被称为&lt;code&gt;Broker&lt;/code&gt;的服务进程构成，&lt;code&gt;Broker&lt;/code&gt;负责接受和处理客户端请求，以及对消息进行持久化。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以简单看作为一个独立的Kafka服务节点（进程示例）&lt;/li&gt;&#xA;&lt;li&gt;Broker层面的领导者被称为Controller&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Producer：客户端节点，发送消息的一方。&lt;/li&gt;&#xA;&lt;li&gt;Customer：客户端节点，接收消息的一方。&lt;/li&gt;&#xA;&lt;li&gt;Customer Group：消费者组内每个消费者负责消费不同分区的数据。一个分区只能由组内一个消费者消费，不同消费组之间互不影响。&lt;/li&gt;&#xA;&lt;li&gt;&lt;!-- raw HTML omitted --&gt;Zookeeper集群：负责元数据管理，集群选举。&lt;!-- raw HTML omitted --&gt;目前最新版3.1.0提供了KRaft模式，集群不再依赖ZK。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ZK主要负责存储Kafka集群的元数据，协调集群工作。&lt;/li&gt;&#xA;&lt;li&gt;记录信息如下：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;/brokers/ids/{0-n}：记录broker服务器节点，不同的broker使用不同的brokerid，会将自己的ip地址和端口信息记录到节点&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;/brokers/topics/{topic}：记录topic分区以及broker的对应信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;/comsumers/{group_id}/ids/{consumer_id}：消费者负载均衡&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Topic：&lt;strong&gt;逻辑概念&lt;/strong&gt;，Kafka中消息以topic为单位进行分类，生产者将消息发送到特定的topic，消费者订阅topic进行消费。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分区partition&#34;&gt;分区（partition）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Partition：topic可以分为多个partition，分区在物理存储层面可以看作一个可Append的Log文件，消息被Append到Log中会分配一个&lt;code&gt;offset&lt;/code&gt;，这个属性是消息的唯一标识 ，&lt;strong&gt;Kafka通过它来保证消息在分区内的顺序性&lt;/strong&gt;，因此Kafka&lt;strong&gt;保证分区有序&lt;/strong&gt;而不是主题有序。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主题中的partition可以分布在不同的Broker中。&lt;/li&gt;&#xA;&lt;li&gt;消息到达broker后，根据分区规则存储到指定的partition。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;多副本机制replica&#34;&gt;多副本机制（Replica）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多副本机制（Replica）：是对于&lt;strong&gt;分区&lt;/strong&gt;而言的，&lt;strong&gt;同一分区的不同副本中保存的是相同的消息。&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Leader：分区中的主副本，负责处理读写请求，Producer/Consumer交互的对象。&lt;/li&gt;&#xA;&lt;li&gt;Follower：分区中的从副本，只会实时从Leader副本同步数据。&lt;/li&gt;&#xA;&lt;li&gt;所有副本被称为AR（Assigned Replicas），所有与Leader副本数据一致性差距过多的副本组成OSR（Out-of-Sync Replicas），于leader保持一定程度同步的副本称为ISR（In-Sync Replicas）。&lt;/li&gt;&#xA;&lt;li&gt;Leader故障后，从ISR中选举新的Leader。&lt;/li&gt;&#xA;&lt;li&gt;高水位（HW-High Watermark）：消费者能消费的最大offset位置，相当于&lt;strong&gt;所有副本中都存在的消息&lt;/strong&gt;（木桶效应）&lt;/li&gt;&#xA;&lt;li&gt;LEO（Log End Offset）：标识当前日志文件中下一条待写入消息的offset，每个副本都会维护自身的LEO，&lt;strong&gt;ISR中最小的LEO即为分区的HW&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;多副本的作用：提高Kafka的可用性。&lt;/p&gt;&#xA;&lt;p&gt;涉及参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;unclean.leader.election.enable：为true则ISR为空也能选举，为false则只能从ISR选举。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;metadata&#34;&gt;metadata&lt;/h3&gt;&#xA;&lt;p&gt;Q：客户端如何知道请求哪个broker？&lt;/p&gt;&#xA;&lt;p&gt;client通过metadata从任意broker获取集群信息，其中包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;topic信息&lt;/li&gt;&#xA;&lt;li&gt;每个topic的分区、副本情况&lt;/li&gt;&#xA;&lt;li&gt;leader分区所在的broker连接信息&lt;/li&gt;&#xA;&lt;li&gt;每个broker的连接信息&lt;/li&gt;&#xA;&lt;li&gt;其他信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230718224608.png&#34; alt=&#34;Kafka应用架构(https://developer.confluent.io/courses/architecture/get-started/)&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;&#xA;&lt;p&gt;使用WSL 2环境进行单机部署。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;zero@Pluto:~$ uname -a&#xA;Linux Pluto 4.19.128-microsoft-standard #1 SMP Tue Jun 23 12:58:10 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Kafka需要Java环境，由于Kafka最新版本3.1.0不再支持Java8，故使用Java11。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Zookeeper入门教程</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/zookeeper%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 11 Apr 2022 15:26:27 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/zookeeper%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;Zookeeper为分布式系统提供了高效可靠的分布式协调服务，其本质是一个键值存储系统，提供了诸如命名服务、配置管理、分布式锁等服务。其采用ZAB协议对集群数据的一致性进行管理。&lt;/p&gt;&#xA;&lt;p&gt;它负责存储和管理一些数据，然后接受观察者的注册，一旦数据状态发生变化，Zookeeper负责通知观察者做出相应的反应。&lt;/p&gt;&#xA;&lt;p&gt;几个特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个Leader，多个Follow组成的集群。&lt;/li&gt;&#xA;&lt;li&gt;半数以上节点存活，集群即可正常服务，适合部署奇数台节点。&lt;/li&gt;&#xA;&lt;li&gt;全局数据一致，每个节点都保存相同的数据副本。&lt;/li&gt;&#xA;&lt;li&gt;所有客户端看到的数据都是一致的，并且请求按照顺序执行（FIFO）&lt;/li&gt;&#xA;&lt;li&gt;数据更新原子性。&lt;/li&gt;&#xA;&lt;li&gt;更新删除操作都是基于事务的，是用于&lt;strong&gt;读多写少&lt;/strong&gt;环境。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据模型&#34;&gt;数据模型&lt;/h3&gt;&#xA;&lt;p&gt;Zookeeper的数据模型由一个树形结构构成，每个节点称为一个ZNode，由于设计目标是实现协调服务，而不是数据存储，故默认存储大小为1MB，每个ZNode可以通过其路径唯一标识。&lt;/p&gt;&#xA;&lt;h2 id=&#34;运行&#34;&gt;运行&lt;/h2&gt;&#xA;&lt;p&gt;从官网下载Zookeeper的二进制发布版，解压后得到以下文件：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;zero@Pluto:~/Zookeeper/apache-zookeeper-3.5.7-bin$ ls&#xA;LICENSE.txt  NOTICE.txt  README.md  README_packaging.txt  bin  conf  docs  lib&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;code&gt;bin/zkServer.sh version&lt;/code&gt;，看到版本信息说明正常运行。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;zero@Pluto:~/Zookeeper/apache-zookeeper-3.5.7-bin$ bin/zkServer.sh version&#xA;/usr/bin/java&#xA;ZooKeeper JMX enabled by default&#xA;Using config: /home/zero/Zookeeper/apache-zookeeper-3.5.7-bin/bin/../conf/zoo.cfg&#xA;Usage: bin/zkServer.sh [--config &amp;lt;conf-dir&amp;gt;] {start|start-foreground|stop|restart|status|print-cmd}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;单机部署&#34;&gt;单机部署&lt;/h3&gt;&#xA;&lt;p&gt;创建一个zoo.cfg文件，内容如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tickTime=2000&#xA;&#xA;initLimit=10&#xA;&#xA;syncLimit=5&#xA;&#xA;dataDir=/opt/Zookeeper-3.5.7/zkData&#xA;&#xA;clientPort=2181&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;code&gt;bin/zkServer.sh start&lt;/code&gt;启动服务器节点。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;zero@Pluto:/opt/Zookeeper-3.5.7$ bin/zkServer.sh start&#xA;/usr/bin/java&#xA;ZooKeeper JMX enabled by default&#xA;Using config: /opt/Zookeeper-3.5.7/bin/../conf/zoo.cfg&#xA;Starting zookeeper ... STARTED&#xA;&#xA;zero@Pluto:/opt/Zookeeper-3.5.7$ jps -l&#xA;3892 sun.tools.jps.Jps&#xA;3850 org.apache.zookeeper.server.quorum.QuorumPeerMain&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;code&gt;bin/zkCli.sh&lt;/code&gt;启动客户端。&lt;/p&gt;</description>
    </item>
    <item>
      <title>缓存更新策略总结</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 25 Jul 2020 18:12:10 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h2 id=&#34;cache-aside&#34;&gt;Cache Aside&lt;/h2&gt;&#xA;&lt;p&gt;具体逻辑如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写策略：更DB数据，再删除cache数据&lt;/li&gt;&#xA;&lt;li&gt;读策略：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cache hit：直接返回命中数据。&lt;/li&gt;&#xA;&lt;li&gt;cache miss：从数据库中读取，然后将数据写入cache，并返回。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;适用场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;适合读多写少的场景，不适合写多的场景。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;readwrite-through&#34;&gt;Read/Write Through&lt;/h2&gt;&#xA;&lt;p&gt;具体逻辑如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Read Through：写入时先查询cache是否hit，hit直接返回，miss则有cache组件负责去DB查，并写入cache，再返回。&lt;/li&gt;&#xA;&lt;li&gt;Write Through：更新先查询cache是否hit，hit则更新缓存中数据，然后有cache组件更新到DB，完成后通知更新完成。若miss则直接更新数据库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;write-back&#34;&gt;Write Back&lt;/h2&gt;&#xA;&lt;p&gt;具体逻辑如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只更新缓存，立即返回，持久层更新采用异步更新方式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;广泛用于OS，比如CPU Cache、文件系统Cache，数据非强一致性，存在丢数据的问题。&lt;/p&gt;&#xA;&lt;p&gt;适用场景：写多场景&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis内存优化</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 20 Jul 2020 18:12:10 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;查看内存使用情况&#34;&gt;查看内存使用情况&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;info memory&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;used_memory:701520                      redis分配器分配的内存量，也就是实际存储数据的内润使用总量&#xD;&#xA;used_memory_human:685.08K               以可读格式返回redis使用的内存总量&#xD;&#xA;used_memory_rss:664584                  从操作系统角度，redis进程占用的总物理内存&#xD;&#xA;used_memory_rss_human:649.01K          &#xD;&#xA;used_memory_peak:778480                  内存分配器分配的最大内存，代表`used_memory`的历史峰值&#xD;&#xA;used_memory_peak_human:760.23K          以可读的格式显示内存的消耗峰值&#xD;&#xA;total_system_memory:0&#xD;&#xA;total_system_memory_human:0B&#xD;&#xA;used_memory_lua:37888                   Lua引擎消耗的内存&#xD;&#xA;used_memory_lua_human:37.00K&#xD;&#xA;maxmemory:0&#xD;&#xA;maxmemory_human:0B&#xD;&#xA;maxmemory_policy:noeviction&#xD;&#xA;mem_fragmentation_ratio:0.95            内存碎片率，used_memory_rss/used_memory&#xD;&#xA;mem_allocator:jemalloc-3.6.0            redis使用的内存分配器&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;内存划分&#34;&gt;内存划分&lt;/h2&gt;&#xA;&lt;p&gt;Redis中使用的内存可分为如下几类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;自身内存：自身维护的数据字典等元数据，占用较少&lt;/li&gt;&#xA;&lt;li&gt;对象内存：存储的所有entry对象&lt;/li&gt;&#xA;&lt;li&gt;缓存：客户端缓冲区+AOF缓冲区等&lt;/li&gt;&#xA;&lt;li&gt;Lua内存：用于加载Lua脚本&lt;/li&gt;&#xA;&lt;li&gt;子进程内存：一般是持久化时fork出来的子进程占用的内存&lt;/li&gt;&#xA;&lt;li&gt;运行内存：运行时消耗的内存&lt;/li&gt;&#xA;&lt;li&gt;内存碎片：Redis使用jemalloc来分配内存，按照固定大小划分，当删除数据后，释放的内存不会立即返回给OS，Redis无法有效利用，因此形成碎片。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;内存优化方案&#34;&gt;内存优化方案&lt;/h2&gt;&#xA;&lt;h3 id=&#34;对象内存&#34;&gt;对象内存&lt;/h3&gt;&#xA;&lt;p&gt;Redis中对象大多有两种存储方案，尽量将大小控制在较为节省的存储阈值之内。&lt;/p&gt;&#xA;&lt;h3 id=&#34;客户端缓冲区&#34;&gt;客户端缓冲区&lt;/h3&gt;&#xA;&lt;p&gt;客户端缓冲区占用内存较大的原因如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;client访问大key，导致client输出缓存异常增长。&lt;/li&gt;&#xA;&lt;li&gt;client使用monitor命令，它会将所有访问redis的命令持续放到输出缓冲区，导致输出缓冲区异常增长。&lt;/li&gt;&#xA;&lt;li&gt;clinet使用pipeline封装了大量命令&lt;/li&gt;&#xA;&lt;li&gt;从节点复制慢，导致主节点输出缓冲区积压。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;优化方案:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大key需要进行拆分&lt;/li&gt;&#xA;&lt;li&gt;尽量避免使用monitor等指令&lt;/li&gt;&#xA;&lt;li&gt;使用pipeline设置最大阈值&lt;/li&gt;&#xA;&lt;li&gt;主从复制区设置阈值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;内存碎片&#34;&gt;内存碎片&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;手动执行memory purge命令&lt;/li&gt;&#xA;&lt;li&gt;通过配置参数进行控制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;activedefrag yes：启用自动碎片清理开关&#xD;&#xA;active-defrag-ignore-bytes 100mb：内存碎片空间达到多少才开启碎片整理&#xD;&#xA;active-defrag-threshold-lower 10：碎片率达到百分之多少才开启碎片整理&#xD;&#xA;active-defrag-threshold-upper 100：内存碎片率超过多少，则尽最大努力整理（占用最大资源去做碎片整理）&#xD;&#xA;active-defrag-cycle-min 25：内存自动整理占用资源最小百分比&#xD;&#xA;active-defrag-cycle-max 75：内存自动整理占用资源最大百分比&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;子进程优化&#34;&gt;子进程优化&lt;/h3&gt;&#xA;&lt;p&gt;Linux中的fork使用了copy on write机制，fork之后与父进程共享内存空间，只有发生写操作修改内存数据时，才会真正分配内存空间。&lt;/p&gt;&#xA;&lt;h2 id=&#34;其他注意事项&#34;&gt;其他注意事项&lt;/h2&gt;&#xA;&lt;h3 id=&#34;键值生命周期&#34;&gt;键值生命周期&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;周期数据需要设置过期时间，&lt;code&gt;object idle time&lt;/code&gt;可以找垃圾key-value&lt;/li&gt;&#xA;&lt;li&gt;过期时间不宜集中，会导致缓存穿透和雪崩等问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;命令使用技巧&#34;&gt;命令使用技巧&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;O(n)以上命令关注n的数量&#xA;&lt;ul&gt;&#xA;&lt;li&gt;hgetall,lrange,smembers,zrange,sinter等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;禁用命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;禁止线上使用keys,flushall,flushdb，通过redis的rename机制禁用掉命令，或者使用scan的方式渐进式处理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;合理使用select&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redis的多数据库较弱，使用数字进行区分&lt;/li&gt;&#xA;&lt;li&gt;很多客户端支持较差&lt;/li&gt;&#xA;&lt;li&gt;同时多业务用多数据库实际上还是单线程处理，会有干扰&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;redis的事务功能较弱，不建议过多使用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不支持回滚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;redis集群版本在使用Lua上有特殊要求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有的key，必须爱一个slot上，否则返回error&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;必要情况下使用monitor命令时，注意不要长时间使用&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Redis集群机制分析</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 13 Jul 2020 18:12:10 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;主从复制模式&#34;&gt;主从复制模式&lt;/h2&gt;&#xA;&lt;p&gt;Redis集群实现数据同步，保证服务高可用。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一主多从&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据流向是单向的，master-&amp;gt;slave&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;开启指令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;slaveof 192.168.1.10 6379&#x9;&#x9;//当前服务节点称为指定IP的从节点&#xD;&#xA;slaveof no one                  //取消从属关系&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置文件：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;slaveof ip port&#xD;&#xA;slave-read-only yes             //从节点只读&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;全量复制的开销：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bgsave的时间&lt;/li&gt;&#xA;&lt;li&gt;RDB文件网络传输时间&lt;/li&gt;&#xA;&lt;li&gt;从节点清空数据时间&lt;/li&gt;&#xA;&lt;li&gt;从节点加载RDB的时间&lt;/li&gt;&#xA;&lt;li&gt;可能的AOF重写时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;&#xA;&lt;p&gt;Redis复制分为同步和命令传播两个操作：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步：将从服务器的数据库状态更新为主库状态&lt;/li&gt;&#xA;&lt;li&gt;命令传播：同步完后，主库状态又发生变化，此时使用命令传播完成状态同步。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Redis使用&lt;code&gt;PSYNC&lt;/code&gt;可以同时解决全量复制和部分复制两种情况。&lt;/p&gt;&#xA;&lt;p&gt;需要维护的变量包括 ：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;runID：每个Redis实例启动生成的随机ID&lt;/li&gt;&#xA;&lt;li&gt;offset：复制进度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;执行&lt;code&gt;slaveof&lt;/code&gt;时，slave节点会将master的地址保存在：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; redisServer {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;masterhost;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; masterport;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;slave节点会将该命令封装成通信协议并发给master，完成socket建立，并发送PING检查socket是否正常。&lt;/p&gt;&#xA;&lt;h3 id=&#34;心跳检测&#34;&gt;心跳检测&lt;/h3&gt;&#xA;&lt;p&gt;命令传播的阶段，slave默认每秒一次的频率，向master发送心跳：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;REPLCONF ACK &amp;lt;replication_offset&amp;gt;&#xD;&#xA;&#xD;&#xA;replication_offset为slave当前的复制偏移量&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;心跳主要有三个作用：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检测主从之间连接状态：节点保活机制&lt;/li&gt;&#xA;&lt;li&gt;辅助实现min-slaves：防止master在不安全的情况下执行写命令。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;min-slaves-to-write&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;min-slaves-max-log&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;检测命令丢失：如果因为网络原因产生命令丢失，master发现slave的offset小于自己当前offset，则认为产生命令丢失，并按照slave的offset传递数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;sentinel机制&#34;&gt;sentinel机制&lt;/h2&gt;&#xA;&lt;p&gt;主从复制存在的问题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;手动故障转移：master发生宕机，需要手动切换&lt;/li&gt;&#xA;&lt;li&gt;写能力和存储能力受限&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Sentinel（机制）是Redis官方推荐的高可用性(HA)解决方案，由一个或多个sentinel组成的sentinel system，可以监视主从集群的状态，当master发生宕机，自动将master下面的某个slave升级为新的master。&lt;/p&gt;&#xA;&lt;h3 id=&#34;启动&#34;&gt;启动&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./redis-sentinel /path/to/sentinel.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动流程会执行以下步骤：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化server：sentinel本质上是一个运行在特殊模式的Redis服务器。&lt;/li&gt;&#xA;&lt;li&gt;代码：sentinel使用&lt;code&gt;sentinel.c/REDIS_SENTINEL_PORT&lt;/code&gt;作为默认端口，使用&lt;code&gt;sentinel.c/sentinelcmds&lt;/code&gt;作为命令表&lt;/li&gt;&#xA;&lt;li&gt;初始化sentinel状态：&lt;code&gt;sentinel.c/sentinelState&lt;/code&gt;结构&lt;/li&gt;&#xA;&lt;li&gt;根据配置文件，初始化sentinel监视的主服务器列表：上面的结构使用&lt;code&gt;dict&lt;/code&gt;保存master信息，key为master的名称，value为master对应的&lt;code&gt;sentinel.c/sentinelRedisInstance&lt;/code&gt;，每个被监视的Redis服务器实例都被使用该结构存储。master的IP端口信息使用&lt;code&gt;struct sentinelAddr&lt;/code&gt;进行存储。该数据sentinel初始化时从&lt;code&gt;sentinel.conf&lt;/code&gt;完成加载。&lt;/li&gt;&#xA;&lt;li&gt;创建连向master的socket连接：sentinel节点对master创建两个异步连接：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;命令连接：专门向master发送命令，并接收回复&lt;/li&gt;&#xA;&lt;li&gt;订阅连接：订阅master的&lt;code&gt;__sentinel__:hello&lt;/code&gt;频道，用于sentinel发现其他sentinel节点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;获取信息&#34;&gt;获取信息&lt;/h3&gt;&#xA;&lt;p&gt;每10s每个sentinel会对master发送&lt;code&gt;info&lt;/code&gt;命令，sentinel主要获取两方面信息：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis持久化机制分析</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 12 Jul 2020 17:54:10 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;Redis数据保存在内存中，为了防止进程异常退出而导致数据丢失，可以考虑将数据保存到磁盘上。&lt;/p&gt;&#xA;&lt;p&gt;Redis提供的两种持久化方案：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDB：直接将数据库状态写到文件，既可以手动执行，也可以配置为定期执行。&lt;/li&gt;&#xA;&lt;li&gt;AOF：将写命令append到AOF文件中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;rdb&#34;&gt;RDB&lt;/h2&gt;&#xA;&lt;p&gt;两种方案：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;save：直接执行&lt;/li&gt;&#xA;&lt;li&gt;bgsave：fork一个子进程执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;rdbSave&lt;/code&gt;是save的具体实现函数，bgsave与其区别是通过fork子进程完成备份，并在完成后给父进程发送信号。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rdbSave&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;filename) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictIterator &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;di &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictEntry &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;de;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; tmpfile[&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; magic[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mstime&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FILE &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fp;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rio rdb;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; cksum;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建临时文件&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;snprintf&lt;/span&gt;(tmpfile,&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;temp-%d.rdb&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;getpid&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fopen&lt;/span&gt;(tmpfile,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;fp) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;redisLog&lt;/span&gt;(REDIS_WARNING, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed opening .rdb for saving: %s&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;strerror&lt;/span&gt;(errno));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; REDIS_ERR;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化 I/O&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;rioInitWithFile&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rdb,fp);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 设置校验和函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (server.rdb_checksum)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rdb.update_cksum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rioGenericUpdateChecksum;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 写入 RDB 版本号&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;snprintf&lt;/span&gt;(magic,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(magic),&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;REDIS%04d&amp;#34;&lt;/span&gt;,REDIS_RDB_VERSION);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rdbWriteRaw&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rdb,magic,&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历所有数据库&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; server.dbnum; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 指向数据库&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        redisDb &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;db &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; server.db&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;j;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 指向数据库键空间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        dict &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; db&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;dict;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 跳过空数据库&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;dictSize&lt;/span&gt;(d) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 创建键空间迭代器&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        di &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dictGetSafeIterator&lt;/span&gt;(d);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;di) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;fclose&lt;/span&gt;(fp);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; REDIS_ERR;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* Write the SELECT DB opcode &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         * 写入 DB 选择器&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rdbSaveType&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rdb,REDIS_RDB_OPCODE_SELECTDB) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rdbSaveLen&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rdb,j) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;/* Iterate this DB writing every entry &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         * 遍历数据库，并写入每个键值对的数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;         */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;((de &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dictNext&lt;/span&gt;(di)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sds keystr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dictGetKey&lt;/span&gt;(de);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            robj key, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;o &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dictGetVal&lt;/span&gt;(de);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; expire;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 根据 keystr ，在栈中创建一个 key 对象&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;initStaticStringObject&lt;/span&gt;(key,keystr);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 获取键的过期时间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            expire &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getExpire&lt;/span&gt;(db,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;key);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 保存键值对数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rdbSaveKeyValuePair&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rdb,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;key,o,expire,now) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;dictReleaseIterator&lt;/span&gt;(di);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    di &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL; &lt;span style=&#34;color:#75715e&#34;&gt;/* So that we don&amp;#39;t release it again on error. */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* EOF opcode &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 写入 EOF 代码&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rdbSaveType&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rdb,REDIS_RDB_OPCODE_EOF) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* CRC64 checksum. It will be zero if checksum computation is disabled, the&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * loading code skips the check in this case. &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * CRC64 校验和。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 如果校验和功能已关闭，那么 rdb.cksum 将为 0 ，&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 在这种情况下， RDB 载入时会跳过校验和检查。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cksum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rdb.cksum;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;memrev64ifbe&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cksum);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;rioWrite&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rdb,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cksum,&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Make sure data will not remain on the OS&amp;#39;s output buffers */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 冲洗缓存，确保数据已写入磁盘&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;fflush&lt;/span&gt;(fp) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; EOF) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;fsync&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;fileno&lt;/span&gt;(fp)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;fclose&lt;/span&gt;(fp) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; EOF) &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; werr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Use RENAME to make sure the DB file is changed atomically only&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * if the generate DB file is ok. &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * 使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;rename&lt;/span&gt;(tmpfile,filename) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;redisLog&lt;/span&gt;(REDIS_WARNING,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error moving temp DB file on the final destination: %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;strerror&lt;/span&gt;(errno));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;unlink&lt;/span&gt;(tmpfile);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; REDIS_ERR;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 写入完成，打印日志&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;redisLog&lt;/span&gt;(REDIS_NOTICE,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DB saved on disk&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 清零数据库脏状态&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    server.dirty &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 记录最后一次完成 SAVE 的时间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    server.lastsave &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;(NULL);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 记录最后一次执行 SAVE 的状态&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    server.lastbgsave_status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; REDIS_OK;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; REDIS_OK;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;werr:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭文件&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fclose&lt;/span&gt;(fp);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 删除文件&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;unlink&lt;/span&gt;(tmpfile);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;redisLog&lt;/span&gt;(REDIS_WARNING,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Write error saving DB on disk: %s&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;strerror&lt;/span&gt;(errno));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (di) &lt;span style=&#34;color:#a6e22e&#34;&gt;dictReleaseIterator&lt;/span&gt;(di);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; REDIS_ERR;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;rdb载入还原&#34;&gt;RDB载入还原&lt;/h3&gt;&#xA;&lt;p&gt;Redis对RDB文件的载入还原步骤如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis对象机制分析</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 11 Jul 2020 08:12:54 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;Redis中提供的数据结构都使用了下面的redisObject进行包装，通过包装可以提供不同场景下使用不同的数据结构的实现。Redis的对象机制还使用了&lt;strong&gt;引用计数&lt;/strong&gt;方式的内存回收机制。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; redisObject {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 类型&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; type:&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 编码&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; encoding:&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 对象最后一次被访问的时间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; lru:REDIS_LRU_BITS; &lt;span style=&#34;color:#75715e&#34;&gt;/* lru time (relative to server.lruclock) */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 引用计数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; refcount;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 指向实际值的指针&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} robj;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;type值可选：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_STRING 0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_LIST 1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_SET 2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ZSET 3&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_HASH 4&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;encoding可选：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_RAW 0     &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Raw representation */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_INT 1     &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Encoded as integer */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_HT 2      &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Encoded as hash table */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_ZIPMAP 3  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Encoded as zipmap */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_LINKEDLIST 4 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Encoded as regular linked list */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_ZIPLIST 5 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Encoded as ziplist */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_INTSET 6  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Encoded as intset */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_SKIPLIST 7  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Encoded as skiplist */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define REDIS_ENCODING_EMBSTR 8  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Embedded sds string encoding */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;结构的编码方案&#34;&gt;结构的编码方案&lt;/h2&gt;&#xA;&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;&#xA;&lt;p&gt;编码策略如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis过期删除策略与内存淘汰机制</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 10 Jul 2020 13:12:24 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;过期删除策略&#34;&gt;过期删除策略&lt;/h2&gt;&#xA;&lt;p&gt;过期删除策略主要有以下三种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定时删除：设置过期时间的同时，创建一个定时器，当到达过期时间后，执行删除操作。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;优点：对内存友好，不会长时间占用内存&lt;/li&gt;&#xA;&lt;li&gt;缺点：对CPU不友好，当过期entry过多会占用大量CPU时间，并且创建定时器存在性能消耗。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;惰性删除：每次查询到该entry时，检查是否过期，若过期就删除，否则返回。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;优点：对CPU友好&lt;/li&gt;&#xA;&lt;li&gt;缺点：无用数据占用大量内存空间，依赖于客户端请求对过期数据进行删除。有内存泄漏的风险。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;定期删除：每隔一段时间对数据库进行检查，删除其中的过期entry。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;综合考虑上述策略的优缺点，可以合理设置执行时长和频率。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Redis中主要配合使用&lt;strong&gt;惰性删除&lt;/strong&gt;和&lt;strong&gt;定期删除&lt;/strong&gt;两种策略，在内存和CPU性能中取得平衡。&#xA;使用过期字典存储所有key的过期时间。key是一个指针，指向key对象，value是一个long long类型的整数，保存key的过期时间。&lt;/p&gt;&#xA;&lt;p&gt;实现：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;惰性删除：&lt;code&gt;db.c/expireIfNeeded&lt;/code&gt;在读写之前对key进行检查.&lt;/li&gt;&#xA;&lt;li&gt;定期删除：&lt;code&gt;redis.c/activeExpireCycle&lt;/code&gt;实现，每当Redis的&lt;code&gt;serverCron&lt;/code&gt;执行时，都会主动清除过期数据。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;activeExpireCycle&lt;/code&gt;的工作流程如下：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次取出一定数量的随机key进行检查，并删除其中的过期数据&lt;/li&gt;&#xA;&lt;li&gt;全局变量&lt;code&gt;current_db&lt;/code&gt;存储当前的检查进度（db编号），并且下次&lt;code&gt;activeExpireCycle&lt;/code&gt;执行会接着上次进度进行处理。全部检查完毕后该变量置为0。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;内存淘汰策略&#34;&gt;内存淘汰策略&lt;/h2&gt;&#xA;&lt;p&gt;当Redis的运行内存已经超过设置的最大内存时，会使用内存淘汰策略删除符合相关条件的key。&#xA;最大内存通过设置&lt;code&gt;maxmemory &amp;lt;bytes&amp;gt;&lt;/code&gt;即可。默认为0，表示没有内存大小的限制。&lt;/p&gt;&#xA;&lt;p&gt;Redis的内存淘汰策略如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不淘汰&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;noeviction：不淘汰任何数据、直接返回错误。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对设置了过期时间的数据进行淘汰&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;volatile-random： 随意淘汰设置了过期时间的任意entry。&lt;/li&gt;&#xA;&lt;li&gt;volatile-ttl：优先淘汰更早过期的entry。&lt;/li&gt;&#xA;&lt;li&gt;volatile-lru：淘汰所有设置了过期时间的entry中最近最久未使用的entry。&lt;/li&gt;&#xA;&lt;li&gt;volatile-lfu：淘汰所有设置了过期时间的entry中最少使用的entry。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对全部数据进行淘汰&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;allkeys-random：随即淘汰任意entry。&lt;/li&gt;&#xA;&lt;li&gt;allkeys-lru：使用LRU策略淘汰任意entry。&lt;/li&gt;&#xA;&lt;li&gt;allkeys-lfu：使用LFU策略淘汰任意entry。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;修改redis.conf中的&lt;code&gt;maxmemory-policy &amp;lt;策略&amp;gt;&lt;/code&gt;即可。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis基础知识总结</title>
      <link>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 09 Jul 2020 17:06:33 +0000</pubDate>
      <guid>http://localhost:59500/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h2 id=&#34;redis简介&#34;&gt;Redis简介&lt;/h2&gt;&#xA;&lt;h3 id=&#34;redis特性&#34;&gt;Redis特性&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;速度快（内存，10w QPS, C , 单线程）&lt;/li&gt;&#xA;&lt;li&gt;持久化（将内存数据异步更新到磁盘,RDB&amp;amp;AOF）&lt;/li&gt;&#xA;&lt;li&gt;多种数据结构（string list set zset hash BitMaps HyperLogLog GEO）&lt;/li&gt;&#xA;&lt;li&gt;支持多语言&lt;/li&gt;&#xA;&lt;li&gt;功能丰富（发布订阅 事务 Lua脚本 pipeline）&lt;/li&gt;&#xA;&lt;li&gt;简单（23000 lines of code 不依赖外部库 单线程模型）&lt;/li&gt;&#xA;&lt;li&gt;主从复制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;单线程为什么这么快？&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;纯内存&lt;/li&gt;&#xA;&lt;li&gt;非阻塞IO，使用多路复用机制，提升连接并发度。&lt;/li&gt;&#xA;&lt;li&gt;避免多线程切换和竞态消耗&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;redis典型应用场景&#34;&gt;Redis典型应用场景&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缓存系统（缓存）&lt;/li&gt;&#xA;&lt;li&gt;计数器（微博转发和评论）&lt;/li&gt;&#xA;&lt;li&gt;消息队列系统&lt;/li&gt;&#xA;&lt;li&gt;排行榜&lt;/li&gt;&#xA;&lt;li&gt;社交网络&lt;/li&gt;&#xA;&lt;li&gt;实时系统（垃圾邮件&amp;ndash;布隆过滤器）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;redis可执行文件说明&#34;&gt;Redis可执行文件说明&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;redis-server      ---&amp;gt;    Redis服务器&#xD;&#xA;redis-cli         ---&amp;gt;    Redis客户端&#xD;&#xA;redis-benchmark   ---&amp;gt;    Redis性能测试&#xD;&#xA;redis-check-aof   ---&amp;gt;    AOF文件修复&#xD;&#xA;redis-check-dump  ---&amp;gt;    RDB文件检查&#xD;&#xA;redis-sentinel    ---&amp;gt;    Sentinel服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;redis-通用api&#34;&gt;Redis 通用API&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;keys                ---&amp;gt;    遍历所有key，热备从节点         O(n)&#xD;&#xA;dbsize              ---&amp;gt;    计算key的总数                   O(1)&#xD;&#xA;exist key           ---&amp;gt;    检查key是否存在，返回0或1       O(1)&#xD;&#xA;del key             ---&amp;gt;    删除指定的key                   O(1)&#xD;&#xA;expire key seconds  ---&amp;gt;    key在seconds秒后过期            O(1)         &#xD;&#xA;ttl key             ---&amp;gt;    查看key的剩余过期时间           O(1) &#xD;&#xA;persist key         ---&amp;gt;    去掉key的过期时间               O(1) &#xD;&#xA;type key            ---&amp;gt;    查看当前key的类型               O(1)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;常见数据结构&#34;&gt;常见数据结构&lt;/h2&gt;&#xA;&lt;p&gt;String应用场景：字符串缓存、计数器、分布式锁&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
