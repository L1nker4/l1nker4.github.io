<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式系统 on l1nker4&#39;s Blog | 格木观云</title>
    <link>http://localhost:1313/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 分布式系统 on l1nker4&#39;s Blog | 格木观云</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Apr 2022 21:57:47 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Zookeeper论文阅读笔记</title>
      <link>http://localhost:1313/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/zookeeper%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 22 Apr 2022 21:57:47 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/zookeeper%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;&#xA;&lt;p&gt;Zookeeper是一个带有事件驱动的分布式系统缓存，提供了强大的分布式协调能力，结合了组播消息、分布式锁等内容。&lt;/p&gt;&#xA;&lt;p&gt;Zookeeper提供了高性能服务，保证了对客户端请求FIFO顺序执行和线性化写，在给出了在2:1到100:1的读/写比率下，ZooKeeper 每秒可以处理数万到数十万个事务。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1简介&#34;&gt;1.简介&lt;/h2&gt;&#xA;&lt;p&gt;分布式系统需要不同形式的协调程序，&lt;strong&gt;配置&lt;/strong&gt;是协调的最基本形式。&lt;/p&gt;&#xA;&lt;p&gt;Zookeeper的API设计，移除了锁等阻塞原语来提高性能，使用&lt;strong&gt;wait-free的数据结构&lt;/strong&gt;来实现对应的功能。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注：wait-free：他保证任何线程都能在有限的过程内执行完成。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Zookeeper可以用集群模式中的副本来实现高可用性和高性能，是西安了基于领导者的原子广播协议（ZAB：&lt;strong&gt;Zookeeper Atomic Broadcast&lt;/strong&gt;），Zookeeper应用的主要负载是读操作，所以需要保证读吞吐量的可扩展。&lt;/p&gt;&#xA;&lt;p&gt;Zookeeper使用&lt;strong&gt;watch机制&lt;/strong&gt;使得客户端不需要直接管理客户端缓存，对于一个给定的数据对象，客户端可以监视到更新动作，当有更新的时候收到通知消息。而Chubby 直接操作客户端缓存，会阻塞更新直到所有的客户端缓存都被改变。如果任何客户端速度较慢或者故障，更新都会延迟。&lt;/p&gt;&#xA;&lt;p&gt;本文主要讨论ZooKeeper的设计和实现，包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;协调内核：提出了一种可用于分布式系统的无等待、具有宽松的一致性保证的协调服务。&lt;/li&gt;&#xA;&lt;li&gt;协调示例&lt;/li&gt;&#xA;&lt;li&gt;协调相关的思路&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2zookeeper服务&#34;&gt;2.Zookeeper服务&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-概述&#34;&gt;2.1 概述&lt;/h3&gt;&#xA;&lt;p&gt;Zookeeper将客户端抽象为&lt;code&gt;znodes&lt;/code&gt;，并将其构造为树形结构，客户端可以创建两种znode：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;普通：client通过创建和删除显式操作普通节点。&lt;/li&gt;&#xA;&lt;li&gt;临时：创建后可以显式删除或者系统在会话结束后自动删除。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;watch机制使得客户端无须轮询就可以接收到状态变换的通知信息。与一个会话关联的 watches 只会触发一次；一旦触发或者会话结束，就会被注销。&lt;/p&gt;&#xA;&lt;p&gt;设计znode不是用来保存通用数据，而是用来映射客户端应用的抽象，主要是对于协调用途的元数据。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/zookeeper/paper/namespace.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;22-客户端api&#34;&gt;2.2 客户端API&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;create(path, data, flags)&lt;/strong&gt;：使用 path 名称创建一个 znode 节点，保存 data，返回新创建的 znode 名称。 flags 用于创建普通或者临时节点，也可以设置顺序标识。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;delete(path, version)&lt;/strong&gt;： 删除指定 path 和 version 的 znode 节点。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;exists(path, watch)&lt;/strong&gt;： 如果指定 path 的 znode 存在则返回真，如果不存在则返回假。watch 标识用于在 znode 上设置监视器。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;getData(path, watch)&lt;/strong&gt;： 返回数据和元数据，如版本信息。watch 标识与 &lt;code&gt;exists()&lt;/code&gt; 的 watch 标识一样，但如果 znode 不存在则不会设置监视器。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;setData(path, data, version)&lt;/strong&gt;： 根据 path 和 version 将数据写入到 znode。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;getChildren(path, watch)&lt;/strong&gt;： 返回 znode 所有子节点的名称集合。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;sync(path)&lt;/strong&gt;： 在操作开始时，等待所有挂起的更新操作发送到客户端连接的服务器。path 当前未使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所有API都提供同步异步两个版本，无论同步异步，都会保证执行顺序按照FIFO进行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DDIA阅读笔记(一)-数据系统的基石</title>
      <link>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ddia%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3/</link>
      <pubDate>Sun, 03 Apr 2022 18:59:06 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/ddia%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3/</guid>
      <description>&lt;h2 id=&#34;第一章可靠性可伸缩性可维护性&#34;&gt;第一章：可靠性、可伸缩性、可维护性&lt;/h2&gt;&#xA;&lt;p&gt;应用的两个分类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;data-intensive&lt;/strong&gt;：问题通常来自数据量、数据复杂性、以及数据的变更速度。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;compute-intensive&lt;/strong&gt;：瓶颈在于CPU。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;可靠性&#34;&gt;可靠性&lt;/h3&gt;&#xA;&lt;p&gt;可以把可靠性粗略理解为 “即使出现问题，也能继续正确工作”。&lt;/p&gt;&#xA;&lt;p&gt;造成错误的原因叫做 &lt;strong&gt;故障（fault）&lt;/strong&gt;，能预料并应对故障的系统特性可称为 &lt;strong&gt;容错（fault-tolerant）&lt;/strong&gt; 或 &lt;strong&gt;韧性（resilient）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;fault种类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;硬件故障（hardware faults）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;增加单个硬件的冗余度：磁盘可以组建RAID、服务器使用双路电源和热拔插CPU等。&lt;/li&gt;&#xA;&lt;li&gt;云平台的设计就是优先考虑 **灵活性（flexibility）**和 &lt;strong&gt;弹性（elasticity）&lt;/strong&gt;，而不是单机可靠性。&lt;/li&gt;&#xA;&lt;li&gt;引入软件容错机制。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;系统性错误（systematic error）&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件错误&lt;/li&gt;&#xA;&lt;li&gt;修复问题代码、进程隔离、监控分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;人为错误&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以最小化犯错机会的方式设计系统：精心设计的API&lt;/li&gt;&#xA;&lt;li&gt;与最容易犯错的模块解耦&lt;/li&gt;&#xA;&lt;li&gt;彻底的测试：单元测试、系统测试&lt;/li&gt;&#xA;&lt;li&gt;允许从人为错误中简单快速地恢复：快速回滚配置变更、分批发布新代码。&lt;/li&gt;&#xA;&lt;li&gt;配置详细地监控，比如性能指标和错误率。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;可伸缩性&#34;&gt;可伸缩性&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;可伸缩性（Scalability）&lt;/strong&gt; 是用来描述系统应对负载增长能力的术语。&lt;/p&gt;&#xA;&lt;p&gt;描述性能的指标：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;吞吐量（throughput）&lt;/strong&gt;：每秒可以处理的记录数量。或者在特定规模数据集上运行作业的总时间。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;响应时间（response time）&lt;/strong&gt;：客户端发送请求到接收响应之间的时间。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;响应时间的高百分位点（尾部延迟）指标非常重要&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;处理方法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;垂直伸缩：转向更强大的机器。&lt;/li&gt;&#xA;&lt;li&gt;水平伸缩：负载分布到多台小机器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;弹性（elastic）&lt;/strong&gt;：在检测到负载增加时自动增加计算资源&lt;/p&gt;&#xA;&lt;h3 id=&#34;可维护性&#34;&gt;可维护性&lt;/h3&gt;&#xA;&lt;p&gt;三个设计原则来避免自己的软件系统变为遗留系统：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可操作性&lt;/li&gt;&#xA;&lt;li&gt;简单性&lt;/li&gt;&#xA;&lt;li&gt;可演化性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;可操作性&#34;&gt;可操作性&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;监控系统提供可见性&lt;/li&gt;&#xA;&lt;li&gt;将系统与标准化工具集成&lt;/li&gt;&#xA;&lt;li&gt;避免单机部署&lt;/li&gt;&#xA;&lt;li&gt;提供良好的文档&lt;/li&gt;&#xA;&lt;li&gt;提供良好的默认行为（配置参数？）&lt;/li&gt;&#xA;&lt;li&gt;自我修复&lt;/li&gt;&#xA;&lt;li&gt;行为可预测&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;简单性&#34;&gt;简单性&lt;/h4&gt;&#xA;&lt;p&gt;消除&lt;strong&gt;额外复杂度&lt;/strong&gt;的最好工具之一是&lt;strong&gt;抽象&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;抽象帮助我们控制系统复杂度。&lt;/p&gt;&#xA;&lt;h4 id=&#34;可演化性&#34;&gt;可演化性&lt;/h4&gt;&#xA;&lt;p&gt;系统的需求是变化的，使用敏捷工作模式来应对，例如TDD和重构。&lt;/p&gt;&#xA;&lt;h2 id=&#34;第二章数据模型与查询语言&#34;&gt;第二章：数据模型与查询语言&lt;/h2&gt;&#xA;&lt;p&gt;问题：需要将数据模型抽象成对应的概念。&lt;/p&gt;&#xA;&lt;p&gt;每个层都通过提供一个明确的数据模型来隐藏更低层次中的复杂性。&lt;/p&gt;&#xA;&lt;h3 id=&#34;关系模型和文档模型&#34;&gt;关系模型和文档模型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;关系模型&#34;&gt;关系模型&lt;/h4&gt;&#xA;&lt;p&gt;常见分类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TP（事务性）：银行交易&lt;/li&gt;&#xA;&lt;li&gt;AP（分析型）：数据报表&lt;/li&gt;&#xA;&lt;li&gt;HTAP（混合型）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;问题：关系模型很难直观表达&lt;strong&gt;一对多的关系&lt;/strong&gt;．&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raft论文阅读笔记</title>
      <link>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/raft-note/</link>
      <pubDate>Mon, 31 Jan 2022 14:19:03 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/raft-note/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&lt;p&gt;Paxos算法较为复杂，并且不易于应用到工业界，因此诞生了Raft算法，其首要目标是可理解性，Raft算法主要分解为几个部分：领导者选举、日志复制、安全性、成员变更等。Raft算法有一些独特的特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;强领导者：日志entry只从领导者发送给其他服务器&lt;/li&gt;&#xA;&lt;li&gt;领导者选举：Raft算法采用一个随即计时器来选举领导人&lt;/li&gt;&#xA;&lt;li&gt;成员关系调整：Raft算法采用一种共同一致的方法来处理集群成员变换的问题，此时集群依然可以工作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;属性解释&#34;&gt;属性解释&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;所有服务器上的持久性状态&#34;&gt;所有服务器上的持久性状态&lt;/h4&gt;&#xA;&lt;p&gt;(在响应 RPC 请求之前，已经更新到了稳定的存储设备)&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;currentTerm&lt;/td&gt;&#xA;          &lt;td&gt;服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;votedFor&lt;/td&gt;&#xA;          &lt;td&gt;当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;log[]&lt;/td&gt;&#xA;          &lt;td&gt;日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;所有服务器上的易失性状态&#34;&gt;所有服务器上的易失性状态&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;commitIndex&lt;/td&gt;&#xA;          &lt;td&gt;已知已提交的最高的日志条目的索引（初始值为0，单调递增）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;lastApplied&lt;/td&gt;&#xA;          &lt;td&gt;已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;领导人服务器上的易失性状态&#34;&gt;领导人（服务器）上的易失性状态&lt;/h4&gt;&#xA;&lt;p&gt;(选举后已经重新初始化)&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;nextIndex[]&lt;/td&gt;&#xA;          &lt;td&gt;对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;matchIndex[]&lt;/td&gt;&#xA;          &lt;td&gt;对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;追加条目appendentriesrpc&#34;&gt;&lt;strong&gt;追加条目（AppendEntries）RPC&lt;/strong&gt;：&lt;/h4&gt;&#xA;&lt;p&gt;由leader调用，用于日志条目的复制，同时也被当做心跳使用&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;term&lt;/td&gt;&#xA;          &lt;td&gt;领导人的任期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;leaderId&lt;/td&gt;&#xA;          &lt;td&gt;领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;prevLogIndex&lt;/td&gt;&#xA;          &lt;td&gt;紧邻新日志条目之前的那个日志条目的索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;prevLogTerm&lt;/td&gt;&#xA;          &lt;td&gt;紧邻新日志条目之前的那个日志条目的任期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;entries[]&lt;/td&gt;&#xA;          &lt;td&gt;需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;leaderCommit&lt;/td&gt;&#xA;          &lt;td&gt;领导人的已知已提交的最高的日志条目的索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;返回值&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;term&lt;/td&gt;&#xA;          &lt;td&gt;当前任期，对于领导人而言 它会更新自己的任期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;success&lt;/td&gt;&#xA;          &lt;td&gt;如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h5 id=&#34;receiver的实现&#34;&gt;receiver的实现&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果&lt;code&gt;term &amp;lt; currentTerm&lt;/code&gt;， return false&lt;/li&gt;&#xA;&lt;li&gt;在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则return false&lt;/li&gt;&#xA;&lt;li&gt;如果一个已经存在的条目和新条目发生了冲突，那么就删除这个已经存在的条目以及它之后的所有条目&lt;/li&gt;&#xA;&lt;li&gt;追加的条目暂未存在日志中&lt;/li&gt;&#xA;&lt;li&gt;如果&lt;code&gt;leaderCommit &amp;gt; commitIndex&lt;/code&gt;，设置commitIndex = min(leaderCommit, index of last new entry)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;请求投票requestvoterpc&#34;&gt;&lt;strong&gt;请求投票（RequestVote）RPC&lt;/strong&gt;：&lt;/h4&gt;&#xA;&lt;p&gt;由候选人负责调用用来征集选票（5.2 节）&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bitcask论文阅读笔记</title>
      <link>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/bitcask/</link>
      <pubDate>Thu, 13 Jan 2022 17:45:04 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/bitcask/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;Bitcask是Riak分布式数据库使用的日志型存储模型，主要有以下几点特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读写低延迟&lt;/li&gt;&#xA;&lt;li&gt;高吞吐量，尤其是随机写&lt;/li&gt;&#xA;&lt;li&gt;能处理大量的数据集而不降低性能&lt;/li&gt;&#xA;&lt;li&gt;故障时快速恢复且不丢失数据&lt;/li&gt;&#xA;&lt;li&gt;易于备份和恢复&lt;/li&gt;&#xA;&lt;li&gt;易于理解的代码结构和数据格式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;硬盘结构&#34;&gt;硬盘结构&lt;/h3&gt;&#xA;&lt;p&gt;在给定的一段时间内，只有一个&lt;code&gt;active data file&lt;/code&gt;能提供&lt;code&gt;append&lt;/code&gt;（写入）功能，当该文件大小达到指定阈值时，则会创建一个新的&lt;code&gt;active data file&lt;/code&gt;。每一个写入到file的entry结构如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/bitcask/entry.jpg&#34; alt=&#34;Entry结构&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;包括以下内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;crc：校验值&lt;/li&gt;&#xA;&lt;li&gt;tstamp：记录写入该数据的时间&lt;/li&gt;&#xA;&lt;li&gt;ksz：key_size&lt;/li&gt;&#xA;&lt;li&gt;value_sz：value_size&lt;/li&gt;&#xA;&lt;li&gt;key：key&lt;/li&gt;&#xA;&lt;li&gt;value：value&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;内存结构&#34;&gt;内存结构&lt;/h3&gt;&#xA;&lt;p&gt;在写入之后，一个被称为&lt;code&gt;keydir&lt;/code&gt;（hash table）的内存结构将被更新，每一个键映射到固定大小的结构中，包括了以下内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;file_id：去哪个文件查询&lt;/li&gt;&#xA;&lt;li&gt;value_size：读取value多长的字节&lt;/li&gt;&#xA;&lt;li&gt;value_position：value在文件中的位置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;每一次写操作发生，&lt;code&gt;keydir&lt;/code&gt;都会进行原子性的更新。&lt;/p&gt;&#xA;&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;&#xA;&lt;h3 id=&#34;read&#34;&gt;read&lt;/h3&gt;&#xA;&lt;p&gt;读取value的过程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查找keydir中的key，并读取&lt;code&gt;file_id&lt;/code&gt;，&lt;code&gt;position&lt;/code&gt;，&lt;code&gt;size&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;通过&lt;code&gt;file_id&lt;/code&gt;找到对应的&lt;code&gt;data file&lt;/code&gt;，再通过&lt;code&gt;position&lt;/code&gt;和&lt;code&gt;size&lt;/code&gt;字段找到entry中的value。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;merge&#34;&gt;merge&lt;/h3&gt;&#xA;&lt;p&gt;由于删除操作并不会真正删除掉entry，只是将删除操作封装成entry写入文件，因此需要&lt;code&gt;merge&lt;/code&gt;操作将所有的非&lt;code&gt;active&lt;/code&gt;文件中entry遍历，并重组为一个新文件。同时生成一个&lt;code&gt;hint file&lt;/code&gt;，用于存储&lt;code&gt;data file&lt;/code&gt;的位置和大小。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：hint file的作用是什么？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;A：每次进程重启时需要重建&lt;code&gt;keydir&lt;/code&gt;，需要扫描所有的数据文件，因此使用&lt;code&gt;hint file &lt;/code&gt;加速构建&lt;code&gt;keydir&lt;/code&gt;的速度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式系统理论笔记</title>
      <link>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 23 Jan 2021 14:12:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;&#xA;&lt;p&gt;分布式系统面临的问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据一致性&lt;/strong&gt;：数据均匀分布到多个存储节点，如何保证多个副本的数据一致性问题。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;集群可用性&lt;/strong&gt;：集群的服务是否可用。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分区容错性&lt;/strong&gt;：当发生故障，集群如何快速恢复从而提供正常服务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;理论&#34;&gt;理论&lt;/h1&gt;&#xA;&lt;h2 id=&#34;拜占庭将军问题&#34;&gt;拜占庭将军问题&lt;/h2&gt;&#xA;&lt;p&gt;存在恶意节点行为的场景中（数字货币的区块链技术中）：必须使用拜占庭容错算法（BFT）。常用的有PBFT算法、PoW算法。&lt;/p&gt;&#xA;&lt;p&gt;计算机分布式系统中，最常用的是非拜占庭容错算法，即故障容错算法（CFT）。&lt;strong&gt;CFT解决的是分布式系统中存在故障，但不存在恶意节点的场景下的共识问题&lt;/strong&gt;。这个场景可能会丢失信息、消息重复问题，但是不存在错误消息，或者伪造消息的情况。常见算法有Paxos算法、Raft算法、ZAB协议。&lt;/p&gt;&#xA;&lt;h2 id=&#34;cap理论&#34;&gt;CAP理论&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Q：如何设计分区容错一致性模型？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;cap三指标&#34;&gt;CAP三指标&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一致性（Consistency）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;强调的是数据在集群中的一致性。&lt;/li&gt;&#xA;&lt;li&gt;客户端每次的读操作，无论访问哪个节点，要么读到同一份数据，要么读取失败。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可用性（Availability）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;强调的是服务可用，但不保证数据的一致。&lt;/li&gt;&#xA;&lt;li&gt;无论客户端访问哪个节点，都能得到响应数据，但是不保证数据是最新的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分区容错性（Partition Tolerance）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;强调的是集群对分区故障的容错能力。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;节点出现任意数量的消息丢失或高延迟，系统仍然可以继续提供服务。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;cap不可能三角&#34;&gt;CAP不可能三角&lt;/h3&gt;&#xA;&lt;p&gt;对于一个分布式系统而言，一致性、可用性、分区容错性三个指标不可兼得，只能进行三选二。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/CAP/CAP-triangle.jpg&#34; alt=&#34;CAP不可能三角&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何使用cap理论&#34;&gt;如何使用CAP理论&lt;/h3&gt;&#xA;&lt;p&gt;节点之间的分区故障是必然发生的，因此分区容错性（P）是必须要保证的。那么只剩下两种选择：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CP：选择一致性（C）的时候，如果因为消息丢失、延迟过高发生了网络分区，部分节点无法保持一致，这时集群节点拒绝客户端的写操作。&lt;/li&gt;&#xA;&lt;li&gt;AP：选择可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点无法返回最新特定信息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;acid&#34;&gt;ACID&lt;/h2&gt;&#xA;&lt;p&gt;单机上实现ACID可以通过锁、时间序列等机制保障操作的顺序执行。分布式系统的ACID实现需要掌握分布式事务协议，比如二阶段提交协议、TCC（Try-Confirm-Cancel）。&lt;/p&gt;&#xA;&lt;p&gt;可以将ACID特性理解为CAP中一致性的边界（最强的一致性），但是大部分场景对一致性的要求不是特别高，&lt;strong&gt;如果不是必须，尽量不要实现事务，可以考虑采用强一致性或最终一致性。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;二阶段提交协议&#34;&gt;二阶段提交协议&lt;/h3&gt;&#xA;&lt;p&gt;用于保证多个节点操作的原子性，也就是：&lt;strong&gt;要么多个节点的操作全部执行成功，要么全部失败。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;节点分为：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;协调者&lt;/li&gt;&#xA;&lt;li&gt;参与者&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;执行过程如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提交请求阶段（投票阶段）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一个参与者投票表决事务是放弃还是提交，一旦参与者投票要求提交事务，那么不允许中途放弃事务，这个特性需要代码实现时保障的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;提交执行阶段（完成阶段）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务的每个参与者执行最终统一的决定，提交事务或者放弃事务，这个约定是为了实现ACID中的原子性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;存在的问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提交请求阶段，需要预留资源，在资源预留时期，其他人不能操作。&lt;/li&gt;&#xA;&lt;li&gt;数据库是独立的系统。无法动态调整锁的粒度，并发性能下降。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;tcctry-confirm-cancel&#34;&gt;TCC（Try-Confirm-Cancel）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Try（预留）：预留相关资源&lt;/li&gt;&#xA;&lt;li&gt;Confirm（确认）：确认操作，完成分布式事务。&lt;/li&gt;&#xA;&lt;li&gt;Cancel（撤销）：如果无法操作，则进行撤销操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;TCC本质上是补偿事务，核心思想是针对每个操作都要注册一个与之对应的确认操作和撤销操作。它是一个业务层面的协议。在业务中实现分布式事务。对业务代码的侵入性较高。实现的复杂度更高。&lt;/p&gt;&#xA;&lt;h2 id=&#34;base理论&#34;&gt;BASE理论&lt;/h2&gt;&#xA;&lt;p&gt;BASE理论是CAP理论中的AP的延伸，是互联网大规模分布式系统的实践总结，强调可用性。BASE理论的核心就是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本可用（Basically Available）&lt;/li&gt;&#xA;&lt;li&gt;最终一致性（Eventually Consistent）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;基本可用&#34;&gt;基本可用&lt;/h3&gt;&#xA;&lt;p&gt;当分布式系统出现不可预知的故障时，允许损失部分功能的可用性，保证核心功能的可用性。例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;延迟响应&lt;/strong&gt;：12306购票系统出现突发流量时，会将购票请求放入队列中进行排队等待处理，通过牺牲响应时间的可用性，保障核心功能的运行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;流量削峰&lt;/strong&gt;：在不同的时间，出售不同的票，将请求错开，削弱请求峰值。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;体验降级&lt;/strong&gt;：大流量情况，通过降低图片的清晰度和大小，提升系统的处理能力。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;过载保护&lt;/strong&gt;：请求排队时，如果请求等待时间超时，这时直接拒绝超时请求。或者队列满了之后，清除队列中一定数量的排队请求，保证系统不过载，实现系统的基本可用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;最终一致性&#34;&gt;最终一致性&lt;/h3&gt;&#xA;&lt;p&gt;​&#x9;&#x9;系统中所有的数据副本在经过一段时间的同步后，最终能达到一个一致的状态。这存在一个短暂的延迟。几乎所有的互联网系统采用的都是最终一致性，只有实在无法使用最终一致性，才使用强一致性或分布式事务。对于金融系统，需要考虑分布式事务。&lt;/p&gt;&#xA;&lt;p&gt;​&#x9;&#x9;如何实现最终一致性？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以最新写入的数据为准，比如AP模型的KV存储采用的是这种方式。&lt;/li&gt;&#xA;&lt;li&gt;以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;​&#x9;&#x9;如何实现最终一致性？&lt;/p&gt;</description>
    </item>
    <item>
      <title>MapReduce论文阅读笔记</title>
      <link>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/mapreduce-note/</link>
      <pubDate>Wed, 23 Dec 2020 19:29:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/mapreduce-note/</guid>
      <description>&lt;h2 id=&#34;存在的问题&#34;&gt;存在的问题&lt;/h2&gt;&#xA;&lt;p&gt;Google所面临的问题：大数据处理任务庞大，如何通过分布式系统完成并行计算、分发数据、处理错误？&lt;/p&gt;&#xA;&lt;p&gt;为了解决这个问题，需要设计一个新的抽象模型，用来表述我们需要执行的计算。不用关心底层的实现细节，包括并行计算、容错、数据分布、负载均衡等方面。&lt;/p&gt;&#xA;&lt;h2 id=&#34;编程模型&#34;&gt;编程模型&lt;/h2&gt;&#xA;&lt;p&gt;MapReduce编程模型的原理：利用一个输入的&lt;strong&gt;key/value pair&lt;/strong&gt;集合来产生一个输出的&lt;strong&gt;key/value pair&lt;/strong&gt;集合。&lt;/p&gt;&#xA;&lt;p&gt;自定义的Map函数接受一个&lt;strong&gt;key/value pair&lt;/strong&gt;输入，然后产生一个中间&lt;strong&gt;key/value pair&lt;/strong&gt;集合。会将相同key和对应多个value值集合在一起传递给reduce函数。&lt;/p&gt;&#xA;&lt;p&gt;自定义的Reduce函数接受上面的集合，合并这些value值，形成一个新的value值集合。&lt;/p&gt;&#xA;&lt;p&gt;下面是一个计算大文档集合中每个单词出现的次数的案例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map(String key, String value):&#xA;&#x9;//key : document name&#xA;&#x9;//value: document contents&#xA;&#x9;foreach word w in value:&#xA;&#x9;&#x9;emitintermediate(w, &amp;#34;1&amp;#34;);&#xA;&#x9;&#x9;&#xA;reduce(String key, Iterator values):&#xA;&#x9;//key : a word&#xA;&#x9;//values: a list of counts&#xA;&#x9;int result = 0;&#xA;&#x9;foreach v in values:&#xA;&#x9;&#x9;result += ParseInt(v);&#xA;&#x9;emit(AsString(result));&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Map计函数计算文档中&lt;code&gt;(word,count)&lt;/code&gt;这样的&lt;strong&gt;key/value pair&lt;/strong&gt;，Reduce函数把Map函数产生的计数累加起来。&lt;/p&gt;&#xA;&lt;p&gt;Map Reduce函数可以抽象成以下形式：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map(k1, v1) -&amp;gt; list(k2, v2)&#xA;reduce(k2, list(v2)) -&amp;gt; list(v2)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;其他案例&#34;&gt;其他案例&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分布式的grep：Map输出匹配某个模式的一行，Reduce将中间数据处理再输出。&lt;/li&gt;&#xA;&lt;li&gt;计算URL访问频率：Map处理日志，输出&lt;code&gt;(URL, 1)&lt;/code&gt;，Reduce将中间数据累加处理，产生&lt;code&gt;(URL, totalCount)&lt;/code&gt;再输出。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;p&gt;将输入数据自动分割成M块数据片段，Map函数在多台机器上并行处理。Reduce调用也是在多台机器上并行处理。MapReduce实现的全部流程如图所示：&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式锁的实现方案</title>
      <link>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</link>
      <pubDate>Thu, 02 Jan 2020 20:24:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;分布式锁需要具备的条件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;互斥性：在任意一个时刻，只有一个客户端持有锁。&lt;/li&gt;&#xA;&lt;li&gt;无死锁：即使持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。&lt;/li&gt;&#xA;&lt;li&gt;容错：只要大部分Redis节点都活着，客户端可以获取和释放锁。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;分布式锁的主要实现方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据库&lt;/li&gt;&#xA;&lt;li&gt;Redis等缓存数据库，&lt;code&gt;redis&lt;/code&gt;的&lt;code&gt;setnx&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Zookeeper 临时节点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;redis-实现分布式锁&#34;&gt;Redis 实现分布式锁&lt;/h3&gt;&#xA;&lt;h3 id=&#34;第一阶段&#34;&gt;第一阶段&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public void hello() {&#xA;    Integer lock = get(&amp;#34;lock&amp;#34;);&#xA;    if(lock == null){&#xA;        set(&amp;#34;lock&amp;#34;,1);&#xA;        //todo&#xA;        del(&amp;#34;lock&amp;#34;);&#xA;        return;&#xA;    }else {&#xA;        //自旋&#xA;        hello();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;存在的问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;请求同时打进来，所有请求都获取不到锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;第二阶段&#34;&gt;第二阶段&lt;/h3&gt;&#xA;&lt;p&gt;使用&lt;code&gt;setnx&lt;/code&gt;设置锁&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;setnx&lt;/code&gt;在key不存在时可以设置，存在当前key则不操作&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public void hello(){&#xA;   String lock = setnx(&amp;#34;lock&amp;#34;); //0代表没有保存数据，说明有人占坑了，1代表占坑成功&#xA;    if(lock != 0){&#xA;        //todo&#xA;        del(&amp;#34;lock&amp;#34;);&#xA;    }else {&#xA;        //自旋&#xA;        hello();&#xA;    } &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;存在的问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于各种问题（未捕获的异常，断电）等导致锁未释放，其他人永远获取不到锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;第三阶段&#34;&gt;第三阶段&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public void hello(){&#xA;    String lock = setnx(&amp;#34;lock&amp;#34;);&#xA;    if(lock != 0){&#xA;        expire(&amp;#34;lock&amp;#34;,10s);&#xA;        //todo&#xA;        del(&amp;#34;lock&amp;#34;);&#xA;    }else {&#xA;        hello();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;存在的问题：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
