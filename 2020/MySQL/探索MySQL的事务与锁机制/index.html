

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lin Wang">
  <meta name="keywords" content="l1nker4">
  
    <meta name="description" content="事务概念简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。MySQL中事务支持是在存储引擎层实现的。事务拥有四个重要的特性：原子性、一致性、隔离性、持久性，简称为ACID特性，下文将逐一解释。 ACID特性 原子性（Atomicity） 事务开始后所有操作步骤，要么全部完成，要么全部不做，不存在只执行一部分的情况。   一致性（Consistency） 事务执行前后，数据从一个合">
<meta property="og:type" content="article">
<meta property="og:title" content="探索MySQL的事务与锁机制">
<meta property="og:url" content="https://l1n.wang/2020/MySQL/%E6%8E%A2%E7%B4%A2MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="l1nker4&#39;s Blog">
<meta property="og:description" content="事务概念简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。MySQL中事务支持是在存储引擎层实现的。事务拥有四个重要的特性：原子性、一致性、隔离性、持久性，简称为ACID特性，下文将逐一解释。 ACID特性 原子性（Atomicity） 事务开始后所有操作步骤，要么全部完成，要么全部不做，不存在只执行一部分的情况。   一致性（Consistency） 事务执行前后，数据从一个合">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png">
<meta property="og:image" content="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/transaction/1.jpg">
<meta property="og:image" content="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/transaction/%E9%94%81%E5%85%BC%E5%AE%B9%E7%9F%A9%E9%98%B5.png">
<meta property="article:published_time" content="2020-04-29T01:47:16.000Z">
<meta property="article:modified_time" content="2024-07-26T15:47:11.364Z">
<meta property="article:author" content="Lin Wang">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png">
  
  
  
  <title>探索MySQL的事务与锁机制 - l1nker4&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"l1n.wang","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"612bbac3c11e86af5c472b8381f09fa7","google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?612bbac3c11e86af5c472b8381f09fa7";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>l1nker4&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://blog-1251613845.cos.ap-shanghai.myqcloud.com/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="探索MySQL的事务与锁机制"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-04-29 09:47" pubdate>
          2020年4月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          7.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          62 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">探索MySQL的事务与锁机制</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h1><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。MySQL中事务支持是在存储引擎层实现的。事务拥有四个重要的特性：原子性、一致性、隔离性、持久性，简称为ACID特性，下文将逐一解释。</p>
<h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><ul>
<li>原子性（Atomicity）<ul>
<li>事务开始后所有操作步骤，要么全部完成，要么全部不做，不存在只执行一部分的情况。</li>
</ul>
</li>
<li>一致性（Consistency）<ul>
<li>事务执行前后，数据从一个合法性状态变换到另一个合法性状态。<ul>
<li>A、B转账业务，总金额不变。</li>
</ul>
</li>
<li>分为数据一致性和约束一致性。</li>
</ul>
</li>
<li>隔离性（Isolation）<ul>
<li>在一个事务未执行完毕时，其它事务无法读取该事务的数据。</li>
<li>MySQL通过锁机制来保证事务的隔离性。</li>
</ul>
</li>
<li>持久性（Durability）<ul>
<li>事务一旦提交，数据将被保存下来，即使发生宕机等故障，数据库也能将数据恢复。</li>
<li>MySQL使用<code>redo log</code>来保证事务的持久性。当通过事务对数据进行修改时，首先会将操作记录到<code>redo log</code>中，然后对数据库对应行进行修改，这样即使数据库宕机，也能通过<code>redo log</code>进行恢复。</li>
</ul>
</li>
</ul>
<p>ACID关系如下图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png" srcset="/img/loading.gif" lazyload alt="ACID关系"></p>
<h2 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h2><p>开始事务：</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;  
或
<span class="hljs-keyword">START</span> TRANSACTION;</code></pre></div>

<p>两者区别：</p>
<ul>
<li><code>START TRANSACTION</code>后面可以跟随几个修饰符：<ul>
<li>READ ONLY：标识为只读事务，该事务只能读取数据。</li>
<li>READ WRITE：标识为读写事务，该事务可以读写数据。</li>
<li>WITH CONSISTENT SNAPSHOT ：启动一致性读。</li>
</ul>
</li>
</ul>
<p>完成事务：</p>
<div class="code-wrapper"><pre><code class="hljs sql"># 提交事务
<span class="hljs-keyword">COMMIT</span>;

#回滚事务
<span class="hljs-keyword">ROLLBACK</span>;

#将事务回滚到某个保存点。
<span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> [<span class="hljs-keyword">SAVEPOINT</span>]</code></pre></div>



<h2 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;</code></pre></div>



<p>隐式提交数据的情况：</p>
<ol>
<li>数据定义语言：CREATE、ALTER、DROP</li>
<li>隐式修改mysql数据库中的表</li>
<li>事务控制（连续两次BEGIN，第一个BEGIN后面的语句会自动提交）或关于锁定的语句</li>
<li>加载数据的语句</li>
<li>MySQL复制的语句</li>
</ol>
<h2 id="completion-type"><a href="#completion-type" class="headerlink" title="completion_type"></a>completion_type</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-variable">@completion_type</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div>

<p>该变量有三种取值：</p>
<ul>
<li>0：默认值，当我们执行COMMIT时会提交事务，再执行下一个事务时，还需要使用BEGIN来开启。</li>
<li>1：提交事务后，相当于执行了<code>COMMIT AND CHAIN</code>，开启链式事务，当我们提交事务后会开启一个相同隔离级别的事务。</li>
<li>2：相当于<code>COMMIT AND RELEASE</code>，提交事务后，与服务器断开连接。</li>
</ul>
<h2 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h2><ul>
<li>扁平事务：最简单的一种，使用BEGIN开启，由COMMIT或ROLLBACK结束。</li>
<li>带有保存点的扁平事务：支持回滚到指定保存点的事务。</li>
<li>链式事务：一个事务由多个子事务构成，提交前一个事务，触发下一个事务。</li>
<li>嵌套事务：由顶层事务控制下面各个层次的事务。</li>
<li>分布式事务：分布式系统中的扁平事务。</li>
</ul>
<h1 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h1><h2 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h2><p>事务A覆盖了事务B未提交的更新数据。</p>
<p>任何隔离级别都可以解决该问题。</p>
<h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><p><strong>丢失更新</strong>就是两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务更新的情况。这是一种并发写入的问题。基本情景如下表：</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">a &#x3D; 100</td>
<td align="center">a &#x3D; 100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">&#x2F;</td>
<td align="center">a -&#x3D; 10</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">&#x2F;</td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&#x2F;</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">a +&#x3D; 20</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">commit</td>
<td align="center">&#x2F;</td>
</tr>
</tbody></table>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>一个事务读取了另一个未提交的事务写的数据，被称为脏读。基本情景如下：</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">a &#x3D; 100</td>
<td align="center">a &#x3D; 100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">&#x2F;</td>
<td align="center">a &#x3D; 110</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">a &#x3D; 110</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&#x2F;</td>
<td align="center">rollback</td>
</tr>
</tbody></table>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>事务A读取一个字段，然后事务B<strong>更新</strong>了字段，事务A再次读取发现两次值不相等。</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">a &#x3D; 100</td>
<td align="center">a &#x3D; 100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">&#x2F;</td>
<td align="center">a &#x3D; 110</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">a &#x3D; 110</td>
<td align="center">commit</td>
</tr>
</tbody></table>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>事务A读取一个字段，然后事务B<strong>插入</strong>了满足条件的数据，事务A再次读取发现两次值不一样。</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">select * from table where id &#x3D; 1(记录为0条)</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">&#x2F;</td>
<td align="center">insert into table (id) value(1)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">&#x2F;</td>
<td align="center">commit</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">insert into table (id) value(1)</td>
<td align="center">&#x2F;</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">commit(报错，主键冲突)</td>
<td align="center">&#x2F;</td>
</tr>
</tbody></table>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>由于数据库在并发事务中带来一些问题，数据库提供了事务隔离机制来解决相对应的问题。数据库的锁也是为了构建这些隔离级别而存在的。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读（Dirty Read）</th>
<th>不可重复读（NonRepeatable Read）</th>
<th>幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读(Read uncommited)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读(Read commited)</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读(Repeatable read)</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化(Serializable)</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<ul>
<li>未提交读(Read Uncommitted)：在该隔离级别下，所有事务都能看到其他未提交事务的执行结果，会导致脏读、不可重复读、幻读。</li>
<li>提交读(Read Committed)：一个事务只能看见已经提交事务所做的改变，不能避免不可重复读、幻读。</li>
<li>可重复读(Repeated Read)：<strong>默认的隔离级别</strong>，事务A读取到一个数据后，事务B进行了修改并提交，事务A再次读取该数据，还是读取到原来的内容。不能避免幻读问题。</li>
<li>可串行化(Serializable)：对于同一行记录，写会加写锁，读会加读锁，当出现读写冲突的时候，后面的事务必须等待前一个事务执行完成才能继续执行。</li>
</ul>
<p><strong>隔离级别越高，数据库的并发性能越差。</strong></p>
<p>查询与修改隔离级别的SQL语句：</p>
<div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 查看系统隔离级别：</span>
<span class="hljs-keyword">select</span> @@<span class="hljs-keyword">global</span>.tx_isolation;
<span class="hljs-comment">-- 查看当前会话隔离级别</span>
<span class="hljs-keyword">select</span> @@tx_isolation;
<span class="hljs-comment">-- 设置当前会话隔离级别</span>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">serializable</span>;
<span class="hljs-comment">-- 设置全局系统隔离级别</span>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> <span class="hljs-keyword">UNCOMMITTED</span>;</code></pre></div>





<h1 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h1><p>事务日志有两种：</p>
<ul>
<li>REDO LOG：重做日志，提供再写入操作、恢复提交事务修改的页操作，用来保证事务的持久性。是存储引擎层生成的日志，记录<strong>物理页</strong>的修改操作（包括页号、偏移量等），主要保证数据的可靠性。</li>
<li>UNDO LOG：回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。是存储引擎层生成的日志，记录<strong>逻辑操作</strong>日志，用于<strong>事务回滚</strong>和<strong>一致性非锁定读</strong>。</li>
</ul>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>InnoDB以页为单位管理存储空间，读取页首先要将<strong>磁盘</strong>中的页读取到内存中的Buffer Pool再访问，所有的更新都先更新缓冲池数据，缓冲池中的<strong>脏页</strong>会以一定的频率被刷入磁盘（<strong>checkpoint</strong>机制），以此来抵消CPU和磁盘的差距。</p>
<h3 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h3><p>由于checkpoint机制是定时触发，当出现事务提交后，刚写完缓冲池，数据库宕机，那么会发生数据丢失，不符合<strong>持久性</strong>的要求。</p>
<p>解决思路：</p>
<ul>
<li>每次提交的数据都进行刷盘操作，存在以下问题：<ul>
<li>修改量和刷盘工作量不成比例：修改1KB内容，刷盘16KB。</li>
<li>随机IO刷新较慢：一个事务内修改的物理页不一定连续。</li>
</ul>
</li>
<li>使用redo log进行记录，包括物理页、偏移量、修改值等数据。<ul>
<li>降低了频繁刷盘的效率。</li>
</ul>
</li>
</ul>
<p>InnoDB采取的是WAL（<strong>Write-Ahead Logging</strong>），先写日志，后写磁盘，发生宕机后通过redo log进行恢复，<strong>保证持久性，这就是redo log的作用。</strong></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>redo日志<strong>顺序写入磁盘</strong>：磁盘顺序写的性能和写内存差不多。</li>
<li>事务执行过程中，redo日志不断记录。<ul>
<li>bin log直到事务提交，才会一次性写入到bin log中。</li>
</ul>
</li>
<li>占用空间比较小。</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>主要分为两部分：</p>
<ul>
<li>redo log buffer：保存在内存中<ul>
<li>innodb_log_buffer_size：默认16M</li>
</ul>
</li>
<li>redo log file：保存在磁盘中</li>
</ul>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>以更新事务为例，基本流程如下：</p>
<ol>
<li>先将原始数据从磁盘读取到内存中，并进行更新。</li>
<li>生成一条redo log entry并写入redo log buffer。</li>
<li>当事务commit后，将redo log buffer中的内容刷新到redo log file，采用append方式。</li>
<li>定期将内存中修改的数据刷新到磁盘中。</li>
</ol>
<h3 id="redo-log-buffer的刷盘策略"><a href="#redo-log-buffer的刷盘策略" class="headerlink" title="redo log buffer的刷盘策略"></a>redo log buffer的刷盘策略</h3><p>该流程是保证数据持久化的核心环节，这里的刷盘并不直接刷到磁盘，而实刷入<strong>Page Cache（内存）</strong>中（write），真正的刷盘工作（fsync）交给OS去做。如果此时系统宕机，那么数据会丢失。因此InnoDB提供了<code>innodb_flush_log_at_trx_commit</code>参数来控制何时将redo log buffer中的日志刷入redo log file。默认值为1。</p>
<ul>
<li>0：redo log buffer每隔一秒将其数据刷入page cache，该模式下事务提交不会触发刷盘操作。<ul>
<li>mysql进程崩溃会导致数据丢失。</li>
</ul>
</li>
<li>1：每次事务提交都会将将redo log buffer中数据刷入page cache，并立刻刷入磁盘。效率较低也为安全。</li>
<li>2：每次事务提交都会将redo log buffer中数据刷入page cache，由OS同步到磁盘。（每秒一次）<ul>
<li>mysql进程崩溃不会有数据丢失，当时OS宕机会有数据丢失。</li>
</ul>
</li>
</ul>
<h3 id="redo-log-buffer的写入过程"><a href="#redo-log-buffer的写入过程" class="headerlink" title="redo log buffer的写入过程"></a>redo log buffer的写入过程</h3><p>Mini-Transaction：MySQL将对底层页面中的一次原子访问的过程称为Mini-Transaction（mtr）。例如：向默认索引对应的B+ Tree中插入一条记录就是一次mtr。每个mtr会包含一组redo log entry，在进行恢复数据时，一组redo日志作为不可分割的整体。</p>
<p>写入是顺序写入，先往前面的block中写，当写满后，往后续的block写入，提供了<code>buf_free</code>的全局变量用来指明写到了哪个block。</p>
<p>一个block共512字节（磁盘扇区为512，避免非原子性写入），block由以下几个部分组成：</p>
<ul>
<li>log block header：12字节，保存一些block元数据。</li>
<li>log block body：492字节，存储redo log信息。</li>
<li>log block trailer：8字节，保存校验值。</li>
</ul>
<h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><p>相关配置参数：</p>
<ul>
<li>innodb_log_group_home_dir：指定redo log文件存储路径，默认为<code>./</code>，表示在数据库的数据目录中（默认为<code>var/lib/mysql</code>）</li>
<li>innodb_log_files_in_group：指定redo log file的个数，命名方式如：ib_logfile0，默认为2，最大100</li>
<li>innodb_log_file_size：单个redo log file的大小，默认为48M</li>
</ul>
<p>采用循环使用的方式进行写入，整个日志组有两个重要的属性：</p>
<ul>
<li>write pos：当前记录的位置，一边写一边后移。</li>
<li>checkpoint：当前要擦除的位置，也是往后推移。</li>
</ul>
<p>每次刷盘redo log，write pos就往后更新，每次MySQL加载日志文件恢复数据，会清空加载过的日志，并将checkpoint后移更新，两个变量之间的部分用做空闲空间来写入新数据，类似于一个<strong>环形队列</strong>。</p>
<p>当两者相遇，表示文件组已满。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log保证了事务的原子性，主要用来实现事务回滚操作。</p>
<h3 id="为什么需要undo-log"><a href="#为什么需要undo-log" class="headerlink" title="为什么需要undo log"></a>为什么需要undo log</h3><p>事务需要保证<strong>原子性</strong>，如果出现意外情况，例如mysql进程崩溃，OS宕机、断电，或者是事务本身<code>ROLLBACK</code>，都需要对数据进行<strong>回滚</strong>，因此使用undo log完成该项任务。</p>
<p>undo log会产生redo log，因为undo log也需要持久性的保护。</p>
<h3 id="undo-log作用"><a href="#undo-log作用" class="headerlink" title="undo log作用"></a>undo log作用</h3><ul>
<li><strong>回滚数据</strong>：undo并不是<strong>物理</strong>恢复（数据页操作），undo log是<strong>逻辑日志</strong>，只是将数据库逻辑上恢复到原来的样子。</li>
<li><strong>MVCC</strong>：InnoDB中的MVCC通过undo来完成的，当用户读取一行记录时，若该纪录已被其他事务占用，当前事务可以通过undo读取之前的版本，以此实现<strong>非锁定读</strong>。</li>
</ul>
<h3 id="undo存储结构"><a href="#undo存储结构" class="headerlink" title="undo存储结构"></a>undo存储结构</h3><p>采用段的方式进行管理（回滚段），每个回滚段记录了1024个<code>undo log segment</code>，在每个<code>undo log segment</code>中进行undo页的写入。</p>
<p>回滚段和事务的关系：</p>
<ul>
<li>每个事务只使用一个回滚段，一个回滚段在同一时刻服务于多个事务。</li>
<li>事务开始时，会指定一个回滚段，在事务执行过程中，当数据被修改，原始数据会复制到回滚段。</li>
<li>回滚段中事务不断填冲盘区，使用完会扩展下一个盘区，所有已分配的盘区都被用完，会覆盖最初的盘区。</li>
<li>事务提交时，存储引擎处理两个事情：<ul>
<li>将undo log放在列表中，以供后续的purge操作。</li>
<li>判断undo log所在页是否可重用<ul>
<li>该页会被放入链表，并判断可用空间是否小于四分之三，小于则可以被重用，不被回收。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="回滚数据分类"><a href="#回滚数据分类" class="headerlink" title="回滚数据分类"></a>回滚数据分类</h3><ul>
<li>未提交的回滚数据：此时事务暂未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li>
<li>已提交但未过期的回滚数据：事务已提交，受<code>undo retention</code>参数的保持时间的影响。</li>
<li>事务已经提交并过期的回滚数据：数据保存时间超过<code>undo retention</code>指定的时间，回滚段满了后，优先覆盖此部分数据。</li>
</ul>
<h3 id="undo-log参数"><a href="#undo-log参数" class="headerlink" title="undo log参数"></a>undo log参数</h3><ul>
<li>innodb_undo_directory：设置undo log存储路径，默认值为<code>./</code>。</li>
<li>innodb_undo_logs：设置<code>rollback segment</code>的个数，默认为128</li>
<li>innodb_undo_tablespaces：设置<code>rollback segment</code>文件的数量。默认为2。</li>
</ul>
<h3 id="undo类型"><a href="#undo类型" class="headerlink" title="undo类型"></a>undo类型</h3><p>InnoDB中undo log分为以下两种：</p>
<ul>
<li>insert undo log：在insert操作下产生的log，只对事务本身可见，对其他事务不可见（隔离性的要求），事务提交后直接删除，不需要purge。</li>
<li>update undo log：delete和update操作产生的log，需要提供MVCC机制，因此不能直接删除，<strong>等待purge线程进行删除。</strong></li>
</ul>
<h2 id="ACID的实现"><a href="#ACID的实现" class="headerlink" title="ACID的实现"></a>ACID的实现</h2><h3 id="原子性的实现"><a href="#原子性的实现" class="headerlink" title="原子性的实现"></a>原子性的实现</h3><p>每一个写事务，都会修改Buffer Pool，并产生对应的Redo日志，Redo日志以Write Ahead Log方式写，如果不写日志，数据库宕机恢复后，事务无法回滚，无法保证原子性。</p>
<h3 id="持久性的实现"><a href="#持久性的实现" class="headerlink" title="持久性的实现"></a>持久性的实现</h3><p>通过WAL可以保证逻辑上的持久性，物理上的持久性通过存储引擎的数据刷盘实现。</p>
<h3 id="隔离性的实现"><a href="#隔离性的实现" class="headerlink" title="隔离性的实现"></a>隔离性的实现</h3><p>通常用Read View表示一个事务的可见性，读提交状态每一条读操作语句都会获得一次Read View，每次更新都会获取最新事务的提交状态，即每条语句执行都会更新其可见性视图。可重复读的隔离级别下，可见性视图只有在自己当前事务提交之后，才会更新，所以与其他事务没有关系。</p>
<p><strong>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，可以得到之前一个状态的值</strong>。假设一个值从1被按照顺序改成了2，3，4，在回滚日志中会有类似下面的记录。</p>
<p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/transaction/1.jpg" srcset="/img/loading.gif" lazyload alt="记录"></p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的<code>read-view</code>，在视图A、B、C中，记录的值分别为1、2、4。同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC ）。对于<code>read-view A</code>要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>即使现在有另外一个事务正在将 4 改成 5，这个事务跟 <code>read-view A、B、C </code>对应的事务是不会冲突的。</p>
<h3 id="一致性的实现"><a href="#一致性的实现" class="headerlink" title="一致性的实现"></a>一致性的实现</h3><p>一致性是通过其它三个特性来保证的。而其它三个特性由Redo、Undo来保证的。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul>
<li>对数据的操作类型划分<ul>
<li>读锁&#x2F;共享锁</li>
<li>写锁&#x2F;排他锁</li>
</ul>
</li>
<li>粒度划分<ul>
<li>表级锁</li>
<li>行级锁</li>
<li>页级锁</li>
</ul>
</li>
<li>对锁的态度划分<ul>
<li>悲观锁</li>
<li>乐观锁</li>
</ul>
</li>
<li>加锁方式<ul>
<li>显式锁</li>
<li>隐式锁</li>
</ul>
</li>
</ul>
<h2 id="InnoDB的锁"><a href="#InnoDB的锁" class="headerlink" title="InnoDB的锁"></a>InnoDB的锁</h2><p>InnoDB中，锁分为行锁和表锁，行锁包括两种锁。</p>
<ul>
<li>共享锁（S）：共享锁锁定的资源可以被其它用户读取，但不能修改，在进行SELECT的时候，会将对象进行共享锁锁定，数据读取完毕，释放共享锁，保证在读取的过程中不被修改。</li>
<li>排他锁（X）：锁定的数据只允许进行锁定操作的事务使用，其它事务无法对已锁定的数据进行查询和修改</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs SQL"># 给product_comment加上共享锁
LOCK <span class="hljs-keyword">TABLE</span> product_comment READ;

# 解锁
UNLOCK <span class="hljs-keyword">TABLE</span>;

# 对 user_id<span class="hljs-operator">=</span><span class="hljs-number">912178</span> 的数据行加上共享锁
<span class="hljs-keyword">SELECT</span> comment_id, product_id, comment_text, user_id <span class="hljs-keyword">FROM</span> product_comment <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">912178</span> LOCK <span class="hljs-keyword">IN</span> SHARE MODE

# 给 product_comment 数据表添加排它锁
LOCK <span class="hljs-keyword">TABLE</span> product_comment WRITE;

# 解锁
UNLOCK <span class="hljs-keyword">TABLE</span>;

# 对 user_id<span class="hljs-operator">=</span><span class="hljs-number">912178</span> 的数据行加上排他锁
<span class="hljs-keyword">SELECT</span> comment_id, product_id, comment_text, user_id <span class="hljs-keyword">FROM</span> product_comment <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">912178</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;</code></pre></div>





<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB为了允许行锁和表锁共存，实现多粒度锁机制，意向锁就是其中的一种表锁。</p>
<ul>
<li>意向锁的存在是为了协调行锁和表锁的关系</li>
<li>意向锁是一种不与行级锁冲突的表级锁</li>
<li>表明某个事物正在某些行持有了锁或该事务准备去持有锁。</li>
</ul>
<p>InnoDB还有两种内部使用的意向锁，也都是表锁，表锁分为三种：</p>
<ul>
<li><p>意向共享锁（IS）：事务计划给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
</li>
<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
</li>
<li><p>自增锁（AUTO-INC Locks）：特殊表锁，自增长计数器通过该“锁”来获得子增长计数器最大的计数值。自增主键会涉及自增锁，在INSERT结束后立即释放。</p>
</li>
<li><p>如果事务想要获取数据表中某些数据的共享锁，就会在表上添加<strong>意向共享锁</strong>。</p>
</li>
<li><p>如果事务想要获取数据表中某些数据的排他锁，就会在表上添加<strong>意向排他锁</strong>。</p>
</li>
</ul>
<p>意向锁主要为了<strong>提高效率</strong>，避免线程去逐个检查行锁。</p>
<p>在加行锁之前必须先获得表级意向锁，否则等<code>innodb_lock_wait_timeout</code> 超时后根据<code>innodb_rollback_on_timeout</code> 决定是否回滚事务。</p>
<p>插入数据的方式分为三类：</p>
<ul>
<li>Simple inserts：预先确定插入的行数，<ul>
<li><code>INSERT VALUES()</code>、<code>REPLACE</code></li>
</ul>
</li>
<li>bulk inserts：事先不知道插入的行数，每处理一行，为AUTO_INCREMENT分配一个新值。<ul>
<li><code>INSERT ... SELECT</code>、<code>LOAD DATA</code></li>
<li>mixed-mode inserts：是simple inserts语句，但是指定部分新行的自动递增值</li>
</ul>
</li>
</ul>
<p>AUTO-INC锁是当插入数据中含有<code>AUTO_INCREMENT</code>字段时进行lock的表级锁。并发性能较差。</p>
<p>InnoDB通过<code>innodb_autoinc_lock_mode</code>来提供不同的锁定机制。</p>
<ul>
<li>0：所有insert语句都会获得同一个AUTO-INC锁</li>
<li>1：bulk inserts仍使用AUTO-INC锁，Simple inserts由于确定插入条数，在获取自增锁后会释放</li>
<li>2：所有insert语句都不会使用表级AUTO-INC锁，自增值保证所有insert语句获得的值是唯一的，由于多个语句同时生成，生成值可能不是连续的。</li>
</ul>
<p>锁关系矩阵如下图所示：</p>
<p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/transaction/%E9%94%81%E5%85%BC%E5%AE%B9%E7%9F%A9%E9%98%B5.png" srcset="/img/loading.gif" lazyload alt="InnoDB锁关系矩阵"></p>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MySQL5.5引入了meta data lock，简称MDL锁（表锁），其作用是保证读写的正确性。当对一个表做增删改查操作时，加MDL读锁，当对表结构做变更操作时，加MDL写锁。</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB行锁是通过对索引数据页上的记录加锁实现的，在存储引擎层实现。</p>
<p>主要有三种锁：</p>
<ul>
<li><p>Record锁（LOCK_REC_NOT_GAP）：单个行记录的锁（锁数据，不锁Gap）</p>
</li>
<li><p>Gap锁：间隙锁，锁定一个范围，不包括记录本身（不锁数据，锁数据前面的Gap）</p>
<ul>
<li>为了防止插入幻影记录而提出的</li>
</ul>
</li>
<li><p>Next-key锁：锁数据并且锁Gap，可以解决幻读问题。</p>
<ul>
<li><strong>既想锁住某条记录，又想阻止其他事务在该记录前面的间隙插入新纪录。</strong></li>
</ul>
</li>
<li><p>插入意向锁（Insert Intention Locks）：插入一条记录需要判断是否存在gap锁，有的话需要等待。InnoDB规定事务在等待的时候也需要在内存中生成一个<strong>锁结构</strong>，<strong>表明有事务想在某个间隙中插入新记录</strong>，这个锁结构被称为<code>Insert Intention Locks</code>。</p>
<ul>
<li>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</li>
</ul>
</li>
</ul>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>对<strong>整个数据库实例</strong>加锁，整个数据库处于<strong>只读状态</strong>，，使用场景为：<strong>全库逻辑备份</strong>。</p>
<div class="code-wrapper"><pre><code class="hljs sql">Flush tables <span class="hljs-keyword">with</span> read lock</code></pre></div>






<h3 id="InnoDB死锁"><a href="#InnoDB死锁" class="headerlink" title="InnoDB死锁"></a>InnoDB死锁</h3><p>由于InnoDB是逐行加锁的，极容易产生死锁，产生死锁的四个条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程以获得的资源，在没有使用完之前，不能强行剥夺。</li>
<li>循环等待条件：多个进程之前形成的一种互相循环等待资源的关系。</li>
</ul>
<h3 id="InnoDB中如何处理死锁"><a href="#InnoDB中如何处理死锁" class="headerlink" title="InnoDB中如何处理死锁"></a>InnoDB中如何处理死锁</h3><ul>
<li>等待，直到超时：<code>innodb_lock_wait_timeout</code>参数进行控制，默认为50s，超时回对事务进行<strong>回滚</strong>。</li>
<li>使用死锁检测进行处理：InnoDB使用<code>wait-for graph</code>算法来主动进行死锁检测，每次加锁请求无法立即满足时，都会触发此算法。<ul>
<li>这是一种主动的检测机制，要求数据库保存<strong>锁的信息链表</strong>和<strong>事务等待链表</strong>两部分信息。</li>
<li>基于这两部分信息，绘制<code>wait-for graph</code></li>
<li>一旦检测到回路，引擎会选择回滚<strong>undo量最小的事务</strong>，让其他食物继续执行。（此部分通过<code>innodb_deadlock_detect</code>参数控制）</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul>
<li>更新SQL的where条件尽量用索引</li>
<li>合理设置索引，加锁索引准确，缩小锁定范围，减少锁竞争。</li>
<li>减少范围更新，尤其非主键&#x2F;非唯一索引的范围更新。</li>
<li>控制事务大小，减少锁定数据量和锁定时间长度</li>
<li>加锁顺序一致，尽可能一次性锁定所有所需的数据行。</li>
<li>并发要求高的系统，不要显式加锁。</li>
</ul>
<h3 id="锁的结构"><a href="#锁的结构" class="headerlink" title="锁的结构"></a>锁的结构</h3><p>如果出现以下情况，多个逻辑上的锁会放在一个锁结构中：</p>
<ul>
<li>同一个事务中进行加锁</li>
<li>被加锁的记录在同一个页面</li>
<li>加锁的类型是一样的</li>
<li>等待状态一样</li>
</ul>
<p>锁结构包含以下字段：</p>
<ul>
<li>锁所在事务信息：记录哪个事务生成了这个锁结构，指针。</li>
<li>索引信息：对于行锁，需要记录加锁的记录属于哪个索引，指针。</li>
<li>表锁&#x2F;行锁信息：用于区分此类型。<ul>
<li>表锁记录：表信息、其他信息</li>
<li>行锁记录：<ul>
<li>Space ID：所在的表空间</li>
<li>Page Number：记录所在页号</li>
<li>n_bits：一条记录对应一个bit位，用不同的bit位区分哪一条记录加了锁。</li>
</ul>
</li>
</ul>
</li>
<li>type_mode：32bit，分为以下几个部分<ul>
<li>lock_mode：低4位。<ul>
<li>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是IS锁 。 </li>
<li>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是IX锁 。</li>
<li>LOCK_S （十进制的 2 ）：表示共享锁，也就是S锁 。</li>
<li>LOCK_X （十进制的 3 ）：表示独占锁，也就是X锁 </li>
<li>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。</li>
</ul>
</li>
<li>lock_type：低5-8位，目前只有第5、6位被使用<ul>
<li>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。 </li>
<li>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li>rec_lock_type：其余位。<ul>
<li>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。 </li>
<li>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。 </li>
<li>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示记录锁 。 </li>
<li>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><p>可以检查<code>InnoDB_row_lock</code>变量来分析锁状态。</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_row_lock%&#x27;</span>;

Variable_name 	 				<span class="hljs-keyword">Value</span>
Innodb_row_lock_current_waits	<span class="hljs-number">0</span>
Innodb_row_lock_time			<span class="hljs-number">297</span>
Innodb_row_lock_time_avg		<span class="hljs-number">42</span>
Innodb_row_lock_time_max		<span class="hljs-number">83</span>
Innodb_row_lock_waits			<span class="hljs-number">7</span></code></pre></div>

<p>各字段含义分别如下：</p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量； </li>
<li>Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长） </li>
<li>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是 <code>INNODB_TRX</code> 、 <code>data_locks</code>（8.0更新） 和 <code>data_lock_waits</code>（8.0更新） 。</p>
<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><h2 id="单版本控制-锁"><a href="#单版本控制-锁" class="headerlink" title="单版本控制-锁"></a>单版本控制-锁</h2><p>锁用独占的方式保证只有一个版本的情况下事务相互隔离。</p>
<h2 id="多版本控制-MVCC"><a href="#多版本控制-MVCC" class="headerlink" title="多版本控制-MVCC"></a>多版本控制-MVCC</h2><p>MVCC（Multi-Version Concurrency Control）即多版本并发控制。</p>
<p>MVCC 是通过保存数据在<strong>某个时间点的快照</strong>来实现并发控制的。简单来说它的思想就是<strong>保存数据的历史版本</strong>。这样我们就可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁也可以保证事务的隔离效果。</p>
<p>每次对数据库的修改，都会在Undo日志中记录当前修改记录的<strong>事务版本号</strong>以及<strong>修改前数据状态的存储地址</strong>，以便在必要的时候可以回滚到老的数据版本。</p>
<p>MVCC的实现依赖于：Undo Log、Read View、隐藏字段。</p>
<p>MVCC没有正式的标准，在不同DBMS中实现方式也不同。</p>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>MVCC主要解决以下几个问题：</p>
<ul>
<li>读写之间阻塞的问题，通过MVCC可以让读写互相不阻塞，提高并发处理能力。</li>
<li>降低了死锁的概率，MVCC采用了乐观锁的方式，读取数据时不需要加锁，对于写操作，只锁定必要的行。</li>
<li>解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li>
</ul>
<p>MVCC最大的<strong>好处</strong>是<strong>读不加锁，读写不冲突</strong>，在MVCC中，读操作可分为快照读（Snapshot Read）和当前读（Current Read）。 </p>
<ul>
<li>快照读：读取的是记录的可见版本，不用加锁</li>
<li>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其它事务不会并发修改这条记录。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs SQL"># 不加锁的<span class="hljs-keyword">SELECT</span>都是快照读
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">WHERE</span> ...

# 加锁的<span class="hljs-keyword">SELECT</span>和增删改都是用当前读
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player LOCK <span class="hljs-keyword">IN</span> SHARE MODE;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> player <span class="hljs-keyword">values</span> ...</code></pre></div>

<p><strong>MVCC只在<code>Read Commited</code>和<code>Repeatable Read</code>两种级别下工作。核心是Undo Log + Read View。</strong></p>
<h3 id="Read-VIew"><a href="#Read-VIew" class="headerlink" title="Read VIew"></a>Read VIew</h3><p>在 MVCC 机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log 里。而Read View保存了不应该让这个事务看到的其他的事务ID列表。</p>
<p>Read View就是事务使用MVCC机制进行快照读操作时产生的读视图，事务启动时，会产生数据库系统当前的一个快照。</p>
<p><strong>主要问题</strong>：判断版本链中哪个版本是当前事务可见的。</p>
<p>ReadView主要包含以下内容：</p>
<ul>
<li>creator_trx_id：创建这个Read View的事务ID。</li>
<li>trx_ids：生成Read View时系统中活跃的读写事务的<strong>事务id列表</strong>。</li>
<li>up_limit_id：活跃的事务中最小的事务ID。</li>
<li>low_limit_id：生成Read View时系统中应该分配给下一个事务的id</li>
</ul>
<h3 id="ReadView规则"><a href="#ReadView规则" class="headerlink" title="ReadView规则"></a>ReadView规则</h3><p>根据以下步骤判断记录中某个版本是否可见：</p>
<ul>
<li>如果被访问版本的<code>trx_id = ReadView 中的 creator_trx_id </code> ，表示当前事务在访问它修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id &lt; ReadView 中的 creator_trx_id </code>，表明生成该版本的事务已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值 &gt;&#x3D; ReadView中的 low_limit_id 值，表明生成该版本的事 务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul>
<li>在其中，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>不在其中，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<h3 id="MVCC流程"><a href="#MVCC流程" class="headerlink" title="MVCC流程"></a>MVCC流程</h3><p>查询一条记录时，MVCC工作流程如下：</p>
<ol>
<li>首先获取事务的<code>trx_id</code></li>
<li>获取对应的ReadView</li>
<li>查询读到的数据，与ReadView中的<code>trx_id</code>进行比较</li>
<li>如果不符合上述规则，从<code>Undo Log</code>中获取历史快照。</li>
<li>返回最终符合规则的数据。</li>
</ol>
<p><strong>MySQL怎么解决脏读、不可重复读、幻读等问题呢？</strong></p>
<ul>
<li>读操作使用MVCC，写操作进行加锁</li>
</ul>
<p>MVCC会生成一个<strong>ReadView</strong>，通过<code>ReadView</code>找到符合条件的记录版本，查询语句只能读到在生成ReadView之前<strong>已提交事务做的更改</strong>。</p>
<p>在不同隔离级别下使用MVCC会有不同结果：</p>
<ul>
<li><code>READ COMMITED</code>：每次执行SELECT操作都会生成一个ReadView，ReadView本身就保证了只能读到已提交事务的数据，避免了脏读的现象，但是会有不可重复读和幻读问题。</li>
<li><code>REPEATABLE READ</code>：一个事务在执行过程中，只有<strong>第一次执行SELECT操作</strong>才会生成一个ReadView，之后的读操作<strong>复用</strong>这个ReadView，避免了不可重复读和幻读的问题。<ul>
<li>此隔离级别下，<strong>快照读直接通过MVCC即可解决。</strong></li>
<li><strong>当前读通过<code>Next-key Lock</code>来锁定本记录和索引区间防止插入情况，从而避免幻读。</strong></li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/MySQL/" class="category-chain-item">MySQL</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MySQL/" class="print-no-link">#MySQL</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>探索MySQL的事务与锁机制</div>
      <div>https://l1n.wang/2020/MySQL/探索MySQL的事务与锁机制/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lin Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年4月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/MySQL/MySQL%E7%B4%A2%E5%BC%95%E7%BB%86%E8%8A%82/" title="深入MySQL索引细节">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入MySQL索引细节</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/Java%E5%B9%B6%E5%8F%91/threadlocal-rondom/" title="ThreadLocalRondom原理剖析">
                        <span class="hidden-mobile">ThreadLocalRondom原理剖析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'L1nker4/blog_comment');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       2018 - 2024 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/love.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
