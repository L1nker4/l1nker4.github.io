

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lin Wang">
  <meta name="keywords" content="l1nker4">
  
    <meta name="description" content="进程与线程什么是进程操作系统在运行一个程序时，会为其创建一个进程，操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，多个线程共享进程的堆和方法区两块内存空间。 进程和线程的区别 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。  进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程基础知识">
<meta property="og:url" content="https://l1n.wang/2020/Java%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="l1nker4&#39;s Blog">
<meta property="og:description" content="进程与线程什么是进程操作系统在运行一个程序时，会为其创建一个进程，操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，多个线程共享进程的堆和方法区两块内存空间。 进程和线程的区别 进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。  进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/IMG_0041.PNG">
<meta property="article:published_time" content="2020-04-03T12:27:03.000Z">
<meta property="article:modified_time" content="2024-07-26T15:47:11.367Z">
<meta property="article:author" content="Lin Wang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/IMG_0041.PNG">
  
  
  
  <title>Java线程基础知识 - l1nker4&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"l1n.wang","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"612bbac3c11e86af5c472b8381f09fa7","google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?612bbac3c11e86af5c472b8381f09fa7";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>l1nker4&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://blog-1251613845.cos.ap-shanghai.myqcloud.com/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java线程基础知识"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-04-03 20:27" pubdate>
          2020年4月3日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          3.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          29 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java线程基础知识</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>操作系统在运行一个程序时，会为其创建一个进程，操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，多个线程共享进程的堆和方法区两块内存空间。</p>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ul>
<li><p><strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。</strong></p>
</li>
<li><p>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</p>
</li>
<li><p>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</p>
</li>
<li><p>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</p>
</li>
</ul>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换是指CPU从一个进程（线程）切换到另一个进程（线程）。<strong>上下文是指某一个时间点CPU寄存器和PC的数据</strong>。</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul>
<li>并发：同一时刻有多个任务在运行。</li>
<li>并行：同一时间有多个任务在运行。</li>
</ul>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>线程创建方式争议较多，在Oracle官方文档给出的创建方式为两种，分别是继承Thread类和实现Runnable接口。</p>
<blockquote>
<p>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of <code>Thread</code>. This subclass should override the <code>run</code> method of class <code>Thread</code>. An instance of the subclass can then be allocated and started. </p>
<p>The other way to create a thread is to declare a class that implements the <code>Runnable</code> interface. That class then implements the <code>run</code> method. An instance of the class can then be allocated, passed as an argument when creating <code>Thread</code>, and started. </p>
</blockquote>
<p>实现Runnable和Callable接口的类只能当作是一个可以在线程中运行的任务，不是真正意义上的线程。</p>
<p>线程对象在构建的时候需要提供线程所需的属性，如线程所属的线程组，线程优先级，是否守护线程等信息，下面贴出<code>Thread.init()</code>方法。</p>
<ul>
<li>g：线程组，指定该线程在哪个线程组下</li>
<li>target：指定要执行的任务</li>
<li>name：线程的名称</li>
<li>acc：用来初始化私有变量<code>inheritedAccessControlContext</code>，<code>exit</code>时会将该变量置为<code>null</code>，用来做线程的权限控制</li>
<li>inheritThreadLocals：可继承的<code>ThreadLocal</code></li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span>
<span class="hljs-params">                      <span class="hljs-type">long</span> stackSize, AccessControlContext acc,</span>
<span class="hljs-params">                      <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;
        <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;name cannot be null&quot;</span>);
        &#125;
		<span class="hljs-comment">//设置线程名称</span>
        <span class="hljs-built_in">this</span>.name = name;
		<span class="hljs-comment">//设置当前线程为该线程的父线程</span>
        <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();
    	
        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();
        <span class="hljs-keyword">if</span> (g == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-comment">/* Determine if it&#x27;s an applet or not */</span>

            <span class="hljs-comment">/* If there is a security manager, ask the security manager</span>
<span class="hljs-comment">               what to do. */</span>
            <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;
                g = security.getThreadGroup();
            &#125;

            <span class="hljs-comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span>
<span class="hljs-comment">               use the parent thread group. */</span>
            <span class="hljs-keyword">if</span> (g == <span class="hljs-literal">null</span>) &#123;
                g = parent.getThreadGroup();
            &#125;
        &#125;

        <span class="hljs-comment">/* checkAccess regardless of whether or not threadgroup is</span>
<span class="hljs-comment">           explicitly passed in. */</span>
        g.checkAccess();

        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * Do we have the required permissions?</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">if</span> (isCCLOverridden(getClass())) &#123;
                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
            &#125;
        &#125;

        g.addUnstarted();

        <span class="hljs-built_in">this</span>.group = g;
    	<span class="hljs-comment">//将daemon、priority属性设置位父线程的对应属性</span>
        <span class="hljs-built_in">this</span>.daemon = parent.isDaemon();
        <span class="hljs-built_in">this</span>.priority = parent.getPriority();
    
    	<span class="hljs-comment">//设置线程上下文类加载器</span>
        <span class="hljs-keyword">if</span> (security == <span class="hljs-literal">null</span> || isCCLOverridden(parent.getClass()))
            <span class="hljs-built_in">this</span>.contextClassLoader = parent.getContextClassLoader();
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">this</span>.contextClassLoader = parent.contextClassLoader;
        <span class="hljs-built_in">this</span>.inheritedAccessControlContext =
                acc != <span class="hljs-literal">null</span> ? acc : AccessController.getContext();
        <span class="hljs-built_in">this</span>.target = target;
        setPriority(priority);
    
    	<span class="hljs-comment">//将父线程的InheritThreadLocal复制过来</span>
        <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)
            <span class="hljs-built_in">this</span>.inheritableThreadLocals =
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
        <span class="hljs-comment">//设置指定的堆栈大小</span>
        <span class="hljs-built_in">this</span>.stackSize = stackSize;

        <span class="hljs-comment">//设置线程ID</span>
        tid = nextThreadID();
    &#125;</code></pre></div>



<h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
            System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();
        myThread.start();
    &#125;</code></pre></div>



<p>lambda简化代码：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;
            System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);
        &#125;).start();</code></pre></div>



<h5 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h5><p><code>Runnable</code>是一个函数式接口。提供了<code>Lambda</code>方式进行简化。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;
&#125;</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
            System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>()).start();
    &#125;</code></pre></div>



<h4 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h4><p><code>Callable</code>与<code>Runnable</code>类似，都是函数式接口，不过<code>Callable</code>提供的接口有返回值。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;
    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;
&#125;</code></pre></div>

<p><code>Callable</code>一般配合<code>ExecutorService</code>使用。</p>
<div class="code-wrapper"><pre><code class="hljs java">&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;</code></pre></div>



<p>Demo：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableDemo</span> &#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();
        <span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();
        Future&lt;Integer&gt; result = executor.submit(task);
        <span class="hljs-comment">// 注意调用get方法会阻塞当前线程，直到得到结果。</span>
        <span class="hljs-comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span>
        System.out.println(result.get());
    &#125;
&#125;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-comment">// 模拟计算需要一秒</span>
        Thread.sleep(<span class="hljs-number">1000</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    &#125;
&#125;
</code></pre></div>



<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p><code>Future</code>就是对具体的<code>Runnable</code>或者<code>Callable</code>任务执行结果进行取消，查询是否完成，获取结果。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;
    <span class="hljs-comment">//取消任务</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> paramBoolean)</span>;
    <span class="hljs-comment">//任务是否被取消</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;
    <span class="hljs-comment">//是否已经完成</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;
    <span class="hljs-comment">//用来获取执行结果，产生阻塞，知道任务执行完毕才返回</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;
    <span class="hljs-comment">//获取执行结果，指定时间未完成，返回null</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> paramLong, TimeUnit paramTimeUnit)</span>
            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;
&#125;</code></pre></div>



<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p><code>FutureTask</code>实现了<code>Future</code>接口。<code>FutureTask</code>是实现的<code>RunnableFuture</code>接口的，而<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;
            Thread.sleep(<span class="hljs-number">1000</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
        &#125;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;
            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();
            FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());
            executor.submit(futureTask);
            System.out.println(futureTask.get());
        &#125;
    &#125;</code></pre></div>







<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p><code>ThreadGroup</code>可以对线程进行批量控制。每个<code>Thread</code>必然属于一个<code>ThreadGroup</code>。创建新线程是不显式指定，默认将父线程所属线程组设置成自己的线程组。</p>
<div class="code-wrapper"><pre><code class="hljs java">System.out.println(Thread.currentThread().getThreadGroup().getName());</code></pre></div>



<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干个时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配，线程分配到的时间片多少决定线程使用处理器资源的多少，而线程优先级就是决定线程需要多或少分配一些处理器资源的线程属性。</p>
<p>在<code>Java</code>线程中，通过一个priority来控制优先级，优先级范围从1~10，在线程构建的时候，可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级为5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>Java只是给操作系统一个优先级的<strong>参考值</strong>，线程最终<strong>在操作系统的优先级</strong>是由操作系统的<strong>线程调度算法</strong>决定的。</p>
<p>可以通过<code>Thread</code>中的<code>setPriority()</code>方法设置线程的优先级</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java线程在运行的生命周期中可能处于6种不同的状态，在给定的时刻，线程只能处于其中的一种状态。</p>
<table>
<thead>
<tr>
<th align="center">状态名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NEW</td>
<td align="center">初始状态，线程被构建，但是还没有调用start()方法</td>
</tr>
<tr>
<td align="center">RUNNABLE</td>
<td align="center">运行状态，Java线程将操作系统中的就绪和运行两种状态统称为运行</td>
</tr>
<tr>
<td align="center">BLOCKED</td>
<td align="center">阻塞状态，表示线程阻塞</td>
</tr>
<tr>
<td align="center">WAITING</td>
<td align="center">等待状态，进入该状态表示当前线程需要等待其他线程做出一些动作（通知或中断）</td>
</tr>
<tr>
<td align="center">TIME_WAITING</td>
<td align="center">限期等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">终止状态，表示当前线程执行完毕</td>
</tr>
</tbody></table>
<p>Java线程状态转换如图所示：</p>
<p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/IMG_0041.PNG" srcset="/img/loading.gif" lazyload alt="Java线程状态转换"></p>
<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持性线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个JVM种不存在非Daemon线程的时候，JVM将会退出。可以通过<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程。</p>
<p>在JVM退出时，Daemon线程中的finally块并不一定会执行。因此，在构建Daemon线程时，不能依靠finally块中的内存来确保执行关闭或清理资源的逻辑。</p>
<ul>
<li>垃圾回收线程是一种守护线程</li>
<li>Tomcat中的Acceptor和Poller线程都是守护线程。</li>
</ul>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作，其他线程通过调用该线程的<code>interrupt()</code>方法对其进行中断操作。</p>
<p>线程通过检查自身是否被中断来进行响应。线程通过<code>isinterrupted()</code>方法来判断是否被中断，也可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位。</p>
<p>在许多声明抛出<code>InterruptedException</code>的方法中，在抛出<code>InterruptedException</code>方法之前，JVM会将该线程的中断标识位清除，然后抛出，此时调用<code>isinterrupted()</code>将返回false。</p>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h3><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">notify()</td>
<td align="center">通知一个在对象的waitSet上等待的线程，使其从wait()方法返回，而返回的前提时该线程获得到了对象的锁</td>
</tr>
<tr>
<td align="center">notifyAll()</td>
<td align="center">通知所有等待在该对象上的线程</td>
</tr>
<tr>
<td align="center">wait()</td>
<td align="center">调用该方法的线程进入WAITING状态，<strong>进入waitSet等待</strong>。只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁</td>
</tr>
<tr>
<td align="center">wait(long)</td>
<td align="center">超时等待一段时间，这里的参数是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回</td>
</tr>
<tr>
<td align="center">wait(long,int)</td>
<td align="center">对于超时时间更细粒度的控制，可以达到纳秒</td>
</tr>
</tbody></table>
<p>等待&#x2F;通知机制，是指一个线程A调用了对象O的<code>wait()</code>方法进入等待状态，而另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>返回，进而执行后续操作。</p>
<p>使用等待&#x2F;通知机制需要注意以下细节：</p>
<ol>
<li>使用<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>时需要先对调用对象加锁。</li>
<li>调用<code>wait()</code>方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。</li>
<li><code>notify()</code>、<code>notifyAll()</code>方法调用后，等待线程依旧不会从<code>wait()</code>返回，需要调用<code>notify()</code>或<code>notifyAll()</code>的线程释放锁之后，等待线程才有机会从<code>wait()</code>返回。</li>
<li><code>notify()</code>方法将等待队列的一个等待线程从等待队列移到同步队列中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移同步队列，被移动的线程状态由WAITING变为BLOCKED。</li>
<li>从<code>wait()</code>方法返回的前提是获得了调用对象的锁。</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/4/4 21:07</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span>：</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span> &#123;

    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
        <span class="hljs-type">Thread</span> <span class="hljs-variable">waitThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wait</span>(),<span class="hljs-string">&quot;waitThread&quot;</span>);
        waitThread.start();
        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        <span class="hljs-type">Thread</span> <span class="hljs-variable">notifyThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Notify</span>(),<span class="hljs-string">&quot;notifyThread&quot;</span>);
        notifyThread.start();
    &#125;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wait</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
            <span class="hljs-comment">//加锁，拥有lock的监视器</span>
            <span class="hljs-keyword">synchronized</span> (lock)&#123;
                <span class="hljs-comment">//当条件不满足时，继续wait，同时释放了lock的锁</span>
                <span class="hljs-keyword">while</span> (flag)&#123;
                    <span class="hljs-keyword">try</span> &#123;
                        System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;flag is true. wait @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));
                        lock.wait();
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;

                    &#125;
                &#125;
                <span class="hljs-comment">//条件满足时，完成工作</span>
                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;flag is false, running @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));
            &#125;
        &#125;
    &#125;


    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notify</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
            <span class="hljs-comment">//加锁</span>
            <span class="hljs-keyword">synchronized</span> (lock)&#123;
                <span class="hljs-comment">//获取lock的锁，然后进行通知，通知时不会释放lock的锁</span>
                <span class="hljs-comment">//直到当前线程释放了lock后，waitThread才能从wait方法返回</span>
                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;hold lock, notify @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));
                lock.notifyAll();
                flag = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5000</span>);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;

            <span class="hljs-comment">//再次加锁</span>
            <span class="hljs-keyword">synchronized</span> (lock)&#123;
                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;hold lock again,sleep @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));
                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5000</span>);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

&#125;
</code></pre></div>

<p>输出：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[waitThread,<span class="hljs-number">5</span>,main]flag is true. wait @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">08</span>
<span class="hljs-attribute">Thread</span>[notifyThread,<span class="hljs-number">5</span>,main]hold lock, notify @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">09</span>
<span class="hljs-attribute">Thread</span>[notifyThread,<span class="hljs-number">5</span>,main]hold lock again,sleep @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">14</span>
<span class="hljs-attribute">Thread</span>[waitThread,<span class="hljs-number">5</span>,main]flag is false, running @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span></code></pre></div>

<p>WaitThread首先获取了对象的锁，然后调用对象的<code>wait()</code>方法，从而放弃了锁并进入了对象的等待队列<code>WaitQueue</code>，进入等待状态，由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用了对象的<code>notify()</code>方法，将WaitThread从<code>WaitQueue</code>移到<code>SynchronizedQueue</code>中，此时WaitThread的状态变为阻塞状态，NotifyThread释放了锁之后，WaitThread再次获取到锁并从<code>wait()</code>方法返回继续执行。</p>
<p>本例可以提炼出等待&#x2F;通知的经典范式，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。</p>
<p>消费者遵循如下原则：</p>
<ol>
<li>获取对象的锁</li>
<li>如果条件不满足，那么调用对象的<code>wait()</code>方法，被通知仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ol>
<p>对应伪代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象)&#123;
    <span class="hljs-keyword">while</span>(条件不满足)&#123;
        对象.wait();
    &#125;
    对应的处理逻辑
&#125;</code></pre></div>

<p>生产者遵循如下原则：</p>
<ol>
<li>获得对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<p>对应的伪代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象)&#123;
    改变条件
    对象.notifyAll();
&#125;</code></pre></div>



<h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><p>如果线程A执行了<code>thread.join()</code>方法，那么当前线程A等待thread线程终止之后才从<code>thread.join()</code>返回。</p>
<h3 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h3><ul>
<li>当一个线程执行sleep方法后，调用线程会暂时让出指定时间的执行权，也就是这段时间不参与CPU的调度，<strong>但是该线程持有的锁是不让出的。</strong>指定睡眠时间到了后该函数就会正常返回。</li>
<li>调用sleep会从Running状态进入Timed Waiting状态</li>
<li>其他线程可以使用<code>interrupt</code>方法</li>
<li><code>while(true)</code>语句中使用<code>sleep</code>可以避免CPU空转</li>
</ul>
<h3 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h3><ul>
<li>当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会获取到一个优先级最高的线程。</li>
<li>调用yield会让当前线程从Running进入Runnable状态。</li>
<li>具体实现依赖于OS的任务调度器。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Java%E5%B9%B6%E5%8F%91/" class="category-chain-item">Java并发</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91/" class="print-no-link">#并发</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java线程基础知识</div>
      <div>https://l1n.wang/2020/Java并发/Java线程基础知识/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lin Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年4月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/Spring%20Cloud/spring-cloud-alibaba-nacos/" title="Spring Cloud Alibaba Nacos">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring Cloud Alibaba Nacos</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/JVM/jvm09-bytecode-engine/" title="JVM之字节码执行引擎（九）">
                        <span class="hidden-mobile">JVM之字节码执行引擎（九）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'L1nker4/blog_comment');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       2018 - 2024 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/love.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
