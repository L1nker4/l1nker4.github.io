<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flink入门</title>
    <link href="/2024/Big-Data/flink-note/"/>
    <url>/2024/Big-Data/flink-note/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Flink是一个用于有状态的并行数据流的分布式计算系统，同时支持流式处理和批量处理。</p><p>实际数据分析应用都是面向无限数据流，三类通常使用有状态流处理实现的应用程序：</p><ol><li>事件驱动应用程序：使用特定的业务逻辑来提取事件流并处理事件。<ol><li>实时推荐、行为模式检测、异常检测</li></ol></li><li>数据管道应用程序：将数据从A组件复制到B组件的ETL流程，pipeline包括多个源（source）和接收器（sink）。<ol start="3"><li>实时数据仓库：数据实时清洗、归并、结构化</li></ol></li><li>数据流式分析应用程序：连续地提取事件流数据，并计算出最新结果并存储，用于查询。<ol><li>用户行为等实时数据分析</li></ol></li></ol><p>常见的流式处理框架对比：</p><table><thead><tr><th></th><th>Flink</th><th>Spark Streaming</th><th>Apache Storm</th></tr></thead><tbody><tr><td>架构</td><td>主从模式</td><td>主从模式，依赖Spark，每个Batch处理都依赖主节点</td><td>主从模式，依赖ZK</td></tr><tr><td>处理方式</td><td>Native</td><td>Micro-Batch</td><td>Native</td></tr><tr><td>容错</td><td>基于Chandy-Lamport distributed snapshots checkpoint机制</td><td>WAL与RDD机制</td><td>Record’s ACK</td></tr><tr><td>处理模式</td><td>单条事件处理、时间窗口划分的所有事件</td><td>时间窗口内的所有时间</td><td>单条事件处理</td></tr><tr><td>数据保证</td><td>exactly once</td><td>exactly once</td><td>at least once</td></tr><tr><td>API支持</td><td>high</td><td>high</td><td>low</td></tr><tr><td>社区活跃度</td><td>high</td><td>high</td><td>medium</td></tr><tr><td>部署性</td><td>部署简单，仅依赖JRE</td><td>部署简单，仅依赖JRE</td><td>依赖JRE和Zookeeper</td></tr></tbody></table><p>Flink优点：</p><ol><li>毫秒级延迟</li><li>统一数据处理组件栈，可以处理不同类型的数据需求</li><li>支持事件时间、接入时间、处理时间等概念</li><li>基于轻量级分布式快照实现的容错</li><li>支持有状态计算，灵活的state-backend（HDFS、内存、RocksDB）</li><li>满足Exactly-once需求</li><li>支持高度灵活的window操作</li><li>带反压的连续流模型</li><li>每秒千万级吞吐量</li><li>易用性：提供了SQL、Table API、Stream API等方式</li></ol><p>流式计算的时间窗口，涉及处理时间和事件时间，主要有以下区别：</p><ul><li>处理时间提供了低延迟，但不能保证准确性</li><li>事件时间保证了结果准确性，实时性较差</li></ul><p>结果保证：</p><ul><li>at-most-once：最多处理一次事件，事件可以被丢弃掉，也没有任何操作保证结果的正确性。</li><li>at-least-once：允许事件被多次处理，以此保证结果的正确性</li><li>exactly-once：恰好一次，最严格的保证，也最难实现，没有事件丢失，并且每个数据只处理一次。</li></ul><p>Flink相关概念：</p><ul><li>Task：一个阶段中，多个功能相同的subTask集合，一个Task就是一个可以链接的最小算子链，这样可以减少线程间切换导致的开销，提高整体的吞吐量。</li><li>SubTask：Flink任务最小执行单元（Java类），完成具体的计算逻辑。</li><li>Slot：对计算资源进行隔离的单元，一个Slot中可以运行多个subTask</li><li>State：运行过程中计算的中间结果</li><li>Source：数据源</li><li>Transformation：数据处理算子，包括map、filter、reduce</li><li>Sink：Flink作业的数据存放点，例如MySQL、Kafka</li><li>JobGraph：Flink运行任务的抽象图表达结构<ul><li>通过有向无环图DAG方式表达用户程序的执行流程</li><li>不同接口程序的统一抽象表达：DataStream API、Flink SQL、Table API等</li><li>转换流程：Application Code -&gt; StreamGraph -&gt; JobGraph</li></ul></li></ul><p>Task是概念上的任务，SubTask是实际提交给Task Slots的任务（单独的线程）。</p><p>部署模式：</p><ul><li>Session Mode（资源共享）：根据指定的资源初始化一个Flink集群，拥有固定数量的JobManager和TaskManager，所有Job在一个Runtime中运行。<ul><li>客户端通过RPC或者Rest API链接集群的管理节点</li><li>Deployer需要上传以来的Denpendences Jar</li><li>Deployer需要生成JobGraph，并提交到管理节点</li><li>JobManager的生命周期不受提交的Job影响。</li></ul></li><li>Per-Job Mode（deprecated）：基于资源协调框架为每一个提交的作业启动专属的Flink集群，作业完成后，资源将被关闭并清除，提供了良好的资源隔离能力。<ul><li><code>&gt; Per-job mode is only supported by YARN and has been deprecated in Flink 1.15. It will be dropped in [FLINK-26000](https://issues.apache.org/jira/browse/FLINK-26000). Please consider application mode to launch a dedicated cluster per-job on YARN.</code></li></ul></li><li>Application Mode<ul><li>运行在Cluster上，而不在客户端</li><li>每一个Application对应一个Runtime，Application中可以包含多个Job</li><li>客户端无需将Denpendencies上传到JobManager，仅负责提交Job</li><li>main方法运行在JobManager中，将JobGraph的生成放在Cluster中运行</li></ul></li></ul><p>当前支持以下资源管理器部署集群：</p><ul><li>Standalone</li><li>Hadoop Yarn</li><li>Apache Mesos</li><li>Docker</li><li>Kubernetes</li></ul><h1 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h1><p>Flink集群是类似于Master-Slave的结构，核心组件包括：</p><ul><li>JobManager：master节点，负责Flink作业的调度与执行，包括：Checkpoint Coordinator、jobGraph -&gt; Execution Graph、Task部署和调度、RPC通信(Actor System)、Job接收(Job Dispatch)、集群资源管理、TaskManager注册与管理<ul><li>ResourceManager：负责Flink集群中的资源提供、回收与分配。ResourceManager是Task Slot的管理者，slot是Flink定义的处理资源单元。接收到JobManager的资源请求时，会将存在空闲slot的TaskManager分配给JobManager执行任务。</li><li>Dispatcher：提供了Restful接口用于提交Flink程序，并为每个提交的作业启动一个新的JobMaster。</li><li>JobMaster：负责单个JobGraph的执行。</li></ul></li><li>TaskManager：worker节点，负责实际SubTask的执行，并且缓存数据流。每个TaskManager都拥有Task Slot，slot由ResourceManager统一管理。功能包括：<ul><li>Task Execution</li><li>Network Manager</li><li>Shuttle Environment manager</li><li>RPC system</li><li>Data Exchange</li><li>Offer Slots to JobManager</li></ul></li><li>Client：用户运行的main方法进程，包括以下功能：<ul><li>JobGraph Generate</li><li>Execution Environment manager</li><li>Job Submit</li><li>RPC with JobManager</li><li>Cluster Deploy</li></ul></li></ul><h1 id="Flink编程模型"><a href="#Flink编程模型" class="headerlink" title="Flink编程模型"></a>Flink编程模型</h1><ol><li>创建Flink程序执行环境</li><li>从数据源source读取一条或多条数据</li><li>使用算子实现业务逻辑（transformation）</li><li>将计算结果输出（sink）</li></ol><h1 id="Flink-API"><a href="#Flink-API" class="headerlink" title="Flink API"></a>Flink API</h1><p>Flink根据抽象程度，将API分为以下三类，分别适用不同的应用场景：</p><ul><li>SQL&#x2F; Table API</li><li>DataStream API</li><li>ProcessFuction</li></ul><h1 id="DataStream-API"><a href="#DataStream-API" class="headerlink" title="DataStream API"></a>DataStream API</h1><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>从文件读取数据：</p><div class="code-wrapper"><pre><code class="hljs java">DataStreamSource&lt;String&gt; source = env.readTextFile(<span class="hljs-string">&quot;/tmp/data&quot;</span>);</code></pre></div><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>从Socket读取数据：</p><div class="code-wrapper"><pre><code class="hljs java">DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8089</span>);</code></pre></div><p>可以通过nc等工具，本地调试验证。</p><h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><p>从变量读取数据：</p><div class="code-wrapper"><pre><code class="hljs java">DataStreamSource&lt;String&gt; source = env.fromCollection(collection);DataStream&lt;SensorReading&gt; source = env.fromElements(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>())</code></pre></div><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>从Kafka读取数据：</p><p>存在Kafka Source、Kafka Consumer两种读取方式。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">flink.version</span>&gt;</span>1.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">flink.version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-runtime-web_$&#123;scala.binary.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java">KafkaSource&lt;String&gt; kafkaSource = KafkaSource.&lt;String&gt;builder()          .setBootstrapServers(<span class="hljs-string">&quot;192.168.1.100:9092&quot;</span>)          .setTopics(<span class="hljs-string">&quot;test_topic&quot;</span>)          .setGroupId(<span class="hljs-string">&quot;flink-demo&quot;</span>)          .setStartingOffsets(OffsetsInitializer.earliest())          .setValueOnlyDeserializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleStringSchema</span>())          .build();    DataStreamSource&lt;String&gt; source = env.fromSource(kafkaSource, WatermarkStrategy.noWatermarks(), <span class="hljs-string">&quot;Kafka Source&quot;</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">consumerProperties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  consumerProperties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">&quot;192.168.1.100:9092&quot;</span>);  consumerProperties.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="hljs-string">&quot;flink-demo&quot;</span>);  DataStreamSource&lt;String&gt; source =          env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlinkKafkaConsumer</span>&lt;&gt;(<span class="hljs-string">&quot;test_topic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleStringSchema</span>(), consumerProperties));</code></pre></div><h3 id="自定义Source"><a href="#自定义Source" class="headerlink" title="自定义Source"></a>自定义Source</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction;<span class="hljs-keyword">import</span> java.util.Calendar;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SensorSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RichParallelSourceFunction</span>&lt;SensorReading&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(SourceContext&lt;SensorReading&gt; srcCtx)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();        String[] sensorIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];        <span class="hljs-type">double</span>[] curFTemp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            sensorIds[i] = <span class="hljs-string">&quot;sensor_&quot;</span> + i;            curFTemp[i] = <span class="hljs-number">65</span> + (rand.nextGaussian() * <span class="hljs-number">20</span>);        &#125;        <span class="hljs-keyword">while</span> (running) &#123;            <span class="hljs-type">long</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> Calendar.getInstance().getTimeInMillis();            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                curFTemp[i] += rand.nextGaussian() * <span class="hljs-number">0.5</span>;                srcCtx.collect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SensorReading</span>(sensorIds[i], curTime, curFTemp[i]));            &#125;            Thread.sleep(<span class="hljs-number">100</span>);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.running = <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java">DataStream&lt;SensorReading&gt; sensorData = env.addSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SensorSource</span>());</code></pre></div><h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><p>算子负责将一个或多个DataStream转换为新的DataStream,，转换算子可以分为以下四类：</p><ul><li>基本转换算子：作用在数据流中的每一条单独数据上。</li><li>KeyedStream转换算子，在数据有key的情况下，对数据应用转换算子。</li><li>多流转换算子：合并多条流为一条流，或者将一条流分割为多条流。</li><li>分布式转换算子：将重新组织流里面的事件。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Java Lambda Stream Map用法。</p><p>转换关系：将1个元素，转换为1个新元素。</p><p>Example：将输入元素自增1</p><div class="code-wrapper"><pre><code class="hljs java">source.map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapFunction</span>&lt;Integer, Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">map</span><span class="hljs-params">(Integer value)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">return</span> value + <span class="hljs-number">1</span>;    &#125;&#125;);</code></pre></div><h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p>转换关系：将1个元素，转换为任意个元素。</p><p>Example：将输入的String，按照<code> </code>进行拆分</p><div class="code-wrapper"><pre><code class="hljs java">dataStream.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlatMapFunction</span>&lt;String, String&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatMap</span><span class="hljs-params">(String value, Collector&lt;String&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">for</span>(String word: value.split(<span class="hljs-string">&quot; &quot;</span>))&#123;            out.collect(word);        &#125;    &#125;&#125;);</code></pre></div><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>按照设置的条件过滤，筛选出符合条件的元素。</p><p>Example: 过滤空串</p><div class="code-wrapper"><pre><code class="hljs java">source.filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterFunction</span>&lt;String&gt;() &#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <span class="hljs-keyword">return</span> StringUtils.isNotBlank(s);  &#125;&#125;);</code></pre></div><h3 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h3><p>将DataStream转换为KeyedStream：将key值相同的记录分配到相同的分区，类似于SQL的group by。</p><div class="code-wrapper"><pre><code class="hljs java">source.keyBy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KeySelector</span>&lt;Tuple2&lt;String, Integer&gt;, String&gt;() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getKey</span><span class="hljs-params">(Tuple2&lt;String, Integer&gt; value)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-keyword">return</span> value.f0;      &#125;  &#125;)</code></pre></div><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>将KeyedStream转换为DataStream：将数据流中的元素与上一个Reduce后的元素进行合并产生一个新值，一般作用于有界数据流。</p><div class="code-wrapper"><pre><code class="hljs java">keyedStream.reduce(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReduceFunction</span>&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">reduce</span><span class="hljs-params">(Integer value1, Integer value2)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">return</span> value1 + value2;    &#125;&#125;);</code></pre></div><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>将两个以上的DataStream合并成一个。</p><div class="code-wrapper"><pre><code class="hljs java">dataStream.union(stream1, stream2...);</code></pre></div><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>连接两个DataStream，允许两个流之间共享数据，与union有所区别：</p><ol><li>union支持多个，connect仅支持两个</li><li>union要求流的数据类型一致，connect允许类型不一样。</li><li>connect允许两个流有不同的处理逻辑。</li></ol><h3 id="CoMap"><a href="#CoMap" class="headerlink" title="CoMap"></a>CoMap</h3><p>对被Connect后的ConnectedStream执行map</p><div class="code-wrapper"><pre><code class="hljs java">connectedStreams.map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CoMapFunction</span>&lt;Integer, String, Boolean&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">map1</span><span class="hljs-params">(Integer value)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">map2</span><span class="hljs-params">(String value)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;);</code></pre></div><h3 id="CoFlatMap"><a href="#CoFlatMap" class="headerlink" title="CoFlatMap"></a>CoFlatMap</h3><p>对被Connect后的ConnectedStream执行FlatMap</p><div class="code-wrapper"><pre><code class="hljs java">connectedStreams.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CoFlatMapFunction</span>&lt;Integer, String, String&gt;() &#123;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatMap1</span><span class="hljs-params">(Integer value, Collector&lt;String&gt; out)</span> &#123;       out.collect(value.toString());   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatMap2</span><span class="hljs-params">(String value, Collector&lt;String&gt; out)</span> &#123;       <span class="hljs-keyword">for</span> (String word: value.split(<span class="hljs-string">&quot;,&quot;</span>)) &#123;         out.collect(word);       &#125;   &#125;&#125;);</code></pre></div><h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><p>数据交换策略决定将输入流通过何种策略输出到下游算子的并行任务。</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>将数据随机分配到下游算子的并行任务中。</p><div class="code-wrapper"><pre><code class="hljs java">source.shuffle();</code></pre></div><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>使用轮询方式将输入流平均分配到下游算子的并行任务中，它会与所有的下游算子联系，默认的交换策略。</p><div class="code-wrapper"><pre><code class="hljs java">source.rebalance();</code></pre></div><h3 id="Rescale"><a href="#Rescale" class="headerlink" title="Rescale"></a>Rescale</h3><p>将数据发送到一部分的下游算子的并行任务中。</p><div class="code-wrapper"><pre><code class="hljs java">source.rescale();</code></pre></div><h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><p>将数据发送到下游算子的所有并行任务中。</p><div class="code-wrapper"><pre><code class="hljs java">source.broadcast();</code></pre></div><h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><p>将数据发送到下游算子的第一个并行任务中。</p><div class="code-wrapper"><pre><code class="hljs java">source.global();</code></pre></div><h3 id="Custom"><a href="#Custom" class="headerlink" title="Custom"></a>Custom</h3><p>自定义分区策略，使用<code>partitionCustom()</code></p><h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>Sink负责对计算结果的输出，Flink支持的Sink组件包括：Kafka、ES、Redis等。</p><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p>将数据输出到控制台，用于调试阶段。</p><div class="code-wrapper"><pre><code class="hljs java">dataStream.print();</code></pre></div><h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.flink<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flink-connector-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 定义 kafka sink</span><span class="hljs-type">Properties</span> <span class="hljs-variable">produceProperties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();produceProperties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, KAFKA_BROKER_SERVERS);FlinkKafkaProducer&lt;String&gt; kafkaProducer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlinkKafkaProducer</span>&lt;&gt;(    <span class="hljs-string">&quot;test&quot;</span>,    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleStringSchema</span>(),    produceProperties);dataStream.addSink(kafkaProducer);</code></pre></div><h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><p>对于流式数据（无界），部分计算指标不存在实际意义，Window主要解决无界性问题，按照规则将其划分成有界数据，用于业务逻辑的处理。</p><p>Keyed vs Non-Keyed：定义Window时，需要确认数据流是否调用过keyBy()方法。</p><p>keyBy()后的Stream支持多个窗口并行计算，可以按照key拆分数据流并行计算，Non-Keyed Stream只支持并行度为1的计算。</p><p>模板：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// Keyed Window</span>stream       .keyBy(...)               &lt;-  仅 keyed 窗口需要       .window(...)              &lt;-  必填项：<span class="hljs-string">&quot;assigner&quot;</span>      [.trigger(...)]            &lt;-  可选项：<span class="hljs-string">&quot;trigger&quot;</span> (省略则使用默认 trigger)      [.evictor(...)]            &lt;-  可选项：<span class="hljs-string">&quot;evictor&quot;</span> (省略则不使用 evictor)      [.allowedLateness(...)]    &lt;-  可选项：<span class="hljs-string">&quot;lateness&quot;</span> (省略则为 <span class="hljs-number">0</span>)      [.sideOutputLateData(...)] &lt;-  可选项：<span class="hljs-string">&quot;output tag&quot;</span> (省略则不对迟到数据使用 side output)       .reduce/aggregate/apply()      &lt;-  必填项：<span class="hljs-string">&quot;function&quot;</span>      [.getSideOutput(...)]      &lt;-  可选项：<span class="hljs-string">&quot;output tag&quot;</span><span class="hljs-comment">// Non-Keyed Window</span>stream       .windowAll(...)           &lt;-  不分组，将数据流中的所有元素分配到相应的窗口中      [.trigger(...)]            &lt;-  指定触发器Trigger（可选）      [.evictor(...)]            &lt;-  指定清除器Evictor(可选)       .reduce/aggregate/process()      &lt;-  窗口处理函数Window Function</code></pre></div><h2 id="Window-schema"><a href="#Window-schema" class="headerlink" title="Window schema"></a>Window schema</h2><p>决定数据流入窗口的策略</p><h3 id="Tumbling-Window"><a href="#Tumbling-Window" class="headerlink" title="Tumbling Window"></a>Tumbling Window</h3><p>滚动窗口：固定大小、不可重叠</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// tumbling event-time windows  </span>input  .keyBy(&lt;key selector&gt;)  .window(TumblingEventTimeWindows.of(Time.seconds(<span class="hljs-number">5</span>)))  .&lt;windowed transformation&gt;(&lt;window function&gt;);</code></pre></div><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>滑动窗口：固定大小、允许重叠</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// sliding event-time windows  </span>input  .keyBy(&lt;key selector&gt;)  .window(SlidingEventTimeWindows.of(Time.seconds(<span class="hljs-number">10</span>), Time.seconds(<span class="hljs-number">5</span>)))  .&lt;windowed transformation&gt;(&lt;window function&gt;);</code></pre></div><h3 id="Session-Window"><a href="#Session-Window" class="headerlink" title="Session Window"></a>Session Window</h3><p>当一个窗口在大于session gap的时间内没有接收到新数据，就会被关闭<br>i<br>会话窗口：不会重叠，也没有固定的起始时间，关闭取决于session gap的触发。</p><h2 id="Window-Function"><a href="#Window-Function" class="headerlink" title="Window Function"></a>Window Function</h2><p>Stream指定窗口划分数据后，需要执行计算逻辑，通常包括以下三种。</p><h3 id="ReduceFunction"><a href="#ReduceFunction" class="headerlink" title="ReduceFunction"></a>ReduceFunction</h3><p>可以将输入流中前后两个元素进行合并操作，并输出类型相同的新元素。</p><h3 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h3><p>可以将输入元素进行增量聚合</p><p>AggregateFunction接口定义了以下4个方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PublicEvolving</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AggregateFunction</span>&lt;IN, ACC, OUT&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>, Serializable &#123;  <span class="hljs-comment">//创建初始累加器</span>    ACC <span class="hljs-title function_">createAccumulator</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//累加输入元素到累加器</span>    ACC <span class="hljs-title function_">add</span><span class="hljs-params">(IN value, ACC accumulator)</span>;  <span class="hljs-comment">//从累加器提取输出结果</span>    OUT <span class="hljs-title function_">getResult</span><span class="hljs-params">(ACC accumulator)</span>;  <span class="hljs-comment">//合并累加器</span>    ACC <span class="hljs-title function_">merge</span><span class="hljs-params">(ACC a, ACC b)</span>;  &#125;</code></pre></div><p>计算一个窗口内的平均数：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AverageAccumulator</span> &#123;      <span class="hljs-type">long</span> count;      <span class="hljs-type">long</span> sum;  &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeightedAverage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AggregateFunction</span>&lt;Double, AverageAccumulator, Double&gt; &#123;        <span class="hljs-keyword">public</span> AverageAccumulator <span class="hljs-title function_">createAccumulator</span><span class="hljs-params">()</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AverageAccumulator</span>();      &#125;        <span class="hljs-keyword">public</span> AverageAccumulator <span class="hljs-title function_">merge</span><span class="hljs-params">(AverageAccumulator a, AverageAccumulator b)</span> &#123;          a.count += b.count;          a.sum += b.sum;          <span class="hljs-keyword">return</span> a;      &#125;        <span class="hljs-keyword">public</span> AverageAccumulator <span class="hljs-title function_">add</span><span class="hljs-params">(Double value, AverageAccumulator acc)</span> &#123;          acc.count += value;          acc.sum += value;          <span class="hljs-keyword">return</span> acc;      &#125;        <span class="hljs-keyword">public</span> Double <span class="hljs-title function_">getResult</span><span class="hljs-params">(AverageAccumulator acc)</span> &#123;          <span class="hljs-keyword">return</span> acc.sum / (<span class="hljs-type">double</span>) acc.count;      &#125;    &#125;</code></pre></div><h3 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h3><p>ProcessWindowFunction包含了以下内容：</p><ul><li>IN：输入元素类型</li><li>OUT：输出元素类型</li><li>KEY：用于分区字段的类型</li><li>W：可被使用的窗口函数类型</li></ul><p>使用起来更灵活，可以缓存窗口所有数据。</p><h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><p>决定Window Function启动时机和窗口数据清理时机。</p><h2 id="Evictor"><a href="#Evictor" class="headerlink" title="Evictor"></a>Evictor</h2><p>在Trigger触发后、调用Window Function之前或者之后从窗口中删除数据。</p><p>Flink内置三个Evictor：</p><ul><li>CountEvictor：仅记录用户指定数量的元素，一旦窗口元素超过指定值，多余元素从开头进行移除。</li><li>DeltaEvictor：接收指定的threshold参数，计算窗口内最后一个元素和其他所有元素的差值，并移除差值&gt;&#x3D; threshold的元素。</li><li>TimeEvictor：接收interval参数，找到窗口中元素最大的timestamp，并移除比max - interval小的所有元素。</li></ul><h1 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h1><p>数据乱序场景时，当新数据输入进来触发窗口关闭后，旧数据找不到对应窗口就会丢失。</p><p>Watermark是用来度量数据event-time进展的字段，表明在watermark之前时间的数据都已经接收。</p><p>Watermark（水位线）：一条特殊的数据记录，以长整型值保存了一个时间戳，有两个基本属性：</p><ol><li>必须单调递增，以确保任务的时间再向前推进</li><li>必须与数据的时间戳相关，后续的数据时间戳都必须大于它，可用于处理时间乱序数据流。</li></ol><h2 id="Watermark策略"><a href="#Watermark策略" class="headerlink" title="Watermark策略"></a>Watermark策略</h2><p>Flink需要从每个元素中提取可分配的时间戳，通常使用TimestampAssigner从元素某个字段提取出时间戳，同时通过指定WatermarkGenerator配置watermark生成策略。</p><p>Flink可以通过两种方式生成watermark：</p><ol><li>数据源source分配：通过SourceFunction分配watermark</li><li>设置WatermarkStrategy</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">StreamExecutionEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();DataStream&lt;MyEvent&gt; stream = env.readFile(        myFormat, myFilePath, FileProcessingMode.PROCESS_CONTINUOUSLY, <span class="hljs-number">100</span>,        FilePathFilter.createDefaultFilter(), typeInfo);DataStream&lt;MyEvent&gt; withTimestampsAndWatermarks = stream        .filter( event -&gt; event.severity() == WARNING )        .assignTimestampsAndWatermarks(&lt;watermark strategy&gt;);withTimestampsAndWatermarks        .keyBy( (event) -&gt; event.getGroup() )        .window(TumblingEventTimeWindows.of(Time.seconds(<span class="hljs-number">10</span>)))        .reduce( (a, b) -&gt; a.add(b) )        .addSink(...);</code></pre></div><h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><h2 id="Sate-Backend"><a href="#Sate-Backend" class="headerlink" title="Sate Backend"></a>Sate Backend</h2><p>State Backend是状态的管理组件，主要解决两个问题：</p><ol><li>管理本地状态，包括访问、存储和更新</li><li>checkpoint被激活时，决定状态同步的方式和位置</li></ol><h1 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h1><p>Flink作为一个分布式计算系统，需要有一套机制用于满足分区容错性，处理各类故障。</p><p>Flink主要提供了checkpoint与流重放相结合的机制来解决。</p><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>Flink恢复机制的核心就是应用状态的一致检查点，checkpoint会每隔一段时间就保存一份snapshot，它包含了数据流中所有任务在某个时间点的状态信息。如果发生故障，使用最近的checkpoint恢复状态，并重启处理流程。</p><p>Flink基于Chandy-Lamport算法实现分布式快照的checkpoint的保存，该算法不会暂停整个应用程序，将保存流程和数据处理流程分离。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">StreamExecutionEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  env.enableCheckpointing(<span class="hljs-number">5000</span>);</code></pre></div><p>TODO：算法细节</p><h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>从checkpoint触发开始到checkpoint成功生成快照的过程中，如何判断哪些数据需要在当前checkpoint阶段进行保存，使用Barrier进行隔离。</p><p>特点：</p><ul><li>随数据流传递的数据字段</li><li>以广播的方式向下游传递</li></ul><h3 id="Storage-Location"><a href="#Storage-Location" class="headerlink" title="Storage Location"></a>Storage Location</h3><ul><li>JobManagerCheckpointStorage：状态保存在JobManager的内存堆<ul><li>通常用于本地开发测试</li></ul></li><li>FileSystemCheckpointStorage：状态保存到checkpointDirectory指向<ul><li>本地或远程</li></ul></li></ul><h3 id="保留模式"><a href="#保留模式" class="headerlink" title="保留模式"></a>保留模式</h3><p>作业取消后，checkpoint是否保留，提供了两个参数：</p><ul><li>DELETE_ON_CANCELLATION：Flink 作业取消后删除 checkpoint 文件</li><li>RETAIN_ON_CANCELLATION：Flink 作业取消后保留 checkpoint 文件</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">CheckpointConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> env.getCheckpointConfig();  config.enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</code></pre></div><h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><p>作业出现故障后，Flink会停止数据流，将数据流重置到checkpoint最新生成的快照，包括两种恢复策略：</p><ul><li>Restart：决定了是否重启、何时重启作业</li><li>Failover：决定应该重启哪些任务</li></ul><blockquote><p><a href="https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/execution/task_failure_recovery/">https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/execution/task_failure_recovery/</a></p></blockquote><h2 id="savepoint"><a href="#savepoint" class="headerlink" title="savepoint"></a>savepoint</h2><p>允许应用程序从指定savepoint启动程序，创建savepoint的算法和checkpoint完全相同，可以认为是具有一些额外元数据的checkpoint，Flink不会自动创建，由外部程序触发创建操作。</p><h2 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h2><p>反压通常发生于的场景：短时间内系统接收数据的速率远高于处理数据的速率。因此需要对上游进行限速。</p>]]></content>
    
    
    <categories>
      
      <category>Big Data</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存问题排查流程</title>
    <link href="/2024/JVM/JVM%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/JVM/JVM%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="确认问题现象"><a href="#确认问题现象" class="headerlink" title="确认问题现象"></a>确认问题现象</h2><p>可以通过服务状态，监控面板、日志信息、监控工具（VisualVM）等，确认问题类型：</p><ol><li>内存使用率居高不下、内存缓慢增加、OOM等</li><li>频繁GC：Full GC等</li></ol><p>发现问题不建议重启，留存状态。</p><h2 id="保留数据"><a href="#保留数据" class="headerlink" title="保留数据"></a>保留数据</h2><h3 id="heapdump文件"><a href="#heapdump文件" class="headerlink" title="heapdump文件"></a>heapdump文件</h3><div class="code-wrapper"><pre><code class="hljs ruby"><span class="hljs-comment">#arthas导出方式</span>heapdump /tmp/dump.hprof<span class="hljs-comment">#jmap命令保存整个Java堆</span>jmap -<span class="hljs-symbol">dump:</span>format=b,file=heap.bin &lt;pid&gt; <span class="hljs-comment">#jmap命令只保存Java堆中的存活对象, 包含live选项，会在堆转储前执行一次Full GC</span>jmap -<span class="hljs-symbol">dump:</span>live,format=b,file=heap.bin &lt;pid&gt;<span class="hljs-comment">#jcmd命令保存整个Java堆,Jdk1.7后有效</span>jcmd &lt;pid&gt; <span class="hljs-variable constant_">GC</span>.heap_dump filename=heap.bin<span class="hljs-comment">#在出现OutOfMemoryError的时候JVM自动生成（推荐）节点剩余内存不足heapdump会生成失败</span>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+HeapDumpOnOutOfMemoryError</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:HeapDumpPath=/tmp/heap</span>.bin<span class="hljs-comment">#编程的方式生成</span>使用<span class="hljs-title class_">HotSpotDiagnosticMXBean</span>.dumpHeap()方法<span class="hljs-comment">#在出现Full GC前后JVM自动生成，本地快速调试可用</span>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+HeapDumpBeforeFullGC</span>或 -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+HeapDumpAfterFullGC</span></code></pre></div><p>JVM参数：</p><div class="code-wrapper"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:printGCDetails</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseConcMarkSweepGC</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+HeapDumpOnOutOfMemoryError</span></code></pre></div><h3 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h3><p>JVM启动参数如下：</p><div class="code-wrapper"><pre><code class="hljs ruby"><span class="hljs-comment"># Java8及以下</span>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDetails</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDateStamps</span> -<span class="hljs-title class_">Xloggc</span><span class="hljs-symbol">:&lt;path&gt;</span><span class="hljs-comment"># Java9及以上</span>-<span class="hljs-title class_">Xlog</span><span class="hljs-symbol">:gc*</span><span class="hljs-symbol">:&lt;path&gt;</span><span class="hljs-symbol">:time</span></code></pre></div><p>可以通过EasyGC进行日志分析。</p><h3 id="服务日志"><a href="#服务日志" class="headerlink" title="服务日志"></a>服务日志</h3><p>通常由日志组件（Promtail &amp; loki）进行采集、存储、展示。</p><h2 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h2><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><p>问题现象：</p><ol><li>OutOfMemoryError</li></ol><h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><p>问题现象：top指令中相关Java进程占用的RES超过了-Xmx的大小，并且内存占用不断上升。</p><p>问题定位方法：</p><ol><li>可通过开启NMT（**-XX:NativeMemoryTracking&#x3D;detail**）定位问题</li><li>jcmd查看直接内存情况：jcmd pid VM.native_memory detail</li></ol><p>NIO、Netty等常用直接内存，Netty可以通过<code>-Dio.netty.leakDetectionLevel</code>开启</p><h3 id="栈空间溢出"><a href="#栈空间溢出" class="headerlink" title="栈空间溢出"></a>栈空间溢出</h3><p>问题现象：</p><ol><li>StackOverflow</li><li>OutOfMemoryError：unable to create new native thread</li></ol><p>问题定位方法：</p><ol><li>分析Java调用栈</li><li>开启Linux coredump日志</li></ol><h3 id="频繁GC"><a href="#频繁GC" class="headerlink" title="频繁GC"></a>频繁GC</h3><p>问题现象：通过监控面板、jstat等方式，发生频繁GC现象：</p><ol><li>Minor GC：回收新生代区域</li><li>Major GC：回收老年代区域</li><li>Full GC：回收整个堆区和方法区</li><li>Mixed GC：回收整个新生代和部分老年代，部分GC实现（G1）</li></ol><h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>用于查看虚拟机垃圾回收的情况，主要是堆内存使用、垃圾回收次数和占用时间</p><div class="code-wrapper"><pre><code class="hljs shell">jstat -gcutil  -h 20 pid 1000 100各列分别为：S0使用率、S1使用率、Eden使用率、Old使用率Method方法区使用率、CCS压缩使用率YGC年轻代垃圾回收次数、YGCT年轻代垃圾回收占用时间FGC全局垃圾回收次数、FGCT全局垃圾回收消耗时间GCT总共垃圾回收时间</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2023/png/406326/1675906799781-537c7346-3eb0-4b60-91e9-64ca73e0b215.png#averageHue=%230b0806&clientId=u200445ac-f1ae-4&from=paste&height=241&id=ub7219716&originHeight=316&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63366&status=done&style=none&taskId=ue414be00-c4c6-4321-ba74-055bf4a9997&title=&width=731" alt="image.png"></p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>用于保存虚拟机内存镜像到文件中，可以使用JVisualVM或MAT进行分析</p><div class="code-wrapper"><pre><code class="hljs shell">jmap -dump:format=b,file=filename.hprof pid</code></pre></div><p>也可以通过运行参数，当发生OOM时，主动保存堆dump文件。</p><div class="code-wrapper"><pre><code class="hljs shell">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof</code></pre></div><h3 id="JMC"><a href="#JMC" class="headerlink" title="JMC"></a>JMC</h3><p>Java Mission Control：用于追踪热点代码和热点线程</p><h2 id="附JVM参数"><a href="#附JVM参数" class="headerlink" title="附JVM参数"></a>附JVM参数</h2><h4 id="Xms512m"><a href="#Xms512m" class="headerlink" title="-Xms512m"></a>-Xms512m</h4><ul><li>意义： 设置堆内存初始值大小。</li><li>默认值：如果未设置，初始值将是老年代和年轻代分配制内存之和。</li></ul><h4 id="Xmx1024m"><a href="#Xmx1024m" class="headerlink" title="-Xmx1024m"></a>-Xmx1024m</h4><ul><li>意义： 设置堆内存最大值。</li></ul><h4 id="XX-NewRatio-n"><a href="#XX-NewRatio-n" class="headerlink" title="-XX:NewRatio&#x3D;n"></a>-XX:NewRatio&#x3D;n</h4><ul><li>意义：设置老年代和年轻代的比例。比如：-XX:NewRatio&#x3D;2</li></ul><p>-XX:SurvivorRatio<br>年轻代分配：默认情况下Eden、From、To的比例是8:1:1。SurvivorRatio默认值是8，如果SurvivorRatio修改成4，那么其比例就是4:1:1</p><h4 id="XX-MaxRAMPercentage-85-0"><a href="#XX-MaxRAMPercentage-85-0" class="headerlink" title="-XX:MaxRAMPercentage&#x3D;85.0"></a>-XX:MaxRAMPercentage&#x3D;85.0</h4><p>堆的最大值百分比</p><h4 id="Xalwaysclassgc"><a href="#Xalwaysclassgc" class="headerlink" title="-Xalwaysclassgc"></a>-Xalwaysclassgc</h4><p>在全局垃圾回收期间始终执行动态类卸载检查。</p><h4 id="Xaggressive"><a href="#Xaggressive" class="headerlink" title="-Xaggressive"></a>-Xaggressive</h4><p>Enables performance optimizations and new platform exploitation that are expected to be the default in future releases.</p><h4 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h4><p>打印GC日志</p><h4 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:+PrintGCTimeStamps"></a>-XX:+PrintGCTimeStamps</h4><p>打印GC时间戳</p><h4 id="Xloggc"><a href="#Xloggc" class="headerlink" title="-Xloggc"></a>-Xloggc</h4><p>GC日志存储位置</p><h4 id="verbose-class"><a href="#verbose-class" class="headerlink" title="-verbose:class"></a>-verbose:class</h4><p>用于同时跟踪类的加载和卸载 </p><h4 id="XX-TraceClassLoading"><a href="#XX-TraceClassLoading" class="headerlink" title="-XX:+TraceClassLoading"></a>-XX:+TraceClassLoading</h4><p>单独跟踪类的加载</p><h4 id="XX-TraceClassUnloading"><a href="#XX-TraceClassUnloading" class="headerlink" title="-XX:+TraceClassUnloading"></a>-XX:+TraceClassUnloading</h4><p>单独跟踪类的卸载</p><h4 id="XX-NativeMemoryTracking-off-summary-detail"><a href="#XX-NativeMemoryTracking-off-summary-detail" class="headerlink" title="-XX:NativeMemoryTracking&#x3D;[off | summary | detail ]"></a>-XX:NativeMemoryTracking&#x3D;[off | summary | detail ]</h4><p>开启直接内存追踪</p><h4 id="XX-MaxDirectMemorySize"><a href="#XX-MaxDirectMemorySize" class="headerlink" title="-XX:MaxDirectMemorySize"></a>-XX:MaxDirectMemorySize</h4><p>最大直接内存</p><h4 id="XX-MaxJavaStackTraceDepth"><a href="#XX-MaxJavaStackTraceDepth" class="headerlink" title="-XX:MaxJavaStackTraceDepth"></a>-XX:MaxJavaStackTraceDepth</h4><p>栈帧输出数量</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《软件研发效能之美》思维导图</title>
    <link href="/2024/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD%E4%B9%8B%E7%BE%8E%E3%80%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2024/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD%E4%B9%8B%E7%BE%8E%E3%80%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87%E4%B9%8B%E7%BE%8E.png" alt="软件研发效能提升之美-思维导图"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>研发效能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>研发效能</tag>
      
      <tag>DevOps</tag>
      
      <tag>项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSDI&#39;10 《Finding a needle in Haystack Facebook’s photo storage》</title>
    <link href="/2023/Paper%20Reading/Finding-a-needle-in-Haystack-Facebook%E2%80%99s-photo-storage/"/>
    <url>/2023/Paper%20Reading/Finding-a-needle-in-Haystack-Facebook%E2%80%99s-photo-storage/</url>
    
    <content type="html"><![CDATA[<h2 id="业务量级"><a href="#业务量级" class="headerlink" title="业务量级"></a>业务量级</h2><p>FaceBook存储超过2600亿张图片，20PB，一周存储10亿张，峰值每秒100W图片。一次性写、不修改、很少删除的图片数据。</p><h2 id="原始设计的挑战"><a href="#原始设计的挑战" class="headerlink" title="原始设计的挑战"></a>原始设计的挑战</h2><p>访问webserver，获取图片URL，先去CDN获取，cache hit则返回，miss则去Storage加载到CDN再返回。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20231125152100170.png" alt="Typical Design"></p><p>当文件存储NAS的文件夹存储数千个文件时，请求单个图片的请求会产生多于10次的磁盘IO，即使文件夹内文件数量下降到几百时，还是会产生三次磁盘IO。</p><p>可以看出，原始架构的性能瓶颈：读操作存在多次磁盘IO。</p><p>传统POSIX filesystem缺点：文件元信息，例如权限等信息占用较多存储成本。对于巨量数据的情况，成本极大，对于NAS，一个文件读写需要三次磁盘IO：</p><ol><li>根据filename获取inode number</li><li>读取指定inode</li><li>读取文件信息本身</li></ol><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>Haystack结构实现的四个目标：</p><ol><li>高吞吐量与低延迟：所有metadata都存储在内存，最多执行一次磁盘IO</li><li>容错：异地容灾</li><li>低成本</li><li>简单</li></ol><h2 id="新设计"><a href="#新设计" class="headerlink" title="新设计"></a>新设计</h2><p>Haystack主要解决上述架构的瓶颈问题：多次磁盘IO，关键方法：将多个图片存储为单个大文件，由此仅需要保存大文件的文件元信息。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20231125190839452.png" alt="Haystack架构"></p><p>Haystack架构包括以下三部分：</p><ol><li>Haystack Store：真正存储文件的组件，管理文件系统元信息。使用物理volume进行管理，可以将不同主机上的某些物理volume组成一个逻辑volume，这样就可以产生多份副本，进行容错或分流。</li><li>Haystack Directory：管理逻辑到物理volume的映射关系，以及一些应用元信息，例如图片到逻辑volume的映射，逻辑volume的空闲空间等信息。</li><li>Haystack Cache：内部缓存CDN，减少对外部CDN的依赖。</li></ol><p>浏览器从Haystack Directory组件获取到的URL如下：</p><div class="code-wrapper"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>〈CDN〉<span class="hljs-regexp">/〈Cache〉/</span>〈Machine id〉/〈Logical volume, Photo〉</code></pre></div><p> CDN，Haystack Cache层如果hit cache就返回，否则去掉该层地址，请求转发到下一层。</p><h3 id="Haystack-Directory"><a href="#Haystack-Directory" class="headerlink" title="Haystack Directory"></a>Haystack Directory</h3><p>四个功能：</p><ol><li>逻辑volume到物理volume的映射。</li><li>跨逻辑卷读写的负载均衡能力。</li><li>决定一个请求是由CDN处理还是Cache处理。</li><li>检查逻辑卷是否因为操作原因或达到存储容量导致read-only</li></ol><h3 id="Haystack-Cache"><a href="#Haystack-Cache" class="headerlink" title="Haystack Cache"></a>Haystack Cache</h3><p>从浏览器或CDN接收HTTP请求。该组件使用图片id定位数据，将其组织成了分布式hash table，如果cache miss，则去Haystack Store服务器获取图片信息。</p><p>对图片进行cache的两个必要条件：</p><ol><li>请求直接来自浏览器而非CDN</li><li>图片从可写服务器获取的</li></ol><h3 id="Haystack-Store"><a href="#Haystack-Store" class="headerlink" title="Haystack Store"></a>Haystack Store</h3><p>每台存储服务器都维护了多个逻辑volume，每个volume都可以理解为一个大文件（100 GB ），文件名为&#x2F;hay&#x2F;haystack_<volume_id>，可以通过逻辑volume id和图片offset快速定位到图片信息，可以不通过磁盘IO读取图片（<strong>Q：为什么能不通过磁盘操作读取到磁盘数据？</strong>），服务器都在内存中维护着物理卷对应文件描述符和图片id到文件系统元信息的映射关系</p><p>具体的物理结构如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20231205220244979.png" alt="Haystack-Store"></p><p>每台存储服务器代表着一个物理卷，同时也称为superblock，其中包括多个needle，每个needle存储着图片元信息和图片数据。</p><p> <img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20231205222508419.png" alt="fields-explanation"></p><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p>来自Cache服务器的读请求会有以下参数：逻辑volume id、key、alternate key、cookie，Store服务器首先从内存中查找对应元信息，然后读取图片数据，使用checksum进行校验后返回。</p><h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><p>写请求会包括以下参数：逻辑volume id、key、alternate key、cookie、data，Store服务器将数据组装成needle结构并追加到volume file中。如果(key, alternate key)唯一二元组存在重复问题，有两种情况：</p><ol><li>不同逻辑volume：Directory更新图片到逻辑volume的映射关系</li><li>相同逻辑volume：通过offset区分，最新版本的数据为offset大的needle</li></ol><h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><p>同步设置内存和volume file中对应元信息的delFlag，如果请求到被删除的图片信息，抛出异常。在定期compact时，会清理被删除的数据。</p><h4 id="Index-File"><a href="#Index-File" class="headerlink" title="Index File"></a>Index File</h4><p>系统宕机后，重建内存中的索引是较为耗时的操作，因此使用index file存储了内存的映射关系，以便机器重启时能更快的重建映射关系。Store服务器每个volume都会维护一个index file。</p><p>当前存在以下问题：</p><ol><li>新文件写入到磁盘volume和内存映射后，还没写入到index file就宕机。</li><li>删除文件后，同步设置volume和内存中的delflag后，还没写入index file就宕机。</li></ol><p>解法：</p><ol><li>读取index file时，将needle中不符合索引记录的，构建成新记录并追加到index file末尾（Q：为什么读取needles？）</li><li>每次读取文件时，检查删除标记，并同步到内存和index file。</li></ol><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20231205220840006.png" alt="index-file"></p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>Haystack并不需要使用很多内存来支持大文件的随机IO，因此Store服务器都使用XFS，它有两个有点：</p><ol><li>对于多个相邻的大文件的块映射可以足够小到存储到内存中。</li><li>XFS提供了搞笑的文件预分配、减少了碎片并控制了块映射的增长。</li></ol><p>不能保证每一个读请求都只有一次磁盘IO，因为存在数据跨界的情况。</p><h3 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h3><p>Store服务器避免不了硬件故障，应对方法主要是：定期检测、适时恢复。</p><ol><li>定期检测：启动一个后台任务（称为pitchfork），定期检查每台Store服务器的联通情况和volume file的可用性，如果检查出问题，该任务会标记Store服务器所有volume只读。</li><li>恢复：存在问题后会尽快修复，无法修复的使用bulk sync从备份节点全量同步数据过来。</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h4><p>compacttion是一个在线操作，实现思路：生成一个新文件，将needle逐个拷贝到新文件，其中会跳过被删除和重复的needle，一旦完成，它会阻塞任意打到该volume file的请求并原子性交换文件和内存映射关系。</p><p>实际业务中，大约25%的图片被删除。</p><h4 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h4><p>当前系统的flag字段仅用作于删除标志，设置删除标记的同时，可以将offset设为0。同时将cookie从内存中删除，改为从磁盘中读取（needle header），上述两个优化点节约了20%的内存。</p><h4 id="批量上传"><a href="#批量上传" class="headerlink" title="批量上传"></a>批量上传</h4><p>磁盘的顺序写性能优于随机写，同时用户都是同时上传一批图片，该应用场景也契合于磁盘特点。</p>]]></content>
    
    
    <categories>
      
      <category>Paper Reading</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>述职报告要点小记</title>
    <link href="/2023/%E9%9A%8F%E7%AC%94/%E8%BF%B0%E8%81%8C%E6%8A%A5%E5%91%8A%E8%A6%81%E7%82%B9%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/%E9%9A%8F%E7%AC%94/%E8%BF%B0%E8%81%8C%E6%8A%A5%E5%91%8A%E8%A6%81%E7%82%B9%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="述职目的"><a href="#述职目的" class="headerlink" title="述职目的"></a>述职目的</h2><ul><li>企业：掌握员工的具体工作情况与表现。</li><li>个人：对自己的阶段性总结、反思、阶段规划</li></ul><h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/bg.jpg" alt="述职文档结构（摘自：阿里开发者）"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>核心：用一分钟总结一下自己这段时间<strong>干了些什么</strong>，让大家对你有个总体的认知。<strong>业务结果</strong>有两个重点：</p><ul><li>归因：业务结果与个人的关系</li><li>增量：业务价值有一定的增量部分</li><li>技术结果：个人的技术能力<ol><li>不要造轮子</li><li>带来变化：新项目、代码重构、性能优化、技术先进性、效率提升等</li></ol></li></ul><h3 id="工作总结（重点）"><a href="#工作总结（重点）" class="headerlink" title="工作总结（重点）"></a>工作总结（重点）</h3><h4 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h4><p>核心：<strong>搞清楚why</strong></p><p>方法论：</p><ul><li>靠谱的PD，会把why说清楚</li><li>不靠谱的PD，需要自己去调研清楚，调研方案：<ol><li>扩大自己的领域知识</li><li>请教专家</li></ol></li></ul><h4 id="解题思考"><a href="#解题思考" class="headerlink" title="解题思考"></a>解题思考</h4><p>需要盘清楚现有的资源情况（人力、机器、资金、组织等），然后给出最合适的解决方案，这个过程就是<strong>解题思考</strong>。</p><h4 id="目标制定"><a href="#目标制定" class="headerlink" title="目标制定"></a>目标制定</h4><ul><li><p>环境决定决策：业务目标由业务增长率决定</p></li><li><p>技术目标：<strong>技术目标是围绕着业务在当前的阶段或形态来设定的</strong></p></li></ul><h4 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h4><ul><li><p><strong>面向未来的架构设计</strong>：着眼眼前，根据眼前的情况定一个合适的目标，设计系统要面向未来</p></li><li><p><strong>怎么画系统架构图（四部分）</strong>：系统和外部的边界、内部组件的上下左右关系、系统的非功能性设计、面向未来的设计</p><ul><li>面向未来的设计：起码看到未来三年的发展形态，抽象总结业务表层问题，把本质抽象成领域模型的概念。</li></ul></li><li><p>落地再次贴近现实：架构设计完成后，到具体的落地环节，做出时序图、流程图等，最好能做到后面可以直接编码的程度，后续的多次迭代其实就是对原始的图不断完善和扩展。</p></li><li><p>技术深度：某个领域，通过长时间的沉淀积累，总结出一套在该领域下的技术方案。</p></li></ul><h4 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明"></a>结果说明</h4><p>具体的数据、计算公式等，技术结果可以把核心模块、扩展性、性能等方面例举出来</p><h4 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h4><p>总结出做得好的和做的不好的地方。</p><h3 id="个人成长-团队贡献"><a href="#个人成长-团队贡献" class="headerlink" title="个人成长&amp;团队贡献"></a>个人成长&amp;团队贡献</h3><ul><li>可迁移的个人能力：复杂系统架构设计能力、结构化思考能力、组织协调能力、项目管理能力、团队管理能力、沟通能力、演讲能力、数据洞察能力</li><li>团队贡献：本质还是个人成长，需要把你的成长输出给团队成员。</li></ul><h3 id="财年规划"><a href="#财年规划" class="headerlink" title="财年规划"></a>财年规划</h3><ul><li>一块业务的下一年的规划</li></ul><p>难点：</p><ul><li>业务定位</li><li>衡量指标</li><li>核心业务&amp;技术问题，解决方案</li><li>竞品分析</li><li>资源组织最大化</li><li>风险分析</li><li>…………</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247532301&idx=1&sn=23481d31aed34389bb8c28a5e5db6be5&chksm=e92a4202de5dcb1424bf2378fa83742ce47afd9b670e2f4950593cc8aac0d0d5f5d7c750c564&scene=178&cur_album_id=1427971693057998849#rd">来自一线技术人的经验分享｜如何写出让人眼前一亮的述职报告</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《十次经济危机》学习笔记</title>
    <link href="/2023/%E7%BB%8F%E6%B5%8E/%E3%80%8A%E5%8D%81%E6%AC%A1%E7%BB%8F%E6%B5%8E%E5%8D%B1%E6%9C%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/%E7%BB%8F%E6%B5%8E/%E3%80%8A%E5%8D%81%E6%AC%A1%E7%BB%8F%E6%B5%8E%E5%8D%B1%E6%9C%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本课程分析了中国从1949-2018的十次经济危机。</p><p><strong>理性分析专业知识，无任何意识形态掺杂在内。</strong></p><h3 id="背景和问题"><a href="#背景和问题" class="headerlink" title="背景和问题"></a>背景和问题</h3><p>二战后超级大国地缘政治的不确定性以及冷战特点：</p><ul><li>战后双寡头地缘政治重构派生两个<strong>雁阵式重工产业转移</strong>：<ul><li>USA完成了对西欧日韩的控制（马歇尔计划）<ul><li>朝鲜战争导致日本得到美国约150亿美元投资再实现工业化</li><li>中国得到苏联约50亿美元投资用于国家工业化</li></ul></li><li>USSR完成对东欧的控制，但受阻于中国维护原住民暴力革命夺取的国家主权<ul><li>中国土改利于新政权战胜最初的危机但不利于工业化：分散小农户经济70%在山区不可能使用工业化产品；资本不断增密的重工业无法提取原始积累</li></ul></li></ul></li></ul><p><strong>现代化</strong>：资本和风险向城市集中的过程，周期性爆发危机，是一个阶段性过程。</p><p>美国最严重经济波动发生于一战和二战时期。</p><p>中国严重波动发生于西方主导的冷战时期，伴随着意识形态偏差的庸俗化传播。</p><p>土地革命完成了：动员全民参加经济建设，土改提供的农产品打赢了城市私人资本引导的<strong>白色大战</strong>。</p><p>工业化：<strong>资本增密、排斥劳动力</strong>的过程。</p><ul><li>1950-1960：第一次外资因苏联1967年援助投资终止而引发60-62和68-70两次债务&#x2F;赤字&#x2F;危机。</li><li>1971-1980：第二次外资引进西方设备，造成74-76和79-81两次外债&#x2F;赤字&#x2F;危机。</li><li>1980-1990：第三次外资（改革开放）造成88-89和93-94两次恶性通胀经济危机。</li><li>1990-now：第四次外资，带来98-99输入性通缩演化为第一次生产过剩，08-09输入型通胀，2015受西方债务危机影响发生第二次生产过剩<ul><li>产业资本危机-&gt;金融资本危机</li><li>三大差距逐渐拉大：沿海和内地的区域差别、城市和乡村的收入差别、贫富差距</li><li>政府通过倾斜投资来缓解差距，基础设施建设、农村五通，促进经济发展。</li><li>国债投资基础设施建设存在的三个问题<ul><li>贷款被国有企业占有，既不产生税收，也不产生回报，对私人企业有挤出效应，资本主义国家也无法避免。</li><li>短期生产过剩通过投资解决，无法根治，导致长期产生。</li><li>金融资本流动性减缓，导致金融资本不断扩张，导致金融资本过剩</li></ul></li><li>2020之后产业资本、商业资本、金融资本全部过剩</li></ul></li></ul><p>中国的金字塔形双稳态经济&#x2F;社会结构：</p><ul><li>经济结构<ul><li>地方主要掌握<strong>实质资产</strong>500万亿，<strong>土地</strong>随基建投资升值到150万亿。</li><li>中央主要掌握<strong>金融资产</strong>180万亿（可扩张）</li><li>无限负责政府<strong>债务资产</strong>约40万亿（可扩张）</li></ul></li><li>社会结构<ul><li>地方面对分散小资60%（农民住宅拥有率约为100%）</li><li>地方面对新崛起中资30-40%，约为5亿人</li><li>中央掌握政治化大资约10%</li></ul></li></ul><p>就业形势：</p><ul><li><p>劳动力总量8亿，每年增加0.1亿</p><ul><li>农村劳动力5亿：农业需要0.5亿、乡镇企业吸纳1亿、进城打工2.2亿、仍有1亿以上需要非农就业。</li><li>越多劳动力进入市场，劳工待遇越差<ul><li>收入减少、劳动强度增大、缺乏社保体系</li></ul></li></ul></li><li><p>经济增长 vs 社会稳定</p></li><li><p>双重过剩：生产过剩和劳动力过剩</p></li></ul><p>路权战略：</p><ul><li>一带一路：向南向西的陆路交通建设与次区域交通网络连接。</li></ul><p>发展中国家在资本主义文明阶段的经验归纳：</p><ul><li>任何跟进工业化的后发国家面对资本稀缺都势所必然地采取<strong>亲资本</strong>政策，只有进入资本过剩阶段后才可能转向<strong>亲民生</strong>。</li><li>任何资本投资国都在试图运用其建制权直接控制，或以债权来渗透后发国家的政府制度体系以最大化获取资本收益。</li><li>发展中国家只有维护<strong>资源和货币主权</strong>，才能在危机挑战中使用逆周期调节。<ul><li>没有货币主权时，危机爆发，外部资本会逃走（做空）。</li></ul></li></ul><h2 id="新中国的第一次周期性经济危机（1949-1951）"><a href="#新中国的第一次周期性经济危机（1949-1951）" class="headerlink" title="新中国的第一次周期性经济危机（1949-1951）"></a>新中国的第一次周期性经济危机（1949-1951）</h2><p><strong>革命红利 + 局部战争 –&gt; 恶性通胀</strong></p><ul><li><p>政治上：三反五反</p></li><li><p>经济上：动用国有部门政府直接干预，战争拉动</p></li></ul><p>引入外资-&gt;外债-&gt;财政赤字-&gt;降低财政对于扩大再生产的投入-&gt;减少就业-&gt;经济危机-&gt;社会动乱</p><p>不支持线性社会发展论，只适合地中海周围的国家</p><p><strong>危机情况：</strong></p><ul><li>物价恶性上涨：解放的大城市物价上涨几十倍。</li><li>财政严重赤字：军队开支超过财政总支出60%</li></ul><p>农业自身内在具有自然过程与经济过程高度结合的特征，在世界近代通过殖民化推工业化的资本文明史中，农业内在特质不可能被根除，客观分化为三个异质性很强的不同类型：</p><ul><li><strong>盎格鲁撒克逊的殖民化大农场</strong>：新大陆因彻底殖民化造成资源充足的客观条件而得以实现农业规模化和资本化，对应的是公司化和产业化的农业政策。</li><li><strong>莱茵模式的前殖民主义宗主国（欧盟为代表）的中小农场农业</strong>：农业资本化和生态化结合，农业不能为工业化提供原始积累，也没有自由市场体制下的竞争力，另一方面与农业生态化高度相关的绿色社会运动从欧洲兴起。</li><li><strong>未被西方彻底殖民化的原住民为主的东亚模式的传统小农经济国家的农户经济（日韩为代表）</strong>：通过对农村人口全覆盖的普惠制的综合性合作社体系来实现社会资源资本化维持工业化原始积累时期的三农的稳定。</li></ul><p>危机根源于<strong>增发无储备货币</strong>和<strong>物价失控</strong>：</p><ul><li>1948年底，KMD政权将所有黄金、银元等资产转移到台湾，中央政府只能发行无储备货币。</li><li>物价失控：1949年7月城市兴起投机，米价棉纱等产品轮番涨价。</li></ul><p><strong>政府化解危机</strong>：</p><ul><li>直接对资本集中的城市实行军事管制，无偿占有一切官僚资本和跨国资本的资本，最低成本建立能够集中力量办大事的国有资本与国家管控的制度体系。</li><li>政府直接出手对物资进行全国范围内的超大规模统筹和动员，通过大量增发主权货币在<strong>农村</strong>收购物资，使政府掌控的物资与货币量大致相当，才能直接与城市投机商的硬通货对决。</li></ul><p>土地改革实现了中国几千年来的农民诉求：耕者有其田。和制度没有直接关系。</p><p>土改的作用：中国20世纪土地制度回嵌于社会政治的客观经验</p><ul><li>上半个世纪三次土地革命战争客观作用在于财产关系稳定的小农村社制是城市危机的载体。</li><li>通过战争实现均田，但是没有免赋</li></ul><p>东亚的土地均分制度使人口占比最多的是小农。西方模式的南亚拉美土改未见成功。</p><p>新政权以革命手段推进土改，造成基本财产关系的制度变迁，解决了民国延续下来主要发生在城市的高通胀危机，经验有四点：</p><ul><li>依靠脱离现代化回归传统农村多元化的实体经济，满足了城市生活需求</li><li>继续强化动员农村参加土改的意识形态，以革命的名义从乡土社会筹集到足够的实体产品运往城市，成功抑制了私商把控物资的投机行为，国家资本借助革命动员打赢私人资本</li><li>国家借此把宏观调控必须的财政金融体系建立于实物经济的基础上，成为国家构建基本经济制度的最初依据。</li><li>国家采取直接成本最低的军事手段和三反五反的政治运动，强行取缔城市私人资本投机，有效抑制了一般私人企业按照经济理性做顺周期，造成对经济危机的恶化作用。</li></ul><h2 id="新中国的第二次周期性经济危机（1952-1960）"><a href="#新中国的第二次周期性经济危机（1952-1960）" class="headerlink" title="新中国的第二次周期性经济危机（1952-1960）"></a>新中国的第二次周期性经济危机（1952-1960）</h2><p>再依附：外资依赖性工业化的代价</p><p>几个核心概念：</p><ul><li>发展：资源资本化并取得资本化的增值收益（资源转化为资本）<ul><li>资源：历史资源、政治资源、环境资源、文化资源……………………</li></ul></li><li>制度：基于一定<strong>资源</strong>禀赋而形成的，资源资本化进程中的<strong>要素组织结构</strong>以及<strong>成本、收益的分配方式</strong><ul><li>制度变迁：制度成本谁来承担，制度收益谁来收取</li></ul></li><li>资本原始积累<ul><li>任何工业化都难以逾越的阶段</li><li>由政府或其他注意来完成，是一个派生问题</li></ul></li><li>政府公司主义：政府直接干预经济<ul><li>晚进工业化国家加快原始积累的一种必由制度安排。（为了尽快发展而产生的主义）</li><li>日本、中国等</li></ul></li></ul><h3 id="背景和问题-1"><a href="#背景和问题-1" class="headerlink" title="背景和问题"></a>背景和问题</h3><ul><li>战后双寡头地缘政治重构派生两个<strong>雁阵式重工产业转移</strong>：<ul><li>USA完成了对西欧日韩的控制（马歇尔计划）<ul><li>朝鲜战争导致日本得到美国约150亿美元投资再实现工业化</li><li>中国得到苏联约50亿美元投资用于国家工业化</li></ul></li><li>USSR完成对东欧的控制，但受阻于中国维护原住民暴力革命夺取的国家主权<ul><li>中国土改利于新政权战胜最初的危机但不利于工业化：分散小农户经济70%在山区不可能使用工业化产品；资本不断增密的重工业无法提取原始积累</li></ul></li></ul></li></ul><h3 id="集体化与二元体制下的国家工业化资本原始积累"><a href="#集体化与二元体制下的国家工业化资本原始积累" class="headerlink" title="集体化与二元体制下的国家工业化资本原始积累"></a>集体化与二元体制下的国家工业化资本原始积累</h3><ul><li>无论是私人还是政府，也无论是任何力量，都不可能绕过从农民那里提取剩余的资本原始积累来完成工业化。</li><li>为了降低统购统销的制度成本，国家在1953年建立了农村合作社制度，允许农民占有地租收益。</li><li>按工业部门要求，1956年建立集体化制度，剥夺了农民地权，以便政府通过长期的工农产品剪刀差垄断占用农业剩余来完成工业化。</li></ul><h3 id="怎么评价中国农村的集体化和农业现代化"><a href="#怎么评价中国农村的集体化和农业现代化" class="headerlink" title="怎么评价中国农村的集体化和农业现代化"></a>怎么评价中国农村的集体化和农业现代化</h3><ul><li>国家工业化的制度收益：奠定中国高速度增长的基础<ul><li>宏观收益：基于农村集体化制度，国家得以通过<strong>政府公司主义</strong>缩短工业化原始积累</li><li>微观收益：基于国家对于资源的直接控制和集体化能够大量动员过剩劳动力，中国得以在1950-1970年代以所谓农业的集体化制度的最低土地成本，建设了大陆性国家最大规模的配套的水利系统。</li></ul></li><li>农业现代化的制度成本：在农业产出品价格既定条件下，但用于农业的机械和化学产品投入增加导致成本上升，集体化各级生产单位严重亏损</li></ul><h3 id="第二次经济危机的特征"><a href="#第二次经济危机的特征" class="headerlink" title="第二次经济危机的特征"></a>第二次经济危机的特征</h3><ul><li>内生性危机<ul><li>1950年代是原始积累起步时期，在资本极度稀缺的压力下<strong>引入苏联设备</strong>造成1960年代出现政府赤字大幅度上升导致投资不足，就业仅为失业的二分之一</li><li>1957年苏联停止对华战略性援助改为<strong>贸易项下</strong>，此前所有投资转为中央政府对外负债，造成中央财政投资维持苏式重工业严重赤字，与此同时试图调动地方政府开支工业化建设（两个积极性），是为大跃进。</li><li>1958-1960中国靠自身努力维持苏式重工业化失败，财政几乎破产，工人大量失业，城里不能就业的年轻人被动员<strong>上山下乡</strong></li></ul></li><li>外生性因素：发展中国家在资本主义文明阶段的经验归纳<ul><li>任何资本投资国都试图运用其建制权直接控制，或以债权来渗透后发国家的政府制度体系以最大化获取资本收益，受援国家任何政治家试图维护主权的努力，都会引发内部受惠集团的复杂矛盾</li><li>任何跟进工业化的后发国家面对资本稀缺都势所必然采取<strong>亲资本</strong>（无论左右翼），只有在进入资本过剩阶段之后才能转向<strong>亲民生</strong>。</li></ul></li></ul><p>中国的主要制度经验：</p><ul><li>中国能够长期保持没有成规模的饥饿记录，是所有大型发展中国家中能够维持社会基本稳定的国家。<ul><li>工业化的资本原始积累造成的负外部性加于乡土中国</li><li>传统农业有了稳定乡土中国的正外部性：我们其实是在完成工业化的原始积累、无条件实现并基本放弃了农业现代化制度。</li><li>中国新世纪大规模增加对农村的投资形成第二资产池，缓解三农困境：三农问题主要产生于国家工业化的原始积累阶段和1990年代加快工业化和城市化的产业资本扩张阶段；农村的土地劳动力资源和资金的大规模净流出。</li></ul></li></ul><h2 id="新中国的第三次周期性经济危机（1962-1970）"><a href="#新中国的第三次周期性经济危机（1962-1970）" class="headerlink" title="新中国的第三次周期性经济危机（1962-1970）"></a>新中国的第三次周期性经济危机（1962-1970）</h2><p>主题：<strong>去依附的代价：地缘环境紧张与三线建设</strong></p><h3 id="背景与问题"><a href="#背景与问题" class="headerlink" title="背景与问题"></a>背景与问题</h3><p>1960年代世界动荡，中国地缘政治环境劣化</p><p>现象：</p><ol><li>战后和平环境人口大幅增长，1960年后人均GDP下降快，产业资本主义的危机常态化</li><li>霸权主义国家通过<strong>对外战争</strong>和<strong>颠覆</strong>转嫁国内矛盾<ul><li>西方产业资本遭遇社会成本加快上涨的压力，开始对外转移劳动密集型产业，造成国内失业率提升</li><li>城市武装斗争和游击队运动在西方大城市爆发，美国是黑人民权运动、反战等</li></ul></li><li>中国对美苏去依附，加入不结盟运动，导致中国地缘关系紧张</li><li>为了保护初步形成结构和规模的重工业和军事工业，中国开始向内地大规模转移沿海制造业，投资三线建设，造成倍加的制度成本</li><li>资本极度稀缺的压力下，中国动员工农群众，实现劳动代替资本</li></ol><h3 id="危机前的主要矛盾"><a href="#危机前的主要矛盾" class="headerlink" title="危机前的主要矛盾"></a>危机前的主要矛盾</h3><ul><li>苏式军重工业为主的产业资本的维护成本过高，没有外资条件下必须做回嵌本土的制度改造</li><li>再依附成本1968年第二次爆发</li></ul><h3 id="一般规律"><a href="#一般规律" class="headerlink" title="一般规律"></a>一般规律</h3><ul><li>地缘关系的紧张压力下，1963年提出四个现代化目标的<strong>三五计划</strong>被<strong>三线建设</strong>取代</li><li>1966年宣布中国没有外债，但是偿付外债+三线建设都使得财政负担过重，1967年，财政投资能力下跌到-30%</li><li>1968年再次动员城市青年下乡。</li></ul><h2 id="新中国的第四次周期性经济危机（1969-1975）"><a href="#新中国的第四次周期性经济危机（1969-1975）" class="headerlink" title="新中国的第四次周期性经济危机（1969-1975）"></a>新中国的第四次周期性经济危机（1969-1975）</h2><p>主题：<strong>中美苏三大角调整与第二次外资的代价</strong></p><h3 id="背景：西方产业转移与中美苏战略调整"><a href="#背景：西方产业转移与中美苏战略调整" class="headerlink" title="背景：西方产业转移与中美苏战略调整"></a>背景：西方产业转移与中美苏战略调整</h3><ul><li>西方产业资本输出与经济结构升级<ul><li>西方国家二战后全面完成<strong>再工业化</strong>，持续发生<strong>生产过剩危机</strong>，资本主义内生性矛盾加剧，在1970s通过向外输出制造业得到海外产业投资收益而缓解；社会转型渡过痛期，开始进入中产阶级化。</li><li>日本对东亚做雁阵式产业转移，形成加工贸易、劳动密集、轻型产业的四小龙和四小虎</li><li>美国放弃布雷顿森林体系，奠定<strong>金融全球化</strong>的主导地位。</li></ul></li><li>中美苏三角关系再次发生二战后的重大变化<ul><li><strong>美国</strong>：深陷中苏共同支持的东南亚战争，又遭受到国内民权与反战结合的运动压力，迫切需要<strong>战略调整</strong>。</li><li><strong>苏联</strong>：与中国关系恶化，边境发生冲突。</li><li>中国：领导人在遭受核威胁的压力下，研判国际形势，认为核大战不会打，应该及时转向经济建设</li></ul></li></ul><p><strong>中美战略接近</strong>：华沙会谈+乒乓外交+基辛格访华+美国部分解除对华封锁+尼克松访华</p><h3 id="中国1970s自主吸收外资与东亚加工贸易模式不同"><a href="#中国1970s自主吸收外资与东亚加工贸易模式不同" class="headerlink" title="中国1970s自主吸收外资与东亚加工贸易模式不同"></a>中国1970s自主吸收外资与东亚加工贸易模式不同</h3><ul><li>中美苏大三角战略关系调整在1989年苏联阵营解体之前有20年的宏观效应<ul><li>美国认为与中国外交，客观上改善了美苏双寡头地缘战略竞争中美国的弱势地位，中美进入蜜月期</li><li>美国和苏联都不可能对中国进行核打击，中国得到了20年和平发展机遇期。</li></ul></li><li>第二次利用外资：中国1950s形成的苏式重工业，客观上需要轻纺工业、化工等民生工业</li><li>毛泽东和周恩来直接指定从1972年引入西方43亿美元设备和技术的四三方案。</li><li>中国确立的外资策略是：消化吸收，主要对国内现有工业结构进行内部改造，没有FDI直接投资。</li></ul><h2 id="新中国的第五次周期性经济危机（1978-1980）"><a href="#新中国的第五次周期性经济危机（1978-1980）" class="headerlink" title="新中国的第五次周期性经济危机（1978-1980）"></a>新中国的第五次周期性经济危机（1978-1980）</h2><p>主题：<strong>外债与赤字引发的经济改革</strong></p><p>在此期间完成：工业化初期的<strong>产业资本原始积累</strong>。</p><p>此后都是：<strong>产业资本原始扩张</strong></p><h3 id="背景：中国向后毛时代转转变之际的国际国内形势"><a href="#背景：中国向后毛时代转转变之际的国际国内形势" class="headerlink" title="背景：中国向后毛时代转转变之际的国际国内形势"></a>背景：中国向后毛时代转转变之际的国际国内形势</h3><ul><li>国际环境：中国得到和平发展的历史机遇期<ul><li>1971年恢复联合国席位后，对世界各类国家都实现了国家关系正常化。</li><li>中国放弃对日本侵略战争提出赔偿，日本1979年开始对华援助官方低息贷款，中日友好成为两国各界认同的趋势，东北亚局势明显缓和。</li><li>中越爆发边境战争，越南撤出柬埔寨，东南亚局势趋于稳定。</li><li>地缘政治冲突远离中国（南亚、中东、非洲、拉美）</li></ul></li><li>国内变化：中国处于后毛时代的政治转型期<ul><li>1976年华国锋接任党政军领导人，1978年三中全会拨乱反正，资深政治家群体协商决策替代领袖集中决策。这个现象直到1989年政治风波。</li><li>确定“以经济建设为中心”的反正取代“阶级斗争为纲”。 </li><li>中国把应对经济危机时政治家群体协商决定的“财政甩包袱” + “放权让利”，统称为<strong>改革</strong>。</li></ul></li></ul><h3 id="危机成因：中国政治过渡期利用外资过量形成外债和赤字"><a href="#危机成因：中国政治过渡期利用外资过量形成外债和赤字" class="headerlink" title="危机成因：中国政治过渡期利用外资过量形成外债和赤字"></a>危机成因：中国政治过渡期利用外资过量形成外债和赤字</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230501171016036.png" alt="危机成因"></p><p>国家资本危机的成本转嫁常态化引发社会不满：</p><ul><li>每年数十上百万无业青年下乡成为常态化的政策</li><li>社会不满逐渐积聚，不断演化为街头政治</li></ul><h3 id="中国经济改革从农村起步"><a href="#中国经济改革从农村起步" class="headerlink" title="中国经济改革从农村起步"></a>中国经济改革从农村起步</h3><p>第二次土改：农村家庭承包制的内外因素与制度成本</p><ul><li>外因：中央财政严重赤字条件下，领导人提出<strong>甩包袱</strong>政策，大包干是”农民自己包肚子“，财政支农占比降到不足3%，农村公共品全部压在土地上。</li><li>内因：农村长期存在劳动承包制，以及按人均分到户的自留地等</li></ul><p>农村改革的制度成本：</p><ul><li>传统农户经济恢复的代价是：<strong>集体经济解体</strong>，大约四分之一的集体资产损毁。</li><li>国家支农工业随着集体化而破产，大约两千多家农机厂和拖拉机厂倒闭</li></ul><h3 id="农村改革制度收益：乡镇企业异军突起缓解外债压力、拉动内需"><a href="#农村改革制度收益：乡镇企业异军突起缓解外债压力、拉动内需" class="headerlink" title="农村改革制度收益：乡镇企业异军突起缓解外债压力、拉动内需"></a>农村改革制度收益：乡镇企业异军突起缓解外债压力、拉动内需</h3><p>乡镇企业兴起的内外部因素：</p><ul><li>中央政府对外负债，需要更多创汇企业提供外汇，于1979年赤字明显上升之际开始向出口较多的江浙一带集体企业提供资金等资源。</li><li>宏观政策改变促进了最大的生产力解放：土体到户之后农村过剩劳动力在地化的非农就业到1980年代末增加到九千万。</li></ul><p>农村工业化的制度收益：</p><ul><li>农村改革中农民自主工业化的结构调整，带动农民收入增加，拉动内需，也带动了城镇化及其基本建设的需求，这些都符合国家引入西方设备调整工业结构的需求，为1980s初期的危机局面得以缓解起到重要作用。</li></ul><h3 id="应对经济危机的城市政策"><a href="#应对经济危机的城市政策" class="headerlink" title="应对经济危机的城市政策"></a>应对经济危机的城市政策</h3><ul><li>政府直接出手<strong>做多</strong>的宏观政策：<ul><li><strong>增发货币</strong>：国家增发超过市场商品可供量的400亿货币。</li><li><strong>增发国债</strong>：财政赤字对应增发国债，第一次发行了40亿的国债。</li></ul></li></ul><h2 id="新中国的第六次周期性经济危机（1985-1989）"><a href="#新中国的第六次周期性经济危机（1985-1989）" class="headerlink" title="新中国的第六次周期性经济危机（1985-1989）"></a>新中国的第六次周期性经济危机（1985-1989）</h2><p>主题：<strong>再依附：西方外资依赖型结构调整的制度成本</strong></p><h3 id="背景与问题-1"><a href="#背景与问题-1" class="headerlink" title="背景与问题"></a>背景与问题</h3><p>中西关系蜜月期以及四小龙产业移出对中国工业结构调整的历史机遇及其内在矛盾</p><p>国际背景：</p><ul><li>美国1980s年代进入金融资本主导的新自由主义阶段：以美元为主的金融全球化去收割纳入美元体系的任何国家的产业收益。</li><li>中国与西方和解之后大约10年的蜜月期：各工业化国家因生产过剩争相进入中国的设备市场，使得中国传统的偏军重工业的结构得以全面调整，但是制度成本很高。</li></ul><p>国内变化：</p><ul><li>1980-1982年全国推进家庭承包制，缓解经济危机，也造成一定的制度成本<ul><li>一方面廉价劳动力大量离开农业，为沿海劳动力密集的加工贸易发展创造条件，同时也扩大了农村企业对城市设备制造业的市场、带动城市就业，城市产业资本由此缓解。</li><li>兼业化小农不利于国家工业化继续提取农业剩余，遂有全国大部分农机厂倒闭，同期政府涉农单位，因无法与分散小农户经济做交易而解体。</li></ul></li></ul><h3 id="体制矛盾"><a href="#体制矛盾" class="headerlink" title="体制矛盾"></a>体制矛盾</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230521163037380.png" alt="体制矛盾"></p><h3 id="危机爆发"><a href="#危机爆发" class="headerlink" title="危机爆发"></a>危机爆发</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230521163612339.png" alt="危机爆发"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230521174353537.png" alt="总结"></p><h2 id="新中国的第七次周期性经济危机-1991-1995"><a href="#新中国的第七次周期性经济危机-1991-1995" class="headerlink" title="新中国的第七次周期性经济危机(1991-1995)"></a>新中国的第七次周期性经济危机(1991-1995)</h2><p>主题：跳出中国崩溃论的艰难转轨</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230526211648874.png" alt="背景"></p><h3 id="如何度过短期但深化的危机"><a href="#如何度过短期但深化的危机" class="headerlink" title="如何度过短期但深化的危机"></a>如何度过短期但深化的危机</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230527195445189.png" alt="应对措施"></p><h3 id="危机及应对政策评价"><a href="#危机及应对政策评价" class="headerlink" title="危机及应对政策评价"></a>危机及应对政策评价</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230527200624280.png" alt="危机及应对政策评价"></p><h2 id="新中国的第八次周期性经济危机（1997-2001）"><a href="#新中国的第八次周期性经济危机（1997-2001）" class="headerlink" title="新中国的第八次周期性经济危机（1997-2001）"></a>新中国的第八次周期性经济危机（1997-2001）</h2><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>主题：东亚金融风暴引发的中国“生产过剩”与中国应对危机的二元选择</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230709162454.png" alt="主要观点"></p><h3 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230709193929.png" alt="背景分析"></p><h2 id="新中国的第九次周期性经济危机（2007-2010）"><a href="#新中国的第九次周期性经济危机（2007-2010）" class="headerlink" title="新中国的第九次周期性经济危机（2007-2010）"></a>新中国的第九次周期性经济危机（2007-2010）</h2><p>主题：华尔街金融海啸引发全球危机与中国的逆周期调节</p><h3 id="宏观背景"><a href="#宏观背景" class="headerlink" title="宏观背景"></a>宏观背景</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230709195612.png" alt="宏观背景"></p><p> 美国增发货币扩张资本市场流动性，同时向能源和粮食转嫁通胀</p><h3 id="危机与应对：中国被动接受输入型危机"><a href="#危机与应对：中国被动接受输入型危机" class="headerlink" title="危机与应对：中国被动接受输入型危机"></a>危机与应对：中国被动接受输入型危机</h3><p>外资市场化与国家垄断化同步发展</p><ul><li>中国主流在推动市场化和全球化的同时加快国内经济的金融化<ul><li>外资控制出口：外资为主的出口使得沿海经济从一般贸易转型为加工贸易</li><li>加快经济货币化：外资管控条件下外资流入造成人民币对冲增发，导致M2对GDP比重迅速上升，大量流动性资本进入投机领域，民间集资炒作引发社会冲突</li></ul></li><li>国有部门在10年考基本建设投资拉动GDP的过程中已经占主要成分<ul><li>大有国有企业：让出竞争性领域，维持在战略性经济部门的垄断地位</li><li>国有银行改革：国家对金融业完成一行三会监管体制、国有银行坏帐剥离的同时法人权上收至中央，完成股份制改革相继上市，国家占资本金80%以上，能够以绝对控股地位实行党组制度，尚可执行中央政府逆周期调节的责任。</li></ul></li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230713225133.png" alt="成本转嫁"></p><p>政府逆周期调节：</p><ul><li>西方大危机爆发前，2005-2010年中国十一五规划把<strong>社会主义新农村建设</strong>作为国家战略</li><li>国家一万亿投资基本建设实现<strong>五通</strong></li></ul><p>遗留问题：</p><ul><li>农村基本建设占用稀缺资源多，引发社会冲突</li><li>投资周期长，没有短期回报、大量占压银行资金，促使央行增发货币补充流动性</li><li>私人资本无利可图不可能介入，以国有企业投资为主带动国有资本增加，对私人资本形成挤出效应。</li></ul><h2 id="新中国的第十次经济危机（2013-2018）"><a href="#新中国的第十次经济危机（2013-2018）" class="headerlink" title="新中国的第十次经济危机（2013-2018）"></a>新中国的第十次经济危机（2013-2018）</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>为什么不提周期性？</p><p>金融资本危机不存在周期性。</p><p>中美在客观上已经成为金融资本阶段主要矛盾的两个方面：</p><ol><li>实质的共性在于：只有强势政府才能把财政增发债务与央行增发货币密切配合，吸纳海外投资，这是造成全球信用虚拟化扩展的竞劣机制</li><li>实质的差别在于：美国两党都试图向实体产业回调，中国是中央试图向生态文明转型</li></ol><p>中国第十次危机以及应对政策摘要：</p><ol><li><strong>投资拉动失灵</strong>：在全球危机外需低迷压力下，被前两次危机时期政府逆周期政策推进国内基本建设投资所延缓的生产过剩危机再度爆发，中国GDP增速下跌1&#x2F;3</li><li><strong>政府顺周期调节</strong>：政策主流仍然认同市场化和全球化，全球危机深化在2013年被理解为新常态，应对政策改为顺周期做空，加剧资金析出 脱实向虚，造成包括金融在内的三大资本过剩</li><li><strong>金融资本异化</strong>：外汇储备先增后减，央行增发货币中的对冲增发占3&#x2F;4，实体经济不可能吸纳的过剩流动性进入股市和房地产等投机性领域形成巨大泡沫，主流坚持金融开放试图借低价外资支撑股市，实际上既绑架社会资本，也使得富豪借道海外投资流出</li><li><strong>中央提出战略转型</strong>：绿色发展理念上升，一方面推出亚投行和一带一路结合，加上区域整合和乡村振兴结合，化解生产过剩危机，另一方面美丽中国与生态文明相结合化解资源环境与社会危机</li></ol><h3 id="中国金融资本崛起以及参加全球竞争"><a href="#中国金融资本崛起以及参加全球竞争" class="headerlink" title="中国金融资本崛起以及参加全球竞争"></a>中国金融资本崛起以及参加全球竞争</h3><p>全球金融资本都在扩张，当时投入方向不同的主要内因 与国家与资本的结合方式：</p><ul><li>美国是私人银行家组成美联储确定货币发行和金融政策</li><li>中国是中央政府赋权形成主权货币由国有银行为主运营国家信用</li></ul><h3 id="中国艰难地向生态文明转型"><a href="#中国艰难地向生态文明转型" class="headerlink" title="中国艰难地向生态文明转型"></a>中国艰难地向生态文明转型</h3><p>另一个方向逆周期做多：一带一路 + 扶贫攻坚 + 乡村振兴</p><p>乡村振兴存在的问题：</p><ul><li><p>主流的一带一路体现向陆权战略转变：</p><ol><li>通过陆路建设与周边国家实现互联互通带动资源和能源开发</li><li>通过基本建设投资向低度发展国家转移适用产业与适用技术，带动劳动力资源富裕国家的就业可持续发展</li><li>通过文化交流促进融合、化解冲突</li></ol></li><li><p>非主流的生态文明之下的消除贫困与乡村振兴</p><ol><li>国情约束与安全压力趋紧下的工业化、信息化、城镇化、农业农村现代化等传统战略都在大幅度调整，外部冲突遏止产业扩张+ 内部中产阶级崛起挑战两端</li></ol></li></ul><p>百年工业化历史形成的多种利益集团大部分不能跟进，各种结构性矛盾都在暴露，遂有加强党治的对策。</p>]]></content>
    
    
    <categories>
      
      <category>经济</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跑步理论知识</title>
    <link href="/2023/%E9%9A%8F%E7%AC%94/running-theory/"/>
    <url>/2023/%E9%9A%8F%E7%AC%94/running-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="心率区间"><a href="#心率区间" class="headerlink" title="心率区间"></a>心率区间</h1><p>心率区间有以下三种计算方式，最大心率百分比、储备心率百分比、乳酸阈值百分比</p><p>计算方式：</p><ul><li>最大心率：220 - age</li><li>储备心率：最大心率 - 静息心率</li><li>乳酸阈值百分比：根据乳酸阈值划分心率区间</li></ul><p>乳酸阈值：血液中乳酸浓度的增长速度快于乳酸的代谢速度，使得乳酸开始在血液中堆积的临界状态。</p><h2 id="储备心率法"><a href="#储备心率法" class="headerlink" title="储备心率法"></a>储备心率法</h2><p>心率区间 &#x3D;（最大心率-静止心率）*储备心率%+静止心率</p><table><thead><tr><th>心率区间名称</th><th>储备心率法</th><th>实际数值</th><th>说明</th><th>含义</th></tr></thead><tbody><tr><td>区间1（E）</td><td>59%-74%</td><td>138-159</td><td>LSD配速，有氧耐力</td><td>轻松聊天，锻炼心肌强度，增强身体供氧能力，提高有氧耐力</td></tr><tr><td>区间2（M）</td><td>74%-84%</td><td>159-173</td><td>马拉松配速</td><td>呼吸加重</td></tr><tr><td>区间3（T）</td><td>84%-88%</td><td>173-179</td><td>乳酸阈值强度</td><td>呼吸会喘，身体开始堆积乳酸，提升乳酸阈值，增强乳酸排出能力</td></tr><tr><td>区间4（A）</td><td>88%-95%</td><td>179-188</td><td>无氧区间</td><td>间歇跑，增强乳酸耐受能力，提升无氧耐力</td></tr><tr><td>区间5（I）</td><td>95%-100%</td><td>188-196</td><td>最大摄氧量强度</td><td>高强度间歇，提高无氧能力和速度</td></tr></tbody></table><h2 id="最大心率法"><a href="#最大心率法" class="headerlink" title="最大心率法"></a>最大心率法</h2><table><thead><tr><th>心率区间名称</th><th>最大心率法</th><th>说明</th><th>实际数值</th></tr></thead><tbody><tr><td>区间1（热身）</td><td>50%-60%</td><td>热身</td><td>98-117</td></tr><tr><td>区间2（燃脂）</td><td>60%-70%</td><td>有效燃脂，增强心肺能力</td><td>117-137</td></tr><tr><td>区间3（有氧耐力）</td><td>70%-80%</td><td>有氧耐力</td><td>137-156</td></tr><tr><td>区间4（马拉松配速）</td><td>80%-90%</td><td>提升乳酸耐受能力</td><td>156-176</td></tr><tr><td>区间5（无氧耐力）</td><td>90%-100%</td><td>高强度</td><td>176-196</td></tr></tbody></table><h2 id="有氧心率区间计算方法"><a href="#有氧心率区间计算方法" class="headerlink" title="有氧心率区间计算方法"></a>有氧心率区间计算方法</h2><ul><li>最大心率法</li><li>储备心率法</li><li>MAF180：最大有氧心率&#x3D; 180 - age</li></ul><h1 id="有氧能力"><a href="#有氧能力" class="headerlink" title="有氧能力"></a>有氧能力</h1><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image.png" alt="有氧能力"></p><ul><li>心脏氧气输出，心脏的强大能力，主要有三点：<ol><li>容积</li><li>心肌</li><li>心脏的毛细血管</li></ol></li><li>氧气运输：任何增加血液需求的锻炼都能提升该能力</li><li>氧气利用：肌肉线粒体能力</li><li>乳酸利用：乳酸是能够被利用提供能源的。乳酸利用能极大提高一个人的跑步能力。<ul><li>乳酸的利用能力：需要刺激主管乳酸新陈代谢的酶，训练中生成越多乳酸越好。</li></ul></li><li>脂肪利用：慢跑是最有效的刺激主管脂肪新陈代谢的酶的运动<ul><li>LSD远大于其他训练方式。</li></ul></li></ul><h1 id="步频与伤病"><a href="#步频与伤病" class="headerlink" title="步频与伤病"></a>步频与伤病</h1><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image%20(1).png" alt="步频问题"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://space.bilibili.com/3945971">https://space.bilibili.com/3945971</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解析Java动态代理机制的实现</title>
    <link href="/2023/Java%E5%9F%BA%E7%A1%80/%E8%A7%A3%E6%9E%90Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/Java%E5%9F%BA%E7%A1%80/%E8%A7%A3%E6%9E%90Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>代理模式主要是Proxy对原始方法做了一层包装，用以增加一些新的统一处理逻辑，来增强目标对象的功能。静态代理是传统设计模式中一种传统的实现方案，动态代理能将代理对象的创建延迟到程序运行阶段。</p><p>以下是一个动态代理的示例：</p><p>被代理类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DemoService</span> &#123;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">process</span><span class="hljs-params">(String value)</span>;&#125;<span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DemoService</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RESULT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;result&quot;</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">process</span><span class="hljs-params">(String value)</span> &#123;        log.info(<span class="hljs-string">&quot;&#123;&#125; is processing, parameter: &#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>.getClass().getName(), value);        <span class="hljs-keyword">return</span> RESULT;    &#125;&#125;</code></pre></div><p>代理类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoInvokerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DemoInvokerHandler</span><span class="hljs-params">(Object target)</span> &#123;        <span class="hljs-built_in">this</span>.target = target;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        log.info(<span class="hljs-string">&quot;before...&quot;</span>);        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);        log.info(<span class="hljs-string">&quot;after...&quot;</span>);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 创建代理对象</span>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                target.getClass().getInterfaces(), <span class="hljs-built_in">this</span>);    &#125;&#125;</code></pre></div><p>代理调用：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyMain</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">DemoService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoServiceImpl</span>();        <span class="hljs-type">DemoInvokerHandler</span> <span class="hljs-variable">demoInvokerHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoInvokerHandler</span>(service);        <span class="hljs-type">DemoService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (DemoService) demoInvokerHandler.getProxy();        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.process(<span class="hljs-string">&quot;test&quot;</span>);        log.info(<span class="hljs-string">&quot;result is : &#123;&#125;&quot;</span>, result);    &#125;&#125;</code></pre></div><h2 id="动态代理实现原理"><a href="#动态代理实现原理" class="headerlink" title="动态代理实现原理"></a>动态代理实现原理</h2><p>通过上述示例中<code>getProxy()</code>方法可以看出，创建代理对象的核心方法是：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><span class="hljs-params">                                          Class&lt;?&gt;[] interfaces,</span><span class="hljs-params">                                          InvocationHandler h)</span>        <span class="hljs-keyword">throws</span> IllegalArgumentException</code></pre></div><p>传入参数分别为：</p><ul><li>loader：加载动态代理类的classloader</li><li>interfaces：代理目标的接口类型</li><li>h：InvocationHandler类型，用于执行代理目标的方法时，触发的handler</li></ul><p>该方法的具体实现与注释如下：</p><div class="code-wrapper"><pre><code class="hljs java">&#123;        Objects.requireNonNull(h);    <span class="hljs-comment">//检查classloader、包权限等</span>        <span class="hljs-keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();        <span class="hljs-keyword">final</span> <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();        <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);        &#125;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Look up or generate the designated proxy class.</span><span class="hljs-comment">         */</span>    <span class="hljs-comment">//获取代理类class</span>        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Invoke its constructor with the designated invocation handler.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;                checkNewProxyPermission(Reflection.getCallerClass(), cl);            &#125;            <span class="hljs-comment">//获取代理类的构造方法</span>            <span class="hljs-keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);            <span class="hljs-comment">//Q：这里赋值ih的意义是什么</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">ih</span> <span class="hljs-operator">=</span> h;            <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;                AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;                    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                        cons.setAccessible(<span class="hljs-literal">true</span>);                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                    &#125;                &#125;);            &#125;            <span class="hljs-comment">//创建代理对象</span>            <span class="hljs-keyword">return</span> cons.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;h&#125;);        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e.toString(), e);        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;            <span class="hljs-type">Throwable</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> e.getCause();            <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;                <span class="hljs-keyword">throw</span> (RuntimeException) t;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(t.toString(), t);            &#125;        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(e.toString(), e);        &#125;    &#125;</code></pre></div><p>加载Class对象是通过<code>getProxyClass0()</code>方法实现的：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,                                           Class&lt;?&gt;... interfaces) &#123;        <span class="hljs-keyword">if</span> (interfaces.length &gt; <span class="hljs-number">65535</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;interface limit exceeded&quot;</span>);        &#125;        <span class="hljs-comment">// If the proxy class defined by the given loader implementing</span>        <span class="hljs-comment">// the given interfaces exists, this will simply return the cached copy;</span>        <span class="hljs-comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span>        <span class="hljs-keyword">return</span> proxyClassCache.get(loader, interfaces);    &#125;</code></pre></div><p><code>proxyClassCache</code>用于缓存已经创建过的代理类，定义如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;        proxyClassCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakCache</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyFactory</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyClassFactory</span>());</code></pre></div><h3 id="代理类缓存WeakCache"><a href="#代理类缓存WeakCache" class="headerlink" title="代理类缓存WeakCache"></a>代理类缓存WeakCache</h3><p>WeakCache是上述缓存proxyClassCache的具体实现，WeakCache包含以下字段：</p><ul><li><p>refQueue：ReferenceQueue类型，用于存储被回收的key</p><ul><li>ReferenceQueue：用于处理弱引用、软引用和虚引用的回收操作，当对象被GC后，可以从queue中获取对应的对象信息，进行其他处理。</li></ul></li><li><p>map：ConcurrentMap类型，存储键值对的map，有两级缓存，存储结构为：key -&gt; (subKey -&gt; value)</p><ul><li>一级缓存的key为classloader</li><li>二级缓存为KeyFactory为代理类的接口数组生成的key，包括key0、key1、key2、keyx</li></ul></li><li><p>reverseMap：记录了所有可用的代理类，key为代理类的cacheValue</p></li><li><p>subKeyFactory：BiFunction函数式接口，生成subKey的工厂类，Proxy类传入：<code>java.lang.reflect.Proxy.KeyFactory</code></p></li><li><p>valueFactory：BiFunction函数式接口，生成value的工厂类，Proxy类传入：<code>java.lang.reflect.Proxy.ProxyClassFactory</code></p></li></ul><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-comment">/*</span><span class="hljs-comment"> * @author Peter Levart</span><span class="hljs-comment"> * @param &lt;K&gt; type of keys</span><span class="hljs-comment"> * @param &lt;P&gt; type of parameters</span><span class="hljs-comment"> * @param &lt;V&gt; type of values</span><span class="hljs-comment"> */</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakCache</span>&lt;K, P, V&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReferenceQueue&lt;K&gt; refQueue        = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();    <span class="hljs-comment">// the key type is Object for supporting null key</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map        = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap        = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;&#125;</code></pre></div><h4 id="KeyFactory"><a href="#KeyFactory" class="headerlink" title="KeyFactory"></a>KeyFactory</h4><p><code>java.lang.reflect.Proxy.KeyFactory</code>是用于生成二级cache的subKey的工厂类，返回的对象为<code>WeakReference</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyFactory</span>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Object&gt;    &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces)</span> &#123;            <span class="hljs-keyword">switch</span> (interfaces.length) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Key1</span>(interfaces[<span class="hljs-number">0</span>]); <span class="hljs-comment">// the most frequent</span>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Key2</span>(interfaces[<span class="hljs-number">0</span>], interfaces[<span class="hljs-number">1</span>]);                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> key0;                <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyX</span>(interfaces);            &#125;        &#125;    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;Class&lt;?&gt;&gt; &#123;&#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Key2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;Class&lt;?&gt;&gt; &#123;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyX</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;Class&lt;?&gt;&gt;[] refs;&#125;</code></pre></div><h4 id="ProxyClassFactory"><a href="#ProxyClassFactory" class="headerlink" title="ProxyClassFactory"></a>ProxyClassFactory</h4><p><code>java.lang.reflect.Proxy.ProxyClassFactory</code>根据传入classloader和接口类数组，返回代理类的工厂。主要流程如下：</p><ul><li>校验参数的正确性：<ul><li>校验classloader加载的接口类和传入接口是否为同一个</li><li>校验是否为接口类</li><li>校验接口是否重复</li><li>判断接口的权限修饰符，非public接口的代理类包名取接口类的包名，public取<code>com.sun.proxy</code></li></ul></li><li>设置代理类的包名：包名 + $Proxy + 原子递增数字<ul><li>例如：<code>com.sun.proxy.$Proxy0</code></li></ul></li><li>调用<code>ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)</code>生成class文件</li><li>调用native方法<code>defineClass0()</code>将class文件加载到JVM</li></ul><h4 id="WeakCache-get"><a href="#WeakCache-get" class="headerlink" title="WeakCache#get"></a>WeakCache#get</h4><p><code>java.lang.reflect.Proxy#getProxyClass0</code>中调用<code>get(loader, interfaces)</code>，传入的key为<code>ClassLoader</code>类型，parameter为<code>Class&lt;?&gt;</code>类型，为代理类接口。主要流程如下：</p><ul><li>参数校验、执行<code>expungeStaleEntries()</code>清理过期对象</li><li>使用一级cache的key获取二级cache的map对象</li><li>向KeyFactory传入key和parameter，生成二级cache的key</li><li>轮询获取supplier中的value<ul><li>如果supplier为空，将当前subKey对应的数据设置为Factory实例。</li><li>Factory会通过ProxyClassFactory生成代理类</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key, P parameter)</span> &#123;        Objects.requireNonNull(parameter);        expungeStaleEntries();<span class="hljs-comment">//包装classloader，生成一级cache的key</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> CacheKey.valueOf(key, refQueue);        <span class="hljs-comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span>    <span class="hljs-comment">//获取二级cache的map对象</span>        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);        <span class="hljs-keyword">if</span> (valuesMap == <span class="hljs-literal">null</span>) &#123;            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap                = map.putIfAbsent(cacheKey,                                  valuesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;());            <span class="hljs-keyword">if</span> (oldValuesMap != <span class="hljs-literal">null</span>) &#123;                valuesMap = oldValuesMap;            &#125;        &#125;        <span class="hljs-comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span>        <span class="hljs-comment">// subKey from valuesMap</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">subKey</span> <span class="hljs-operator">=</span> Objects.requireNonNull(subKeyFactory.apply(key, parameter));    <span class="hljs-comment">//获取二级cache的值</span>        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);        <span class="hljs-type">Factory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//轮询获取supplier中的value</span>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (supplier != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span>                <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> supplier.get();                <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-keyword">return</span> value;                &#125;            &#125;            <span class="hljs-comment">// else no supplier in cache</span>            <span class="hljs-comment">// or a supplier that returned null (could be a cleared CacheValue</span>            <span class="hljs-comment">// or a Factory that wasn&#x27;t successful in installing the CacheValue)</span>            <span class="hljs-comment">// lazily construct a Factory</span>            <span class="hljs-keyword">if</span> (factory == <span class="hljs-literal">null</span>) &#123;                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory</span>(key, parameter, subKey, valuesMap);            &#125;<span class="hljs-comment">//二级cache直接放入subKey -&gt; factory的映射</span>            <span class="hljs-comment">//设置supplier = factory</span>            <span class="hljs-keyword">if</span> (supplier == <span class="hljs-literal">null</span>) &#123;                supplier = valuesMap.putIfAbsent(subKey, factory);                <span class="hljs-keyword">if</span> (supplier == <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-comment">// successfully installed Factory</span>                    supplier = factory;                &#125;                <span class="hljs-comment">// else retry with winning supplier</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//轮询时如果其他线程已经设置了值的情况</span>                <span class="hljs-comment">//替换为factory</span>                <span class="hljs-keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;                    <span class="hljs-comment">// successfully replaced</span>                    <span class="hljs-comment">// cleared CacheEntry / unsuccessful Factory</span>                    <span class="hljs-comment">// with our Factory</span>                    supplier = factory;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// retry with current supplier</span>                    supplier = valuesMap.get(subKey);                &#125;            &#125;        &#125;    &#125;</code></pre></div><h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h4><p>通过Factory实例调用<code>ProxyClassFactory.apply(key, parameter)</code>生成代理类，通过<code>synchronized</code>保证线程安全，get()的具体逻辑参考注释：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Supplier</span>&lt;V&gt; &#123;<span class="hljs-comment">//一级cache的key，为classloader</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> K key;    <span class="hljs-comment">//代理类的接口数组</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> P parameter;    <span class="hljs-comment">//二级cache的key，根据接口数组生成</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object subKey;    <span class="hljs-comment">//二级缓存的引用</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;        Factory(K key, P parameter, Object subKey,                ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;            <span class="hljs-built_in">this</span>.key = key;            <span class="hljs-built_in">this</span>.parameter = parameter;            <span class="hljs-built_in">this</span>.subKey = subKey;            <span class="hljs-built_in">this</span>.valuesMap = valuesMap;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// serialize access</span>            <span class="hljs-comment">// re-check</span>            Supplier&lt;V&gt; supplier = valuesMap.get(subKey);            <span class="hljs-comment">//避免多线程数据不一致</span>            <span class="hljs-keyword">if</span> (supplier != <span class="hljs-built_in">this</span>) &#123;                <span class="hljs-comment">// something changed while we were waiting:</span>                <span class="hljs-comment">// might be that we were replaced by a CacheValue</span>                <span class="hljs-comment">// or were removed because of failure -&gt;</span>                <span class="hljs-comment">// return null to signal WeakCache.get() to retry</span>                <span class="hljs-comment">// the loop</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;            &#125;            <span class="hljs-comment">// else still us (supplier == this)</span>            <span class="hljs-comment">// create new value</span>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//通过ProxyClassFactory去生成代理类</span>                value = Objects.requireNonNull(valueFactory.apply(key, parameter));            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// remove us on failure</span>                    valuesMap.remove(subKey, <span class="hljs-built_in">this</span>);                &#125;            &#125;            <span class="hljs-comment">// the only path to reach here is with non-null value</span>            <span class="hljs-keyword">assert</span> value != <span class="hljs-literal">null</span>;            <span class="hljs-comment">// wrap value with CacheValue (WeakReference)</span>            CacheValue&lt;V&gt; cacheValue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheValue</span>&lt;&gt;(value);            <span class="hljs-comment">// put into reverseMap</span>            reverseMap.put(cacheValue, Boolean.TRUE);            <span class="hljs-comment">// try replacing us with CacheValue (this should always succeed)</span>            <span class="hljs-keyword">if</span> (!valuesMap.replace(subKey, <span class="hljs-built_in">this</span>, cacheValue)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;Should not reach here&quot;</span>);            &#125;            <span class="hljs-comment">// successfully replaced us with new CacheValue -&gt; return the value</span>            <span class="hljs-comment">// wrapped by it</span>            <span class="hljs-keyword">return</span> value;        &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SPI机制学习与常用框架SPI案例</title>
    <link href="/2023/Java%E5%9F%BA%E7%A1%80/Java%20SPI%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6SPI%E6%A1%88%E4%BE%8B/"/>
    <url>/2023/Java%E5%9F%BA%E7%A1%80/Java%20SPI%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6SPI%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> SPI（Service Provider Interface）是JDK内置的服务提供机制，常用于框架的动态扩展，类似于可拔插机制。提供方将接口实现类配置在classpath下的指定位置，调用方读取并加载。当提供方发生变化时，接口的实现也会改变。Java生态中JDK、Dubbo、Spring等都通过SPI提供了动态扩展的能力。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Search</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearchImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Search</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;file search...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataBaseSearchImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Search</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;db search&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpiTest</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        ServiceLoader&lt;Search&gt; searches = ServiceLoader.load(Search.class);        searches.forEach(Search::search);    &#125;&#125;</code></pre></div><p>resources文件夹创建<code>META-INF/services/wang.l1n.spi.Search</code>文件，内容为接口实现类：</p><div class="code-wrapper"><pre><code class="hljs stylus">wang<span class="hljs-selector-class">.l1n</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.FileSearchImpl</span>wang<span class="hljs-selector-class">.l1n</span><span class="hljs-selector-class">.spi</span>.DataBaseSearchImpl</code></pre></div><p>运行结果：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230226183550948.png" alt="SPI运行结果"></p><h3 id="load加载流程"><a href="#load加载流程" class="headerlink" title="load加载流程"></a>load加载流程</h3><p><code>ServiceLoder.load</code>静态方法用于加载SPI实现类，实现逻辑如下：</p><ol><li>获取当前线程类加载器和上下文信息，调用实例化方法，重新加载SPI</li><li>重新加载SPI的流程：<ol><li>清空缓存providers中已实例化的SPI服务，providers是LinkedHashMap类型，用于保存已经被成功加载的SPI示例对象<ul><li>如果providers非空，直接返回Iterator，否则返回LazyIterator的Iterator。</li></ul></li><li>创建LazyIterator懒加载迭代器，传入SPI类型和类加载器</li></ol></li></ol><p>实现代码和对应的成员变量如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();        <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service,</span><span class="hljs-params">                                            ClassLoader loader)</span>    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);    &#125;<span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceLoader</span><span class="hljs-params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;        service = Objects.requireNonNull(svc, <span class="hljs-string">&quot;Service interface cannot be null&quot;</span>);        loader = (cl == <span class="hljs-literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;        acc = (System.getSecurityManager() != <span class="hljs-literal">null</span>) ? AccessController.getContext() : <span class="hljs-literal">null</span>;        reload();    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reload</span><span class="hljs-params">()</span> &#123;        providers.clear();        lookupIterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyIterator</span>(service, loader);    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;META-INF/services/&quot;</span>;    <span class="hljs-comment">// The class or interface representing the service being loaded</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;S&gt; service;    <span class="hljs-comment">// The class loader used to locate, load, and instantiate providers</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader loader;    <span class="hljs-comment">// The access control context taken when the ServiceLoader is created</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;    <span class="hljs-comment">// Cached providers, in instantiation order</span>    <span class="hljs-keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();    <span class="hljs-comment">// The current lazy-lookup iterator</span>    <span class="hljs-keyword">private</span> LazyIterator lookupIterator;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;S&gt;() &#123;            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders                = providers.entrySet().iterator();            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">if</span> (knownProviders.hasNext())                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                <span class="hljs-keyword">return</span> lookupIterator.hasNext();            &#125;            <span class="hljs-keyword">public</span> S <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">if</span> (knownProviders.hasNext())                    <span class="hljs-keyword">return</span> knownProviders.next().getValue();                <span class="hljs-keyword">return</span> lookupIterator.next();            &#125;            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();            &#125;        &#125;;    &#125;</code></pre></div><h3 id="LazyIterator加载流程"><a href="#LazyIterator加载流程" class="headerlink" title="LazyIterator加载流程"></a>LazyIterator加载流程</h3><p>加载流程参考代码注释：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyIterator</span>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;S&gt;    &#123;        Class&lt;S&gt; service;        ClassLoader loader;        Enumeration&lt;URL&gt; configs = <span class="hljs-literal">null</span>;        Iterator&lt;String&gt; pending = <span class="hljs-literal">null</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">nextName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazyIterator</span><span class="hljs-params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;            <span class="hljs-built_in">this</span>.service = service;            <span class="hljs-built_in">this</span>.loader = loader;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNextService</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (nextName != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (configs == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//获取接口的全称，拼接了META-INF/services/</span>                    <span class="hljs-type">String</span> <span class="hljs-variable">fullName</span> <span class="hljs-operator">=</span> PREFIX + service.getName();                    <span class="hljs-comment">//类加载加载文件内容</span>                    <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)                        configs = ClassLoader.getSystemResources(fullName);                    <span class="hljs-keyword">else</span>                        configs = loader.getResources(fullName);                &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;                    fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);                &#125;            &#125;            <span class="hljs-comment">//解析文件内容，获取SPI接口的实现类名</span>            <span class="hljs-keyword">while</span> ((pending == <span class="hljs-literal">null</span>) || !pending.hasNext()) &#123;                <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                pending = parse(service, configs.nextElement());            &#125;            nextName = pending.next();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">private</span> S <span class="hljs-title function_">nextService</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (!hasNextService())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();            <span class="hljs-type">String</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> nextName;            nextName = <span class="hljs-literal">null</span>;            Class&lt;?&gt; c = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//获取Class对象</span>                c = Class.forName(cn, <span class="hljs-literal">false</span>, loader);            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException x) &#123;                fail(service,                     <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not found&quot;</span>);            &#125;            <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) &#123;                fail(service,                     <span class="hljs-string">&quot;Provider &quot;</span> + cn  + <span class="hljs-string">&quot; not a subtype&quot;</span>);            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//使用newInstance创建对象，并添加到providers缓存中</span>                <span class="hljs-type">S</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> service.cast(c.newInstance());                providers.put(cn, p);                <span class="hljs-keyword">return</span> p;            &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;                fail(service,                     <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; could not be instantiated&quot;</span>,                     x);            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();          <span class="hljs-comment">// This cannot happen</span>        &#125;&#125;</code></pre></div><p>JDK SPI能实现加载扩展接口的基本要求，存在几个缺点：</p><ul><li>需要遍历所有class并进行实例化，需要调用某个特定实现只能循环找。</li><li>无法和Spring提供的上下文融合使用。</li><li>ServiceLoader类非线程安全</li></ul><h2 id="常用框架SPI案例"><a href="#常用框架SPI案例" class="headerlink" title="常用框架SPI案例"></a>常用框架SPI案例</h2><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p><code>org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames</code>方法用于加载所有<code>META-INF/spring.factories</code>文件，主要流程如下：</p><ul><li>搜索classpath下所有<code>META-INF/spring.factories</code>配置文件</li><li>解析文件，获取文件中对应的全限定类名</li></ul><p>代码注释如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FACTORIES_RESOURCE_LOCATION</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> classLoader;<span class="hljs-keyword">if</span> (classLoaderToUse == <span class="hljs-literal">null</span>) &#123;classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();&#125;<span class="hljs-type">String</span> <span class="hljs-variable">factoryTypeName</span> <span class="hljs-operator">=</span> factoryType.getName();<span class="hljs-keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">loadSpringFactories</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;    <span class="hljs-comment">//读取缓存</span>    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);<span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> result;&#125;result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取文件路径</span>Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);            <span class="hljs-comment">//遍历所有路径</span><span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.nextElement();<span class="hljs-type">UrlResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(url);                解析获取Properties对象<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> PropertiesLoaderUtils.loadProperties(resource);                <span class="hljs-comment">//解析properties，存放到map中</span><span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;<span class="hljs-type">String</span> <span class="hljs-variable">factoryTypeName</span> <span class="hljs-operator">=</span> ((String) entry.getKey()).trim();String[] factoryImplementationNames =StringUtils.commaDelimitedListToStringArray((String) entry.getValue());<span class="hljs-keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;result.computeIfAbsent(factoryTypeName, key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()).add(factoryImplementationName.trim());&#125;&#125;&#125;<span class="hljs-comment">// Replace all lists with unmodifiable lists containing unique elements</span>result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));cache.put(classLoader, result);&#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unable to load factories from location [&quot;</span> +FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">&quot;]&quot;</span>, ex);&#125;<span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>Dubbo并未使用Java SPI，基于SPI机制实现了了功能更强的ExtensionLoader，核心模块位于：org.apache.dubbo.common.extension.ExtensionLoader<br>配置文件需要放在META-INF&#x2F;dubbo下，以如下配置为例：</p><div class="code-wrapper"><pre><code class="hljs stylus">optimusPrime = org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.OptimusPrime</span>bumblebee = org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.spi</span>.Bumblebee</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DubboSPITest</span> &#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        ExtensionLoader&lt;Robot&gt; extensionLoader =             ExtensionLoader.getExtensionLoader(Robot.class);        <span class="hljs-type">Robot</span> <span class="hljs-variable">optimusPrime</span> <span class="hljs-operator">=</span> extensionLoader.getExtension(<span class="hljs-string">&quot;optimusPrime&quot;</span>);        optimusPrime.sayHello();        <span class="hljs-type">Robot</span> <span class="hljs-variable">bumblebee</span> <span class="hljs-operator">=</span> extensionLoader.getExtension(<span class="hljs-string">&quot;bumblebee&quot;</span>);        bumblebee.sayHello();    &#125;&#125;</code></pre></div><p>下面简要一下Dubbo SPI的核心类ExtensionLoader的实现。</p><h3 id="核心成员变量"><a href="#核心成员变量" class="headerlink" title="核心成员变量"></a>核心成员变量</h3><ul><li><code>LoadingStrategy[] strategies</code>：配置文件加载策略。</li><li><code>ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS</code>：每个扩展接口对应一个ExtensionLoader实例，该集合缓存了所有Loader实例。</li><li><code>ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES</code>：该Map缓存了扩展实现类与对应实例对象的映射关系</li></ul><h4 id="LoadStrategy"><a href="#LoadStrategy" class="headerlink" title="LoadStrategy"></a>LoadStrategy</h4><p>Subbo在加载SPI实现类时存在优先级，当前存在三个实现：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230806222254.png" alt="LoadStrategy"></p><p>配置文件目录有以下三个位置：</p><ol><li>META-INF&#x2F;dubbo：由DubboLoadingStrategy负责，用户自定义SPI配置文件</li><li>META-INF&#x2F;services：由ServicesLoadingStrategy负责，兼容JDK SPI</li><li>META-INF&#x2F;dubbo&#x2F;internal：由DubboInternalLoadingStrategy负责，Dubbo内部使用的SPI配置文件</li></ol><h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><p>Dubbo SPI的核心实现方法为：org.apache.dubbo.common.extension.ExtensionLoader#getExtension</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getExtension</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Extension name == null&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(name)) &#123;        <span class="hljs-comment">//获取默认的扩展实现类</span>            <span class="hljs-keyword">return</span> getDefaultExtension();        &#125;        <span class="hljs-comment">//从cachedInstances&lt;name, Holder&lt;&gt;&gt;</span>        <span class="hljs-keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> holder.get();        <span class="hljs-comment">//double check</span>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (holder) &#123;                instance = holder.get();                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">//若未创建实例，则创建并set</span>                    instance = createExtension(name);                    holder.set(instanc  e);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> (T) instance;    &#125;</code></pre></div><p>在createExtension()方法中实现了SPI配置文件的查找已经对应实现类的实例化，同时还实现了自动装配以及自动Wrapper包装等功能：</p><ol><li>getExtensionClasses()会获取cachedClass缓存，根据扩展名获取对应的实现类，如果未初始化，则调用loadExtensionClasses()加载实现类。</li><li><strong>自动装配</strong>扩展对象的属性（injectExtension()方法）</li><li>自动包装扩展对象</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//扩展实现类的加载过程</span><span class="hljs-keyword">private</span> T <span class="hljs-title function_">createExtension</span><span class="hljs-params">(String name)</span> &#123;        Class&lt;?&gt; clazz = getExtensionClasses().get(name); <span class="hljs-comment">// 1</span>        <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> findException(name);        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">T</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());                instance = (T) EXTENSION_INSTANCES.get(clazz);            &#125;            injectExtension(instance); <span class="hljs-comment">// 2</span>        <span class="hljs-comment">//3</span>            Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;                <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;                    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));                &#125;            &#125;            initExtension(instance);            <span class="hljs-keyword">return</span> instance;        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Extension instance (name: &quot;</span> + name + <span class="hljs-string">&quot;, class: &quot;</span> +                    type + <span class="hljs-string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);        &#125;    &#125;</code></pre></div><p>getExtensionClasses()实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;      Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();      <span class="hljs-keyword">if</span> (classes == <span class="hljs-literal">null</span>) &#123;          <span class="hljs-keyword">synchronized</span> (cachedClasses) &#123;              classes = cachedClasses.get();              <span class="hljs-keyword">if</span> (classes == <span class="hljs-literal">null</span>) &#123;                  classes = loadExtensionClasses();                  cachedClasses.set(classes);              &#125;          &#125;      &#125;      <span class="hljs-keyword">return</span> classes;  &#125;<span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;        cacheDefaultExtensionName();        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (LoadingStrategy strategy : strategies) &#123;            loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());            loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(<span class="hljs-string">&quot;org.apache&quot;</span>, <span class="hljs-string">&quot;com.alibaba&quot;</span>), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());        &#125;        <span class="hljs-keyword">return</span> extensionClasses;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态机引擎的业务实践</title>
    <link href="/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BC%95%E6%93%8E%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BC%95%E6%93%8E%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中通常会有状态属性，例如订单状态、事件处置状态、OA请假单状态等，都会根据不同的动作，去更新对应的状态。如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (condition1)&#123;      status = <span class="hljs-number">1</span>;  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2)&#123;      status = <span class="hljs-number">2</span>;  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition3)&#123;      status = <span class="hljs-number">3</span>;  &#125;</code></pre></div><p>上述示例存在的问题：</p><ul><li>在需求增加的情况下，if.else会不断膨胀</li><li>代码可读性差，略微改动会导致各种问题</li><li>其他业务逻辑会耦合在if.else代码段中</li></ul><p>针对系统中状态的管理，可以使用<strong>有限状态机</strong>去解决，有限状态机是表示有限个状态以及状态间转移的模型。状态机由事件、状态、动作三部分组成。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230220205838434.png" alt="image-20230220205838434"></p><h2 id="状态机的简单实现"><a href="#状态机的简单实现" class="headerlink" title="状态机的简单实现"></a>状态机的简单实现</h2><h3 id="条件分支判断"><a href="#条件分支判断" class="headerlink" title="条件分支判断"></a>条件分支判断</h3><p>最简单的方案是通过条件分支控制状态的转移，这适合于业务状态较少，并且状态跳转的逻辑较简单的场景，但是当触发事件较多时，需要嵌套多层条件判断，当需求中状态变更事件改变时，需要改动的逻辑较大。案例代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ActivityState</span> &#123;    PREPARE(<span class="hljs-number">0</span>),    STARTED(<span class="hljs-number">1</span>),    END(<span class="hljs-number">2</span>)    ;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> status;    ActivityState(<span class="hljs-type">int</span> status) &#123;        <span class="hljs-built_in">this</span>.status = status;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> status;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 活动状态-状态机</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> l1nker4</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityStateMachine</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 活动状态</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ActivityState currentState;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivityStateMachine</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.currentState = ActivityState.PREPARE;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 活动开始</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (currentState.equals(ActivityState.PREPARE)) &#123;            <span class="hljs-built_in">this</span>.currentState = ActivityState.STARTED;            <span class="hljs-comment">//do something....</span>        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 活动结束</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">if</span> (currentState.equals(ActivityState.STARTED))&#123;            <span class="hljs-built_in">this</span>.currentState = ActivityState.END;            <span class="hljs-comment">//do something...</span>        &#125;    &#125;&#125;</code></pre></div><h3 id="状态模式实现"><a href="#状态模式实现" class="headerlink" title="状态模式实现"></a>状态模式实现</h3><p>设计模式中的状态模式也是状态机的一种实现方式，定义了状态-行为的对应关系，并将各自的行为封装到状态类中。状态模式会引入较多的状态类和方法，需求变更时维护成本大。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IActivityState</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    ActivityState <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareAction</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAction</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">endAction</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityStateMachine</span> &#123;    <span class="hljs-keyword">private</span> IActivityState currentState;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivityStateMachine</span><span class="hljs-params">(IActivityState currentState)</span> &#123;        <span class="hljs-built_in">this</span>.currentState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityPrepareState</span>(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentState</span><span class="hljs-params">(IActivityState currentState)</span> &#123;        <span class="hljs-built_in">this</span>.currentState = currentState;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareAction</span><span class="hljs-params">()</span>&#123;        currentState.prepareAction();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAction</span><span class="hljs-params">()</span>&#123;        currentState.startAction();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endAction</span><span class="hljs-params">()</span>&#123;        currentState.endAction();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityPrepareState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IActivityState</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActivityStateMachine stateMachine;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivityPrepareState</span><span class="hljs-params">(ActivityStateMachine stateMachine)</span> &#123;        <span class="hljs-built_in">this</span>.stateMachine = stateMachine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ActivityState <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ActivityState.PREPARE;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareAction</span><span class="hljs-params">()</span> &#123;        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityPrepareState</span>(stateMachine));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAction</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endAction</span><span class="hljs-params">()</span> &#123;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityStartState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IActivityState</span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActivityStateMachine stateMachine;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivityStartState</span><span class="hljs-params">(ActivityStateMachine stateMachine)</span> &#123;        <span class="hljs-built_in">this</span>.stateMachine = stateMachine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ActivityState <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ActivityState.STARTED;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareAction</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAction</span><span class="hljs-params">()</span> &#123;        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityStartState</span>(stateMachine));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endAction</span><span class="hljs-params">()</span> &#123;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityEndState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IActivityState</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActivityStateMachine stateMachine;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivityEndState</span><span class="hljs-params">(ActivityStateMachine stateMachine)</span> &#123;        <span class="hljs-built_in">this</span>.stateMachine = stateMachine;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ActivityState <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ActivityState.END;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareAction</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAction</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endAction</span><span class="hljs-params">()</span> &#123;        stateMachine.setCurrentState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityEndState</span>(stateMachine));    &#125;&#125;</code></pre></div><h2 id="DSL方案"><a href="#DSL方案" class="headerlink" title="DSL方案"></a>DSL方案</h2><p>DSL（<a href="https://www.martinfowler.com/dsl.html">Domain-Specific Languages</a>）：针对以特定领域的语言，用于解决一类问题，例如：正则表达式可以解决字符串匹配这一类问题。可分为以下两种类型：</p><ul><li>Internal DSL：业务代码通过代码直接进行配置，Java Internal DSL一般直接利用建造者模式和流式接口构建</li><li>External DSL：通过外部配置文件，运行时读取进行解析，例如XML、JSON等格式</li></ul><h3 id="COLA"><a href="#COLA" class="headerlink" title="COLA"></a>COLA</h3><p><a href="https://github.com/alibaba/COLA/tree/master/cola-components/cola-component-statemachine">COLA</a>是阿里巴巴开源的DSL状态机实现，根据作者的介绍，相比较其他开源的状态机实现（Spring Statemachine等），其优点如下：</p><ul><li>开源的状态机引擎性能较差，状态机有状态，需要考虑<strong>线程安全</strong></li><li>开源的状态机较为复杂，太重。</li></ul><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p>COLA状态机的核心概念有：</p><ul><li>State：状态</li><li>Event：状态由事件触发</li><li>Transition：状态间转换的过程</li><li>External Transition：stateA -&gt; stateB</li><li>Internal Transition：steteA -&gt; stateA</li><li>Condition：是否允许到达某种状态</li><li>Action：state变化时执行的动作</li></ul><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>pom.xml：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cola<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cola-component-statemachine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Events</span> &#123;    STARTED(<span class="hljs-string">&quot;activity started&quot;</span>),    END(<span class="hljs-string">&quot;activity ended&quot;</span>)    ;    <span class="hljs-keyword">private</span> String event;    Events(String event) &#123;        <span class="hljs-built_in">this</span>.event = event;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEvent</span><span class="hljs-params">(String event)</span> &#123;        <span class="hljs-built_in">this</span>.event = event;    &#125;&#125;<span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMachine</span><span class="hljs-params">()</span> &#123;        StateMachineBuilder&lt;ActivityState, Events, Object&gt; builder = StateMachineBuilderFactory.create();        builder.externalTransition()                .from(ActivityState.PREPARE)                .to(ActivityState.STARTED)                .on(Events.STARTED)                .when(checkCondition())                .perform(doAction());        StateMachine&lt;ActivityState, Events, Object&gt; machine = builder.build(<span class="hljs-string">&quot;test&quot;</span>);        <span class="hljs-type">ActivityState</span> <span class="hljs-variable">activityState</span> <span class="hljs-operator">=</span> machine.fireEvent(ActivityState.PREPARE, Events.STARTED, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());        log.info(<span class="hljs-string">&quot;new state: &#123;&#125;&quot;</span>, activityState);    &#125;    <span class="hljs-keyword">private</span> Condition&lt;Object&gt; <span class="hljs-title function_">checkCondition</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> (context -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;);    &#125;    <span class="hljs-keyword">private</span> Action&lt;ActivityState, Events, Object&gt; <span class="hljs-title function_">doAction</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> ((from, to, event, context) -&gt; &#123;            log.info(<span class="hljs-string">&quot;&#123;&#125; is doing, from &#123;&#125;, to &#123;&#125;, on: &#123;&#125;&quot;</span>, context, from, to, event);        &#125;);    &#125;</code></pre></div><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.martinfowler.com/dsl.html">Domain-Specific Languages</a></p><p><a href="https://blog.csdn.net/significantfrank/article/details/104996419">实现一个状态机引擎，教你看清DSL的本质</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS通信过程分析</title>
    <link href="/2023/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2023/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h3><p>HTTP缺点：</p><ol><li>明文传输</li><li>C&#x2F;S两端不存在验证机制，无法确认对方身份，可能存在中间人攻击。</li></ol><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>对称加密：客户端和服务器持有同一个密钥对数据进行加密解密。</li><li>非对称加密：公钥加密私钥解密、私钥加密公钥解密</li><li>CA：证书认证机构，签发数字证书，保证公钥的可信度。</li><li>数字证书：包含版本、序列号、有效期、颁发者、公钥等信息</li></ul><p>数字证书是由CA颁发用于证明身份的证书，通过域名申请对应证书，域名的合法性由CA机构保证。</p><p>TLS有以下几个子协议：</p><ul><li>记录协议（Record Protocol）：规定TLS收发数据的基本单位为<strong>record</strong>，类似于TCP的segment，所有子协议都必须通过记录协议发出。</li><li>警报协议（Alert  Protocol）：向对方发出警报信息，比如：证书问题等</li><li>握手协议（Handshake Protocol）：两端协商TLS版本号、随机数、密码套件等信息，然后客户端通过服务端的公钥和证书上的数字签名、两端协商得到会话密钥。</li><li>变更密码规范协议：通知对方后续数据使用密码加密保护</li></ul><h2 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h2><p>HTTPS通信可以划分为三个阶段：</p><ul><li><p>TCP协议：通过三次握手建立TCP连接</p></li><li><p>TLS协议：四次握手建立TLS连接</p></li><li><p>HTTPS协议：客户端发送请求，服务端响应请求，通信报文使用密钥加密。</p></li><li><p>TLS 1.2 握手：使用非对称加密方式创建对称密钥，并使用对称加密完成HTTP通信。</p></li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230326182939.png" alt="TLS 1.2 handshake"></p><p>详细过程：</p><ol><li>客户端发送<code>Client Hello</code>消息到服务端，消息包含TLS版本、加密套件（Cipher Suite）、压缩算法、随机数，会话信息扩展信息等。</li><li>服务端发送<code>Server Hello</code>消息，消息包含服务端的TLS版本、加密套件（Cipher Suite）、会话信息</li><li>服务端发送<code>Certificate</code>消息，包括服务端的证书信息。</li><li>服务端发送<code>Server Key Exchange</code>消息，发送公钥与签名信息等。可能与<code>Server Hello Done</code>消息一同发送。</li><li>客户端发送<code>Client Key Exchange</code>消息，根据自己信任的CA列表，验证服务端证书是否可行，可信则生成一串伪随机数，并使用公钥加密，这串随机数被用于生成新的<strong>对称密钥</strong>。</li><li>服务器端使用私钥解密随机数，并使用随机数生成自己的<strong>对称主密钥</strong>。</li><li>客户端发送<code>Finished</code>消息，使用对称密钥加密这次通信的hash值。</li><li>服务端生成自己的hash值，然后解密客户端发来的信息，检查这两个值是否对应，若对应则发送<code>Finished</code>消息。</li><li>接下来，整个HTTP会话都是用对称密钥进行加密并传输。</li></ol><p>TLS握手的关键点：通过生成的随机数和服务端公钥，生成新的密钥，后续通信使用这个对称密钥加密，防止中间人攻击。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShardingSphere-JDBC学习笔记</title>
    <link href="/2023/%E4%B8%AD%E9%97%B4%E4%BB%B6/ShardingSphere-JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/%E4%B8%AD%E9%97%B4%E4%BB%B6/ShardingSphere-JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>ShardingSphere-JDBC是Apache ShardingSphere项目中的一个子项目，Apache ShardingSphere是一款分布式的数据库生态系统，可以通过分片、弹性伸缩、加密等能力对原有数据库进行增强。</p><p>ShardingSphere-JDBC定位是<strong>轻量级Java框架</strong>，在JDBC层提供额外服务。它能尽量透明化水平分库分表所带来的影响，让业务方逻辑上感知到一个数据库节点和逻辑表，当收到SQL查询，主要做了以下工作：</p><ul><li>SQL解析：词法解析和语法解析，提炼出解析上下文</li><li>SQL路由：根据解析上下文匹配用户配置的库表的分片策略，并生成路由后的SQL（一条或多条）。</li><li>SQL改写：将SQL改写为物理数据库能正常执行的语句（逻辑SQL -&gt; 物理SQL）。</li><li>SQL执行：通过多线程异步执行改写后的SQL语句。</li><li>结果归并：将多个执行结果归并为统一的JDBC接口输出。</li></ul><p>几个概念：</p><ul><li><p>逻辑表：ORM框架的业务层面，表现为一张表，例如：t_order</p></li><li><p>物理表：数据库层面实际存在的表，例如：t_order_0、t_order_1</p></li><li><p>绑定表：分片规则一致的一组分片表，进行关联查询时，建议使用分片键进行关联，否则影响查询效率。</p><ul><li><code>SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);</code></li></ul></li><li><p>广播表：数据源中都存在的表，且结构和数据都完全一致。适用于数据量不大且需要与其他大数据量表进行关联查询。</p></li><li><p>分片键：根据某个字段的计算结果（取模等）进行水平分片</p></li><li><p>路由：通过SQL语句中的信息，找到对应分片的过程</p></li></ul><h3 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h3><ul><li><p>标准分片算法：单一键作为分片键。</p><ul><li><p>取模算法：根据一些字段，或多个字段hash求值再取模。</p></li><li><p>范围限定算法，按照年份、实践等策略路由到目标数据库。</p></li></ul></li><li><p>复合分片算法：多键作为分片键，自行设计</p></li><li><p>Hint分片算法：用于处理使用Hint行分片的场景（非数据库字段的分片方式）</p></li></ul><h3 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h3><p>包含分片键和分片算法，ShardingSphere-JDBC提供了以下几种分片策略：</p><ul><li>标准分片策略（StandardSharingStrategy）：使用精确分片算法或范围分片算法，支持单分片键。</li><li>复合分片策略（ComplexShardingStrategy）：使用复合分片算法，支持多分片键。</li><li>Hint分片策略（HintShardingStrategy）：使用Hint分片算法</li><li>Inline分片策略（InlineShardingStrategy）：使用groovy表达式作为分片算法</li><li>不分片策略（NoneShardingStrategy）：不使用分片算法</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>pom.xml</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0-RC1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sharding-core-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0-RC1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>ShardingSphere提供了多种配置方式：</p><ul><li>Java代码配置</li><li>yaml、properties配置</li><li>Spring Boot配置</li></ul><p>该案例使用配置文件方式：application.properties</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">spring.shardingsphere.datasource.names</span>=test-<span class="hljs-number">0</span>,test-<span class="hljs-number">1</span><span class="hljs-attr">spring.main.allow-bean-definition-overriding</span>=<span class="hljs-literal">true</span><span class="hljs-attr">spring.datasource.driver-class-name</span>=com.mysql.cj.jdbc.Driver<span class="hljs-attr">spring.shardingsphere.datasource.test-0.type</span>=com.alibaba.druid.pool.DruidDataSource<span class="hljs-attr">spring.shardingsphere.datasource.test-0.driver-class-name</span>=com.mysql.jdbc.Driver<span class="hljs-attr">spring.shardingsphere.datasource.test-0.url</span>=jdbc:mysql://<span class="hljs-number">172.27</span>.<span class="hljs-number">184.50</span>:<span class="hljs-number">3306</span>/test-<span class="hljs-number">0</span>?useUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=utf8&amp;tinyInt1isBit=<span class="hljs-literal">false</span>&amp;useSSL=<span class="hljs-literal">false</span><span class="hljs-attr">spring.shardingsphere.datasource.test-0.username</span>=root<span class="hljs-attr">spring.shardingsphere.datasource.test-0.password</span>=<span class="hljs-number">123456</span><span class="hljs-attr">spring.shardingsphere.datasource.test-1.type</span>=com.alibaba.druid.pool.DruidDataSource<span class="hljs-attr">spring.shardingsphere.datasource.test-1.driver-class-name</span>=com.mysql.jdbc.Driver<span class="hljs-attr">spring.shardingsphere.datasource.test-1.url</span>=jdbc:mysql://<span class="hljs-number">172.27</span>.<span class="hljs-number">184.50</span>:<span class="hljs-number">3306</span>/test-<span class="hljs-number">1</span>?useUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=utf8&amp;tinyInt1isBit=<span class="hljs-literal">false</span>&amp;useSSL=<span class="hljs-literal">false</span><span class="hljs-attr">spring.shardingsphere.datasource.test-1.username</span>=root<span class="hljs-attr">spring.shardingsphere.datasource.test-1.password</span>=<span class="hljs-number">123456</span><span class="hljs-attr">spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column</span>=order_id<span class="hljs-attr">spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression</span>=test-$-&gt;&#123;order_id % <span class="hljs-number">2</span>&#125;<span class="hljs-attr">spring.shardingsphere.sharding.tables.t_order.actual-data-nodes</span>=test-$-&gt;&#123;<span class="hljs-number">0</span>..<span class="hljs-number">1</span>&#125;.t_order_$-&gt;&#123;<span class="hljs-number">0</span>..<span class="hljs-number">2</span>&#125;<span class="hljs-attr">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.sharding-column</span>=order_id<span class="hljs-attr">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.algorithm-expression</span>=t_order_$-&gt;&#123;order_id % <span class="hljs-number">3</span>&#125;<span class="hljs-attr">spring.shardingsphere.sharding.broadcast-tables</span>=t_config<span class="hljs-attr">spring.shardingsphere.props.sql.show</span>=<span class="hljs-literal">true</span></code></pre></div><p>分别创建<code>test-0</code>和<code>test-1</code>数据库，并创建以下表：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_order_0` (  `order_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `order_no` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `create_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `price` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`order_id`)) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ROW_FORMAT<span class="hljs-operator">=</span><span class="hljs-keyword">DYNAMIC</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_order_1` (  `order_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `order_no` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `create_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `price` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`order_id`)) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ROW_FORMAT<span class="hljs-operator">=</span><span class="hljs-keyword">DYNAMIC</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_order_2` (  `order_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `order_no` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `create_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `price` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`order_id`)) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ROW_FORMAT<span class="hljs-operator">=</span><span class="hljs-keyword">DYNAMIC</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_config` (  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  `remark` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `create_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,  `last_modify_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>latin1;</code></pre></div><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230212192526669.png" alt="数据库结构"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@TableName(&quot;t_order&quot;)</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TOrder</span> &#123;    <span class="hljs-keyword">private</span> Long orderId;    <span class="hljs-keyword">private</span> String orderNo;    <span class="hljs-keyword">private</span> String createName;    <span class="hljs-keyword">private</span> BigDecimal price;&#125;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertOrder</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-type">TOrder</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TOrder</span>();            order.setOrderId(ID.getAndIncrement());            order.setOrderNo(<span class="hljs-string">&quot;A000&quot;</span> + i);            order.setCreateName(<span class="hljs-string">&quot;订单 &quot;</span> + i);            order.setPrice(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;&quot;</span> + i));            orderMapper.insert(order);        &#125;    &#125;    <span class="hljs-keyword">public</span> List&lt;TOrder&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span>&#123;        QueryWrapper&lt;TOrder&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();        queryWrapper.like(<span class="hljs-string">&quot;create_name&quot;</span>, <span class="hljs-string">&quot;订单&quot;</span>);        <span class="hljs-keyword">return</span> orderMapper.selectList(queryWrapper);    &#125;&#125;<span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;TOrder&gt; &#123;    &#125;<span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> OrderService orderService;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        orderService.insertOrder();<span class="hljs-comment">//        List&lt;TOrder&gt; orderList = orderService.selectList();</span><span class="hljs-comment">//        log.info(&quot;orderList : &#123;&#125;&quot;, orderList);</span>    &#125;&#125;</code></pre></div><p>查询数据库，数据按照指定规则存储：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20230212210352405.png" alt="数据库结果"></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>DB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习笔记(三)- 时间轮算法</title>
    <link href="/2022/Netty/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%20%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/"/>
    <url>/2022/Netty/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%20%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="定时器理论"><a href="#定时器理论" class="headerlink" title="定时器理论"></a>定时器理论</h2><p>实际的业务场景会遇到许多使用定时任务的场景，定时器主要有三种表现形式：固定周期定时执行、延迟一定时间执行，指定某个时刻执行。再实现层面，定时器需要考虑<strong>存储和调度</strong>指定任务，内部通过轮询的方式检查任务是否到期并需要执行。</p><h2 id="Java定时器"><a href="#Java定时器" class="headerlink" title="Java定时器"></a>Java定时器</h2><p>Java提供了三种常用的定时器实现方式：</p><ul><li>Timer</li><li>DelayQueue</li><li>ScheduledThreadPoolExecutor</li></ul><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>Timer使用的就是上述最原始的定时器实现方式：</p><ul><li><strong>存储</strong>：TaskQueue是数组实现的小根堆，deadline最近的任务位于堆顶端。</li><li><strong>调度</strong>：TimerThread异步线程，定时轮询队列，如果堆顶任务的deadline已到，那么执行任务，如果是周期性任务，执行完计算下次deadline，并再次放入小根堆。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskQueue</span>();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TimerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerThread</span>(queue);    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Timer</span><span class="hljs-params">(String name)</span> &#123;        thread.setName(name);        thread.start();    &#125;&#125;</code></pre></div><p>Timer存在几个缺陷：</p><ol><li>单线程模式，某个TimeTask阻塞，会影响其他的任务调度。</li><li>Timer的任务调度基于系统时间的，系统时间不正确，可能出现问题。</li><li>TimeTask执行出现异常，Timer不会捕获，线程终止后，其他任务都不能执行。</li></ol><p>使用案例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<span class="hljs-comment">//设置一个10s后调度一个周期为1s的定时任务</span>timer.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// do something</span>    &#125;&#125;, <span class="hljs-number">10000</span>, <span class="hljs-number">1000</span>);</code></pre></div><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue是一种可以延迟获取对象的阻塞队列，内部使用PriorityQueue存储任务，每个元素必须实现Delayed接口，并重写指定方法。DelayQueue提供了put和take两个阻塞方法。对象put进去后，通过compareTo进行优先级排序，getDelay计算出剩余时间，只有小于等于0时，对象才能从其中被取出。</p><p>实际上只实现了存储定时任务的功能，还需要配合异步线程才能实现定时器。</p><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>该线程池继承于ThreadPoolExecutor，提供了周期执行和延迟执行的功能，在ThreadPoolExecutor的基础上，重新设计了任务ScheduledFutureTask和阻塞队列DelayedWorkQueue。</p><ul><li>ScheduledFutureTask：继承于FutureTask，重写run方法，使其具有周期执行任务的能力。</li><li>DelayedWorkQueue：优先级队列，deadline最近的任务在头部，周期任务执行完重设事件，再次放入队列。</li></ul><p>以上三种定时器在面临海量任务的插入删除都存在性能瓶颈，时间轮算法可以解决相应的性能问题。</p><h2 id="时间轮结构"><a href="#时间轮结构" class="headerlink" title="时间轮结构"></a>时间轮结构</h2><p>如下图所示，时间轮可以理解成环型队列，每个元素代表一个时间段（slot），并且能存放多个任务，同一个时间段中的任务通过链表保存，时间轮随着时间变化，时针指向一个个区间，并执行区间内所有任务。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221203230539952.png" alt="时间轮结构"></p><p>- </p><h2 id="HashedWheelTimer"><a href="#HashedWheelTimer" class="headerlink" title="HashedWheelTimer"></a>HashedWheelTimer</h2><h3 id="接口关系"><a href="#接口关系" class="headerlink" title="接口关系"></a>接口关系</h3><p>HashedWheelTimer是Netty中的时间轮算法的实现类。其实现了Timer接口，该接口提供了两个方法：</p><ul><li><strong>newTimeout</strong>：创建定时任务</li><li><strong>stop</strong>：停止所有未执行的定时任务</li></ul><p>HashedWheelTimer类图如下所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221204132943857.png" alt="HashedWheelTimer类图结构"></p><p>Timer中使用的TimerTask和Timeout是两个接口，分别定义如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimerTask</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Timeout</span> &#123;    Timer <span class="hljs-title function_">timer</span><span class="hljs-params">()</span>;    TimerTask <span class="hljs-title function_">task</span><span class="hljs-params">()</span>;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExpired</span><span class="hljs-params">()</span>;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span>;&#125;</code></pre></div><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashedWheelTimer</span><span class="hljs-params">(</span><span class="hljs-params">            ThreadFactory threadFactory,</span><span class="hljs-params">            <span class="hljs-type">long</span> tickDuration, TimeUnit unit, <span class="hljs-type">int</span> ticksPerWheel, <span class="hljs-type">boolean</span> leakDetection,</span><span class="hljs-params">            <span class="hljs-type">long</span> maxPendingTimeouts)</span></code></pre></div><p>核心属性如下：</p><ul><li><strong>threadFactory</strong>：线程池，只创建了一个线程。</li><li><strong>tickDuration</strong>：时针移动的单位，相当于时间段长度。</li><li><strong>unit</strong>：tickDuration的时间单位。</li><li><strong>ticksPerWheel</strong>：时间轮上的slot数量，默认为512个。</li><li><strong>leakDetection</strong>：是否开启内存泄漏检测</li><li><strong>maxPendingTimeouts</strong>：最大允许等待的任务数量。</li></ul><h3 id="createWheel-时间轮初始化"><a href="#createWheel-时间轮初始化" class="headerlink" title="createWheel-时间轮初始化"></a>createWheel-时间轮初始化</h3><p>createWheel方法是HashedWheelTimer构造方法中用来创建HashedWheelBucket数组，该数组就是时间轮，内部是一个双向链表，存储的元素为HashedWheelTimeout，这代表的是定时任务。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashedWheelBucket[] createWheel(<span class="hljs-type">int</span> ticksPerWheel) &#123;    <span class="hljs-comment">// 省略其他代码</span>    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);    HashedWheelBucket[] wheel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelBucket</span>[ticksPerWheel];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wheel.length; i ++) &#123;        wheel[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelBucket</span>();    &#125;    <span class="hljs-keyword">return</span> wheel;&#125;<span class="hljs-comment">//找到不小于ticksPerWheel的最小2次幂</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">normalizeTicksPerWheel</span><span class="hljs-params">(<span class="hljs-type">int</span> ticksPerWheel)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">normalizedTicksPerWheel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;        normalizedTicksPerWheel &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> normalizedTicksPerWheel;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashedWheelBucket</span> &#123;    <span class="hljs-keyword">private</span> HashedWheelTimeout head;    <span class="hljs-keyword">private</span> HashedWheelTimeout tail;&#125;</code></pre></div><h3 id="newTimeout-创建定时任务"><a href="#newTimeout-创建定时任务" class="headerlink" title="newTimeout-创建定时任务"></a>newTimeout-创建定时任务</h3><p>该方法用于往时间轮添加任务，主要有三个流程：</p><ul><li>启动工作线程</li><li>创建定时任务</li><li>把HashedWheelTimeout任务添加到Mpsc Queue<ul><li>Mpsc Queue是线程安全的队列，借助该队列保证添加任务的线程安全性。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Timeout <span class="hljs-title function_">newTimeout</span><span class="hljs-params">(TimerTask task, <span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;        ObjectUtil.checkNotNull(task, <span class="hljs-string">&quot;task&quot;</span>);        ObjectUtil.checkNotNull(unit, <span class="hljs-string">&quot;unit&quot;</span>);        <span class="hljs-type">long</span> <span class="hljs-variable">pendingTimeoutsCount</span> <span class="hljs-operator">=</span> pendingTimeouts.incrementAndGet();        <span class="hljs-keyword">if</span> (maxPendingTimeouts &gt; <span class="hljs-number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;            pendingTimeouts.decrementAndGet();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Number of pending timeouts (&quot;</span>                + pendingTimeoutsCount + <span class="hljs-string">&quot;) is greater than or equal to maximum allowed pending &quot;</span>                + <span class="hljs-string">&quot;timeouts (&quot;</span> + maxPendingTimeouts + <span class="hljs-string">&quot;)&quot;</span>);        &#125;<span class="hljs-comment">//启动工作线程</span>        start();        <span class="hljs-comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span>        <span class="hljs-comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span>        <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + unit.toNanos(delay) - startTime;        <span class="hljs-comment">// Guard against overflow.</span>        <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span> &amp;&amp; deadline &lt; <span class="hljs-number">0</span>) &#123;            deadline = Long.MAX_VALUE;        &#125;        <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimeout</span>(<span class="hljs-built_in">this</span>, task, deadline);        timeouts.add(timeout);        <span class="hljs-keyword">return</span> timeout;    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, <span class="hljs-string">&quot;workerState&quot;</span>);<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//获取工作线程的状态</span>        <span class="hljs-keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="hljs-built_in">this</span>)) &#123;            <span class="hljs-keyword">case</span> WORKER_STATE_INIT:                <span class="hljs-keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;                    workerThread.start();                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> WORKER_STATE_STARTED:                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> WORKER_STATE_SHUTDOWN:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;cannot be started once stopped&quot;</span>);            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid WorkerState&quot;</span>);        &#125;        <span class="hljs-comment">// Wait until the startTime is initialized by the worker.</span>        <span class="hljs-keyword">while</span> (startTime == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                startTimeInitialized.await();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;                <span class="hljs-comment">// Ignore - it will be ready very soon.</span>            &#125;        &#125;    &#125;</code></pre></div><h3 id="Worker-执行引擎"><a href="#Worker-执行引擎" class="headerlink" title="Worker-执行引擎"></a>Worker-执行引擎</h3><p>worker是负责执行任务的，实现了Runnable接口，工作线程通过<code>workerThread = threadFactory.newThread(worker);</code>来创建。执行流程如下：</p><ol><li>waitForNextTick计算出下次tick时间，sleep到下次tick</li><li>计算当前tick在时间轮中的对应下标</li><li>移除被取消的任务</li><li>执行当前时间轮的到期任务</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Timeout&gt;();        <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> tick;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">// Initialize the startTime.</span>            startTime = System.nanoTime();            <span class="hljs-keyword">if</span> (startTime == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// We use 0 as an indicator for the uninitialized value here, so make sure it&#x27;s not 0 when initialized.</span>                startTime = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">// Notify the other threads waiting for the initialization at start().</span>            startTimeInitialized.countDown();            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-comment">//计算下次tick时间</span>                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> waitForNextTick();                <span class="hljs-keyword">if</span> (deadline &gt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">//获取当前tick在时间轮中的下标</span>                    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (tick &amp; mask);                    <span class="hljs-comment">//移除被取消的任务</span>                    processCancelledTasks();                    <span class="hljs-type">HashedWheelBucket</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span>                            wheel[idx];                    <span class="hljs-comment">//从Mpsc Queue取出任务，加入slot</span>                    transferTimeoutsToBuckets();                    <span class="hljs-comment">//执行所有到期的任务</span>                    bucket.expireTimeouts(deadline);                    tick++;                &#125;            &#125; <span class="hljs-keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="hljs-built_in">this</span>) == WORKER_STATE_STARTED);            <span class="hljs-comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span>            <span class="hljs-keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;                bucket.clearTimeouts(unprocessedTimeouts);            &#125;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">HashedWheelTimeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> timeouts.poll();                <span class="hljs-keyword">if</span> (timeout == <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (!timeout.isCancelled()) &#123;                    unprocessedTimeouts.add(timeout);                &#125;            &#125;            processCancelledTasks();        &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习笔记(二)- 内部机制</title>
    <link href="/2022/Netty/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%20%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/Netty/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%20%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件调度层"><a href="#事件调度层" class="headerlink" title="事件调度层"></a>事件调度层</h1><h2 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h2><p>Netty中三种Reactor线程模型来源于<a href="https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable I&#x2F;O in Java</a>，主要有以下三种：</p><ul><li>单线程模型：所有IO操作（连接建立、读写、事件分发）都由一个线程完成。</li><li>多线程模型：使用多线程处理任务。线程内部仍然是串行化。</li><li>主从多线程模型：主线程只负责连接的Accept事件，从线程负责除连接外的事件。</li></ul><p>Reactor线程模型运行机制可以分为以下四个步骤：</p><ul><li>注册连接：将Channel注册到Reactor线程中的Selector。</li><li>事件轮询：轮询Selector中已注册的Channel的IO事件。</li><li>事件分发：将连接的IO事件分发给worker线程。</li><li>任务处理：Reactor线程负责队列中的非IO任务。</li></ul><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop是一种<strong>事件处理模型</strong>，Netty中EventLoop运行机制如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221113182321659.png" alt="EventLoop运行机制"></p><ul><li>BossEventLoopGroup：负责监听客户端的Accept事件，触发时将事件注册到WorkerEventLoopGroup中的一个NioEventLoop，</li><li>WorkerEventLoopGroup：每建立一个Channel，都选择一个NioEventLoop与其绑定，Channel的所有事件都是线程独立的。不会和其他线程发生交集。</li></ul><h3 id="任务处理机制"><a href="#任务处理机制" class="headerlink" title="任务处理机制"></a>任务处理机制</h3><p>NioEventLoop不仅负责处理IO事件，还要兼顾执行任务队列中的任务。任务队列遵守FIFO原则。任务基本可以分为三类：</p><ul><li>普通任务：通过NioEventLoop的execute()方法向taskQueue中添加的。</li><li>定时任务：通过NioEventLoop的schedule()方法向scheduledtaskQueue添加的定时任务，例如心跳消息可以通过该任务实现。</li><li>尾部队列：执行完taskQueue中任务后会去获取尾部队列tailTasks中的任务去执行。主要做收尾工作，例如统计事件循环的执行时间等。</li></ul><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ul><li>使用Boss和Worker两个Group分别处理不同的事件，合理分担压力。</li><li>对于耗时较长的ChannelHandler可以考虑维护一个业务线程池，将任务封装成Task进行异步处理。，避免ChannelHandler阻塞而造成EventLoop不可用。</li><li>选用合理的ChannelHandler数量，明确业务和Netty的分层。</li></ul><h1 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h1><h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p>Pipeline如同字面意思，原始的网络字节流流经pipeline，被逐层处理，最终得到成品数据并返回。Netty中的ChannelPipeline采取责任链模式，调用链路环环相扣。</p><p>ChannelPipeline由一组ChannelHandlerContext组成，内部通过双向链表将ChannelHandlerContext连接起来，当IO事件触发时，依次调用Handler对数据进行处理。ChannelHandlerContext用于保存ChannelHandler的上下文，包含了其生命周期的所有事件：connect、bind、read等。</p><p>根据数据流向，ChannelPipeline可以分为入站和出站两种处理器，对应<strong>ChannelInboundHandler</strong>和<strong>ChannelOutboundHandler</strong>。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>ChannelHandler采用了责任链模式，如果前置的Handler抛出呢Exception，会传递到后置Handler，异常处理的最佳实践，就是在最后加上自定义的异常处理器。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelDuplexHandler</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;        <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;            System.out.println(<span class="hljs-string">&quot;Handle Business Exception Success.&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>Netty中面向用户态的数据操作优化，主要包含以下几个方面：</p><ol><li>使用堆外内存，避免JVM内存到堆外内存之间的数据拷贝</li><li>使用CompositeByteBuf，可以组合多个Buffer，将其合并成逻辑上的一个对象，避免物理的内存拷贝。</li><li>使用Unpooled.wrappedBuffer，将byte数组包装成ByteBuf对象，过程间不产生内存拷贝。</li><li>ByteBuf.slice切分时不产生内存拷贝，底层共享一个byte数组。</li><li>使用FileRegion实现文件传输，使用的FileChannel#transferTo()，直接将缓冲区数据输出到目标Channel，避免内核缓冲区和用户态缓冲区的数据拷贝。</li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinIO的分布式存储实践方案</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/MinIO/MinIO%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/MinIO/MinIO%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MinIO是一个开源的分布式对象存储组件，它兼容Amazon S3 API，适合于存储大容量的非结构化数据，支持单个对象最大5TB。</p><p>MinIO特点：</p><ul><li>部署简单，仅需要单独一个二进制文件</li><li>支持纠删码机制，能恢复部分数据块丢失的情况。</li><li>读写性能高</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220924181123151.png" alt="MinIO Benchmark"></p><h2 id="基础原理"><a href="#基础原理" class="headerlink" title="基础原理"></a>基础原理</h2><h3 id="纠删码"><a href="#纠删码" class="headerlink" title="纠删码"></a>纠删码</h3><p>纠删码是分布式存储领域常见的一种冗余技术，与副本机制相对比，纠删码拥有更高的磁盘利用率。纠删码的基本原理：通过<strong>纠删码算法</strong>对原始数据进行计算，得到冗余的编码数据，并将数据和冗余编码一起存储，如果未来存储介质发生故障，导致其中部分数据出错，此时可以通过对应的重构算法，<strong>解码</strong>出完整的原始数据，以达到容错的目的。即<strong>总数据块 &#x3D; 原始块 + 校验快</strong>($n &#x3D; k + m$)。纠删码技术的磁盘利用率为$k &#x2F; (k + m)$，允许总数据块中任意m个数据块损坏。</p><p>上面提到的n、m的比值，是衡量纠删码的核心参数，这个值被称为冗余度，冗余度越高（校验快越多），允许丢失的数据块可以越多，同时数据存储成本也就越高。k值决定数据分块的粒度，k越小，数据分散度越小、重建代价越大。k值越大，数据拷贝的负载越大。常见的公有云独享存储的冗余度一般在<code>1.2-1.4</code>左右。</p><p>目前常用的纠删码算法：<code>Reed-Solomon</code>，它有两个参数n和m，记为$RS(n , m)$。n代表原始数据块个数。m代表校验块个数。</p><p>下图中是使用16块磁盘作为存储设备的情况，假设此时MinIOn持有16个磁盘，MinIO会将其中8块作为数据盘，另外八块作为校验盘，数据盘存储对象的原始数据，校验盘存储对象的校验数据。纠删码默认配置是<strong>1:1</strong>，也就是将所有磁盘中的一半作为数据盘，一半做为校验盘。同时MinIO使用HighwayHash编码计算数据块的hash值，获取文件时会计算hash值来校验文件的准确性。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/erasure-code1.jpg" alt="纠删码的磁盘布局"></p><ul><li>纠删码缺点<ul><li>需要读取其他的数据块和校验块</li><li>编码解码需要消耗CPU资源</li></ul></li><li>纠删码优点<ul><li>副本机制对于大文件机极其消耗磁盘空间，纠删码可以通过较少的磁盘冗余，较为高效的解决数据丢失的问题。</li></ul></li><li>应用场景<ul><li>对于不被长期访问的冷数据，采用纠删码技术，可以大大减少副本数量。</li></ul></li></ul><h3 id="Server-Pool"><a href="#Server-Pool" class="headerlink" title="Server Pool"></a>Server Pool</h3><p>使用minio server指令创建的MinIO节点集合，提供对象存储和处理请求的功能。</p><p>MinIO可以通过增加Server Pool的方式，实现集群的横向扩展。</p><p>当有新的Server Pool加入Cluster，存储的元数据会进行同步，但是其他Server Pool已存储对象不会同步。</p><p>举例：</p><ul><li><p>minio server <a href="https://minio{1...4}.example.net/mnt/disk%7B1...4%7D%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AAServer">https://minio{1...4}.example.net/mnt/disk{1...4}代表一个Server</a> Pool，其中有四个server节点各有4块磁盘。</p></li><li><p>minio server <a href="https://minio{1...4}.example.net/mnt/disk%7B1...4%7D">https://minio{1...4}.example.net/mnt/disk{1...4}</a> <a href="https://minio{5...8}.example.net/mnt/disk%7B1...4%7D%E4%BB%A3%E8%A1%A8%E6%9C%89%E4%B8%A4%E4%B8%AAServer">https://minio{5...8}.example.net/mnt/disk{1...4}代表有两个Server</a> Pool。</p></li></ul><p>MinIO选择Server Pool策略；选择剩余空间最大的Server Pool进行存储。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221113153730493.png" alt="MinIO选择策略"></p><h3 id="存储级别"><a href="#存储级别" class="headerlink" title="存储级别"></a>存储级别</h3><p>MinIO目前支持两种存储级别：Reduced Redundancy和Standard，提供两种不同的级别来修改数据块和校验块的比例。MinIO使用<strong>EC:N</strong>来表示EC Set中存储校验块的磁盘数量，N越大，容错能力越强，但占用磁盘空间越多。</p><p>可以通过在S3 Put API中添加x-amz-storage-class参数来指定当前文件的存储级别。</p><ul><li>Standard：默认使用的存储级别，EC:N参数与Set中磁盘数量有关。可通过环境变量MINIO_STORAGE_CLASS_STANDARD&#x3D;EC:N来设置，N不能大于磁盘数量的一半。</li><li>Reduced Redundancy：使用比Standard级别更少的磁盘数量存储校验块。通过环境变量MINIO_STORAGE_CLASS_RRS&#x3D;EC:N来设置。默认参数为EC:2</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20221113154043570.png" alt="存储级别设置"></p><h3 id="Erasure-Sets"><a href="#Erasure-Sets" class="headerlink" title="Erasure Sets"></a>Erasure Sets</h3><p>MinIO集群会将所持有的磁盘设备（数据盘+校验盘）划分为多个<strong>Erasure Sets（EC Set）</strong>。EC Set的磁盘数量取值为<strong>4-16之间</strong>。Ec Set具体划分情况参考2.1节表格。文件通过S3 API传入集群后，通过分片算法找到<strong>具体的存储Set</strong>，假设当前Set拥有16个磁盘，按照默认的纠删策略，会将整个文件划分成8个数据分片(data shards)，再通过纠删码算法算出8个校验分片（parity shards）。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/minio-architecture.png" alt="MinIO EC Set模型"></p><p>MinIO使用<strong>EC:N</strong>来表示<strong>EC Set</strong>中存储校验块的磁盘数量，N越大，容错能力越强，占用磁盘空间越多。假设使用EC:2策略，当前总共有4个磁盘，对象会被分为2个数据块，2个奇偶校验块，共4个块，其中允许任意2个出错，但是能正常<strong>读</strong>数据。但是如果需要保证正常<strong>读写，</strong>需要保证3个磁盘正常（N+1）。上面的参数N可通过<strong>MINIO_STORAGE_CLASS_STANDARD</strong>参数来指定，最大值为磁盘总数量的一半，最小值为2（开启纠删码功能最小磁盘数量为4）。</p><p>EC Set的磁盘数量和对应的默认纠删策略对应如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220819174124842.png" alt="image-20220819174124842"></p><h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><ul><li><p><strong>Write</strong>：根据对象名计算出hash得到所处的EC Set，然后创建临时目录，将对象数据写入，直到所有数据写入完成，接下来每次读取10MB，进行EC编码，并将编码数据保存，然后写入meta信息，最终将数据移动到指定存储位置，并删除临时目录。</p></li><li><p><strong>Read</strong>：根据对象名获取对应的EC Set，然后去读取meta信息，通过meta信息去做解码，每次读取10MB，在纠删码特性中，如果是默认1:1策略，只需要读取N&#x2F;2的数据即可完成解码。</p></li><li><p>Server Pool：通过minio server指定的服务端节点集合，可以提供对象存储和检索请求等功能。当有新的Server Pool加入Cluster，bucket的元数据会进行同步，但是其他Server Pool已存储的对象不会同步到新的Server Pool。</p><ul><li>例如minio server <a href="https://minio{1...4}.example.net/mnt/disk%7B1...4%7D">https://minio{1...4}.example.net/mnt/disk{1...4}</a>  代表一个Server Pool，其中有四个server节点各有4块磁盘。</li></ul></li><li><p>Cluster：集群中包括一个或多个Server Pool。每个hostname参数代表一个Server Pool。MinIO均匀地将对象放入更为空闲的Server Pool。</p><ul><li>minio server <a href="https://minio{1...4}.example.net/mnt/disk%7B1...4%7Dhttps://minio%7B5...8%7D.example.net/mnt/disk%7B1...4%7D">https://minio{1...4}.example.net/mnt/disk{1...4}https://minio{5...8}.example.net/mnt/disk{1...4}</a> 代表有两个Server Pool。</li></ul></li></ul><h2 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h2><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/minio-server-startup-mode.png" alt="部署方案图"></p><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><p>单机单磁盘：</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./minio</span> server <span class="hljs-params">--address</span> <span class="hljs-function">:50851</span> <span class="hljs-params">--console-address</span> <span class="hljs-function">:19003</span> <span class="hljs-string">/data01/miniotest</span></code></pre></div><p>单机多磁盘（最低四个盘开启纠删功能）</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./minio</span> server <span class="hljs-params">--address</span> <span class="hljs-function">:50851</span> <span class="hljs-params">--console-address</span> <span class="hljs-function">:19003</span> <span class="hljs-string">/data01/miniotest</span> <span class="hljs-string">/data02/miniotest</span> <span class="hljs-string">/data03/miniotest</span> <span class="hljs-string">/data04/miniotest</span><span class="hljs-string">./minio</span> server <span class="hljs-params">--address</span> <span class="hljs-function">:50851</span> <span class="hljs-params">--console-address</span> <span class="hljs-function">:19003</span> <span class="hljs-string">/data0</span>&#123;1.<span class="hljs-string">..4</span>&#125;<span class="hljs-string">/miniotest</span></code></pre></div><table><thead><tr><th align="center">挂载磁盘数量（n）</th><th align="center">EC  Set情况</th></tr></thead><tbody><tr><td align="center">4 &lt;&#x3D;  n &lt;&#x3D;16</td><td align="center">1个</td></tr><tr><td align="center">18</td><td align="center">2个，每个9个磁盘</td></tr><tr><td align="center">19</td><td align="center">报错</td></tr><tr><td align="center">20</td><td align="center">2个，每个10个磁盘</td></tr><tr><td align="center">31</td><td align="center">报错</td></tr><tr><td align="center">32</td><td align="center">2个，每个16个磁盘</td></tr><tr><td align="center">33</td><td align="center">3个，每个11个磁盘</td></tr><tr><td align="center">34</td><td align="center">报错</td></tr><tr><td align="center">35</td><td align="center">5个，每个7个磁盘</td></tr><tr><td align="center">36</td><td align="center">3个，每个12个磁盘</td></tr></tbody></table><p>经过验证，挂载数量4 &lt;&#x3D; n &lt;&#x3D;16时，EC Set只有一个，并且set中磁盘数即为n。16 &lt;&#x3D; n &lt;&#x3D; 32时，n只能取被2整除。</p><p>如果n &gt; 32时，n必须有以下集合的公因数（用a表示），共有n &#x2F; a 个EC Set，每个set有a个磁盘。</p><p>集合为：[4 5 6 7 8 9 10 11 12 13 14 15 16]</p><h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p>由于集群需要保证数据一致性，因此MinIO使用分布式锁<a href="https://github.com/minio/dsync">Dsync</a>来实现，Dsync在节点数量少的时候性能很高，随着节点数量增加，性能会出现下降趋势，能保证的最大节点数量为32。如果当前集群节点数量已到达32个，但是仍需要扩容，可以考虑<strong>多集群方案</strong>：通过负载均衡组件，可以根据header、文件名hash等将请求转发给不同的集群。</p><p>分布式部署需要有相同的账号密码，集群节点的时间差不能超过3秒，需要使用NTP来保证时间的一致。集群节点数量必须是大于等于4的偶数。官方建议使用Nginx、HAProxy等组件来实现负载均衡。受限于纠删码策略，MinIO扩容的机器数量必须保持和原有集群数量大小相同或为倍数。不支持扩容单个节点等操作。</p><p>将n01-n03三台主机下面的data01-data04的miniotest1作为存储位置。共12块磁盘</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./minio</span> server <span class="hljs-params">--address</span> <span class="hljs-function">:50851</span> <span class="hljs-params">--console-address</span> <span class="hljs-function">:19003</span> http:<span class="hljs-string">//n0</span>&#123;1.<span class="hljs-string">..3</span>&#125;<span class="hljs-string">.bda.test.com/data0</span>&#123;1.<span class="hljs-string">..4</span>&#125;<span class="hljs-string">/miniotest1</span></code></pre></div><p>扩容时，末尾添加扩容的节点，并重启集群：</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./minio</span> server <span class="hljs-params">--address</span> <span class="hljs-function">:50851</span> <span class="hljs-params">--console-address</span> <span class="hljs-function">:19003</span> http:<span class="hljs-string">//n0</span>&#123;1.<span class="hljs-string">..3</span>&#125;<span class="hljs-string">.bda.test.com/data0</span>&#123;1.<span class="hljs-string">..4</span>&#125;<span class="hljs-string">/miniotest1</span> http:<span class="hljs-string">//n0</span>&#123;1.<span class="hljs-string">..3</span>&#125;<span class="hljs-string">.bda.test.com/data0</span>&#123;5.<span class="hljs-string">..8</span>&#125;<span class="hljs-string">/miniotest1</span></code></pre></div><h2 id="监控方案"><a href="#监控方案" class="headerlink" title="监控方案"></a>监控方案</h2><p>设置环境变量<code>MINIO_PROMETHEUS_AUTH_TYPE=&quot;public&quot;</code>，并在<code>Prometheus.yml</code>添加如下配置：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">scrape_configs</span><span class="hljs-punctuation">:</span><span class="hljs-bullet">-</span> <span class="hljs-string">job_name: minio-job</span>  <span class="hljs-attribute">metrics_path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/minio/v2/metrics/cluster</span>  <span class="hljs-attribute">scheme</span><span class="hljs-punctuation">:</span> <span class="hljs-string">https</span>  <span class="hljs-attribute">static_configs</span><span class="hljs-punctuation">:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">targets: [&#x27;minio.example.net:9000&#x27;]W</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MinIO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty学习笔记(一)-概览</title>
    <link href="/2022/Netty/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E6%A6%82%E8%A7%88/"/>
    <url>/2022/Netty/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Netty是一个应用于网络编程领域的NIO网络框架，通过屏蔽底层Socket编程细节，封装了提供上层业务使用的API，简化了网络应用的开发过程。Netty需要关注以下几点：</p><ul><li>IO模型、线程模型</li><li>事件处理机制</li><li>API接口的使用</li><li>数据协议、序列化的支持</li></ul><p>Netty的IO模型是基于非阻塞IO实现的，底层通过<code>JDK NIO</code>中的<code>Selector</code>实现，<code>Selector</code>可以同时轮询多个<code>Channel</code>，采用<code>epoll</code>模式后只需要一个线程负责<code>Selector</code>的轮询。</p><p>IO多路复用的场景中，需要一个<code>Event Dispather</code>负责将读写事件分发给对应的<code>Event Handler</code>，事件分发器主要有两种：</p><ul><li>Reactor：采用同步IO，实现简单，适用于处理耗时短的场景，耗时长的IO操作容易出现阻塞。</li><li>Proactor：采用异步IO，实现逻辑复杂，性能更高</li></ul><p>Netty的优点：</p><ul><li>易用：将NIO的API进一步封装，提供了开箱即用的工具</li><li>稳定：修复了NIO的bug</li><li>可扩展：可以通过启动参数选择Reactor线程模型</li><li>低消耗：Netty性能优化<ul><li>对象池复用</li><li>零拷贝</li></ul></li></ul><h2 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h2><p>NIO是一种同步非阻塞的IO模型，NIO与普通IO的最大区别就是非阻塞，通过每个线程通过Selector去监听多个Channel，并且读写数据是以块为单位，与BIO相比，大大提升了IO效率。</p><p>BIO存在的问题：</p><ul><li>accept、read、write都是同步阻塞，处理IO时，线程阻塞。</li><li>BIO模型严重依赖线程，线程资源比较宝贵。<ul><li>Linux中用<code>task_struct</code>管理，创建或销毁线程使用系统调用，开销大，并且进程切换也存在开销</li><li>每个线程在JVM中占用1MB内存，连接数量大的时候，极易产生OOM</li></ul></li></ul><p>Standard IO是对字节流进行读写，读写单位是字节，NIO将IO抽象成块，读写单位是块。</p><p>基本概念：</p><ul><li><p>Channel：对原IO包中流的模拟，可以通过它来读取和写入数据，数据流向是双向的。</p><ul><li>FileChannel：从文件中读取数据</li><li>DatagramChannel：通过UDP读写网络数据</li><li>SocketChannel：通过TCP读写网络数据</li><li>ServerSocketChannel：监听新的TCP连接，对每个新连接都创建一个SocketChannel</li></ul></li><li><p>Buffer：Channel中的数据都需要通过Buffer进行传递，本质上是数组</p><ul><li>ByteBuffer、CharBuffer等</li><li>Buffer的内部变量：<ul><li>capacity：最大容量</li><li>position：当前读写处的下标位置</li><li>limit：还可读写的下标位置</li></ul></li></ul></li><li><p>Selector：NIO采用的Reactor模型，一个线程使用一个Selector通过轮询的方式去监听多个Channel上面的事件，将Channel配置为非阻塞，那么Selector检测到当前Channel没有IO事件，就会轮询其他Channel。</p></li></ul><p>内存映射文件：是一种读写文件的方式，比常规基于流或者Channel的IO快。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将文件的前1024字节映射到内存中，map()方法返回一个MappedByteBuffer</span><span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mbb</span> <span class="hljs-operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>);</code></pre></div><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleServer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * ServerBootstrap：服务端启动器，负责组装、协调netty组件</span><span class="hljs-comment">         * NioEventLoopGroup：thread + selector</span><span class="hljs-comment">         * NioServerSocketChannel：对原生NIO的ServerSocketChannel封装</span><span class="hljs-comment">         * ChannelInitializer：对channel进行初始化</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())                .channel(NioServerSocketChannel.class)                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;                    <span class="hljs-comment">//连接建立后执行initChannel</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;                        <span class="hljs-comment">//StringDecoder：将Bytebuffer转为string</span>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>());                        <span class="hljs-comment">//自定义handler</span>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;                                System.out.println(msg);                            &#125;                        &#125;);                    &#125;                &#125;)                .bind(<span class="hljs-number">8080</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleClient</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())                .channel(NioSocketChannel.class)                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());                    &#125;                &#125;)                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))                <span class="hljs-comment">//阻塞直到连接建立</span>                .sync()                <span class="hljs-comment">//代表连接对象</span>                .channel()                <span class="hljs-comment">//发送数据</span>                .writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="Netty组件"><a href="#Netty组件" class="headerlink" title="Netty组件"></a>Netty组件</h2><ul><li>Core：提供了底层网络通信的抽象和实现，支持零拷贝的ByteBuffer、可扩展的事件模型、通信API。</li><li>协议支持层：对主流协议的编解码实现，包括：HTTP、SSL、Protobuf等，还支持自定义应用层协议。</li><li>传输服务层：提供了网络传输能力的抽象和实现，支持Socket、HTTP tunnel、VM pipe等方式</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/components.png" alt="netty-components"></p><p>从逻辑架构上可以分为：</p><ul><li>网络通信层：执行网络IO的操作，支持多种网络协议和IO模型，数据被读取到内核缓冲区时，会触发各种网络事件，事件会分发给上层处理，包括以下组件：<ul><li>Bootstrap：负责整个Netty的启动、初始化、服务器连接等过程，主要负责客户端的引导，可以连接远程服务器，只绑定一个EventLoopGroup</li><li>ServerBootStrap：负责服务端的引导。用于服务端启动绑定本地端口，绑定两个EventLoopGroup。这两个被称为Boss和Worker。<ul><li>Boss负责监听网络连接事件，新的连接到达，将Channel注册到Worker</li><li>Worker分配一个EventLoop处理Channel的读写实现，通过Selector进行事件循环</li></ul></li><li>Channel：网络通信的载体，提供了较NIO的Channel更高层次的抽象。会有生命周期，每一种状态都会绑定事件回调。</li></ul></li><li>事件调度层：通过Reactor线程模型对各类事件进行处理，通过Selector主循环线程集成多种事件，实际的处理逻辑交给服务编排层的Handler完成。<ul><li>- </li><li><strong>EventLoop</strong>：本质上是一个单线程执行器，内部维护一个Selector，run方法处理Channel在生命周期内的所有IO事件，比如accept、connect、read、write等。同一时间与一个线程绑定，负责处理多个Channel。<ul><li>继承关系：<ul><li>继承netty的OrderedEventExecutor。<ul><li>拥有netty特有的自定义线程池方法：包括判断一个线程是否属于当前EventLoop。</li></ul></li><li>继承JUC的ScheduledExecutorService，因此其含有线程池的方法</li></ul></li></ul></li><li><strong>EventLoopGroup</strong>：本质是一个线程池，负责接收IO请求，并分配线程去执行。内部有EventLoop。是Reactor线程模型的具体实现方式，channel调用group的register方法来绑定相应的EventLoop，通过传入不同参数，支持Reactor的三种线程模型：<ul><li>单线程模型：EventLoopGroup内部包含一个EventLoop，Boss和Worker同时使用一个EventLoopGroup。</li><li>多线程模型：EventLoopGroup内部包含多个EventLoop，Boss和Worker同时使用一个EventLoopGroup。</li><li>主从多线程模型：EventLoopGroup内部包含多个EventLoop，Boss是主Reactor，Worker是从Reactor，使用不同的EventLoopGroup，主Reactor负责新连接的Channel创建，然后将Channel注册到从Reactor。</li></ul></li></ul></li><li>服务编排层：负责组装各类服务，实现对网络事件的处理<ul><li><strong>ChannelPipeline</strong>：负责组装各种ChannelHandler，内部通过双向链表来管理ChannelHandler，IO事件触发时，依次调用ChannelHandler来对数据进行拦截和处理。一个 ChannelPipeline 关联一个 EventLoop。<ul><li>客户端和服务端都有各自的ChannelPipeline，数据从客户端发向服务端，该过程称为出站。反之为入站。</li></ul></li><li><strong>ChannelHandler</strong>：负责数据的编解码和加工处理，分为InBound和OutBound，分别负责入站和出站。每一个ChannelHandler都会绑定一个ChannelHandlerContext。<ul><li>ChannelInboundHandler：入站处理器的父类，用于读取客户端数据，写回结果。</li><li>ChannelOutboundHandler：出站处理器的父类，用于处理写回结果。</li></ul></li><li><strong>ChannelHandlerContext</strong>：用于保存ChannelHandler的上下文，通过它可以知道handler和pipeline的关联关系，可以实现handler之间的交互。它包含了 ChannelHandler 生命周期的所有事件，如 connect、bind、read、flush、write、close 等。</li></ul></li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/Netty-framework.png" alt="Netty-framework"></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件管理模块分析</title>
    <link href="/2022/Linux/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"/>
    <url>/2022/Linux/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="硬盘文件系统"><a href="#硬盘文件系统" class="headerlink" title="硬盘文件系统"></a>硬盘文件系统</h2><h3 id="inode与块的存储"><a href="#inode与块的存储" class="headerlink" title="inode与块的存储"></a>inode与块的存储</h3><p>硬盘读写时以扇区为单位，文件系统中读写数据最小单位为块，一个块（簇）内部是相邻的几个扇区，在Linux中的ext文件系统，默认大小为4K。</p><p>文件的元数据存放在inode中，ext4中定义如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_inode</span> &#123;</span>__le16i_mode;<span class="hljs-comment">/* File mode */</span>__le16i_uid;<span class="hljs-comment">/* Low 16 bits of Owner Uid */</span>__le32i_size_lo;<span class="hljs-comment">/* Size in bytes */</span>__le32i_atime;<span class="hljs-comment">/* Access time */</span>__le32i_ctime;<span class="hljs-comment">/* Inode Change time */</span>__le32i_mtime;<span class="hljs-comment">/* Modification time */</span>__le32i_dtime;<span class="hljs-comment">/* Deletion Time */</span>__le16i_gid;<span class="hljs-comment">/* Low 16 bits of Group Id */</span>__le16i_links_count;<span class="hljs-comment">/* Links count */</span>__le32i_blocks_lo;<span class="hljs-comment">/* Blocks count */</span>__le32i_flags;<span class="hljs-comment">/* File flags */</span>......__le32i_block[EXT4_N_BLOCKS];<span class="hljs-comment">/* Pointers to blocks */</span>__le32i_generation;<span class="hljs-comment">/* File version (for NFS) */</span>__le32i_file_acl_lo;<span class="hljs-comment">/* File ACL */</span>__le32i_size_high;......&#125;;<span class="hljs-meta">#<span class="hljs-keyword">define</span>EXT4_NDIR_BLOCKS12</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>EXT4_IND_BLOCKEXT4_NDIR_BLOCKS</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>EXT4_DIND_BLOCK(EXT4_IND_BLOCK + 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>EXT4_TIND_BLOCK(EXT4_DIND_BLOCK + 1)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span>EXT4_N_BLOCKS(EXT4_TIND_BLOCK + 1)</span></code></pre></div><p><code>i_block</code>中存放文件所在的磁盘块地址，可以通过多层寻址增加文件大小上限。</p><p>但是这样的结构存在很严重的性能问题：大文件需要多次进行磁盘IO才能找到相应的块，而磁盘IO的时间往往很慢。</p><p>ext4对其进行优化，引入了一个新的概念<strong>Extents</strong>，将多个连续的块存放在一个Extents中。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220723145824483.png" alt="image-20220723145824483"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux内存管理模块分析</title>
    <link href="/2022/Linux/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"/>
    <url>/2022/Linux/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>内存管理主要分为三个方面：</p><ul><li>管理物理内存：只有内核中负责内存管理的模块可以使用</li><li>管理虚拟内存：每个进程看到的都是独立且互不干扰的虚拟空间</li><li>物理内存和虚拟内存的转换：上述两者的映射关系</li></ul><p>无论是内核态程序还是用户态程序，都使用虚拟内存，虚拟内存空间布局如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220723131749685.png" alt="Linux-Process-Virtual-Memory"></p><ul><li>内核空间部分：存放内核进程的程序</li><li>用户空间部分：存放用户进程的程序，从最低位开始，逐个段如下：<ul><li>Text Segment：存放二进制可执行代码的位置</li><li>Data Segment：存放静态常量</li><li>BSS Segment：存放未初始化的静态变量</li><li>Heap：动态分配内存的区域，malloc在这个空间分配</li><li>Memory Mapping Segment：用来把文件映射到内存的区域，如果可执行文件依赖某个动态链接库，so文件就映射在这。</li><li>Stack：进程的函数调用栈，由一个个frame（相当于函数实体）构成，内部存放局部变量、返回地址等信息，frame结构如下图所示：</li></ul></li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220717113852718.png" alt="stack-frame"></p><p>可以通过<code>pmap pid</code>展示进程的地址空间相关信息。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h3><p>分段机制如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220717133205056.png" alt="分段机制"></p><p>在Linux中，段表被称为<strong>段描述符表</strong>，放在<strong>全局描述符表 GDT</strong>中，一个段表项由段基址base，界限limit，还有一些标识符组成：</p><div class="code-wrapper"><pre><code class="hljs c">DEFINE_PER_CPU_PAGE_ALIGNED(<span class="hljs-keyword">struct</span> gdt_page, gdt_page) = &#123; .gdt = &#123;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_64</span>[GDT_ENTRY_KERNEL32_CS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_KERNEL_CS]= GDT_ENTRY_INIT(<span class="hljs-number">0xa09b</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_KERNEL_DS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc093</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_DEFAULT_USER32_CS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_DEFAULT_USER_DS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc0f3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_DEFAULT_USER_CS]= GDT_ENTRY_INIT(<span class="hljs-number">0xa0fb</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>[GDT_ENTRY_KERNEL_CS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc09a</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_KERNEL_DS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc092</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_DEFAULT_USER_CS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc0fa</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),[GDT_ENTRY_DEFAULT_USER_DS]= GDT_ENTRY_INIT(<span class="hljs-number">0xc0f2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xfffff</span>),......<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125; &#125;;EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);<span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_CS(GDT_ENTRY_KERNEL_CS*8)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __KERNEL_DS(GDT_ENTRY_KERNEL_DS*8)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __USER_DS(GDT_ENTRY_DEFAULT_USER_DS*8 + 3)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __USER_CS(GDT_ENTRY_DEFAULT_USER_CS*8 + 3)</span></code></pre></div><p>分段机制在Linux中，可以做权限审核，用户态试图访问内核态，权限不足会禁止访问。</p><h3 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h3><p>Linux使用的更多的是分页机制，将物理内存分成一块块相同大小的page，其机制如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220717135216416.png" alt="分页机制"></p><p>多级页表的好处：</p><ul><li>减少页表占用的内存空间</li><li>增加地址映射空间</li></ul><p>Linux的64位系统使用四级页表，其结构如下所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220717135853082.png" alt="多级页表"></p><h2 id="进程空间管理"><a href="#进程空间管理" class="headerlink" title="进程空间管理"></a>进程空间管理</h2><p>进程的<code>task_struct</code>中对进程地址存储了<code>mm_struct</code>，整个虚拟内存空间分为用户态空间和内核态空间，两者分界线由<code>mm_struct-&gt;task_size</code>决定。</p><p>32位最大寻址空间为$2^{32} &#x3D;4G$，其中内核态占用顶部1G，用户态占用底部3G</p><p>64为系统虚拟地址只使用了48位，内核态和用户态各使用128T</p><h3 id="用户态空间"><a href="#用户态空间" class="headerlink" title="用户态空间"></a>用户态空间</h3><p><code>mm_struct</code>中关于用户态空间的信息如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> mmap_base;<span class="hljs-comment">/* base of mmap area */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> total_vm;<span class="hljs-comment">//总共映射的页数量</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> locked_vm;<span class="hljs-comment">//被锁定不能换出到磁盘的页数量</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pinned_vm;<span class="hljs-comment">//不能换出也不能移动的页数量</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> data_vm;<span class="hljs-comment">//存放数据的页数量</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exec_vm;<span class="hljs-comment">//存放可执行文件的页数量</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_vm;<span class="hljs-comment">//栈所占的页数量</span><span class="hljs-comment">//可执行代码开始位置、结束位置，已初始化数据开始位置、结束位置</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_code, end_code, start_data, end_data;<span class="hljs-comment">//堆开始位置、结束位置、栈开始位置</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start_brk, brk, start_stack;<span class="hljs-comment">//参数列表的开始结束位置，环境变量的开始结束位置，这两者都位于栈的最顶部</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg_start, arg_end, env_start, env_end;<span class="hljs-comment">//描述内存区域</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">mmap</span>;</span><span class="hljs-comment">/* list of VMAs */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">mm_rb</span>;</span></code></pre></div><p><code>vm_area_struct</code>是一个单链表，将<strong>进程拥有的内存区域</strong>串接起来 （根据地址串起来），并使用红黑树存储，方便快速查询。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> &#123;</span><span class="hljs-comment">/* The first cache line has the info for VMA tree walking. */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_start;<span class="hljs-comment">//区域开始位置</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> vm_end;<span class="hljs-comment">//区域结束位置</span><span class="hljs-comment">/* linked list of VM areas per task, sorted by address */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vm_next</span>, *<span class="hljs-title">vm_prev</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">vm_rb</span>;</span><span class="hljs-comment">//红黑树存储节点</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span>;</span><span class="hljs-comment">/* The address space we belong to. */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">anon_vma_chain</span>;</span> <span class="hljs-comment">/* Serialized by mmap_sem &amp;</span><span class="hljs-comment">  * page_table_lock */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anon_vma</span> *<span class="hljs-title">anon_vma</span>;</span><span class="hljs-comment">/* Serialized by page_table_lock */</span><span class="hljs-comment">/* Function pointers to deal with this struct. */</span><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_operations_struct</span> *<span class="hljs-title">vm_ops</span>;</span><span class="hljs-comment">//可以操作的动作</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">vm_file</span>;</span><span class="hljs-comment">/* File we map to (can be NULL). */</span><span class="hljs-type">void</span> * vm_private_data;<span class="hljs-comment">/* was vm_pte (shared mem) */</span>&#125; __randomize_layout;</code></pre></div><blockquote><p> Q：什么时候将<code>vm_area_struct</code>和上面的内存区域关联起来？</p></blockquote><p><code>load_elf_binary </code>除了解析ELF格式外，还需要建立内存映射：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_elf_binary</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> linux_binprm *bprm)</span>&#123;......  <span class="hljs-comment">//设置内存映射区mmap_base</span>  setup_new_exec(bprm);......  <span class="hljs-comment">//设置栈的vm_area_struct的args等参数</span>  retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP), executable_stack);......    error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,elf_prot, elf_flags, total_size);......  <span class="hljs-comment">//设置堆的参数</span>  retval = set_brk(elf_bss, elf_brk, bss_prot);......  <span class="hljs-comment">//依赖的so文件映射到内存中的内存映射区域。</span>  elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,    interpreter,    &amp;interp_map_addr,    load_bias, interp_elf_phdata);......  current-&gt;mm-&gt;end_code = end_code;  current-&gt;mm-&gt;start_code = start_code;  current-&gt;mm-&gt;start_data = start_data;  current-&gt;mm-&gt;end_data = end_data;  current-&gt;mm-&gt;start_stack = bprm-&gt;p;......&#125;</code></pre></div><h3 id="内核态空间"><a href="#内核态空间" class="headerlink" title="内核态空间"></a>内核态空间</h3><p>32位系统的内核态空间布局如下所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220717151758224.png" alt="内核态内存空间结构"></p><ul><li>直接映射区：这部分与物理地址的前896MB进行映射。<ul><li>系统启动时，使用物理内存的前1M加载内核代码段等，可以查看<code>/proc/iomem</code></li><li>如果系统调用创建进程，进程<code>task_struct</code>会存放在这，相应的页表项也会被创建。</li><li>内核栈分也被分配在该区域。</li></ul></li><li>内核动态映射空间（vmalloc）：类似于用户态的堆区，内核态使用<code>vmalloc</code>申请内存</li><li>持久内核映射：可以调用<code>kmap</code>将高端内存页到该区域</li><li>固定内核映射：满足特殊需求。</li></ul><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><p>平坦内存模型（Flat Memory Model）：物理内存中页是连续的，对于任何物理地址，只需要除以页大小，就可以算出具体的页面地址，每个页通过<code>struct page</code>表示。</p><ul><li>SMP（Symmetric multiprocessing）：多处理器通过一个总线同时访问内存。<ul><li>总线称为性能瓶颈</li></ul></li><li>NUMA（Non-uniform memory access）：非一致内存访问，每个CPU拥有自己的本地内存，这块内存称为一个NUMA节点，本地内存不足时可以申请另外的NUMA节点。<ul><li>此时内存被分为一个个内存节点，节点再划分一个个页面，此时页号需要保证全局唯一</li><li>NUMA是非连续内存模型</li></ul></li></ul><p>物理内存管理整体分为以下的流程：</p><ul><li>物理内存分为NUMA节点，分别管理。</li><li>每个NUMA节点分为多个内存区域</li><li>每个内存区域分为多个物理页面</li><li>Buddy System将多个连续的页面作为一个大内存块分配给需求进程</li><li>kswapd内核进程负责物理页的换入换出</li><li>slab机制将从伙伴系统申请的大内存块划分成小块，并将热点结构<code>task_struct</code>等做缓存块，提供需求方使用。</li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>对于NUMA方式，首先需要一个结构来表示NUMA节点，Linux中使用下面的结构体来表示，各字段注释如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> <span class="hljs-title">node_zones</span>[<span class="hljs-title">MAX_NR_ZONES</span>];</span><span class="hljs-comment">//每个节点划分一个个zone，放在该数组中</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zonelist</span> <span class="hljs-title">node_zonelists</span>[<span class="hljs-title">MAX_ZONELISTS</span>];</span><span class="hljs-comment">//备用节点和内存区域的情况</span><span class="hljs-type">int</span> nr_zones;<span class="hljs-comment">//当前节点的zone数量</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">node_mem_map</span>;</span><span class="hljs-comment">//该节点的struct page数组</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_start_pfn;<span class="hljs-comment">//节点的起始页号</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_present_pages; <span class="hljs-comment">//真正可用的物理页面数</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> node_spanned_pages; <span class="hljs-comment">//节点中包含不连续的物理内存地址的页面数</span><span class="hljs-type">int</span> node_id;<span class="hljs-comment">//节点</span>......&#125; <span class="hljs-type">pg_data_t</span>;</code></pre></div><h3 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h3><p>表示zone的数据结构定义如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> &#123;</span>......<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pglist_data</span>*<span class="hljs-title">zone_pgdat</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pageset</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">pageset</span>;</span><span class="hljs-comment">//区分冷热页面</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>zone_start_pfn;<span class="hljs-comment">//zone的第一个页</span>  <span class="hljs-comment">/*</span><span class="hljs-comment"> * spanned_pages is the total pages spanned by the zone, including</span><span class="hljs-comment"> * holes, which is calculated as:</span><span class="hljs-comment"> * spanned_pages = zone_end_pfn - zone_start_pfn;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * present_pages is physical pages existing within the zone, which</span><span class="hljs-comment"> * is calculated as:</span><span class="hljs-comment"> *present_pages = spanned_pages - absent_pages(pages in holes);</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * managed_pages is present pages managed by the buddy system, which</span><span class="hljs-comment"> * is calculated as (reserved_pages includes pages allocated by the</span><span class="hljs-comment"> * bootmem allocator):</span><span class="hljs-comment"> *managed_pages = present_pages - reserved_pages;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>managed_pages;<span class="hljs-comment">//被伙伴系统管理的所有page数量</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>spanned_pages;<span class="hljs-comment">//spanned_pages = zone_end_pfn - zone_start_pfn;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>present_pages;<span class="hljs-comment">//真实的page数量</span>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;......<span class="hljs-comment">/* free areas of different sizes */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span><span class="hljs-title">free_area</span>[<span class="hljs-title">MAX_ORDER</span>];</span>  <span class="hljs-comment">/* zone flags, see below */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;  <span class="hljs-comment">/* Primarily protects free_area */</span><span class="hljs-type">spinlock_t</span>lock;......&#125; ____cacheline_internodealigned_in_    <span class="hljs-comment">//zone的类型</span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">zone_type</span> &#123;</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span>ZONE_DMA,<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA32</span>ZONE_DMA32,<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>ZONE_NORMAL,<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HIGHMEM</span>ZONE_HIGHMEM,<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>ZONE_MOVABLE,__MAX_NR_ZONES&#125;;</code></pre></div><p>zone的类型分别如下：</p><ul><li>ZONE_DMA：用作DMA的内存结构</li><li>ZONE_NORMAL：直接映射区</li><li>ZONE_HIGHMEM：高端内存区</li><li>ZONE_MOVABLE：可移动区域，通过将内存划分为可移动区域和不可移动区域，来避免内存碎片。</li></ul><p><strong>冷热页面</strong>：页面是否被加载到CPU cache中，若在cache中则是<code>Hot Page</code>，CPU读取非常快。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">per_cpu_pages</span> &#123;</span>  <span class="hljs-type">int</span> count;    <span class="hljs-comment">// number of pages in the list</span>  <span class="hljs-type">int</span> high;    <span class="hljs-comment">// high watermark, emptying needed</span>  <span class="hljs-type">int</span> batch;    <span class="hljs-comment">// chunk size for buddy add/remove</span>   <span class="hljs-comment">// Lists of pages, one per migrate type stored on the pcp-lists</span>   <span class="hljs-comment">//每个CPU在每个zone上都有MIGRATE_PCPTYPES个冷热页链表（根据迁移类型划分）</span>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lists</span>[<span class="hljs-title">MIGRATE_PCPTYPES</span>];</span> &#125;;</code></pre></div><h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3><p>page是组成物理内存的基本单位，内部有很多<code>union</code>结构，物理页面若直接使用一整页的内存，page直接和虚拟地址空间建立映射关系，则被称为<strong>匿名页</strong>，若page用于关联一个文件，再和虚拟地址空间建立映射关系，这种文件则被称为内存映射文件。</p><p>第一种模式，使用以下字段存储元数据：</p><ul><li>struct address_space *mapping：用于内存映射</li><li>pgoff_t index：映射区的偏移量</li><li>atomic_t _mapcount：记录指向该页的页表项</li><li>struct list_head lru：如果页面被换出，就在换出页的链表中</li></ul><p>第二种模式，仅需要分配小块内存，例如一个<code>task_struct</code>结构只需要一小块内存。Linux使用<code>slab allocator</code>分配称为slab的一小块内存，其基本原理是：申请一整块内存页，然后划分成多个小块的内存存储池，并使用复杂的队列来维护状态。，由于队列的维护操作过于复杂，后来使用<code>slub allocator</code>分配，此方式不使用队列。可以看成前者的另一种的实现。</p><h3 id="page整页分配"><a href="#page整页分配" class="headerlink" title="page整页分配"></a>page整页分配</h3><p>对于分配较大的内存（分配页级别的），可以使用<code>Buddy System</code>来分配。Linux中内存页大小默认为<code>4KB</code>，将所有的空闲页分组为11个页块链表，页块大小分别是1、2、4、8、16、32、64、128、256、512、1024个连续页，最大可以申请1024个连续页（共4MB），其结构如下所示：</p><p>当向内核请求分配$(2^{i-1}, 2^i] $个页块时，按照$2 ^ i$个请求处理，如果该页块链表中没有足够的空闲页快，就去更大一级的链表中申请，并且会将更大一级的页块分裂，并返回所需页块大小给请求进程。</p><h3 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h3><p>首先slab分配器是基于<code>Buddy System</code>的，slab需要从buddy分配器获取连续的物理页，然后将其内部划分为一个个小的slab。Linux内核从2.6起提供了slab和slub两种方案，两者差异上面已经记录。</p><h4 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h4><p>slab机制主要针对一些<strong>经常被分配并释放的对象</strong>，这些对象一般比较小，使用buddy分配器会造成大量的内存碎片，并且处理速度慢，slab分配器基于对象进行管理，相同类型分为一类，每次申请时，slab分配器就从列表中分配一个该类型的对象，当要释放时，将其重新保存在该类型的列表中，而不是返回给buddy分配器，避免了重复初始化等开销。slab对象类型主要有：<code>task_struct</code>、<code>mm_struct </code>、<code>fs_struct</code>等。</p><p>创建进程时，需要创建<code>task_struct</code>并复制父进程数据，需要先调用<code>alloc_task_struct_node</code>分配，其执行流程如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">task_struct_cachep</span>;</span> <span class="hljs-comment">//task_struct_cachep被kmem_cache_create创建，大小为arch_task_struct_size</span>task_struct_cachep = kmem_cache_create(<span class="hljs-string">&quot;task_struct&quot;</span>,arch_task_struct_size, align,SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT, <span class="hljs-literal">NULL</span>); <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> task_struct *<span class="hljs-title function_">alloc_task_struct_node</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<span class="hljs-keyword">return</span> kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);&#125; <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">free_task_struct</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk)</span>&#123;kmem_cache_free(task_struct_cachep, tsk);&#125;</code></pre></div><p><code>task_struct_cachep</code>被用作分配<code>task_struct</code>的缓存，每次创建该结构时，都会先查看缓存是否有直接可用的，而不用直接去内存里面分配。当进程结束后，<code>task_struct</code>不会被直接销毁，而是放回到缓存中。SLAB缓存结构信息如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_slab</span>;</span><span class="hljs-comment">/* Used for retriving partial slabs etc */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_partial;<span class="hljs-type">int</span> size;<span class="hljs-comment">//包含指针的大小</span><span class="hljs-type">int</span> object_size;<span class="hljs-comment">//纯对象的大小</span><span class="hljs-type">int</span> offset;<span class="hljs-comment">//下一个空闲对象指针的offset</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><span class="hljs-type">int</span> cpu_partial;<span class="hljs-comment">/* Number of per cpu partial objects to keep around */</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><span class="hljs-comment">/* Allocation and freeing of slabs */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">max</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><span class="hljs-type">gfp_t</span> allocflags;<span class="hljs-comment">/* gfp flags to use on each alloc */</span><span class="hljs-type">int</span> refcount;<span class="hljs-comment">/* Refcount for slab cache destroy */</span><span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);......<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* Name (only for display!) */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-comment">//slab的缓存链表</span>......<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span>&#125;;</code></pre></div><p>缓存块分为以下两种：</p><ul><li>kmem_cache_cpu：CPU slab块，快速通道</li><li>kmem_cache_node：Node slab块，普通通道</li></ul><p>分配时首先从快速通道分配，若里面没有空闲块，再到普通通道分配，如果还是没有空闲块，才去Buddy System分配新的页。</p><p><code>kmem_cache_cpu</code>结构如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> &#123;</span><span class="hljs-type">void</span> **freelist;<span class="hljs-comment">//指向大内存块的第一个空闲的项，形成空闲链表</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<span class="hljs-comment">/* Globally unique transaction id */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><span class="hljs-comment">//指向内存块的第一个页，缓存块从里面分配</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">partial</span>;</span><span class="hljs-comment">//部分空闲的slab缓存块</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>......&#125;;</code></pre></div><p><code>kmem_cache_node</code> 结构如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> &#123;</span><span class="hljs-type">spinlock_t</span> list_lock;......<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_partial;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">partial</span>;</span><span class="hljs-comment">//存放部分空闲的slab块</span>......<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>&#125;;</code></pre></div><p><code>kmem_cache_alloc_node</code>会调用<code>slab_alloc_node</code>，流程如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)</span><span class="hljs-comment"> * have the fastpath folded into their functions. So no function call</span><span class="hljs-comment"> * overhead for requests that can be satisfied on the fastpath.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The fastpath works by first checking if the lockless freelist can be used.</span><span class="hljs-comment"> * If not then __slab_alloc is called for slow processing.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Otherwise we can simply pick the next object from the lockless free list.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_alloc_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span>&#123;<span class="hljs-type">void</span> *object;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;......tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);    <span class="hljs-comment">//取出cpu slab缓存</span>c = raw_cpu_ptr(s-&gt;cpu_slab);......    <span class="hljs-comment">//取出freelist，这是第一个空闲的项</span>object = c-&gt;freelist;page = c-&gt;page;<span class="hljs-keyword">if</span> (unlikely(!object || !node_match(page, node))) &#123;        <span class="hljs-comment">//若没有空闲的cpu slab，调用__slab_alloc进入普通通道。</span>object = __slab_alloc(s, gfpflags, node, addr, c);stat(s, ALLOC_SLOWPATH);&#125; ......<span class="hljs-keyword">return</span> object;&#125;<span class="hljs-comment">//__slab_alloc进入普通通道</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> *___slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c)&#123;<span class="hljs-type">void</span> *freelist;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span>......redo:......<span class="hljs-comment">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span>    <span class="hljs-comment">//再次尝试cpu slab，万一有其他进程释放</span>freelist = c-&gt;freelist;<span class="hljs-keyword">if</span> (freelist)<span class="hljs-keyword">goto</span> load_freelist;  freelist = get_freelist(s, page);  <span class="hljs-keyword">if</span> (!freelist) &#123;c-&gt;page = <span class="hljs-literal">NULL</span>;stat(s, DEACTIVATE_BYPASS);        <span class="hljs-comment">//如果还是没有，调用new_slab</span><span class="hljs-keyword">goto</span> new_slab;&#125;  load_freelist:c-&gt;freelist = get_freepointer(s, freelist);c-&gt;tid = next_tid(c-&gt;tid);<span class="hljs-keyword">return</span> freelist;  new_slab:  <span class="hljs-keyword">if</span> (slub_percpu_partial(c)) &#123;page = c-&gt;page = slub_percpu_partial(c);slub_set_percpu_partial(c, page);stat(s, CPU_PARTIAL_ALLOC);<span class="hljs-keyword">goto</span> redo;&#125;  <span class="hljs-comment">//调用new_slab_objects</span>freelist = new_slab_objects(s, gfpflags, node, &amp;c);......<span class="hljs-keyword">return</span> freelist<span class="hljs-comment">//创建slab块</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *new_slab_objects(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags,<span class="hljs-type">int</span> node, <span class="hljs-keyword">struct</span> kmem_cache_cpu **pc)&#123;<span class="hljs-type">void</span> *freelist;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span> =</span> *pc;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span>  <span class="hljs-comment">///根据node_id，找到对应的kmem_cache_node，然后调用get_partial_node</span>freelist = get_partial(s, flags, node, c);  <span class="hljs-keyword">if</span> (freelist)<span class="hljs-keyword">return</span> freelist;  page = new_slab(s, flags, node);<span class="hljs-keyword">if</span> (page) &#123;c = raw_cpu_ptr(s-&gt;cpu_slab);<span class="hljs-keyword">if</span> (c-&gt;page)flush_slab(s, c);  freelist = page-&gt;freelist;page-&gt;freelist = <span class="hljs-literal">NULL</span>;  stat(s, ALLOC_SLAB);c-&gt;page = page;*pc = c;&#125; <span class="hljs-keyword">else</span>freelist = <span class="hljs-literal">NULL</span>;  <span class="hljs-keyword">return</span> freelist<span class="hljs-comment">/*</span><span class="hljs-comment"> * Try to allocate a partial slab from a specific node.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> *get_partial_node(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> kmem_cache_node *n,<span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">gfp_t</span> flags)&#123;<span class="hljs-keyword">struct</span> page *page, *page2;<span class="hljs-type">void</span> *object = <span class="hljs-literal">NULL</span>;<span class="hljs-type">int</span> available = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> objects;......list_for_each_entry_safe(page, page2, &amp;n-&gt;partial, lru) &#123;<span class="hljs-type">void</span> *t;  <span class="hljs-comment">//acquire_slab从普通node的partial链表中取下一大块内存，并将freelist第一块空闲内存赋给t</span>t = acquire_slab(s, n, page, object == <span class="hljs-literal">NULL</span>, &amp;objects);<span class="hljs-keyword">if</span> (!t)<span class="hljs-keyword">break</span>;  available += objects;<span class="hljs-keyword">if</span> (!object) &#123;c-&gt;page = page;stat(s, ALLOC_FROM_PARTIAL);object = t;&#125; <span class="hljs-keyword">else</span> &#123;put_cpu_partial(s, page, <span class="hljs-number">0</span>);stat(s, CPU_PARTIAL_NODE);&#125;<span class="hljs-keyword">if</span> (!kmem_cache_has_cpu_partial(s)|| available &gt; slub_cpu_partial(s) / <span class="hljs-number">2</span>)<span class="hljs-keyword">break</span>;&#125;......<span class="hljs-keyword">return</span> object;</code></pre></div><h3 id="页面换出"><a href="#页面换出" class="headerlink" title="页面换出"></a>页面换出</h3><p>进程拥有的虚拟内存空间往往非常大，但是物理内存没有足够的空间，只有页面被使用时，才会放在物理内存中，如果一段时间不使用且用户进程没有释放，物理内存管理模块需要将这些页面换出到磁盘中，将空出的物理内存交给其他进程使用。</p><p>例如，当分配内存时，发现没有足够的内存时，会试图进行回收，函数调用链为：<code>get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node</code>。当然也有内核线程<strong>kswapd</strong>主动检查内存是否需要换出。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kswapd</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_order, reclaim_order;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> classzone_idx = MAX_NR_ZONES - <span class="hljs-number">1</span>;<span class="hljs-type">pg_data_t</span> *pgdat = (<span class="hljs-type">pg_data_t</span>*)p;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tsk</span> =</span> current;      <span class="hljs-keyword">for</span> ( ; ; ) &#123;......        kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,classzone_idx);......        reclaim_order = balance_pgdat(pgdat, alloc_order, classzone_idx);......    &#125;&#125;</code></pre></div><p><code>shrink_node</code>调用<code>shrink_node_memcg</code>：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">shrink_node_memcg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pglist_data *pgdat, <span class="hljs-keyword">struct</span> mem_cgroup *memcg,</span><span class="hljs-params">      <span class="hljs-keyword">struct</span> scan_control *sc, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *lru_pages)</span>&#123;......<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr[NR_LRU_LISTS];<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">lru_list</span> <span class="hljs-title">lru</span>;</span>......    <span class="hljs-keyword">while</span> (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||nr[LRU_INACTIVE_FILE]) &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_anon, nr_file, percentage;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_scanned;  <span class="hljs-comment">//从LRU中检查</span>for_each_evictable_lru(lru) &#123;<span class="hljs-keyword">if</span> (nr[lru]) &#123;nr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);nr[lru] -= nr_to_scan;  nr_reclaimed += shrink_list(lru, nr_to_scan,    lruvec, memcg, sc);&#125;&#125;......&#125;......</code></pre></div><p>所有页面都挂在LRU列表上，页面划分为匿名页和内存映射页两种，并且都存在active和inactive两种状态的LRU列表，如果要换出内存，找出不活跃列表中最不活跃的，换出到硬盘。</p><h2 id="mmap用户态内存映射"><a href="#mmap用户态内存映射" class="headerlink" title="mmap用户态内存映射"></a>mmap用户态内存映射</h2><p>mmap是一个系统调用，本质是一个用户态进程的虚拟内存映射方法，基本作用如下：</p><ul><li>将文件映射到进程的虚拟内存空间<ul><li>可以通过文件实现进程间通信、IO优化（零拷贝）等</li></ul></li><li>进程申请内存时，例如堆内存，mmap将内存空间映射到物理内存。</li></ul><p>mmap系统调用如下：</p><div class="code-wrapper"><pre><code class="hljs c">SYSCALL_DEFINE6(mmap, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, len,                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, prot, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, flags,                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, off)    ......        error = sys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);......&#125;  SYSCALL_DEFINE6(mmap_pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, len,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, prot, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, flags,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, pgoff)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> <span class="hljs-literal">NULL</span>;......file = fget(fd);......retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);<span class="hljs-keyword">return</span> retval;&#125;</code></pre></div><p>如果映射到文件，fd传入一个文件描述符，通过<code>mmap_pgoff-&gt;fget</code>根据fd获取<code>struct_file</code>，接下来调用<code> vm_mmap_pgoff-&gt;do_mmap_pgoff-&gt;do_mmap</code>，这里主要调用了两个方法：</p><ul><li>get_unmapped_area：找到一个没有映射的内存区域</li><li>mmap_region：映射到这个内存区域</li></ul><p><code>get_unmapped_area</code>流程如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><span class="hljs-title function_">get_unmapped_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>,</span><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;......    <span class="hljs-comment">//如果是匿名页，直接调用mm-&gt;get_unmapped_area找到vm_area_struct红黑树上对应的位置</span>get_area = current-&gt;mm-&gt;get_unmapped_area;    <span class="hljs-comment">//如果是映射到文件，找到file_operations并调用get_unmapped_area</span><span class="hljs-keyword">if</span> (file) &#123;<span class="hljs-keyword">if</span> (file-&gt;f_op-&gt;get_unmapped_area)get_area = file-&gt;f_op-&gt;get_unmapped_area;&#125; ......&#125;</code></pre></div><p><code>mmap_region</code>流程如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mmap_region</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">vm_flags_t</span> vm_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> list_head *uf)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>, *<span class="hljs-title">prev</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> **<span class="hljs-title">rb_link</span>, *<span class="hljs-title">rb_parent</span>;</span>  <span class="hljs-comment">/*</span><span class="hljs-comment"> * Can we just expand an old mapping?</span><span class="hljs-comment"> */</span>    <span class="hljs-comment">//首先看是否能和前一个vm_area_struct合并</span>vma = vma_merge(mm, prev, addr, addr + len, vm_flags,<span class="hljs-literal">NULL</span>, file, pgoff, <span class="hljs-literal">NULL</span>, NULL_VM_UFFD_CTX);<span class="hljs-keyword">if</span> (vma)<span class="hljs-keyword">goto</span> out;  <span class="hljs-comment">/*</span><span class="hljs-comment"> * Determine the object being mapped and call the appropriate</span><span class="hljs-comment"> * specific mapper. the address has already been validated, but</span><span class="hljs-comment"> * not unmapped, but the maps are removed from the list.</span><span class="hljs-comment"> */</span>    <span class="hljs-comment">//不能则调用kmem_cache_zalloc在slab里面创建一个vm_area_struct </span>vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);<span class="hljs-keyword">if</span> (!vma) &#123;error = -ENOMEM;<span class="hljs-keyword">goto</span> unacct_error;&#125;  vma-&gt;vm_mm = mm;vma-&gt;vm_start = addr;vma-&gt;vm_end = addr + len;vma-&gt;vm_flags = vm_flags;vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);vma-&gt;vm_pgoff = pgoff;INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);  <span class="hljs-comment">//如果是文件，则设置vm_file为目标文件，调用call_mmap</span><span class="hljs-keyword">if</span> (file) &#123;vma-&gt;vm_file = get_file(file);error = call_mmap(file, vma);addr = vma-&gt;vm_start;vm_flags = vma-&gt;vm_flags;&#125; ......    <span class="hljs-comment">//vma_link将创建的vm_area_struct存放在mm_struct里面的红黑树上面</span>vma_link将创建的(mm, vma, prev, rb_link, rb_parent);<span class="hljs-keyword">return</span> addr;.....</code></pre></div><p><code>vma_link</code>将内存到文件的映射关系建立后，文件到内存的映射通过<code>struct file</code>里面成员指向<code>struct address_space</code>，这个结构中有一个红黑树，内存区域<code>vm_area_struct</code>挂在这棵树上。</p><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>上述流程仍然在虚拟内存中进行操作，只有真正使用时，才回去分配物理内存，当进程开始访问虚拟内存中某个地址，如果没有找到对应的物理页，就会触发缺页中断，调用<code>do_page_fault</code>，页表存储在<code>mm_struct</code>中。</p><div class="code-wrapper"><pre><code class="hljs c">dotraplinkage <span class="hljs-type">void</span> notrace<span class="hljs-title function_">do_page_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address = read_cr2(); <span class="hljs-comment">/* Get the faulting address */</span>......__do_page_fault(regs, error_code, address);......&#125;  <span class="hljs-comment">/*</span><span class="hljs-comment"> * This routine handles page faults.  It determines the address,</span><span class="hljs-comment"> * and the problem, and then passes it off to one of the appropriate</span><span class="hljs-comment"> * routines.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> noinline <span class="hljs-type">void</span>__do_page_fault(<span class="hljs-keyword">struct</span> pt_regs *regs, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tsk</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span>tsk = current;mm = tsk-&gt;mm;  <span class="hljs-comment">//首先判断终端是否发生在内核中</span><span class="hljs-keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;        <span class="hljs-comment">//内核中断调用vmalloc_fault</span><span class="hljs-keyword">if</span> (vmalloc_fault(address) &gt;= <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;&#125;......    <span class="hljs-comment">//若是用户态中断，查找地址所在的vm_area_struct</span>vma = find_vma(mm, address);......    <span class="hljs-comment">//调用handle_mm_fault完成映射</span>fault = handle_mm_fault(vma, address, flags);......        <span class="hljs-type">static</span> <span class="hljs-type">int</span> __handle_mm_fault(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_fault</span> <span class="hljs-title">vmf</span> =</span> &#123;.vma = vma,.address = address &amp; PAGE_MASK,.flags = flags,.pgoff = linear_page_index(vma, address),.gfp_mask = __get_fault_gfp_mask(vma),&#125;;    <span class="hljs-comment">//设置四级页表</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<span class="hljs-type">pgd_t</span> *pgd;<span class="hljs-type">p4d_t</span> *p4d;<span class="hljs-type">int</span> ret;  pgd = pgd_offset(mm, address);p4d = p4d_alloc(mm, pgd, address);......vmf.pud = pud_alloc(mm, p4d, address);......vmf.pmd = pmd_alloc(mm, vmf.pud, address);......<span class="hljs-keyword">return</span> handle_pte_fault(&amp;vmf);&#125;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handle_pte_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_fault *vmf)</span>&#123;<span class="hljs-type">pte_t</span> entry;......vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);vmf-&gt;orig_pte = *vmf-&gt;pte;......<span class="hljs-keyword">if</span> (!vmf-&gt;pte) &#123;<span class="hljs-keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))<span class="hljs-keyword">return</span> do_anonymous_page(vmf);<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> do_fault(vmf);&#125;  <span class="hljs-keyword">if</span> (!pte_present(vmf-&gt;orig_pte))<span class="hljs-keyword">return</span> do_swap_page(vmf);......&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存管理的体系可以总结为：</p><ul><li><p>物理内存根据NUMA架构分节点，节点内部再分区域，区域内再分页</p></li><li><p>物理页面通过buddy system进行分配，物理页面可以映射到虚拟内存空间，内核进程kswapd根据物理页面使用情况，按照LRU等缓存算法对页面进行换入换出。</p></li><li><p>内核态内存分配</p><ul><li><strong>大内存块的情况</strong>：kmalloc分配大内存时，以及vmalloc分配不连续物理页，直接用buddy system，分配后转为虚拟地址，访问时通过内核页表进行地址映射。<ul><li>该部分会被换出，当访问发生缺页时，通过调用<code>dp_page_fault</code>处理缺页中断。</li></ul></li><li><strong>小内存块的情况</strong>：对于 kmem_cache 以及 kmalloc 分配小内存时，使用slab分配器，当slab缓存块不足时，从buddy system申请大块内存，然后切分成小块进行分配。<ul><li>该部分不会被换出，因为slab保存的是常用且关键的struct。</li></ul></li></ul></li><li><p>用户态内存分配：调用mmap系统调用或brk系统调用，用户态内存都会被换出，缺页时使用中断调入内存。</p><ul><li>申请内存小于128k时，调用<code>brk()</code>完成，通过<code>sys_brk</code>系统调用实现。</li><li>申请内存大于128k时，调用<code>mmap()</code>在堆栈之间的映射区分配。</li></ul></li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/memory.png" alt="memory"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理模块分析</title>
    <link href="/2022/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"/>
    <url>/2022/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="二进制程序执行"><a href="#二进制程序执行" class="headerlink" title="二进制程序执行"></a>二进制程序执行</h2><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>源代码文件会经过以下的步骤生成可执行文件（CSAPP）：</p><ul><li>预处理：预处理过程会将头文件嵌入代码中，定义宏展开，生成<code>.i</code>文件</li><li>编译：编译生成汇编语言程序,生成<code>.s</code>文件</li><li>汇编：汇编器as将汇编语言翻译成机器指令，打包成<code>.o</code>文件，这被称为<code>Relocatable File</code></li><li>链接：链接器ld将链接库和重定位文件合并，生成可执行文件</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>process.c</code>内容如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>  <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">create_process</span> <span class="hljs-params">(<span class="hljs-type">char</span>* program, <span class="hljs-type">char</span>** arg_list)</span>;  <span class="hljs-type">int</span> <span class="hljs-title function_">create_process</span> <span class="hljs-params">(<span class="hljs-type">char</span>* program, <span class="hljs-type">char</span>** arg_list)</span>&#123;    <span class="hljs-type">pid_t</span> child_pid;    child_pid = fork ();    <span class="hljs-keyword">if</span> (child_pid != <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> child_pid;    <span class="hljs-keyword">else</span> &#123;        execvp (program, arg_list);        <span class="hljs-built_in">abort</span> ();    &#125;</code></pre></div><p><code>createprocess.c</code>内容如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span> <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">create_process</span> <span class="hljs-params">(<span class="hljs-type">char</span>* program, <span class="hljs-type">char</span>** arg_list)</span>; <span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>&#123;    <span class="hljs-type">char</span>* arg_list[] = &#123;        <span class="hljs-string">&quot;ls&quot;</span>,        <span class="hljs-string">&quot;-l&quot;</span>,        <span class="hljs-string">&quot;/opt/&quot;</span>,        <span class="hljs-literal">NULL</span>    &#125;;    create_process (<span class="hljs-string">&quot;ls&quot;</span>, arg_list);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>编译上面两个文件，生成<code>.o</code>文件</p><div class="code-wrapper"><pre><code class="hljs tap">gcc -c -fPIC process.cgcc -c -fPIC createprocess.cdrwxr-xr-x<span class="hljs-number"> 2 </span>root root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 12 </span>18:29 ./drwxr-xr-x<span class="hljs-number"> 3 </span>root root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 12 </span>18:25 ../-rw-r--r--<span class="hljs-number"> 1 </span>root root <span class="hljs-number"> 289 </span>Jul<span class="hljs-number"> 12 </span>18:27 createprocess.c-rw-r--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 1888 </span>Jul<span class="hljs-number"> 12 </span>18:29 createprocess.o-rw-r--r--<span class="hljs-number"> 1 </span>root root <span class="hljs-number"> 373 </span>Jul<span class="hljs-number"> 12 </span>18:28 process.c-rw-r--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 1712 </span>Jul<span class="hljs-number"> 12 </span>18:28 process.o</code></pre></div><p>Linux中的二进制文件格式为<strong>ELF</strong>（Executeable and Linkable Format），上面的<code>.o</code>文件是ELF文件中的<code>Relocatable File</code>，其各部分与其功能如下所示：</p><ul><li>ELF Header：描述整个文件，文件格式在kernel中定义，64位由<code>struct elf64_hdr</code>定义</li><li>.text：编译好的二进制可执行代码</li><li>.data：初始化好的全局变量</li><li>.rodata：只读数据，const声明的变量、字符串常量</li><li>.bss：未初始化的全局变量，运行时置为0</li><li>.symtab：符号表，记录的是函数和变量名</li><li>.strtab：字符串表，字符串常量和变量名</li><li>Section Header Table：存储section的元数据</li><li>.rel.*：重定位表，记录重定位项</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>需要让<code>create_process </code>能被重用，需要形成链接库文件，使用下面的命令完成静态链接生成：</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">ar <span class="hljs-literal">cr</span> libstaticprocess.<span class="hljs-keyword">a</span> <span class="hljs-built_in">process</span>.o</code></pre></div><p>将两者连接起来生成二进制执行文件<code>staticcreateprocess</code>：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> -o staticcreateprocess createprocess.o -L. -lstaticprocess</code></pre></div><p>上面生成的二进制执行文件可以直接在Linux运行，这也是ELF文件，格式和对象文件十分类似，是由多个<code>.o</code>文件合并而成，各部分如下：</p><ul><li>代码段<ul><li>.text</li><li>.rodata</li></ul></li><li>数据段<ul><li>.data</li><li>.bss</li></ul></li><li>不加载到内存的部分：ELF header、.symtab、.strtab、Section Header Table<ul><li>Segment Header Table：代码中定义为<code>struct elf64_phdr</code>，主要是对段的描述，</li><li>ELF Header中的<code>e_entry</code>字段存储程序入口的虚拟地址</li></ul></li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接库是多个对象文件的组合，可以被多个程序共享。</p><div class="code-wrapper"><pre><code class="hljs stylus">gcc -shared -fPIC -o libdynamicprocess<span class="hljs-selector-class">.so</span> process<span class="hljs-selector-class">.o</span>gcc -o dynamiccreateprocess createprocess<span class="hljs-selector-class">.o</span> -L. -ldynamicprocess<span class="hljs-comment">//默认去/lib、/usr/lib 寻找动态链接库，修改为当前路径</span>export LD_LIBRARY_PATH=.</code></pre></div><p>动态链接也是ELF格式文件，多了<code>.interp</code>的segment，里面是<code>ld-linux.so</code>，这是做动态链接的工具。</p><p>新增的section如下：</p><ul><li>.plt（Procedure Linkage Table）：过程链接表，entry存储地址，跳转到GOT的entry</li><li>.got.plt（Global Offset Table GOT）：全局偏移量表，这里的entry存储函数的实际内存虚拟地址<ul><li>初始化时GOT如何找到函数的内存地址：回调到PLT，PLT触发<code>ld-linux.so</code>去找地址，并将地址存储在GOT</li></ul></li></ul><h3 id="ELF注册机制"><a href="#ELF注册机制" class="headerlink" title="ELF注册机制"></a>ELF注册机制</h3><p>Linux kernel对支持的可执行文件类型都有<code>linux_binfmt</code>的结构，定义在<code>include/linux/binfmts.h</code>中</p><p>下面的struct定义了加载二进制文件的方法：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> &#123;</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">lh</span>;</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">module</span>;</span>        <span class="hljs-type">int</span> (*load_binary)(<span class="hljs-keyword">struct</span> linux_binprm *);        <span class="hljs-type">int</span> (*load_shlib)(<span class="hljs-keyword">struct</span> file *);        <span class="hljs-type">int</span> (*core_dump)(<span class="hljs-keyword">struct</span> coredump_params *cprm);        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_coredump;     <span class="hljs-comment">/* minimal dump size */</span>&#125; __randomize_layout;<span class="hljs-comment">//ELF文件的实现 </span><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> <span class="hljs-title">elf_format</span> =</span> &#123;        .module         = THIS_MODULE,        .load_binary    = load_elf_binary,        .load_shlib     = load_elf_library,        .core_dump      = elf_core_dump,        .min_coredump   = ELF_EXEC_PAGESIZE,&#125;;</code></pre></div><p>其中的函数与含义如下：</p><ul><li>load_binary：读取可执行文件并为当前进程创建一个新的执行环境。</li><li>load_shlib：动态的把一个共享库捆绑到在运行的进程。</li><li>core_dump：在名称为core的文件中，存放当前进程的上下文，这个文件是进程收到<code>dump</code>信号时被创建的</li></ul><p>Linux中的<code>linux_binfmt</code>都存储在链表中，执行可执行文件时，kernel会遍历list找到指定的<code>linux_binfmt</code>，并调用<code>load_binary</code>来加载程序。</p><blockquote><p>Q：ELF文件在什么时间段完成<code>linux_binfmt</code>的注册？</p></blockquote><h2 id="Linux中使用线程"><a href="#Linux中使用线程" class="headerlink" title="Linux中使用线程"></a>Linux中使用线程</h2><p>普通线程的创建和运行过程：</p><ul><li>声明线程函数：定义一个工作函数</li><li>声明线程对象：<code>pthread_t thread;</code></li><li>设置线程属性：<code>pthread_attr_t、pthread_attr_init、pthread_attr_setdetachstate</code></li><li>创建线程：<code>pthread_create</code></li><li>销毁线程属性：<code>pthread_attr_destroy</code></li><li>等待线程结束：<code>pthread_join</code></li><li>主线程结束：<code>pthread_exit</code></li></ul><p>线程能访问的数据分为以下几种：</p><ul><li>线程stack上的本地数据：函数执行过程中的局部变量<ul><li>stack大小可以通过<code>ulimit -a</code>查看</li><li>stack大小可以通过<code>ulimit -s</code>修改，或者<code>pthread_attr_setstacksize</code>函数修改。</li></ul></li><li>进程共享的全局数据：全局变量，需要使用<code>mutex</code>等方案保证线程安全。</li><li>线程私有数据：线程内部各个函数传递信息，线程外的函数无法访问到这些数据<ul><li>通过<code>pthread_key_create</code>创建key</li><li><code>pthread_setspecific</code>设置key对应的value</li><li><code>pthread_getspecific</code>获取key对应的value</li></ul></li></ul><h2 id="task-struct结构"><a href="#task-struct结构" class="headerlink" title="task_struct结构"></a>task_struct结构</h2><p>在OS理论课程中的PCB，在Linux中实现就是<code>task_struct</code>，该结构体通过<strong>链表</strong>进行连接，无论是进程还是线程，在内核中都被称为<code>task</code>，并使用上述结构体存储<code>metadata</code>。</p><h3 id="进程Id"><a href="#进程Id" class="headerlink" title="进程Id"></a>进程Id</h3><p>线程组id用于区分线程和进程（线程拥有tgid），同一进程中的所有线程具有同一个<code>tgid</code>，<code>tgid</code>等于第一个主线程的pid。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> pid;<span class="hljs-comment">//进程ID</span><span class="hljs-type">pid_t</span> tgid;<span class="hljs-comment">//线程组ID</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">group_leader</span>;</span> c</code></pre></div><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><ul><li>state：进程运行状态</li><li>exit_state：任务终止状态</li><li>flags：进程状态的信息，用于kernel识别进程当前状态</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;    <span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><span class="hljs-type">int</span> exit_state;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Task state bitmask. NOTE! These bits are also</span><span class="hljs-comment"> * encoded in fs/proc/array.c: get_task_state().</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * We have two separate sets of flags: task-&gt;state</span><span class="hljs-comment"> * is about runnability, while task-&gt;exit_state are</span><span class="hljs-comment"> * about the task exiting. Confusing, but this way</span><span class="hljs-comment"> * modifying one set can&#x27;t modify the other one by</span><span class="hljs-comment"> * mistake.</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_RUNNING0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_INTERRUPTIBLE1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_UNINTERRUPTIBLE2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TASK_STOPPED4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TASK_TRACED8</span><span class="hljs-comment">/* in tsk-&gt;exit_state */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_DEAD16</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_ZOMBIE32</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXIT_TRACE(EXIT_ZOMBIE | EXIT_DEAD)</span><span class="hljs-comment">/* in tsk-&gt;state again */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_DEAD64</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_WAKEKILL128</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_WAKING256</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_PARKED512</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_STATE_MAX1024</span>················<span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_KILLABLE(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_STOPPED(TASK_WAKEKILL | __TASK_STOPPED)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_TRACED(TASK_WAKEKILL | __TASK_TRACED)</span></code></pre></div><p>Linux中的睡眠状态：</p><ul><li><strong>TASK_INTERRUPTIBLE</strong>：可中断睡眠</li><li><strong>TASK_UNINTERRUPTIBLE</strong>：不可中断睡眠，不可被信号唤醒</li><li><strong>TASK_KILLABLE</strong>：可终止的新睡眠状态，只能接受致命信号</li></ul><p>其他状态：</p><ul><li><p><strong>TASK_RUNNING</strong>：要么正在执行，要么准备被调度</p></li><li><p><strong>TASK_STOPPED</strong> ：进程接收到了SIGSTOP、SIGTTIN、SIGTSTP、SIGTTOU信号后进入该状态。</p></li><li><p><strong>TASK_TRACED</strong> ：进程正在被debug进程监视</p></li><li><p><strong>EXIT_ZOMBIE</strong> ：进程结束进入的状态，若父进程没有用<code>wait()</code>等syscall获取它的终止信息，该进程变成僵尸进程。</p></li><li><p><strong>EXIT_DEAD</strong>：进程执行完的最终状态</p></li></ul><p><code>flags</code>取值如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Per process flags</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_EXITING0x00000004<span class="hljs-comment">/* getting shut down */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_EXITPIDONE0x00000008<span class="hljs-comment">/* pi exit done on shut down */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_VCPU0x00000010<span class="hljs-comment">/* I&#x27;m a virtual CPU */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_WQ_WORKER0x00000020<span class="hljs-comment">/* I&#x27;m a workqueue worker */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_FORKNOEXEC0x00000040<span class="hljs-comment">/* forked but didn&#x27;t exec */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_MCE_PROCESS  0x00000080      <span class="hljs-comment">/* process policy on mce errors */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_SUPERPRIV0x00000100<span class="hljs-comment">/* used super-user privileges */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_DUMPCORE0x00000200<span class="hljs-comment">/* dumped core */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_SIGNALED0x00000400<span class="hljs-comment">/* killed by a signal */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_MEMALLOC0x00000800<span class="hljs-comment">/* Allocating memory */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_NPROC_EXCEEDED 0x00001000<span class="hljs-comment">/* set_user noticed that RLIMIT_NPROC was exceeded */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_USED_MATH0x00002000<span class="hljs-comment">/* if unset the fpu must be initialized before use */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_USED_ASYNC0x00004000<span class="hljs-comment">/* used async_schedule*(), used by module init */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_NOFREEZE0x00008000<span class="hljs-comment">/* this thread should not be frozen */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_FROZEN0x00010000<span class="hljs-comment">/* frozen for system suspend */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_FSTRANS0x00020000<span class="hljs-comment">/* inside a filesystem transaction */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_KSWAPD0x00040000<span class="hljs-comment">/* I am kswapd */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_MEMALLOC_NOIO 0x00080000<span class="hljs-comment">/* Allocating memory without IO involved */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_LESS_THROTTLE 0x00100000<span class="hljs-comment">/* Throttle me less: I clean memory */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_KTHREAD0x00200000<span class="hljs-comment">/* I am a kernel thread */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_RANDOMIZE0x00400000<span class="hljs-comment">/* randomize virtual address space */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_SWAPWRITE0x00800000<span class="hljs-comment">/* Allowed to write to swap */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_NO_SETAFFINITY 0x04000000<span class="hljs-comment">/* Userland is not allowed to meddle with cpus_allowed */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_MCE_EARLY    0x08000000      <span class="hljs-comment">/* Early kill for mce process policy */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_MUTEX_TESTER0x20000000<span class="hljs-comment">/* Thread belongs to the rt mutex tester */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_FREEZER_SKIP0x40000000<span class="hljs-comment">/* Freezer should not count it as freezable */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PF_SUSPEND_TASK 0x80000000      <span class="hljs-comment">/* this thread called freeze_processes and should not be frozen */</span></span></code></pre></div><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>信号处理函数默认使用用户态的函数栈，也可以开辟新的栈用于信号处理。这里定义了那些信号被阻塞暂不处理（blocked）、哪些信号尚待处理（pending）、哪些正在通过信号处理函数处理（sighand）</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Signal handlers: */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">signal_struct</span>*<span class="hljs-title">signal</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sighand_struct</span>*<span class="hljs-title">sighand</span>;</span><span class="hljs-type">sigset_t</span>blocked;<span class="hljs-type">sigset_t</span>real_blocked;<span class="hljs-type">sigset_t</span>saved_sigmask;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigpending</span><span class="hljs-title">pending</span>;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>sas_ss_sp;<span class="hljs-type">size_t</span>sas_ss_size;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sas_ss_flags;</code></pre></div><h3 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h3><p>各字段含义如下：</p><div class="code-wrapper"><pre><code class="hljs c">u64utime;<span class="hljs-comment">// 用户态消耗的 CPU 时间</span>u64stime;<span class="hljs-comment">// 内核态消耗的 CPU 时间</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nvcsw;<span class="hljs-comment">// 自愿 (voluntary) 上下文切换计数</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nivcsw;<span class="hljs-comment">// 非自愿 (involuntary) 上下文切换计数</span>u64start_time;<span class="hljs-comment">// 进程启动时间，不包含睡眠时间</span>u64real_start_time;<span class="hljs-comment">// 进程启动时间，包含睡眠时间</span></code></pre></div><h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p>若在bash使用某进程创建进程，此时<code>real_parent</code>为bash，parent为某进程id，其他情况两者相同。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">real_parent</span>;</span> <span class="hljs-comment">//指向父进程</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">//指向父进程</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">children</span>;</span>      <span class="hljs-comment">//指向子进程的链表头部</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">sibling</span>;</span>       <span class="hljs-comment">//指向兄弟进程</span></code></pre></div><h3 id="进程拥有权限"><a href="#进程拥有权限" class="headerlink" title="进程拥有权限"></a>进程拥有权限</h3><ul><li>Objective：当前进程能操作的对象</li><li>Subjective：能操作当前进程的对象</li></ul><p>定义的取值是用户和用户所属的用户组信息。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>         *<span class="hljs-title">real_cred</span>;</span><span class="hljs-comment">//谁能操作当前进程</span><span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>         *<span class="hljs-title">cred</span>;</span> <span class="hljs-comment">//当前进程能操作的</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> &#123;</span>......        <span class="hljs-type">kuid_t</span>          uid;            <span class="hljs-comment">//启动当前进程的进程id</span>        <span class="hljs-type">kgid_t</span>          gid;            <span class="hljs-comment">//同上</span>        <span class="hljs-type">kuid_t</span>          suid;           <span class="hljs-comment">/* saved UID of the task */</span>        <span class="hljs-type">kgid_t</span>          sgid;           <span class="hljs-comment">/* saved GID of the task */</span>        <span class="hljs-type">kuid_t</span>          euid;           <span class="hljs-comment">//操作消息队列 共享内存 信号量比较的权限</span>        <span class="hljs-type">kgid_t</span>          egid;           <span class="hljs-comment">/* effective GID of the task */</span>        <span class="hljs-type">kuid_t</span>          fsuid;          <span class="hljs-comment">//文件系统操作比较的权限</span>        <span class="hljs-type">kgid_t</span>          fsgid;          <span class="hljs-comment">/* GID for VFS ops */</span>......        <span class="hljs-type">kernel_cap_t</span>    cap_inheritable; <span class="hljs-comment">//继承的权限集合</span>        <span class="hljs-type">kernel_cap_t</span>    cap_permitted;  <span class="hljs-comment">//当前进程能够使用的权限</span>        <span class="hljs-type">kernel_cap_t</span>    cap_effective;  <span class="hljs-comment">//实际能使用的权限</span>        <span class="hljs-type">kernel_cap_t</span>    cap_bset;       <span class="hljs-comment">//系统中所有进程允许保留的权限</span>        <span class="hljs-type">kernel_cap_t</span>    cap_ambient;    <span class="hljs-comment">/* Ambient capability set */</span>......&#125; __randomize_layout;</code></pre></div><p>除了以用户和用户组控制权限，Linux还用<strong>capabilities</strong>机制控制。用bitmap来表示权限，<code>capability.h</code>可以找到定义的权限。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_CHOWN            0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_KILL             5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_NET_BIND_SERVICE 10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_NET_RAW          13</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_SYS_MODULE       16</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_SYS_RAWIO        17</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_SYS_BOOT         22</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_SYS_TIME         25</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_AUDIT_READ          37</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAP_LAST_CAP         CAP_AUDIT_READ</span></code></pre></div><h3 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h3><p>进程中的函数调用都是通过函数栈来实现的，每个函数都是一个栈帧，函数开始运行入栈，结束运行出栈。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span><span class="hljs-title">thread_info</span>;</span><span class="hljs-comment">//存放对task_struct的补充信息（针对其他体系结构）</span><span class="hljs-type">void</span>  *<span class="hljs-built_in">stack</span>;<span class="hljs-comment">//内核栈</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE_ORDER1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        flags;        <span class="hljs-comment">/* low level flags */</span>    <span class="hljs-type">mm_segment_t</span>        addr_limit;    <span class="hljs-comment">/* address limit */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>    *<span class="hljs-title">task</span>;</span>        <span class="hljs-comment">/* main task structure */</span>    <span class="hljs-type">int</span>            preempt_count;    <span class="hljs-comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span>    <span class="hljs-type">int</span>            cpu;        <span class="hljs-comment">/* cpu */</span>&#125;;</code></pre></div><p>普通函数存储在用户态函数栈，当发生系统调用，从进程空间转换到内核空间时，使用内核态函数栈存储栈帧。</p><p>内核栈在x86架构64bit中，定义在<code>arch/x86/include/asm/page_64_types.h</code>文件中，内核栈大小为<code>PAGE_SIZE</code>右移两位（16K），起始地址必须是8192的整数倍。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KASAN_STACK_ORDER 1</span><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KASAN_STACK_ORDER 0</span><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE_ORDER(2 + KASAN_STACK_ORDER)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></code></pre></div><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220716124604381.png" alt="stack结构图"></p><p><code>stack</code>指向的地址空间最顶端是<code>pt_regs</code>（存储用户态上下文），当发生用户态转内核态时，存储用户态的CPU上下文信息，定义如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span> &#123;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r15;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r14;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r13;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r12;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bp;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> bx;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r11;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r10;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r9;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r8;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ax;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cx;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dx;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> si;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> di;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> orig_ax;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ip;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cs;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sp;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ss;<span class="hljs-comment">/* top of stack page */</span>&#125;;</code></pre></div><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span>                *<span class="hljs-title">mm</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span>                *<span class="hljs-title">active_mm</span>;</span></code></pre></div><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Filesystem information: */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span>                *<span class="hljs-title">fs</span>;</span><span class="hljs-comment">/* Open file information: */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span>             *<span class="hljs-title">files</span>;</span></code></pre></div><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>有关进程调度的字段如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 是否在运行队列上</span><span class="hljs-type">int</span>on_rq;<span class="hljs-comment">// 优先级</span><span class="hljs-type">int</span>prio;<span class="hljs-type">int</span>static_prio;<span class="hljs-type">int</span>normal_prio;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>rt_priority;<span class="hljs-comment">// 调度器类，调度策略执行的逻辑</span><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span>*<span class="hljs-title">sched_class</span>;</span><span class="hljs-comment">// 调度实体</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span><span class="hljs-title">se</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_rt_entity</span><span class="hljs-title">rt</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_dl_entity</span><span class="hljs-title">dl</span>;</span><span class="hljs-comment">// 调度策略</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>policy;<span class="hljs-comment">// 可以使用哪些 CPU</span><span class="hljs-type">int</span>nr_cpus_allowed;<span class="hljs-type">cpumask_t</span>cpus_allowed;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span><span class="hljs-title">sched_info</span>;</span></code></pre></div><p><code>policy</code>是<strong>调度策略</strong>，其取值如下：</p><ul><li>实时调度策略：调度实施进程，需要尽快返回结果的。<ul><li>SCHED_FIFO：按照FIFO调度</li><li>SCHED_RR：时间片轮转调度策略，高优先级任务可以抢占低优先级的任务。</li><li>SCHED_DEADLINE：按照任务deadline进行调度，DL调度器选择deadline距离当前时间点最近的任务</li></ul></li><li>普通调度策略：调度普通进程<ul><li>SCHED_NORMAL：调度普通进程</li><li>SCHED_BATCH：调度后台进程，不需要和前端交互</li><li>SCHED_IDLE：空闲时跑的进程</li></ul></li></ul><p><code>sched_class</code>的具体实现：</p><ul><li><code>stop_sched_class</code> ：优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li><li><code>dl_sched_class</code> ：就对应上面的 deadline 调度策略；</li><li><code>rt_sched_class</code>： 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</li><li><code>fair_sched_class</code>： 就是普通进程的调度策略；</li><li><code>idle_sched_class</code>： 就是空闲进程的调度策略。</li></ul><h3 id="完全公平调度算法"><a href="#完全公平调度算法" class="headerlink" title="完全公平调度算法"></a>完全公平调度算法</h3><p>Linux中实现了基于CFS（Completely Fair Scheduling）调度算法，其原理如下：</p><ul><li><p>根据各个进程的<strong>权重</strong>分配运行时间，<strong>分配给进程的运行时间 &#x3D; 调度周期 * 进程权重 &#x2F; 所有进程权重之和</strong></p></li><li><p>公平体现在：给每个进程安排一个虚拟运行时间<code>vruntime</code>，<strong>vruntime &#x3D; 实际运行时间 * 1024 &#x2F; 进程权重</strong>，<code>vruntime</code>小的进程运行时间不公平，CFS会优先调度这类进程。</p></li><li><p>CFS使用红黑树将调度实体<code>sched_entity</code>组织起来，<code>vruntime</code>是红黑树的key，树中key最小的节点就是CFS下一个调度的进程</p></li></ul><h3 id="主动调度"><a href="#主动调度" class="headerlink" title="主动调度"></a>主动调度</h3><p>主动调度是指进程主动触发以下情况，转入内核态，最后调用<code>schedule()</code>：</p><ul><li>进程发起需要等待的IO，read&#x2F;write</li><li>进程主动调用schedule</li><li>进程等待信号量或mutex，spin lock不会触发调度</li></ul><p>进程调度的具体实现如下：</p><div class="code-wrapper"><pre><code class="hljs c">asmlinkage __visible <span class="hljs-type">void</span> __sched <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tsk</span> =</span> current;  sched_submit_work(tsk);<span class="hljs-keyword">do</span> &#123;preempt_disable();__schedule(<span class="hljs-literal">false</span>);sched_preempt_enable_no_resched();&#125; <span class="hljs-keyword">while</span> (need_resched());&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> __sched notrace __schedule(<span class="hljs-type">bool</span> preempt)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">prev</span>, *<span class="hljs-title">next</span>;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *switch_count;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq_flags</span> <span class="hljs-title">rf</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span>;</span><span class="hljs-type">int</span> cpu;  cpu = smp_processor_id();rq = cpu_rq(cpu);prev = rq-&gt;curr;    next = pick_next_task(rq, prev, &amp;rf);clear_tsk_need_resched(prev);clear_preempt_need_resched(); &#125;<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> task_struct *<span class="hljs-title function_">pick_next_task</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *prev, <span class="hljs-keyword">struct</span> rq_flags *rf)</span>&#123;<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span> *<span class="hljs-keyword">class</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Optimization: we know that if all tasks are in the fair class we can call that function directly, but only if the @prev task wasn&#x27;t of a higher scheduling class, because otherwise those loose the opportunity to pull in more work from other CPUs.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (likely((prev-&gt;sched_class == &amp;idle_sched_class ||    prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;p = fair_sched_class.pick_next_task(rq, prev, rf);<span class="hljs-keyword">if</span> (unlikely(p == RETRY_TASK))<span class="hljs-keyword">goto</span> again;<span class="hljs-comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span><span class="hljs-keyword">if</span> (unlikely(!p))p = idle_sched_class.pick_next_task(rq, prev, rf);<span class="hljs-keyword">return</span> p;&#125;    <span class="hljs-comment">//这里是依次调用调度类</span>again:for_each_class(class) &#123;p = class-&gt;pick_next_task(rq, prev, rf);<span class="hljs-keyword">if</span> (p) &#123;<span class="hljs-keyword">if</span> (unlikely(p == RETRY_TASK))<span class="hljs-keyword">goto</span> again;<span class="hljs-keyword">return</span> p;&#125;&#125;&#125;</code></pre></div><p>逻辑如下：</p><ol><li>在当前CPU取出任务队列rq</li><li>prev指向rq上面正在运行的进程curr，因为curr要被切换下来</li><li>调用<code>pick_next_task</code>选择下一个任务，该函数遍历所有的<code>sched_class</code>，如果<code>rq -&gt; nr_running == rq -&gt; cfs.h_nr_running</code>即队列进程数量&#x3D;&#x3D; CFS调度器进程数量，CFS调度器则调用<code>fair_sched_class.pick_next_task</code></li><li>CFS调度器会调用以下三个函数实现调度：<ol><li>update_curr：更新当前进程的vruntime，然后更新红黑树节点和<code>cfs_rq -&gt; min_vruntime</code></li><li>pick_next_entity：选择红黑树的最左侧节点，比较和当前进程是否相同，不同则执行context_switch</li><li>context_switch：上下文切换主要做两件事：<ul><li>切换进程空间（虚拟内存）</li><li>切换寄存器和CPU上下文（内核栈切换）</li></ul></li></ol></li></ol><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换的核心代码如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * context_switch - switch to the new MM and the new thread&#x27;s register state.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> __always_inline <span class="hljs-keyword">struct</span> rq *<span class="hljs-title function_">context_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *prev,</span><span class="hljs-params">       <span class="hljs-keyword">struct</span> task_struct *next, <span class="hljs-keyword">struct</span> rq_flags *rf)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>, *<span class="hljs-title">oldmm</span>;</span>......mm = next-&gt;mm;oldmm = prev-&gt;active_mm;......    <span class="hljs-comment">//切换内存地址空间</span>switch_mm_irqs_off(oldmm, mm, next);......<span class="hljs-comment">/* Here we just switch the register state and the stack. */</span>    <span class="hljs-comment">//切换寄存器堆栈</span>switch_to(prev, next, prev);barrier();<span class="hljs-keyword">return</span> finish_task_switch(prev);&#125;<span class="hljs-comment">//switch_to实现了栈和寄存器的切换</span>ENTRY(__switch_to_asm)......<span class="hljs-comment">/* switch stack   切换rsp指针（栈顶指针） */</span>movq%rsp, TASK_threadsp(%rdi)movq<span class="hljs-title function_">TASK_threadsp</span><span class="hljs-params">(%rsi)</span>, %rsp......jmp__switch_to<span class="hljs-comment">//__switch_to</span><span class="hljs-title function_">END</span><span class="hljs-params">(__switch_to_asm)</span>    __visible __notrace_funcgraph <span class="hljs-keyword">struct</span> task_struct *__<span class="hljs-title function_">switch_to</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *prev_p, <span class="hljs-keyword">struct</span> task_struct *next_p)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> *<span class="hljs-title">prev</span> =</span> &amp;prev_p-&gt;thread;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> *<span class="hljs-title">next</span> =</span> &amp;next_p-&gt;thread;......<span class="hljs-type">int</span> cpu = smp_processor_id();<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> *<span class="hljs-title">tss</span> =</span> &amp;per_cpu(cpu_tss, cpu);......load_TLS(next, cpu);......this_cpu_write(current_task, next_p);  <span class="hljs-comment">/* Reload esp0 and ss1.  This changes current_thread_info(). */</span>load_sp0(tss, next);......<span class="hljs-keyword">return</span> prev_p;&#125;</code></pre></div><p>X86结构提供了TSS（Task State Segment），这是以硬件的方式进行进程切换的结构，其中有X86所有的寄存器，但是这种切换的<strong>开销较大</strong>，需要保存所有寄存器数据。</p><p>Linux使用软切换方案，初始化时将每个CPU绑定一个TSS，tr指针永远指向这个<code>tss_struct</code>。使用<code>thread_struct</code>来保存上下文。当需要切换进程时，将<code>thread_struct</code>里面寄存器的值写入tr指向的<code>tss_struct</code>。两个结构如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss_struct</span> &#123;</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * The hardware state:</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">x86_hw_tss</span><span class="hljs-title">x86_tss</span>;</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>io_bitmap[IO_BITMAP_LONGS + <span class="hljs-number">1</span>];&#125; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> &#123;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    rsp0;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    rsp;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>     userrsp;    <span class="hljs-comment">/* Copy from PDA */</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    fs;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    gs;    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>    es, ds, fsindex, gsindex;    <span class="hljs-comment">/* Hardware debugging registers */</span>....<span class="hljs-comment">/* fault info */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    cr2, trap_no, error_code;<span class="hljs-comment">/* floating point info */</span>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">i387_union</span>    <span class="hljs-title">i387</span>  __<span class="hljs-title">attribute__</span>((<span class="hljs-title">aligned</span>(16)));</span><span class="hljs-comment">/* IO permissions. the bitmap could be moved into the GDT, that would make</span><span class="hljs-comment">   switch faster for a limited number of ioperm using tasks. -AK */</span>    <span class="hljs-type">int</span>        ioperm;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    *io_bitmap_ptr;    <span class="hljs-type">unsigned</span> io_bitmap_max;<span class="hljs-comment">/* cached TLS descriptors. */</span>    u64 tls_array[GDT_ENTRY_TLS_ENTRIES];&#125; __attribute__((aligned(<span class="hljs-number">16</span>)));</code></pre></div><p>在Linux中可以通过以下操作查看进程的上下文切换：</p><div class="code-wrapper"><pre><code class="hljs bash">vmstatpidstat<span class="hljs-built_in">cat</span> /proc/interrupts</code></pre></div><h3 id="被动调度（抢占式调度）"><a href="#被动调度（抢占式调度）" class="headerlink" title="被动调度（抢占式调度）"></a>被动调度（抢占式调度）</h3><p>一般也被称为抢占式调度，发生时机：</p><ul><li>CPU时钟中断</li><li>fork出新进程，CFS算法检查到CPU当前进程vruntime不是最小</li><li>进程等待IO完成后，进程被唤醒，如果优先级高于CPU当前进程，则会触发抢占。</li></ul><p>时钟中断会调用<code>scheduler_tick</code>：</p><ul><li>首先取出当前cpu运行队列rq</li><li>取到当前正在运行线程的task_struct</li><li>调用这个task的task_tick函数来处理时钟事件</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">scheduler_tick</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<span class="hljs-type">int</span> cpu = smp_processor_id();<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span> =</span> cpu_rq(cpu);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">curr</span> =</span> rq-&gt;curr;......curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="hljs-number">0</span>);cpu_load_update_active(rq);calc_global_load_tick(rq);......&#125;</code></pre></div><p>普通进程使用的公平调度器，对应函数为<code>task_tick_fair</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">task_tick_fair</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *curr, <span class="hljs-type">int</span> queued)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span> *<span class="hljs-title">cfs_rq</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> *<span class="hljs-title">se</span> =</span> &amp;curr-&gt;se;  <span class="hljs-comment">//找到对应的调度实体和cfs队列，调用entity_tick</span>for_each_sched_entity(se) &#123;cfs_rq = cfs_rq_of(se);entity_tick(cfs_rq, se, queued);&#125;......&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">entity_tick</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq, <span class="hljs-keyword">struct</span> sched_entity *curr, <span class="hljs-type">int</span> queued)</span>&#123;    <span class="hljs-comment">//更新当前进程的vruntime</span>update_curr(cfs_rq);update_load_avg(curr, UPDATE_TG);update_cfs_shares(curr);.....<span class="hljs-keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="hljs-number">1</span>)        <span class="hljs-comment">//检查是否需要被抢占，内部检查进程运行时间等信息</span>check_preempt_tick(cfs_rq, curr);&#125;<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">check_preempt_tick</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cfs_rq *cfs_rq, <span class="hljs-keyword">struct</span> sched_entity *curr)</span>&#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ideal_runtime, delta_exec;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span> *<span class="hljs-title">se</span>;</span>s64 delta;  <span class="hljs-comment">//计算runtime</span>ideal_runtime = sched_slice(cfs_rq, curr);delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;<span class="hljs-keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;resched_curr(rq_of(cfs_rq));<span class="hljs-keyword">return</span>;&#125;......    <span class="hljs-comment">//取出红黑树最左侧，比较vruntime</span>se = __pick_first_entity(cfs_rq);delta = curr-&gt;vruntime - se-&gt;vruntime;<span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (delta &gt; ideal_runtime)        <span class="hljs-comment">//调用该方法标记该进程可被抢占</span>resched_curr(rq_of(cfs_rq));&#125;</code></pre></div><h4 id="抢占时机"><a href="#抢占时机" class="headerlink" title="抢占时机"></a>抢占时机</h4><p>上面的流程仅仅将当前进程标记为可抢占，但是真正的调度流程还未执行。需要正在运行的进程调用<code>__schedule()</code>，这个调用可以在用户态和内核态发生。</p><p>用户态时，从系统调用中返回的时刻可以执行。<code>exit_to_usermode_loop</code>执行</p><p>内核态时，<code>preempt_enable</code>进行调度判断。</p><h2 id="fork创建进程"><a href="#fork创建进程" class="headerlink" title="fork创建进程"></a>fork创建进程</h2><p><code>fork</code>是Linux中创建进程的一种方法，主要通过复制当前进程的方式来创建子进程</p><h3 id="拷贝task-struct"><a href="#拷贝task-struct" class="headerlink" title="拷贝task_struct"></a>拷贝task_struct</h3><p>fork是一个系统调用，它的调用流程最终会执行<code>sys_fork</code>，其定义如下：</p><div class="code-wrapper"><pre><code class="hljs c">SYSCALL_DEFINE0(fork)&#123;......<span class="hljs-keyword">return</span> _do_fork(SIGCHLD, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-type">long</span> _do_fork(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clone_flags,      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_start,      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_size,      <span class="hljs-type">int</span> __user *parent_tidptr,      <span class="hljs-type">int</span> __user *child_tidptr,      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tls)&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span><span class="hljs-type">int</span> trace = <span class="hljs-number">0</span>;<span class="hljs-type">long</span> nr;  ......    <span class="hljs-comment">//复制父进程task_struct</span>p = copy_process(clone_flags, stack_start, stack_size, child_tidptr, <span class="hljs-literal">NULL</span>, trace, tls, NUMA_NO_NODE);......<span class="hljs-keyword">if</span> (!IS_ERR(p)) &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">pid</span>;</span>        <span class="hljs-comment">//</span>pid = get_task_pid(p, PIDTYPE_PID);nr = pid_vnr(pid);  <span class="hljs-keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)put_user(nr, parent_tidptr);  ......wake_up_new_task(p);......put_pid(pid);&#125; <span class="hljs-comment">//copy_process实现</span><span class="hljs-type">static</span> __latent_entropy <span class="hljs-keyword">struct</span> task_struct *<span class="hljs-title function_">copy_process</span><span class="hljs-params">(</span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clone_flags,</span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_start,</span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_size,</span><span class="hljs-params"><span class="hljs-type">int</span> __user *child_tidptr,</span><span class="hljs-params"><span class="hljs-keyword">struct</span> pid *pid,</span><span class="hljs-params"><span class="hljs-type">int</span> trace,</span><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tls,</span><span class="hljs-params"><span class="hljs-type">int</span> node)</span>&#123;<span class="hljs-type">int</span> retval;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span>......    <span class="hljs-comment">//</span>p = dup_task_struct(current, node);  <span class="hljs-comment">//执行调度器相关设置，将该task分配给一某个CPU</span>  retval = sched_fork(clone_flags, p);   retval = perf_event_init_task(p);  retval = audit_alloc(p);    <span class="hljs-comment">//拷贝进程的所有信息</span>  shm_init_task(p);   retval = copy_semundo(clone_flags, p);  <span class="hljs-comment">//拷贝进程打开的文件信息</span>  retval = copy_files(clone_flags, p);  <span class="hljs-comment">//拷贝进程的目录信息</span>  retval = copy_fs(clone_flags, p);  <span class="hljs-comment">//拷贝信号处理函数</span>  retval = copy_sighand(clone_flags, p);  retval = copy_signal(clone_flags, p);  <span class="hljs-comment">//复制内存空间</span>  retval = copy_mm(clone_flags, p);  retval = copy_namespaces(clone_flags, p);  retval = copy_io(clone_flags, p);  retval = copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);</code></pre></div><ul><li><p><code>dup_task_struct</code>完成了对进程结构的初始化，具体实现了：</p><ul><li><p>调用<code>alloc_task_struct_node </code>分配<code>task_struct</code>的内存结构</p></li><li><p>调用<code>alloc_thread_stack_node </code>创建<code>task_struct-&gt;stack</code></p></li><li><p>调用<code>arch_dup_task_struct</code>完成<code>task_struct</code>的复制</p></li><li><p>调用<code>setup_thread_stack </code>设置<code>thread_info</code></p></li></ul></li><li><p><code>sched_fork</code>主要对调度所需的变量进行初始化：</p><ul><li><p>调用<code>__sched_fork</code>，对调度变量初始化，比如vruntime等</p></li><li><p>设置进程优先级</p></li><li><p>设置调度类，并调用调度函数<code>task_fork </code>（CFS调度是<code>task_fork_fair</code>）</p></li></ul></li></ul><p>fork主要做了以下的操作：</p><ol><li>完成<code>task_struct</code>的拷贝，通过<code>copy_process</code>实现</li><li>完成权限的拷贝，通过<code>copy_creds </code>实现</li><li>调用<code>sched_fork</code>进行调度</li></ol><h3 id="唤醒子进程"><a href="#唤醒子进程" class="headerlink" title="唤醒子进程"></a>唤醒子进程</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">wake_up_new_task</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *p)</span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq_flags</span> <span class="hljs-title">rf</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span>;</span>......    <span class="hljs-comment">//设置进程状态</span>p-&gt;state = TASK_RUNNING;......    <span class="hljs-comment">//调用enqueue_task，CFS调度会执行对应的enqueue_task_fair</span>activate_task(rq, p, ENQUEUE_NOCLOCK);p-&gt;on_rq = TASK_ON_RQ_QUEUED;trace_sched_wakeup_new(p);    <span class="hljs-comment">//检查是否能抢占当前进程</span>check_preempt_curr(rq, p, WF_FORK);......&#125;</code></pre></div><p>上述的<code>enqueue_task_fair</code>实现以下功能：</p><ul><li>取出rq，调用<code>enqueue_entity</code>将进程节点加入红黑树</li><li>更新队列上运行的进程数量</li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Linux中创建线程调用的是<code>pthread_create</code>，其调用的也是<code>_do_fork</code>实现线程数据复制功能，与进程创建流程的流程图差异如下所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/image-20220716142100955.png" alt="两者区别"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>短网址系统设计总结</title>
    <link href="/2022/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/"/>
    <url>/2022/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="需求评估"><a href="#需求评估" class="headerlink" title="需求评估"></a>需求评估</h2><ul><li>输入数据：一个长网址、过期时间和一个自定义的别名</li><li>输出数据：自定义别名或者随机生成的短网址，过期时间之前访问都会被重定向到原始地址。</li><li>读多写少</li></ul><p>实现原理：将短网址redirect到长网址（301&#x2F;302跳转）</p><p>约束：</p><ul><li>过期即失效</li><li>短网址唯一</li><li>支持自定义短网址</li><li>QPS要求、低延迟、可靠性、安全性</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="可行解"><a href="#可行解" class="headerlink" title="可行解"></a>可行解</h3><ol><li>写<ol><li>输入长域名，判断是否存在</li><li>生成一个未使用的短网址，并进行持久化</li></ol></li><li>读<ol><li>获取短网址，判断是否过期</li><li>正常则返回短网址</li></ol></li></ol><p>其他方面：</p><ul><li>使用延迟删除策略清理过期数据</li><li>读时消重：返回的时候过滤重复元素</li><li>写时消重：写时判断以避免重复写入</li><li>短网址生成算法：<ul><li>UUID：无法保证唯一性</li><li>哈希：MurMurHash等方法，无法保证唯一性，考虑转为62进制</li><li>ID：使用7位62进制，即长度为7，由大小写字母加数字共62个字符组成</li><li>雪花算法：转为62进制</li></ul></li><li>用户自定义：记录正在使用的ID，写入时判断是否存在</li></ul><p>MySQL表结构如下：</p><table><thead><tr><th align="center">id</th><th>long_url</th><th>short_url</th><th>expire_time</th><th>create_time</th><th>delete_time</th></tr></thead></table><p>Redis键值设计：</p><div class="code-wrapper"><pre><code class="hljs">k：长网址, v：短网址</code></pre></div><h3 id="吞吐量优化"><a href="#吞吐量优化" class="headerlink" title="吞吐量优化"></a>吞吐量优化</h3><ul><li><strong>水平扩展</strong>：使用Nginx做负载均衡</li><li><strong>存储层</strong>：MySQL替换为持久化KV存储，比如RocksDB，若存在数据分析的需求，可以添加数仓</li><li><strong>索引优化</strong>：两个方面<ol><li>写入时判需要判断长网址是否存在</li><li>读取时根据短网址查询长网址</li></ol></li><li><strong>分片</strong>：短网址进行一致性哈希等方式计算分片位置。</li><li><strong>缓存层</strong>：<strong>读多写少</strong>的系统使用缓存优化QPS<ul><li>使用bloom filter检查长网址是否存储，短网址是否分配</li><li>直接在本地设计缓存</li></ul></li><li><strong>业务层</strong><ul><li>分布式ID生成需要考虑<strong>数据一致性</strong>问题</li></ul></li><li><strong>网络层</strong>：降低<strong>广域延迟</strong></li></ul><h3 id="可靠性优化"><a href="#可靠性优化" class="headerlink" title="可靠性优化"></a>可靠性优化</h3><ul><li>存储层：考虑主从副本机制，增加数据可靠性</li><li>提供跨机房的数据冗余备份，通过log同步数据</li><li>监控业务集群，实现熔断、限流、扩容缩容等</li></ul><h3 id="安全性优化"><a href="#安全性优化" class="headerlink" title="安全性优化"></a>安全性优化</h3><ul><li>避免使用自增，防止逐个遍历</li><li>防止DDos，对接口做限流，增加IP黑名单机制</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习笔记(四)-集群工作机制</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)-%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Controller机制"><a href="#Controller机制" class="headerlink" title="Controller机制"></a>Controller机制</h2><p>Controller主要作用是在Zookeeper的帮助下管理和协调整个Kafka集群（在zk中存储集群元数据）。Kafka集群中会有一个或多个Broker，其中一个Broker会被选举为Controller，它负责管理整个集群中所有分区和副本的状态，其工作职责包括以下内容：</p><ul><li><strong>Topic管理</strong>：完成对Kafka的Topic的创建删除、分区增加等操作。</li><li><strong>分区重分配</strong>：新的Broker加入集群时，不会自动分担已有的topic负载，只会对后续的topic生效，此时如果需要对已有topic负载，需要用户手动进行<strong>分区重分配</strong>。</li><li><strong>Leader选举</strong>：负责Partition Leader选举的工作</li><li>集群成员管理：<ul><li>Kafka 使用Zookeeper的临时节点来选举Controller</li><li>Zookeeper在Broker加入集群或退出集群时通知Controller</li><li>Controller负责在Broker加入或离开集群时进行分区Leader选举</li></ul></li><li>元数据管理：Controller负责管理集群中所有的元数据</li></ul><p>Controller选举流程：</p><ul><li>每个Broker启动时，都会尝试读取<code>/controller</code>节点的brokerid的值，如果值不为-1，则表明已经有其他broker节点成为Controller，当前broker放弃选举</li><li>如果不存在<code>/controller</code>节点或节点数据异常，则主动创建节点并存储brokerid</li><li>其他broker会将选举成功的Brokerid都在内存保存下来</li><li>同时使用<code>/controller_epoch</code>持久性节点来记录任期号，记录Controller发生变化的次数，类似于Raft中的任期。<ul><li>初始值为1，每个与Controller交互的请求都会携带<code>controller_epoch</code>，如果请求的<code>controller_epoch</code>大于内存中<code>controller_epoch</code>，说明内存中的值过期了，目前已有新的Controller当选。</li><li>由两部分组成：<ul><li>epoch：单调递增的版本号，leader发生变更，进行自增</li><li>start offset：Leader副本在该Epoch值上写入的首条消息的位移。</li></ul></li><li>每个分区都缓存该值，并定期持久化到<code>checkpoint</code>文件中</li></ul></li></ul><h3 id="Partition-Leader选举"><a href="#Partition-Leader选举" class="headerlink" title="Partition Leader选举"></a>Partition Leader选举</h3><p>Controller拥有选举分区Leader的功能，每个分区都会有一个Broker作为Leader，处理所有的读写请求，选举流程由Controller负责：</p><ol><li>Controller从ZK中读取当前分区所有的ISR集合</li><li>调用配置的分区选择算法选举分区的Leader</li></ol><p><code>Partition Leader</code>的定义如下：</p><blockquote><p>Each partition has one server which acts as the “leader” and zero or more servers which act as “followers”. The leader handles all read and write requests for the partition while the followers passively replicate the leader. If the leader fails, one of the followers will automatically become the new leader. Each server acts as a leader for some of its partitions and a follower for others so load is well balanced within the cluster.</p></blockquote><p>触发Partition Leader选举的时机如下：</p><ul><li>Offline：创建新分区或现有分区Leader离线</li><li>Reassign：用户执行重分配操作</li><li>PreferredReplica：leader迁移回首选副本</li><li>分区的现有leader即将下线</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>如果Controller发生故障（宕机或网络超时等），Kafka能够立即启用备用Controller来代替之前的，这个过程称为<code>Failover</code>。其基本流程如下：</p><ol><li>ZK检测到当前controller宕机（ZK的watch机制），删除<code>/controller</code>临时节点。</li><li>某个Broker抢先注册了<code>/controller</code>临时节点，成为新的controller</li><li>该Broker从ZK拉取元数据，并执行初始化。</li></ol><h2 id="分区副本机制"><a href="#分区副本机制" class="headerlink" title="分区副本机制"></a>分区副本机制</h2><p>副本对分区数据进行冗余存储，以保证系统的高可用和数据一致性，当分区Leader发生宕机或数据丢失，可以从其他副本获取分区数据。分区Leader负责处理分区所有的读写请求。</p><p>每个分区都有一个ISR集合，用于维护所有同步并可用的副本，ISR最少拥有Leader副本这一个元素，对于Follower来说，必须满足以下条件才是ISR：</p><ul><li>必须定时向Zookeeper发送心跳</li><li>在规定时间内从Leader获取过消息</li></ul><p>若副本不满足以上两条件，就会从ISR列表移除。</p><p><code>replica.lag.time.max.ms</code>：Follower能落后Leader的最长时间间隔，默认为10s</p><p>使用Zookeeper来管理ISR，节点位置为<code>/brokers/topics/[topic]/partitions/[partition]/state</code></p><h3 id="HW和LEO机制"><a href="#HW和LEO机制" class="headerlink" title="HW和LEO机制"></a>HW和LEO机制</h3><p>几个offset概念：</p><ul><li>base offset：副本中第一条消息的offset</li><li>HW：high watermark，副本中最新一条已提交消息的offset<ul><li>用来标识分区中哪些消息可以消费，HW之后的数据对消费者不可见</li><li>完成副本数据同步的任务</li><li>HW永远小于LEO</li></ul></li><li>LEO：log end offset，副本中下一条待写入消息的offset<ul><li>用于更新HW：follower和Leader的LEO同步后，两者HW就可以更新</li></ul></li></ul><p>Leader除了保存自己的一组HW和LEO，也会保存其他Follower的值，目的是帮助Leader副本确定分区高水位。</p><h3 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h3><ul><li>Follower从Leader同步数据时，会携带自己的LEO值，Leader将Follower中最小的LEO作为HW值，这是为了保证Leader宕机后，新选举的节点拥有所有HW之前的数据，保证了数据安全性。</li><li>Follower获取数据时，请求Leader的HW，然后follower.HW &#x3D; min(follower.LEO, leader.HW)</li></ul><h2 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h2><ul><li>每个Group有一个或多个Consumer</li><li>每个Group可以管理0、1、多个Topic</li><li>每个Group拥有一个全局唯一的id</li><li>Group下的每个Consumer Client可以同时订阅Topic的一个或多个Partition</li><li>Group下同一个Partition只能被一个Consumer订阅</li></ul><h4 id="Group分配策略"><a href="#Group分配策略" class="headerlink" title="Group分配策略"></a>Group分配策略</h4><p>一个Group中有多个Consumer，一个Topic有多个Partition，Group存在一个分配的情况：<strong>确定某个Partition由哪个Consumer来消费</strong>。</p><p>Kafka提供了三种分区分配策略，也支持用户自定义分配策略：</p><ul><li><strong>RangeAssignor</strong>：默认分区分配算法，按照Topic的维度进行分配，Partition按照分区ID进行排序，然后对订阅此Topic的Group内Consumer及逆行排序，之后均衡的按照范围区段将分区分配给Consumer。<ul><li>缺点：当Consumer增加，不均衡的问题就会越来越严重。</li></ul></li><li><strong>RoundRobinAssignor</strong>：将Group内订阅的Topic所有Partition以及所有Consumer进行排序后按照顺序尽量均衡的一个个分配</li><li><strong>StickyAssignor</strong>：发生rebalance时，分配结果尽量与上次分配保持一致。</li></ul><h4 id="心跳保活机制"><a href="#心跳保活机制" class="headerlink" title="心跳保活机制"></a>心跳保活机制</h4><p>Consumer加入到Group中之后，维持状态通过两种方式实现：</p><ol><li>consumer会判断两次poll的时间间隔是否超出max.poll.interval.ms设定的值，超过则主动退出Group。</li><li>异步线程定时发送心跳包，间隔超出session.timeout.ms则broker判定consumer离线，主动将其退出Group。</li></ol><p>若consumer被移出Group，会触发Rebalance。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>Coordinator用于存储Group的相关Meta信息，主要负责：</p><ol><li>Group Rebalance</li><li>offset管理：将对应Partition的Offset信息记录到__consumer_offsets中</li><li>Group Consumer管理</li></ol><p>Broker启动时，都会创建对应的Coordinator组件，每一个Consumer Group，Kafka集群都会给它选一个broker作为其Coordinator</p><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>基于给定的分配策略，为Group下所有的Consumer重新分配所订阅的Partition。</p><p>目的：重新均衡消费者，尽量达到最公平的分配</p><p>触发时机：</p><ol><li>组成员数量发生变化<ul><li>新加入consumer</li><li>已有consumer退出（挂掉、调用unsubscribe）</li></ul></li><li>订阅topic数量发生变化</li><li>订阅topic的分区数发生变化</li></ol><p>影响：</p><ul><li>可能重复消费，consumer还未提交offset，被rebalance</li><li>Rebalance期间，整个Group内的Consumer无法消费消息</li><li>集群不稳定：只要做变动，就发生一次rebalance</li><li>影响消费速度：频繁的rebalance</li></ul><p>如何避免频繁rebalance？</p><ol><li>session.timeout.ms：超时时间，默认10s</li><li>heartbeat.interval.ms：心跳间隔，默认3s</li><li>max.poll.interval.ms：每隔多长时间去拉取消息，超过阈值则被coordinator</li></ol><h2 id="消息投递的三种语义"><a href="#消息投递的三种语义" class="headerlink" title="消息投递的三种语义"></a>消息投递的三种语义</h2><ul><li>At most once：消息发送或消费至多一次<ul><li>Producer：发送完消息，不会确认消息是否发送成功，存在丢失消息的可能性。</li><li>Consumer：对一条消息最多消费一次，可能存在消费失败依旧提交offset的情况 。</li></ul></li><li>at least once：消息发送或消费至少一次<ul><li>Producer：发送完消息会确认是否发送成功，如果没有收到ACK，会不断重复发送</li><li>Consumer：对一条消息可能消费多次。</li></ul></li><li>exactly once：消息恰好只发送或消费一次<ul><li>Producer：消息的发送是幂等的，broker不会有重复的消息。</li><li>Consumer：消费和提交offset的动作是原子性的。</li></ul></li></ul><h2 id="幂等性Producer"><a href="#幂等性Producer" class="headerlink" title="幂等性Producer"></a>幂等性Producer</h2><p>现象：producer在进行重试的时候可能会重复写入消息，使用幂等性可以避免这种情况。</p><p>配置项：enable.idempotence&#x3D;true</p><p>每个producer初始化时，会设置唯一的ProducerID，broker发送消息时会带上ProducerID并为每个消息分配一个seq number，broker端根据pid和seq number去重</p><p>特点：</p><ol><li>只能保证单分区上的幂等性</li><li>只能实现单会话的幂等性，producer重启后，幂等失效。</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Kafka中事务特性用于以下两种场景：</p><ol><li>producer生产消息和consumer消费消息并提交offset在一个事务中，要么同时成功，要么同时失败。</li><li>producer将多条消息封装在一个事务中，要么同时发送成功、要么同时发送失败。</li></ol><h2 id="Ops问题"><a href="#Ops问题" class="headerlink" title="Ops问题"></a>Ops问题</h2><h3 id="PageCache竞争"><a href="#PageCache竞争" class="headerlink" title="PageCache竞争"></a>PageCache竞争</h3><p>现象：同一台broker上的不同partition间竞争PageCache资源，相互影响，导致整个Broker处理延迟上升。</p><ul><li>Producer：Server端的IO线程统一将请求的消息数据写入到PageCache之后立即返回，当达到指定大小后，会刷回到硬盘中。</li><li>Consumer：利用OS的ZeroCopy机制，Broker接收到读请求时，向OS发生sendfile系统调用，OS接收后尝试从PageCache中获取数据，如果数据不存在，触发缺页中断从硬盘中读取数据到buffer，随后DMA操作直接将数据拷贝到网卡Buffer中等待后续TCP传输。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Kafka如何保证消息有序"><a href="#Kafka如何保证消息有序" class="headerlink" title="Kafka如何保证消息有序"></a>Kafka如何保证消息有序</h3><p>Kafka中并不保证消息全局有序，只能保证<strong>分区有序</strong>。</p><ul><li>生产者：使用同步方式发送，设置<code>acks = all &amp;  max.in.flight.requests.per.connection = 1</code>，存在下面的问题：<ul><li>重发问题：发送失败，需要判断是否自动重试，设置<code>retries &gt; 0</code></li><li>幂等问题：设置<code>enable.idempotence = true</code>，设置后生产者客户端会给消息添加序列号，每次发送把序列号递增1</li></ul></li><li>服务端Broder：Kafka只能保证单个Partition内消息有序，若要Topic全局有序，需要设置单分区。</li><li>消费者：根据Group机制，Topic下的分区只能从属group下的某一个消费者，若Consumer单线程消费没有问题，多线程并发消费顺序会乱。</li></ul><h3 id="如何处理Kafka大量消息积压"><a href="#如何处理Kafka大量消息积压" class="headerlink" title="如何处理Kafka大量消息积压"></a>如何处理Kafka大量消息积压</h3><p>出现消息积压的原因：Kafka集群中出现了<strong>性能问题</strong>，来不及消费消息。</p><p>解决：</p><ul><li><p>生产端性能优化</p><ul><li>检查发送消息的业务逻辑，合理设置并发数量和批量大小，注意消息体大小。</li><li>可以动态配置开关，关闭MQ生产，并在解决积压问题后，通过<strong>消息补偿机制</strong>进行补偿，<strong>消费端需要支持幂等</strong>。</li></ul></li><li><p>消费端性能优化</p><ul><li>自动提交改为手动提交</li><li>单条消息消费改为批量消费</li><li>涉及DB操作，一定要检查是否存在慢SQL</li><li>一定要保证消费端速度大于生产端的生产速度，扩容消费端实例来提升总体的消费能力。要注意在扩大Consumer实例的同时，必须扩容Topic的Partition数量，确保两者数量大致相等。</li></ul></li><li><p>查看Broker端日志、监控系统等情况，是否存在硬件层面的问题：磁盘空间等。</p><ul><li>partition分区数 &gt; 应用消费节点时，可以扩大Broker分区数量，否则扩broker分区没用。</li></ul></li></ul><h3 id="Kafka性能瓶颈"><a href="#Kafka性能瓶颈" class="headerlink" title="Kafka性能瓶颈"></a>Kafka性能瓶颈</h3><p>常见问题：</p><ol><li>Kafka单机topic超过64个分区<ul><li>load负载加大</li><li>消息延迟加大</li></ul></li><li>一个分区一个文件</li><li>单个文件按照append写是顺序IO</li><li>分区多文件多，局部的顺序IO会退化到随机IO</li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习笔记(三)-通信协议</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><p>需要进行网络传输的中间件都会拥有自己的一套通信协议，这往往会成为该组件的性能瓶颈，需要考虑的优化点较多。Kafka自定义了基于TCP的二进制通信协议，Kafka2.0中，一共有43种协议类型，每个都有对应的请求和响应，与HTTP协议类似，它同样有<code>RequestHeader</code>和<code>RequestBody</code>。其中<code>RequestHeader</code>结构如下：</p><ul><li>api_key：API标识，例如PRODUCE、FETCH等，用于分别请求的作用。</li><li>api_version：API版本号</li><li>correlation_id：客户端指定的唯一标识，服务端返回响应需要将该字段返回以此对应。</li><li>client_id：客户端id</li></ul><p>Kafka除了提供基本数据类型，还提供了以下的特有类型：</p><ul><li>nullable_string：可为空的字符串类型，若为空用-1表示</li><li>bytes：表示字节序列，开头是数据长度N（int32表示），后面是N个字节</li><li>nullable_bytes：与上述string相同</li><li>records：表示Kafka中的消息序列</li><li>array：表示一个给定类型T的数组</li></ul><p><code>RequestBody</code>结构如下：</p><ul><li>transactional_id：事务id，不使用事务，此项为null</li><li>acks：对应客户端的acks参数</li><li>timeout：超时时间</li><li>topic_data：要发送的数据集合，array类型<ul><li>topic：主题</li><li>data：数据，array类型<ul><li>partition：分区编号</li><li>record_set：数据</li></ul></li></ul></li></ul><p><code>Response</code>结构如下：</p><ul><li>ResponseHeader<ul><li>correlation_id：与请求相对应</li></ul></li><li>ResponseBody<ul><li>responses：array类型，返回的响应结果<ul><li>topic：主题</li><li>partition_responses：返回结果，array类型<ul><li>partition：分区编号</li><li>error_code：错误码，用来标识错误类型</li><li>base_offset：消息集的起始偏移量</li><li>log_append_time：消息写入broker的时间</li><li>log_start_offset：所在分区起始偏移量</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分析Linux中的Zero-Copy技术</title>
    <link href="/2022/Linux/%E5%88%86%E6%9E%90Zero-Copy%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/Linux/%E5%88%86%E6%9E%90Zero-Copy%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="传统IO的流程"><a href="#传统IO的流程" class="headerlink" title="传统IO的流程"></a>传统IO的流程</h2><p>零拷贝技术是对传统IO的性能优化，在介绍零拷贝之前，先简单了解一下传统IO中，数据流向的过程：</p><ol><li>用户进程发起<code>read()</code>调用，从用户态切换至内核态，DMA从文件中读取数据，并存储在IO Buffer（内核态）</li><li>请求得到的数据从IO Buffer拷贝到用户态Buffer（从内核态切换到用户态），然后返回给用户进程。</li><li>用户进程调用<code>write()</code>将数据输出到网卡中，此时将从用户态切换到内核态，请求数据从用户进程空间拷贝到Socket Buffer。</li><li><code>write()</code>调用结束后返回用户进程，此时从内核态切换到用户态。</li></ol><p>整个过程中涉及4次上下文切换、4次数据拷贝（2次CPU拷贝 + 2次DMA拷贝）。</p><p>我们需要对该流程进行优化，以提高IO的性能，因此诞生了零拷贝的概念。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><blockquote><p>“<strong>Zero-copy</strong>“ describes <a href="https://en.wikipedia.org/wiki/Computer">computer</a> operations in which the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> does not perform the task of copying data from one <a href="https://en.wikipedia.org/wiki/RAM">memory</a> area to another or in which unnecessary data copies are avoided. This is frequently used to save CPU cycles and memory bandwidth in many time consuming tasks, such as when transmitting a <a href="https://en.wikipedia.org/wiki/Computer_file">file</a> at high speed over a <a href="https://en.wikipedia.org/wiki/Telecommunications_network">network</a>, etc., thus improving <a href="https://en.wikipedia.org/wiki/Computer_performance">performances</a> of <a href="https://en.wikipedia.org/wiki/Computer_program">programs</a> (<a href="https://en.wikipedia.org/wiki/Process_(computing)">processes</a>) executed by a computer.</p></blockquote><p>维基百科对于零拷贝的定义为：解放CPU对数据的拷贝操作，以提高IO操作的性能。</p><h3 id="零拷贝解决的问题"><a href="#零拷贝解决的问题" class="headerlink" title="零拷贝解决的问题"></a>零拷贝解决的问题</h3><ul><li>减少了内核和用户空间的数据拷贝操作，即上下文切换的开销。</li><li>减少了内核缓冲区的数据拷贝。</li><li>用户进程直接访问硬件接口，而避免访问内核空间。</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>零拷贝是一个概念，那么则会存在多种实现方式，实现上整体可以分为以下三大类：</p><ul><li><strong>减少内核空间和用户空间之间的数据拷贝</strong><ul><li>mmap()： 将内核Buffer和用户Buffer进行映射，实现两者之间的共享，减免了之间的拷贝。</li><li>sendfile()：内核态中实现将文件发送到Socket。</li><li>sendfile() with DMA：Linux 2.4中对<code>sendfile()</code>的优化，通过DMA减少了拷贝次数。</li><li>splice()：实现了不通过内核与用户态之间的拷贝操作完成两个文件的拷贝。。</li><li>send() with MSG_ZEROCOPY：Linux 4.14中提供，用户进程能把用户空间的数据通过零拷贝的方式经过内核空间发送到Socket</li></ul></li><li><strong>允许用户态进程直接和硬件进行数据传输</strong><ul><li>用户态进程直接访问硬件：理论上最高效的技术，存在严重的安全问题，并不是最优方案。</li><li>内核控制访问硬件：比上一种方案更加安全，存在问题：DMA传输过程中，用户缓冲区内存页被锁定以保证数据一致性</li></ul></li><li><strong>IO Buffer（内核）和用户Buffer的传输优化</strong><ul><li>Copy-on-Write：多个进程共享一块数据时，读操作的进程直接访问内核空间的数据，需要执行修改操作才将数据拷贝到自己的用户空间。</li><li>Buffer Sharing：每个进程维护一个缓冲区池，这个区域能被同时映射到用户空间和内核空间，内核和用户共享这个区域，这样避免了拷贝操作。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习笔记(二)-存储架构</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka存储架构"><a href="#Kafka存储架构" class="headerlink" title="Kafka存储架构"></a>Kafka存储架构</h1><p>Kafka是为了解决大数据量的实时日志流而产生的，日志流主要特点包括：</p><ol><li>数据实时存储</li><li>海量数据存储与处理</li></ol><p>Kafka需要保证以下几点：</p><ul><li>存储的主要是消息流</li><li>要保证海量数据的高效存储</li><li>要支持海量数据的高效检索</li><li>要保证数据的安全性和稳定性</li></ul><p>Kafka使用的存储方案是：磁盘顺序写 + 稀疏哈希索引。</p><h2 id="日志目录布局"><a href="#日志目录布局" class="headerlink" title="日志目录布局"></a>日志目录布局</h2><p>Kafka中消息以Topic为单位归类，各个Topic下面分为多个分区，分区中每条消息都会被分配一个唯一的序列号（offset）。日志命名方式为：<code>&lt;topic&gt;-&lt;partition&gt;</code></p><p>在不考虑多副本的情况下，一个分区对应一个Log，为了防止Log过大，Kafka引入<code>LogSegment</code>，将Log切分为多个<code>LogSegment</code>。其结构如下所示：</p><ul><li>Log<ul><li>LogSegment：每个 LogSegment 都有一个基准偏移量 baseOffset，用来表示当前 LogSegment中第一条消息的offset。只有最后一个LogSegment才能写入。下述文件根据<code>baseOffset</code>命名，长度固定为20位数字，没有达到的位数用0填充。<ul><li>.log：日志文件</li><li>.index：偏移量索引文件</li><li>.timeindex：时间戳索引文件</li><li>.snapshot：快照索引文件</li></ul></li></ul></li></ul><h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>消息格式关系到存储性能，比如冗余字段会增加分区的存储空间、网络传输的开销较大。</p><p>Kafka3.0中将<code>BatchRecords</code>作为磁盘中的存储单元，一个<code>BatchRecords</code>中包含多个<code>Record</code>。</p><p><code>BatchRecords</code>的格式如下：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">baseOffset</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int64</span><span class="hljs-attribute">batchLength</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int32</span><span class="hljs-attribute">partitionLeaderEpoch</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int32</span><span class="hljs-attribute">magic</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int8 (current magic value is 2)</span><span class="hljs-attribute">crc</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int32</span><span class="hljs-attribute">attributes</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int16</span>    <span class="hljs-attribute">bit 0~2</span><span class="hljs-punctuation">:</span>        <span class="hljs-attribute">0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">no compression</span>        <span class="hljs-attribute">1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">gzip</span>        <span class="hljs-attribute">2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">snappy</span>        <span class="hljs-attribute">3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">lz4</span>        <span class="hljs-attribute">4</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zstd</span>    <span class="hljs-attribute">bit 3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">timestampType</span>    <span class="hljs-attribute">bit 4</span><span class="hljs-punctuation">:</span> <span class="hljs-string">isTransactional (0 means not transactional)</span>    <span class="hljs-attribute">bit 5</span><span class="hljs-punctuation">:</span> <span class="hljs-string">isControlBatch (0 means not a control batch)</span>    <span class="hljs-attribute">bit 6</span><span class="hljs-punctuation">:</span> <span class="hljs-string">hasDeleteHorizonMs (0 means baseTimestamp is not set as the delete horizon for compaction)</span>    <span class="hljs-attribute">bit 7~15</span><span class="hljs-punctuation">:</span> <span class="hljs-string">unused</span><span class="hljs-attribute">lastOffsetDelta</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int32</span><span class="hljs-attribute">baseTimestamp</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int64</span><span class="hljs-attribute">maxTimestamp</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int64</span><span class="hljs-attribute">producerId</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int64</span><span class="hljs-attribute">producerEpoch</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int16</span><span class="hljs-attribute">baseSequence</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int32</span><span class="hljs-attribute">records</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[Record]</span></code></pre></div><p>字段解释如下：</p><table><thead><tr><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">baseOffset</td><td align="center">这批消息的起始Offset</td></tr><tr><td align="center">partitionLeaderEpoch</td><td align="center">用于分区恢复时保护数据的一致性</td></tr><tr><td align="center">batchLength</td><td align="center">BatchRecords的长度</td></tr><tr><td align="center">magic</td><td align="center">魔数，可以用于拓展存储一些信息，当前3.0版本的magic是2</td></tr><tr><td align="center">crc</td><td align="center">crc校验码，包含从attributes开始到BatchRecords结束的数据的校验码</td></tr><tr><td align="center">attributes</td><td align="center">int16，其中bit0-2中包含了使用的压缩算法，bit3是timestampType，bit4表示是否失误，bit5表示是否是控制指令，bit6-15暂未使用</td></tr><tr><td align="center">lastOffsetDelta</td><td align="center">BatchRecords中最后一个Offset，是相对baseOffset的值</td></tr><tr><td align="center">firstTimestamp</td><td align="center">BatchRecords中最小的timestamp</td></tr><tr><td align="center">maxTimestamp</td><td align="center">BatchRecords中最大的timestamp</td></tr><tr><td align="center">producerId</td><td align="center">发送端的唯一ID，用于做消息的幂等处理</td></tr><tr><td align="center">producerEpoch</td><td align="center">发送端的Epoch，用于做消息的幂等处理</td></tr><tr><td align="center">baseSequence</td><td align="center">BatchRecords的序列号，用于做消息的幂等处理</td></tr><tr><td align="center">records</td><td align="center">具体的消息内容</td></tr></tbody></table><p>Record格式如下：</p><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-symbol">length:</span> varint<span class="hljs-symbol">attributes:</span> int8    bit <span class="hljs-number">0</span>~<span class="hljs-number">7</span>: unused<span class="hljs-symbol">timestampDelta:</span> varlong<span class="hljs-symbol">offsetDelta:</span> varint<span class="hljs-symbol">keyLength:</span> varint<span class="hljs-symbol">key:</span> <span class="hljs-type">byte</span>[]<span class="hljs-symbol">valueLen:</span> varint<span class="hljs-symbol">value:</span> <span class="hljs-type">byte</span>[]Headers =&gt; [Header]<span class="hljs-symbol">headerKeyLength:</span> varint<span class="hljs-symbol">headerKey:</span> <span class="hljs-type">String</span><span class="hljs-symbol">headerValueLength:</span> varint<span class="hljs-symbol">Value:</span> <span class="hljs-type">byte</span>[]</code></pre></div><p>上述使用的<code>Varint</code>编码方式，该编码起到很好的压缩效果。ProtoBuf使用的也是该编码方式。</p><h3 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h3><p>压缩算法在生产者客户端进行配置，通过<code>compression.type</code>参数选择合适的算法，主要有<code>gzip</code>, <code>lz4</code>, <code>snappy</code>,<code>zstd</code></p><h2 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h2><p>索引用来提高查找的效率，<strong>偏移量索引文件</strong>建立了offset到物理地址之间的映射关系，时间戳索引文件根据指定的时间戳来查找对应的偏移量信息。</p><p>Kafka中索引文件以<strong>稀疏索引</strong>的方式构造消息的索引，不能保证每个消息在索引文件中都有对应的索引项，每写入一定量的消息（由broker端的<code>log.index.interval.bytes</code>指定）时，两个索引文件分别增加一个偏移量索引项和时间戳索引项。</p><p>稀疏索引通过<code>MappedByteBuffer</code>将索引文件映射到内存中，以加快索引的查询速度。两个索引文件中索引项根据偏移量和时间戳单调递增的，可以使用<strong>二分查找</strong>快速定位到。</p><p>日志分段策略由以下配置决定（满足其一即可）：</p><ul><li>broker的<code>log.segment.bytes </code>：当前LogSegment大小超过该值，默认1GB</li><li>当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于 <code>log.roll.ms</code>或<code>log.roll.hours</code>参数配置的值。</li><li>偏移量索引文件或时间戳索引文件的大小达到broker端参数<code>log.index.size.max.bytes</code>配置的值。默认为10MB</li><li>追加的消息的偏移量与当前日志分段的偏移量之间的差值大于<code>Integer.MAX_VALUE</code></li></ul><h3 id="偏移量索引项"><a href="#偏移量索引项" class="headerlink" title="偏移量索引项"></a>偏移量索引项</h3><p>每个索引项占用8个字节，分为以下两个部分：</p><ul><li>relativeOffset：相对偏移量，消息相对于<code>baseOffset</code>的偏移量，占用4个字节</li><li>position：物理地址，消息在日志分段文件中的物理位置，占用4个字节。</li></ul><p>Kafka要求索引文件大小必须是索引项的整数倍。</p><h3 id="时间戳索引项"><a href="#时间戳索引项" class="headerlink" title="时间戳索引项"></a>时间戳索引项</h3><p>时间戳索引项占用12字节，分为以下两个部分：</p><ul><li>timestamp：当前日志分段最大的时间戳<ul><li>追加的索引项该字段必须大于前面的时间戳，保持单调递增属性</li></ul></li><li>relativeOffset：时间戳对应的相对偏移量</li></ul><h2 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h2><p>Kafka将消息存储在磁盘上，为了控制占用空间的不断增加，需要对消息做一定的清理操作。提供了两种日志清理策略：</p><ul><li>日志删除：按照一定的保留策略直接删除不符合条件的日志分段。</li><li>日志压缩：对相同key进行整合，保留最新版本的value。</li></ul><p>通过broker端参数<code>log.cleanup.policy</code>来设置日志清理策略，默认采用<code>delete</code>策略，日志清理的粒度可以控制到主题级别</p><h3 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h3><p>日志管理器中会有一个日志删除任务来周期性检测并删除不符合保留条件的日志分段文件，周期通过<code>log.retention.check.interval.ms</code>来配置，默认五分钟，保留策略如下：</p><ul><li>基于时间的保留策略：删除日志文件中超过设定阈值的日志分段</li><li>基于日志大小的保留策略：删除超过阈值的日志分段</li><li>基于日志起始偏移量的保留策略：某日志分段的下一个日志分段的起始偏移量baseOffset 是否小于等于logStartOffset，若是，则可以删除此日志分段。</li></ul><h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p><code>Log Compaction</code>前后，分段中每条消息的偏移量和写入时偏移量保持一致，日志中每条消息的物理位置会改变，类似Redis的RDB过程</p><h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><p><strong>磁盘顺序写速度比磁盘随机写快，比内存随机写快</strong>。</p><p>Kafka采用append的方式写入消息，并且不允许修改写入的消息，这种方式属于<strong>磁盘顺序写</strong>。</p><h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h3><p><code>Page Cache</code>是OS实现的一种主要的磁盘缓存，以此减少对磁盘IO的操作。具体流程：将磁盘数据缓存到内存，将对磁盘的访问转为对内存的访问，极大提高访问效率。</p><p>当进程访问磁盘时，会首先查看数据所在的页是否在<code>page cache</code>中，没有命中，则向磁盘发起读取请求并将数据存入缓存。</p><p>Kafka中大量使用了页缓存，这是Kafka实现高吞吐的重要因素之一，虽然刷盘由OS控制，Kafka同样提供了<code>fsync</code>强制刷盘来保证数据可靠性。</p><h3 id="磁盘IO流程"><a href="#磁盘IO流程" class="headerlink" title="磁盘IO流程"></a>磁盘IO流程</h3><p>磁盘IO的场景从编程角度分为以下几种：</p><ul><li>调用C标准库，数据流向：进程buffer-&gt;C 标准IO库 buffer-&gt;page cache-&gt;磁盘上的具体文件</li><li>调用文件IO，数据流向：进程buffer-&gt;page cache -&gt;磁盘</li><li>打开文件使用<code>O_DIRECT</code>，直接读磁盘</li></ul><p>磁盘IO流程如下：</p><ul><li><strong>写操作</strong>：调用<code>fwrite</code>把数据写入 IO Buffer（会存在将多个请求打包在一个buffer）。调用<code>write</code>将数据写入页缓存，此时不会主动刷盘，存在<code>pdflush</code>线程不断检测脏页，并判断是否写回磁盘。</li><li><strong>读操作</strong>：调用<code>fread</code>去IO Buffer中读取数据，读取到成功返回，否则去页缓存读取，不存在去磁盘读。</li><li><strong>IO请求处理</strong>：通用块层将IO请求构造成多个bio结构提交给调度层，调度器将bio结构排序：<strong>尽可能将随机读写变为顺序读写</strong></li></ul><p>从上到下，逐层分别为：</p><ul><li>应用层：应用程序</li><li>内核层：虚拟文件系统 + 具体文件系统，接收应用层的内核调用，并并封装请求发送给通用块层。</li><li>通用块层：接受上层发出的磁盘请求，并调整结构传给设备层，该层隐藏了底层硬件块的特性，提供了通用视图。</li><li>设备层：磁盘</li></ul><p>Linux的IO调度策略：</p><ul><li>NOOP：FIFO队列</li><li>CFQ：按照IO请求地址进行排序</li><li>DEADLINE：在CFQ的基础上，解决了IO请求饥饿问题。</li><li>ANTICIPATORY：为每个读IO设置了6ms的等待时间窗口，如果在此期间内，收到了相邻位置的读IO请求，立即满足</li></ul><p>Kafka还采用了<strong>零拷贝</strong>技术来提升性能，直接将数据从磁盘文件复制到网卡设备，不经过应用程序的进程空间，减少了内核态和用户态的切换次数，大大提升了性能，Java的NIO采用<code>FileChannal.transferTo()</code>实现零拷贝。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小记-构建RPM包</title>
    <link href="/2022/Linux/%E5%B0%8F%E8%AE%B0-%E6%9E%84%E5%BB%BArpm%E5%8C%85/"/>
    <url>/2022/Linux/%E5%B0%8F%E8%AE%B0-%E6%9E%84%E5%BB%BArpm%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>OS环境与rpm版本号如下：</p><div class="code-wrapper"><pre><code class="hljs llvm">[root<span class="hljs-title">@localhost</span> ~]# uname -aLinux localhost.localdomain <span class="hljs-number">3.10</span>.<span class="hljs-number">0</span><span class="hljs-number">-693</span>.el<span class="hljs-number">7</span>.<span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span> <span class="hljs-variable">#1</span> SMP Tue Aug <span class="hljs-number">22</span> <span class="hljs-number">21</span>:<span class="hljs-number">09</span>:<span class="hljs-number">27</span> UTC <span class="hljs-number">2017</span> <span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span> <span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span> <span class="hljs-keyword">x</span><span class="hljs-number">86</span>_<span class="hljs-number">64</span> GNU/Linux[root<span class="hljs-title">@localhost</span> ~]# rpm --versionRPM 版本 <span class="hljs-number">4.11</span>.<span class="hljs-number">3</span></code></pre></div><p>安装rpm-build</p><div class="code-wrapper"><pre><code class="hljs mipsasm">yum <span class="hljs-keyword">install </span>-y rpm-<span class="hljs-keyword">build</span><span class="hljs-comment"># 构建的rpm的核心组件</span>yum <span class="hljs-keyword">install </span>-y rpmdevtools  <span class="hljs-comment"># 提供了构建rpm包的一些工具</span></code></pre></div><p>查看工作目录：</p><div class="code-wrapper"><pre><code class="hljs ruby">[root<span class="hljs-variable">@localhost</span> rpmbuild]<span class="hljs-comment"># rpmbuild --showrc | grep topdir</span>-<span class="hljs-number">14</span>: _builddir<span class="hljs-string">%&#123;_topdir&#125;</span>/<span class="hljs-variable constant_">BUILD</span>-<span class="hljs-number">14</span>: _buildrootdir<span class="hljs-string">%&#123;_topdir&#125;</span>/<span class="hljs-variable constant_">BUILDROOT</span>-<span class="hljs-number">14</span>: _rpmdir<span class="hljs-string">%&#123;_topdir&#125;</span>/<span class="hljs-variable constant_">RPMS</span>-<span class="hljs-number">14</span>: _sourcedir<span class="hljs-string">%&#123;_topdir&#125;</span>/<span class="hljs-variable constant_">SOURCES</span>-<span class="hljs-number">14</span>: _specdir<span class="hljs-string">%&#123;_topdir&#125;</span>/<span class="hljs-variable constant_">SPECS</span>-<span class="hljs-number">14</span>: _srcrpmdir<span class="hljs-string">%&#123;_topdir&#125;</span>/<span class="hljs-variable constant_">SRPMS</span>-<span class="hljs-number">14</span>: _topdir<span class="hljs-string">%&#123;getenv:HOME&#125;</span>/rpmbuild</code></pre></div><p>工作目录位于<code>$HOME/rpmbuild</code>，在该目录下创建以下文件夹、或直接使用<code>rpmdev-setuptree</code>生成目录：</p><div class="code-wrapper"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> rpmbuild]<span class="hljs-meta"># mkdir -pv /root/rpmbuild/&#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125;</span></code></pre></div><p>目录的各个用途如下：</p><ul><li><code>BUILD</code>：目录用来存放打包过程中的源文件，就是来源于 <code>SOURCE</code></li><li><code>BUILDROOT</code>：编译后存放的目录</li><li><code>SOURCE</code> ：用来存放打包是要用到的源文件和 patch补丁，主要是一些 <code>tar</code> 包</li><li><code>SPECS</code>：用来存放 spec 文件，spec是构建RPM包的配置文件</li><li><code>RPMS</code>：存放打包生成的rpm二进制包</li><li><code>SRPMS</code>：存放打包生成的源码RPM包</li></ul><h2 id="SPEC"><a href="#SPEC" class="headerlink" title="SPEC"></a>SPEC</h2><p>spec文件是构建RPM包的核心文件，内部包含了软件包的名称、版本、编译指令、安装指令、卸载指令、依赖文件等。</p><p>可以使用<code>rpmdev-newspec -o name.spec</code>来生成SPEC模板文件。</p><h3 id="软件包信息"><a href="#软件包信息" class="headerlink" title="软件包信息"></a>软件包信息</h3><p>该部分包含了如下信息，可通过<code>%&#123;value&#125;</code>在后续进行引用：</p><ul><li>Name：软件包名称</li><li>Version：软件版本</li><li>Summary：概述</li><li>Group：软件分组，通过<code>cat /usr/share/doc/rpm-VERSION/GROUPS</code>查看详细分组</li><li>Source0、Source1等：源码包位置，位于<code>%_topdir/SOURCE</code>文件夹下。</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>BuildRequires：定义构建时需要的软件包，逗号分隔，例如<code>gcc &gt;=4.2.2</code></li><li>Requires：安装时的依赖包。格式如下：<ul><li><code>Requires:       xx_package &gt;= %&#123;version&#125;</code></li></ul></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li>BuildRoot：定义了<code>make install</code>的测试安装目录，默认指定为<code>%_topdir/BUILDROOT</code></li><li>BuildArch：编译时处理器架构，默认从<code>cat /usr/lib/rpm/macros</code>读取</li></ul><h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>该阶段包含对rpm包的描述，可以通过<code>rpm -qpi</code>读取。</p><div class="code-wrapper"><pre><code class="hljs yaml">[<span class="hljs-string">root@localhost</span> <span class="hljs-string">rpmbuild</span>]<span class="hljs-comment"># rpm -qpi RPMS/x86_64/bda-monitor-3.0.0-1.x86_64.rpm </span><span class="hljs-attr">Name        :</span> <span class="hljs-string">bda-monitor</span><span class="hljs-attr">Version     :</span> <span class="hljs-number">3.0</span><span class="hljs-number">.0</span><span class="hljs-attr">Release     :</span> <span class="hljs-number">1</span><span class="hljs-attr">Architecture:</span> <span class="hljs-string">x86_64</span><span class="hljs-attr">Install Date:</span> <span class="hljs-string">(not</span> <span class="hljs-string">installed)</span><span class="hljs-attr">Group       :</span> <span class="hljs-string">Applications/Server</span><span class="hljs-attr">Size        :</span> <span class="hljs-number">644017273</span><span class="hljs-attr">License     :</span> <span class="hljs-string">Commercial</span> <span class="hljs-string">License</span><span class="hljs-attr">Signature   :</span> <span class="hljs-string">(none)</span><span class="hljs-attr">Source RPM  :</span> <span class="hljs-string">bda-monitor-3.0.0-1.src.rpm</span><span class="hljs-attr">Build Date  :</span> <span class="hljs-number">2022</span><span class="hljs-string">年06月21日</span> <span class="hljs-string">星期二</span> <span class="hljs-number">03</span><span class="hljs-string">时34分39秒</span><span class="hljs-attr">Build Host  :</span> <span class="hljs-string">localhost</span><span class="hljs-attr">Relocations :</span> <span class="hljs-string">/opt/bda-monitor</span> <span class="hljs-attr">Summary     :</span> <span class="hljs-string">业务处置平台-监控模块</span><span class="hljs-attr">Description :</span></code></pre></div><h3 id="prep"><a href="#prep" class="headerlink" title="prep"></a>prep</h3><p>预处理阶段，该部分填写准备阶段的shell脚本，可以清空指定文件夹，对源码包进行解压等操作。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs bash">%prep<span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$RPM_BUILD_DIR</span>/openssl-1.1.1ntar fx <span class="hljs-variable">$RPM_SOURCE_DIR</span>/openssl-1.1.1n.tar.gz</code></pre></div><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>该阶段主要对<code>%_builddir</code>目录下的源码包执行<code>./configure</code>和<code>make</code>。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs livescript">cd $RPM_BUILD_DIR/nginx-<span class="hljs-number">1.20</span>.<span class="hljs-number">1</span>./configure <span class="hljs-string">\</span>--prefix=%&#123;prefix&#125;/nginx <span class="hljs-string">\</span>--<span class="hljs-keyword">with</span>-http_ssl_module <span class="hljs-string">\</span>--<span class="hljs-keyword">with</span>-openssl=$RPM_BUILD_DIR/openssl-<span class="hljs-number">1.1</span>.<span class="hljs-number">1n</span> <span class="hljs-string">\</span>--<span class="hljs-keyword">with</span>-http_gzip_static_module <span class="hljs-string">\</span>--<span class="hljs-keyword">with</span>-http_auth_request_module <span class="hljs-string">\</span>--<span class="hljs-keyword">with</span>-http_stub_status_modulemake %&#123;?_smp_mflags&#125;</code></pre></div><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p>该部分就是执行<code>make install</code>的操作，将编译好的二进制文件安装到虚拟目录中（或者直接将二进制文件install），这个阶段会在<code>%buildrootdir</code> 目录里建好目录，然后将需要打包的文件从 <code>%builddir</code> 里拷贝到 <code>%_buildrootdir</code> 里。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># prometheus</span>%ifarch x86_64<span class="hljs-built_in">cp</span> -pR prometheus/x86_64/* %&#123;buildroot&#125;%&#123;prefix&#125;/prometheus/%<span class="hljs-keyword">else</span><span class="hljs-built_in">cp</span> -pR prometheus/aarch64/* %&#123;buildroot&#125;%&#123;prefix&#125;/prometheus/%endif<span class="hljs-comment"># grafana</span>%ifarch x86_64<span class="hljs-built_in">cp</span> -pR grafana/x86_64/* %&#123;buildroot&#125;%&#123;prefix&#125;/grafana/%<span class="hljs-keyword">else</span><span class="hljs-built_in">cp</span> -pR grafana/aarch64/* %&#123;buildroot&#125;%&#123;prefix&#125;/grafana/%endif</code></pre></div><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>文件段，用来说明<code>%&#123;buildroot&#125;</code>目录下的哪些文件目录最终打包到rpm包中。</p><div class="code-wrapper"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">defattr</span>(文件权限,用户名,组名,目录权限)</span> # 设置文件权限<span class="hljs-tag">%<span class="hljs-selector-tag">config</span>(noreplace)</span> /etc/my.cnf         # 表明是配置文件，noplace表示替换文件<span class="hljs-tag">%<span class="hljs-selector-tag">attr</span>(644, root, root)</span> %&#123;_mandir&#125;/man8/mysqld.8* # 分别是权限，属主，属组</code></pre></div><h3 id="其他阶段"><a href="#其他阶段" class="headerlink" title="其他阶段"></a>其他阶段</h3><ul><li>pre：安装前执行的阶段</li><li>post：安装后执行的阶段</li><li>preun：卸载前执行的阶段</li><li>postun：卸载后执行的阶段</li><li>changelog：日志段</li><li>clean：打包后的清理段，主要对<code>%&#123;buildroot&#125;</code>进行清空</li></ul><h2 id="spec模板"><a href="#spec模板" class="headerlink" title="spec模板"></a>spec模板</h2><div class="code-wrapper"><pre><code class="hljs perl"><span class="hljs-comment"># 软件包的基本信息</span>Name:           bda-monitorVersion:        <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>Release:        <span class="hljs-number">1</span>Summary:        业务处置平台-监控模块License:        Commercial LicenseGroup: Applications/Server<span class="hljs-comment"># 将要安装的目录位置</span>prefix: <span class="hljs-regexp">/opt/</span>bda-monitor<span class="hljs-comment"># 描述信息</span><span class="hljs-variable">%description</span><span class="hljs-comment"># 准备部分</span><span class="hljs-variable">%prep</span><span class="hljs-comment"># 安装前执行</span><span class="hljs-variable">%pre</span>echo -e <span class="hljs-string">&#x27;开始安装业务处置平台-监控模块&#x27;</span><span class="hljs-comment"># 编译 </span><span class="hljs-variable">%build</span><span class="hljs-comment"># 安装</span><span class="hljs-variable">%install</span>cd <span class="hljs-variable">$RPM_BUILD_DIR</span><span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/mysqld_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/redis_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/blackbox_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/elasticsearch_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/kafka_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/node_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/postgres_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/rabbitmq_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/zookeeper_exporter<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/grafana<span class="hljs-keyword">mkdir</span> -p %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/prometheus<span class="hljs-comment"># mysqld_exporter</span><span class="hljs-comment"># ifarch 判断指令集，安装相应指令集的source</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR mysqld_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/mysqld_exporter/<span class="hljs-variable">%else</span>cp -pR mysqld_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/mysqld_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># redis_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR redis_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/redis_exporter/<span class="hljs-variable">%else</span>cp -pR redis_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/redis_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># blackbox_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR blackbox_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/blackbox_exporter/<span class="hljs-variable">%else</span>cp -pR blackbox_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/blackbox_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># elasticsearch_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR elasticsearch_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/elasticsearch_exporter/<span class="hljs-variable">%else</span>cp -pR elasticsearch_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/elasticsearch_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># kafka_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR kafka_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/kafka_exporter/<span class="hljs-variable">%else</span>cp -pR kafka_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/kafka_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># node_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR node_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/node_exporter/<span class="hljs-variable">%else</span>cp -pR node_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/node_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># postgres_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR postgres_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/postgres_exporter/<span class="hljs-variable">%else</span>cp -pR postgres_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/postgres_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># rabbitmq_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR rabbitmq_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/rabbitmq_exporter/<span class="hljs-variable">%else</span>cp -pR rabbitmq_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/rabbitmq_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># zookeeper_exporter</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR zookeeper_exporter/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/zookeeper_exporter/<span class="hljs-variable">%else</span>cp -pR zookeeper_exporter/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/zookeeper_exporter/<span class="hljs-variable">%endif</span><span class="hljs-comment"># prometheus</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR prometheus/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/prometheus/<span class="hljs-variable">%else</span>cp -pR prometheus/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/prometheus/<span class="hljs-variable">%endif</span><span class="hljs-comment"># grafana</span><span class="hljs-variable">%ifarch</span> x86_64cp -pR grafana/x86_64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/grafana/<span class="hljs-variable">%else</span>cp -pR grafana/aarch64/* %<span class="hljs-string">&#123;buildroot&#125;<span class="hljs-variable">%&#123;prefix&#125;</span></span>/grafana/<span class="hljs-variable">%endif</span><span class="hljs-comment"># 安装后执行、运行系统命令、重启服务等初始化行为</span><span class="hljs-variable">%post</span><span class="hljs-comment"># 卸载完成后执行的脚本</span><span class="hljs-variable">%postun</span>rm -rf <span class="hljs-variable">%&#123;prefix&#125;</span><span class="hljs-comment"># 清理阶段，构建完成rpm包后，可以删除build过程的中间文件</span><span class="hljs-variable">%clean</span>rm -rf <span class="hljs-variable">%&#123;buildroot&#125;</span><span class="hljs-comment"># 此部分定义了要安装的文件以及在目录树中的位置</span><span class="hljs-variable">%files</span><span class="hljs-variable">%&#123;prefix&#125;</span><span class="hljs-variable">%changelog</span><span class="hljs-comment"># 1. 创建监控模块所需各类exporter + Prometheus + Grafana</span></code></pre></div><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>当SPEC文件编写完成后，并且<code>SOURCES</code>目录下的源码包或<code>BUILD</code>目录下的二进制文件准备好，执行如下的打包指令：</p><div class="code-wrapper"><pre><code class="hljs crmsh">rpmbuild --<span class="hljs-attr">target=</span>x86_64 -bb SPECS/bda-<span class="hljs-literal">monitor</span>.<span class="hljs-keyword">spec</span></code></pre></div><p>参数说明如下：</p><div class="code-wrapper"><pre><code class="hljs perl">-bp 执行 spec 文件的<span class="hljs-string">&quot;<span class="hljs-variable">%prep</span>&quot;</span>阶段。这通常等价于解包源代码并应用补丁。-bc 执行 spec 文件的<span class="hljs-string">&quot;<span class="hljs-variable">%build</span>&quot;</span>阶段(在执行了 <span class="hljs-variable">%prep</span> 之后)。这通常等价于执行了<span class="hljs-string">&quot;make&quot;</span>。-bi 执行 spec 文件的<span class="hljs-string">&quot;<span class="hljs-variable">%install</span>&quot;</span>阶段(在执行了 <span class="hljs-variable">%prep</span>, <span class="hljs-variable">%build</span> 之后)。这通常等价于执行了<span class="hljs-string">&quot;make install&quot;</span>。-bb 构建二进制包(在执行 <span class="hljs-variable">%prep</span>, <span class="hljs-variable">%build</span>, <span class="hljs-variable">%install</span> 之后)-bs 只构建源代码包-ba 构建二进制包和源代码包(在执行 <span class="hljs-variable">%prep</span>, <span class="hljs-variable">%build</span>, <span class="hljs-variable">%install</span> 之后)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Prometheus + Grafana 构建监控可视化系统</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Prometheus/%E4%BD%BF%E7%94%A8Prometheus%20+%20Grafana%20%E6%9E%84%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Prometheus/%E4%BD%BF%E7%94%A8Prometheus%20+%20Grafana%20%E6%9E%84%E5%BB%BA%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="监控系统简介"><a href="#监控系统简介" class="headerlink" title="监控系统简介"></a>监控系统简介</h1><p>业务监控系统通常包含以下一些组件：</p><ul><li><strong>采集</strong>：信息源来自log、metrics等。<ul><li>可以通过定期外围探测、AOP手动织入、字节码自动织入</li></ul></li><li><strong>上报</strong>：通过http或者tcp</li><li>聚合</li><li>存储</li><li>可视化、告警</li></ul><p>业务监控系统解决了什么问题？</p><ul><li><p>趋势分析：收集长期监控数据，对监控指标进行趋势分析，例如：分析磁盘空间增长率，预测何时进行磁盘扩容。</p></li><li><p>对照分析：分析不同版本在运行时资源使用情况差异。</p></li><li><p>告警：当服务出现故障时，监控可以迅速反应并告警。</p></li><li><p>故障分析与定位：故障发生时，可以通过分析历史数据去定位问题。</p></li><li><p>数据可视化：通过采集的数据，生成可视化仪表盘。</p></li><li><p>对于运维：监控CPU、内存、硬盘等使用情况。</p></li><li><p>对于研发：监控某个异常指标的变化情况，来保证业务的稳定性。</p></li><li><p>对于产品或运营：关注产品层面：某个活动参加人数的增长情况等</p></li></ul><p>监控系统分为以下五层：</p><ul><li>端监控：对网站、APP、小程序等进行端监控，采集页面打开速度、稳定性、外部服务调用成功率等参数。</li><li>业务层监控：对业务模块进行监控，采集QPS、DAU、业务接口访问数量等。</li><li>应用层监控：对分布式应用进行管理和监控</li><li>中间件监控：对中间件进行监控，主要判断组件是否存活。</li><li>系统层监控：对操作系统监控，主要包括：CPU、磁盘I&#x2F;O、网络连接等参数。</li></ul><h1 id="Prometheus简介"><a href="#Prometheus简介" class="headerlink" title="Prometheus简介"></a>Prometheus简介</h1><p>当前监控系统主要有集中式日志解决方案（ELK）和时序数据库解决方案。监控三要素如下：</p><ul><li>Metrics：可聚合，带有时间戳的数据。</li><li>Logging：离散日志，分为有结构和无结构。</li><li>Tracing：请求域内的调用链。</li></ul><h2 id="Prometheus架构"><a href="#Prometheus架构" class="headerlink" title="Prometheus架构"></a>Prometheus架构</h2><p>Prometheus的架构图如下所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/prometheus/Prometheus-framework.png"></p><p>其中各组件功能如下：</p><ul><li>Prometheus Server：核心部分，负责实现对监控数据的获取，存储以及查询。<ul><li>Retrieval：定时去配置文件中指定target抓取指标数据。（Pull）</li><li>TSDB：Prometheus内置了时序数据库，存储抓取的指标数据。</li><li>HTTP Server：提供了HTTP接口进行操作。</li></ul></li><li>Jobs&#x2F;exporters：exporter将监控数据通过HTTP服务的形式暴露给Prometheus Server，其定时进行Pull。</li><li>Pushgateway：临时性的Job可以将监控数据push到这，Prometheus从Pushgateway拉取数据。</li><li>AlertManager：告警处理中心。Prometheus支持基于PromQL创建告警规则。</li><li>Data Visualization：数据可视化，其中Prometheus自带的web UI可以通过PromQL进行查询，通过Grafana可以展示丰富的图表数据。</li></ul><p>从上述组件可以看出：Prometheus提供了<strong>收集数据-&gt;存储数据-&gt;处理数据-&gt;展示数据</strong>这一系列功能，完全适用上述的应用场景。</p><h2 id="获取监控数据的两种方式"><a href="#获取监控数据的两种方式" class="headerlink" title="获取监控数据的两种方式"></a>获取监控数据的两种方式</h2><ul><li>Pull：从监控的target通过轮询获取监控信息。主要是HTTP API。<ul><li>告警可以按照策略分片，可以做到数据的冷热分离。</li></ul></li></ul><p>主要流程如下：</p><ol><li>Prometheus根据配置定期去targets拉取数据。</li><li>当拉取数据大于配置的内存缓冲区时，Prometheus会将数据持久化到磁盘或云端。</li><li>Prometheus通过PromQL、API等方式获取数据，同时可以配置rules，当触发条件时，将alert推送到配置的alertmanager。</li><li>alertmanager收到告警时，会执行相应的策略。</li></ol><ul><li>Push：程序主动将数据推送到监控系统中，Prometheus采用gateway实现该方式。<ul><li>实时性好</li><li>由于推送时机的不可预知性，监控系统无法掌握主动性，可能会导致对监控进程产生影响。</li><li>增加gateway组件，增加了系统的复杂度。</li></ul></li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p><ul><li>Golang编写，支持云原生，二进制文件直接启动，也支持容器化部署。</li><li>支持多种语言的客户端。</li><li>支持本地存储和云端存储，单机性能强。</li><li>可扩展，使用联邦集群启动多个Prometheus实例来分布式处理。</li><li>支持静态文件配置和动态发现等机制。</li></ul><p>缺点：</p><ul><li>不适用Logging、Tracing等监控。</li><li>Prometheus数据默认保留15天，适用于追踪近期数据。</li><li>本地存储有限，需要考虑第三方存储。</li><li>联邦集群没有提供统一的全局视图。</li></ul><h1 id="Grafana简介"><a href="#Grafana简介" class="headerlink" title="Grafana简介"></a>Grafana简介</h1><p>Grafana是一个可以通过各种图形方式对数据进行可视化的一个开源软件，官网简介如下：</p><blockquote><p>Query, visualize, alert on, and understand your data no matter where it’s stored. With Grafana you can create, explore and share all of your data through beautiful, flexible dashboards.</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="安装Prometheus-Server"><a href="#安装Prometheus-Server" class="headerlink" title="安装Prometheus Server"></a>安装Prometheus Server</h2><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/opt</span>wget https:<span class="hljs-string">//github.com/prometheus/prometheus/releases/download/v2.36.1/prometheus-2.36.1.linux-amd64.tar.gz</span><span class="hljs-comment"># 解压后进入目录，运行时指定配置文件和data路径</span><span class="hljs-string">./prometheus</span> <span class="hljs-params">--config</span>.file=prometheus.yml <span class="hljs-params">--storage</span>.tsdb.path=<span class="hljs-string">/data/prometheus</span></code></pre></div><p>运行成功后，浏览器访问<code>http://localhost:9090</code>可以看到Prometheus自带的Web UI。可以在此界面通过PormQL查询数据。</p><p>注意：在配置<code>prometheus.yml</code>的过程中，可能会出错，可以通过下面的指令检查配置文件的正确性。</p><blockquote><p>.&#x2F;promtool check config prometheus.yml</p></blockquote><h3 id="配置web认证"><a href="#配置web认证" class="headerlink" title="配置web认证"></a>配置web认证</h3><p>安装<code>bcrypt</code>：<code>apt install python3-bcrypt</code>，创建<code>gen-pass.py</code>，文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs stylus">import getpassimport bcryptpassword = getpass<span class="hljs-selector-class">.getpass</span>(<span class="hljs-string">&quot;password: &quot;</span>)hashed_password = bcrypt<span class="hljs-selector-class">.hashpw</span>(password<span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&quot;utf-8&quot;</span>), bcrypt<span class="hljs-selector-class">.gensalt</span>())<span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(hashed_password.decode()</span></span>)</code></pre></div><p>执行<code>python3 gen-pass.py</code>生成加密的password，创建<code>web.yml</code>并填入下述配置。</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">basic_auth_users:</span><span class="hljs-symbol">    admin:</span> xxx</code></pre></div><p>可以使用<code>./promtool check web-config web.yml</code>对其进行验证。</p><p>最后，在运行时，指定web.yml即可。</p><div class="code-wrapper"><pre><code class="hljs routeros">./prometheus --config.<span class="hljs-attribute">file</span>=prometheus.yml --storage.tsdb.<span class="hljs-attribute">path</span>=/data/prometheus --web.config.<span class="hljs-attribute">file</span>=web.yml</code></pre></div><h2 id="安装Node-Exporter"><a href="#安装Node-Exporter" class="headerlink" title="安装Node Exporter"></a>安装Node Exporter</h2><p>Exporter主要是采集数据的组件，Node Exporter是Prometheus官方提供用于采集主机运行指标，例如CPU、内存、硬盘等信息。</p><div class="code-wrapper"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/prometheus/</span>node_exporter<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v1.3.1/</span>node_exporter-<span class="hljs-number">1.3</span>.<span class="hljs-number">1</span>.linux-amd64.tar.gz<span class="hljs-comment"># 解压后进入文件夹</span>./node_exporter</code></pre></div><p>运行成功后，访问<code>http://47.102.201.28:9100/metrics</code>可以看到监控信息。</p><p>返回Prometheus，在<code>prometheus.yml</code>中加入如下配置，相当于将node exporter监控数据纳入Prometheus定时抓取任务中。</p><div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-punctuation">-</span> job_name<span class="hljs-punctuation">:</span> &#x27;node&#x27;  static_configs<span class="hljs-punctuation">:</span>    <span class="hljs-punctuation">-</span> targets<span class="hljs-punctuation">:</span> [&#x27;localhost:<span class="hljs-number">9100</span>&#x27;]</code></pre></div><p>上面的metrics会符合一定的格式，可以通过<code>curl -s http://localhost:9090/metrics | promtool check metrics</code>来对metrics进行检查，<strong>这对于自定义Exporter时，检查报错十分有用。</strong></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># HELP node_filesystem_size_bytes Filesystem size in bytes.</span><span class="hljs-comment"># TYPE node_filesystem_size_bytes gauge</span><span class="hljs-attribute">node_filesystem_size_bytes</span>&#123;device=<span class="hljs-string">&quot;/dev/vda1&quot;</span>,fstype=<span class="hljs-string">&quot;ext4&quot;</span>,mountpoint=<span class="hljs-string">&quot;/&quot;</span>&#125; <span class="hljs-number">4</span>.<span class="hljs-number">2140479488</span>e+<span class="hljs-number">10</span><span class="hljs-attribute">node_filesystem_size_bytes</span>&#123;device=<span class="hljs-string">&quot;tmpfs&quot;</span>,fstype=<span class="hljs-string">&quot;tmpfs&quot;</span>,mountpoint=<span class="hljs-string">&quot;/run&quot;</span>&#125; <span class="hljs-number">2</span>.<span class="hljs-number">07937536</span>e+<span class="hljs-number">08</span><span class="hljs-attribute">node_filesystem_size_bytes</span>&#123;device=<span class="hljs-string">&quot;tmpfs&quot;</span>,fstype=<span class="hljs-string">&quot;tmpfs&quot;</span>,mountpoint=<span class="hljs-string">&quot;/run/lock&quot;</span>&#125; <span class="hljs-number">5</span>.<span class="hljs-number">24288</span>e+<span class="hljs-number">06</span><span class="hljs-attribute">node_filesystem_size_bytes</span>&#123;device=<span class="hljs-string">&quot;tmpfs&quot;</span>,fstype=<span class="hljs-string">&quot;tmpfs&quot;</span>,mountpoint=<span class="hljs-string">&quot;/run/user/0&quot;</span>&#125; <span class="hljs-number">2</span>.<span class="hljs-number">0793344</span>e+<span class="hljs-number">08</span><span class="hljs-comment"># HELP node_forks_total Total number of forks.</span><span class="hljs-comment"># TYPE node_forks_total counter</span><span class="hljs-attribute">node_forks_total</span> <span class="hljs-number">279283</span></code></pre></div><p>上面是一段metrics数据，下面简单解释一下：</p><ul><li><p>HELP：解释当前指标的含义</p></li><li><p>TYPE：说明当前指标的数据类型。分别有以下几种类型（后续详细介绍）</p></li><li><p>node_filesystem_size_bytes：指标名称。</p></li><li><p>大括号内部为<strong>label</strong>，负责对指标做进一步说明。</p></li></ul><h2 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h2><ul><li>DashBoard：看板，其中包含多个panel。</li><li>Panel：图表，每个图表展示<ul><li>预览区：预览设置的图表。</li><li>数据设置区：设置数据源、数据指标等。<ul><li>查询：设置查询数据的数据源、指标等。</li><li>转换：对查询出来的数据进行过滤。</li><li>告警：对指标设置告警规则。</li></ul></li><li>图表设置区：设置图表等信息。</li></ul></li></ul><h1 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h1><p>Prometheus提供了AlertManager来管理告警，我在构建监控系统过程中，使用Grafana配置告警规则，Grafana中的告警，可以结合图表展示出来。</p><h2 id="添加邮件配置"><a href="#添加邮件配置" class="headerlink" title="添加邮件配置"></a>添加邮件配置</h2><p>Grafana的默认配置文件为<code>conf/default.ini</code>，在其中添加如下配置：</p><div class="code-wrapper"><pre><code class="hljs makefile">[smtp]enabled = truehost = smtp.exmail.qq.com:465user = xxx@qq.com<span class="hljs-comment"># If the password contains # or ; you have to wrap it with triple quotes. Ex &quot;&quot;&quot;#password;&quot;&quot;&quot;</span>password = xxxxcert_file =key_file =skip_verify = falsefrom_address = xxx@qq.com  //必须与上面的 user 属性一致from_name = Grafanaehlo_identity =</code></pre></div><p>配置完成后，重启Grafana。</p><p>在<code>Alerting-Notification channels</code>添加告警频道填写后可以测试发送。</p><h1 id="PormQL"><a href="#PormQL" class="headerlink" title="PormQL"></a>PormQL</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h3><p>时间序列（time series）通过<code>metrics name</code>和一组<code>label set</code>来命名的。</p><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><p>Prometheus将所有采集的数据以<strong>时间序列</strong>保存在内存中的时序数据库（TSDB）中，并定时存储到磁盘上。存储单位是：**时间序列(time-series)**，时间序列按照时间戳和值顺序排放，每条时间序列通过<code>metrics name</code>和<code>label set</code>唯一指定。</p><p>时间序列中的值称为**样本(sample)**，样本基于<code>BigTable</code>设计的格式存储，其由以下三部分组成：</p><ul><li>指标(metrics)：<code>metrics name</code>和<code>label set</code>组成。<ul><li>指标名和标签名必须符合正则<code>[a-zA-Z_:][a-zA-Z0-9_:]*</code></li></ul></li><li>时间戳(timestamp)：64bit</li><li>样本值：64bit，float64格式。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>瞬时向量：一组时间序列，每个序列包含单个样本，共享相同的时间戳。</li><li>区间向量：一组时间序列，每个事件序列包含一段时间范围内的样本数据。</li><li>标量：一个浮点型的数据值，没有时序。</li><li>字符串</li></ul><h3 id="Metrics类型"><a href="#Metrics类型" class="headerlink" title="Metrics类型"></a>Metrics类型</h3><ul><li>Counter：计数器，只增不减，例如：HTTP请求量。</li><li>Gauge：可增可减的数据，例如：空闲内存情况。</li><li>Histogram：直方图，对监控指标进行抽样，展示数据分布频率情况。</li><li>Summary：和直方图类似，区别是summary在客户端完成聚合，Histogram在服务端完成。</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>PormQL是Prometheus内置的数据查询语言，提供了对时间序列数据查询、聚合、运算等支持。</p><p>直接输入<code>metrics name</code>可以查询该指标的所有时间序列。</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">http_requests_total</span></code></pre></div><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><ul><li>&#x3D;</li><li>!&#x3D;</li><li>~&#x3D;</li></ul><p>分别是完全匹配、完全不匹配、正则匹配。</p><div class="code-wrapper"><pre><code class="hljs ocaml">http_requests_total&#123;instance=<span class="hljs-string">&quot;localhost:9090&quot;</span>&#125;http_requests_total&#123;environment=~<span class="hljs-string">&quot;development&quot;</span>,<span class="hljs-keyword">method!</span>=<span class="hljs-string">&quot;GET&quot;</span>&#125;</code></pre></div><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>上述查询的数据都被称为瞬时向量，如果查询过去一段时间范围内的数据，需要使用范围查询，使用时间范围选择器进行定义。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 查询最近五分钟的指标数据</span><span class="hljs-attribute">http_requests_total</span>&#123;&#125;[<span class="hljs-number">5</span>m]</code></pre></div><p>时间选择器支持以下的时间单位：</p><ul><li>s-秒</li><li>m-分</li><li>h-小时</li><li>d-天</li><li>w-周</li><li>y-年</li></ul><p>使用<code>offset</code>可以实现时间偏移，如下：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 查询昨天一天的数据</span><span class="hljs-attribute">http_request_total</span>&#123;&#125;[<span class="hljs-number">1</span>d] offset <span class="hljs-number">1</span>d</code></pre></div><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>支持以下运算：</p><div class="code-wrapper"><pre><code class="hljs asciidoc">数学运算：+ - * / % ^布尔运算：<span class="hljs-section">== != &gt; &lt; &gt;= &lt;=</span># bool修饰符将结果返回true or false# 判断http请求量是否超过1000http_requests_total &gt; bool 1000</code></pre></div><p>集合运算：</p><ul><li>vector1 and vector2：产生一个新向量，两者交集。</li><li>vector1 or vector2：两者并集。</li><li>vector1 unless vector2：vector1中没有vector2的元素。</li></ul><h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><p>提供了以下的聚合函数：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">sum</span>()、<span class="hljs-built_in">min</span>()、<span class="hljs-built_in">max</span>()、<span class="hljs-built_in">avg</span>()、<span class="hljs-built_in">stddev</span>(标准差)、<span class="hljs-built_in">stdvar</span>(标准方差)、<span class="hljs-built_in">count</span>()、<span class="hljs-built_in">count_values</span>(对value进行计数)、<span class="hljs-built_in">bottomk</span>(后n条时序)、<span class="hljs-built_in">topk</span>(前n条时序)、<span class="hljs-built_in">quantile</span>(分位数)</code></pre></div><p><code>without</code>用于从结果中移除指定标签，<code>by</code>则是只保留列出的标签，其他全部移除。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">sum</span>(http_requests_total) without (instance)</code></pre></div><h1 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h1><p>Exporter是Prometheus中提供监控数据的程序，每个exporter的实例被称为target，Prometheus通过轮询的方式定期从target中获取数据。</p><p>Prometheus官方提供了主流产品的Exporter程序，同时可以基于其提供的Client Library创建自己的Exporter。官方支持语言有：Go、Java、Python、Ruby。</p><h2 id="Java自定义Exporter"><a href="#Java自定义Exporter" class="headerlink" title="Java自定义Exporter"></a>Java自定义Exporter</h2><p>TODO</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>Prometheus 2.x使用字定义的存储格式将数据存储在磁盘中，两小时内的数据存储在一个block中，每个block包含该时间段内所有chunks（样本数据）、metadata（元数据）、index（索引）。</p><p>收集的样本数据首先保存在内存，使用WAL机制防止丢失数据。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Prometheus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka学习笔记(一)-基础入门</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kafka是由LinkedIn使用Scala语言开发的分布式消息引擎系统，目前已被捐献给Apache基金会，它以高吞吐量、可持久化、流数据处理等特性而被广泛使用。它主要有以下三种主要功能：</p><ul><li>消息中间件：具备常见的消息队列功能：系统解耦、冗余存储、流量削峰填谷、缓冲、异步通信，同时具备消息顺序性保障、回溯消费等功能。</li><li>数据存储系统：使用Kafka存储各种服务的log，然后统一输出，ELK可使用Kafka进行数据中转。</li><li>流数据处理平台：与flink、spark、storm等组件整合，提供实时计算。</li></ul><p>Kafka支持两种常见消息传输模型：</p><ul><li><strong>点对点模型</strong>：也称为消息队列模型，系统A发送的消息只能被系统B接收，其它系统读取不到。</li><li><strong>发布&#x2F;订阅模型</strong>：使用<code>Topic</code>接收消息，<code>Publisher</code>和<code>Subscriber</code>都可以有多个，可以同时向Topic发送接收消息。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Kafka体系结构：一个Kafka集群包括若干Producer、Customer、Broker，以及一个Zookeeper集群。<ul><li>Broker：服务端由被称为<code>Broker</code>的服务进程构成，<code>Broker</code>负责接受和处理客户端请求，以及对消息进行持久化。<ul><li>可以简单看作为一个独立的Kafka服务节点（进程示例）</li><li>Broker层面的领导者被称为Controller</li></ul></li><li>Producer：客户端节点，发送消息的一方。</li><li>Customer：客户端节点，接收消息的一方。</li><li>Customer Group：消费者组内每个消费者负责消费不同分区的数据。一个分区只能由组内一个消费者消费，不同消费组之间互不影响。</li><li><del>Zookeeper集群：负责元数据管理，集群选举。</del>目前最新版3.1.0提供了KRaft模式，集群不再依赖ZK。<ul><li>ZK主要负责存储Kafka集群的元数据，协调集群工作。</li><li>记录信息如下：<ul><li><ol><li>&#x2F;brokers&#x2F;ids&#x2F;{0-n}：记录broker服务器节点，不同的broker使用不同的brokerid，会将自己的ip地址和端口信息记录到节点</li></ol></li><li><ol start="2"><li>&#x2F;brokers&#x2F;topics&#x2F;{topic}：记录topic分区以及broker的对应信息</li></ol></li><li><ol start="3"><li>&#x2F;comsumers&#x2F;{group_id}&#x2F;ids&#x2F;{consumer_id}：消费者负载均衡</li></ol></li></ul></li></ul></li></ul></li><li>Topic：<strong>逻辑概念</strong>，Kafka中消息以topic为单位进行分类，生产者将消息发送到特定的topic，消费者订阅topic进行消费。</li></ul><h3 id="分区（partition）"><a href="#分区（partition）" class="headerlink" title="分区（partition）"></a>分区（partition）</h3><ul><li>Partition：topic可以分为多个partition，分区在物理存储层面可以看作一个可Append的Log文件，消息被Append到Log中会分配一个<code>offset</code>，这个属性是消息的唯一标识 ，<strong>Kafka通过它来保证消息在分区内的顺序性</strong>，因此Kafka<strong>保证分区有序</strong>而不是主题有序。<ul><li>主题中的partition可以分布在不同的Broker中。</li><li>消息到达broker后，根据分区规则存储到指定的partition。</li></ul></li></ul><h3 id="多副本机制（Replica）"><a href="#多副本机制（Replica）" class="headerlink" title="多副本机制（Replica）"></a>多副本机制（Replica）</h3><ul><li>多副本机制（Replica）：是对于<strong>分区</strong>而言的，<strong>同一分区的不同副本中保存的是相同的消息。</strong><ul><li>Leader：分区中的主副本，负责处理读写请求，Producer&#x2F;Consumer交互的对象。</li><li>Follower：分区中的从副本，只会实时从Leader副本同步数据。</li><li>所有副本被称为AR（Assigned Replicas），所有与Leader副本数据一致性差距过多的副本组成OSR（Out-of-Sync Replicas），于leader保持一定程度同步的副本称为ISR（In-Sync Replicas）。</li><li>Leader故障后，从ISR中选举新的Leader。</li><li>高水位（HW-High Watermark）：消费者能消费的最大offset位置，相当于<strong>所有副本中都存在的消息</strong>（木桶效应）</li><li>LEO（Log End Offset）：标识当前日志文件中下一条待写入消息的offset，每个副本都会维护自身的LEO，<strong>ISR中最小的LEO即为分区的HW</strong>。</li></ul></li></ul><p>多副本的作用：提高Kafka的可用性。</p><p>涉及参数：</p><ul><li>unclean.leader.election.enable：为true则ISR为空也能选举，为false则只能从ISR选举。</li></ul><h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>Q：客户端如何知道请求哪个broker？</p><p>client通过metadata从任意broker获取集群信息，其中包括：</p><ol><li>topic信息</li><li>每个topic的分区、副本情况</li><li>leader分区所在的broker连接信息</li><li>每个broker的连接信息</li><li>其他信息</li></ol><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/20230718224608.png" alt="Kafka应用架构(https://developer.confluent.io/courses/architecture/get-started/)"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>使用WSL 2环境进行单机部署。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">zero</span>@Pluto:~$ uname -a<span class="hljs-attribute">Linux</span> Pluto <span class="hljs-number">4</span>.<span class="hljs-number">19</span>.<span class="hljs-number">128</span>-microsoft-standard #<span class="hljs-number">1</span> SMP Tue Jun <span class="hljs-number">23</span> <span class="hljs-number">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">10</span> UTC <span class="hljs-number">2020</span> x86_64 x86_64 x86_64 GNU/Linux</code></pre></div><p>Kafka需要Java环境，由于Kafka最新版本3.1.0不再支持Java8，故使用Java11。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">zero</span>@Pluto:~$ java -version<span class="hljs-attribute">openjdk</span> version <span class="hljs-string">&quot;11.0.15&quot;</span> <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">19</span><span class="hljs-attribute">OpenJDK</span> Runtime Environment (build <span class="hljs-number">11</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>+<span class="hljs-number">10</span>-Ubuntu-<span class="hljs-number">0</span>ubuntu<span class="hljs-number">0.18.04.1</span>)<span class="hljs-attribute">OpenJDK</span> <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">11</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>+<span class="hljs-number">10</span>-Ubuntu-<span class="hljs-number">0</span>ubuntu<span class="hljs-number">0.18.04.1</span>, mixed mode, sharing)</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /opt<span class="hljs-attribute">wget</span> https://dlcdn.apache.org/kafka/<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>/kafka_2.<span class="hljs-number">13</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.tgz<span class="hljs-attribute">tar</span> -zxvf kafka_2.<span class="hljs-number">13</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.tgz<span class="hljs-attribute">cd</span> kafka_2.<span class="hljs-number">13</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span></code></pre></div><p>运行下面命令单机部署：</p><div class="code-wrapper"><pre><code class="hljs pgsql">bin/kafka-<span class="hljs-keyword">server</span>-<span class="hljs-keyword">start</span>.sh config/<span class="hljs-keyword">server</span>.properties</code></pre></div><h3 id="创建主题测试"><a href="#创建主题测试" class="headerlink" title="创建主题测试"></a>创建主题测试</h3><p>创建一个topic名称为test，副本因子为1，分区个数为1的Topic。</p><div class="code-wrapper"><pre><code class="hljs stylus">bin/kafka-topics<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--create</span> <span class="hljs-attr">--bootstrap-server</span> localhost:<span class="hljs-number">9092</span> <span class="hljs-attr">--replication-factor</span> <span class="hljs-number">1</span> <span class="hljs-attr">--partitions</span> <span class="hljs-number">1</span> <span class="hljs-attr">--topic</span> test</code></pre></div><p>通过<code>--describe</code>可以进行查看。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">bin</span>/kafka-topics.sh --describe --topic test --bootstrap-server localhost:<span class="hljs-number">9092</span><span class="hljs-attribute">Topic</span>: test     TopicId: Zb5Tr1MpS1ukdX22mnoBoQ PartitionCount: <span class="hljs-number">1</span>       ReplicationFactor: <span class="hljs-number">1</span>    Configs: segment.bytes=<span class="hljs-number">1073741824</span>        <span class="hljs-attribute">Topic</span>: test     Partition: <span class="hljs-number">0</span>    Leader: <span class="hljs-number">0</span>       Replicas: <span class="hljs-number">0</span>     Isr: <span class="hljs-number">0</span></code></pre></div><h3 id="发送-消费消息测试"><a href="#发送-消费消息测试" class="headerlink" title="发送&#x2F;消费消息测试"></a>发送&#x2F;消费消息测试</h3><p><code>bin/kafka-console-producer.sh</code>可以通过命令行输入消息并发送给Kafka，每一行是一条消息。</p><div class="code-wrapper"><pre><code class="hljs stylus">bin/kafka-console-producer<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--broker-list</span> localhost:<span class="hljs-number">9092</span> <span class="hljs-attr">--topic</span> test</code></pre></div><p>同时提供了<code>bin/kafka-console-consumer.sh</code>提供消费消息的功能。</p><div class="code-wrapper"><pre><code class="hljs stylus">bin/kafka-console-consumer<span class="hljs-selector-class">.sh</span> <span class="hljs-attr">--bootstrap-server</span> localhost:<span class="hljs-number">9092</span> <span class="hljs-attr">--topic</span> test <span class="hljs-attr">--from-beginning</span></code></pre></div><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 指明连接的Zookeeper集群服务地址，使用逗号进行分割</span><span class="hljs-comment"># </span><span class="hljs-attr">zookeeper.connect</span>=localhost:<span class="hljs-number">2181</span><span class="hljs-comment"># 指定kakfa集群中broker的唯一标识</span><span class="hljs-attr">broker.id</span>=<span class="hljs-number">0</span><span class="hljs-comment"># Kafka日志文件位置</span><span class="hljs-attr">log.dirs</span>=/opt/kafka_2.<span class="hljs-number">13</span>-<span class="hljs-number">2.8</span>.<span class="hljs-number">1</span>/logs<span class="hljs-comment">#  定义Kafka Broker的Listener</span><span class="hljs-attr">listeners</span>=PLAINTEXT://:<span class="hljs-number">9092</span><span class="hljs-comment">#将Broker的Listener信息发布到Zookeeper中</span><span class="hljs-attr">advertised.listeners</span>=PLAINTEXT://<span class="hljs-number">172.19</span>.<span class="hljs-number">143.59</span>:<span class="hljs-number">9092</span></code></pre></div><h3 id="部署kafka-map"><a href="#部署kafka-map" class="headerlink" title="部署kafka-map"></a>部署kafka-map</h3><p><code>kafka-map</code>是使用<code>Java11</code>和<code>React</code>开发的一款<code>kafka</code>可视化工具。</p><div class="code-wrapper"><pre><code class="hljs livescript">docker run -d <span class="hljs-string">\</span>    -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> <span class="hljs-string">\</span>    -v /opt/kafka-<span class="hljs-keyword">map</span>/data:/usr/local/kafka-<span class="hljs-keyword">map</span>/data <span class="hljs-string">\</span>    -e DEFAULT_USERNAME=admin <span class="hljs-string">\</span>    -e DEFAULT_PASSWORD=zero... <span class="hljs-string">\</span>    --name kafka-<span class="hljs-keyword">map</span> <span class="hljs-string">\</span>    --restart always dushixiang/kafka-map:latest</code></pre></div><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>消息队列：可以替代传统消息队列，比如ActiveMQ、RabbitMQ等。</li><li>流处理平台：对数据进行实时流处理。</li><li>网站活动追踪：用户活动（浏览网页、搜索等）、网站活动发布到不同的主题，进行实时处理监测，可替代Hadoop或其他离线数仓。</li><li>日志聚合</li><li>事件采集</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Kafka有5个核心API：</p><ul><li>Producer API：客户端发送消息到Kafka集群中的Topic。</li><li>Consumer API：客户端从Kafka集群读取消息。</li><li>Streams API：允许从输入topic转换数据流到输出topic。</li><li>Connect API：通过实现<code>connector</code>，不断从源系统拉取数据到Kafka，或者从Kafka提交数据到系统。</li><li>Admin API：用于检查和管理topic、broker等资源。</li></ul><p>Maven工程添加如下依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="生产者-API"><a href="#生产者-API" class="headerlink" title="生产者 API"></a>生产者 API</h3><p>生产者的缓冲池保存尚未发送给服务端的消息，后台的IO线程负责将消息转换为请求发送给服务端，<strong>如果使用后不关闭生产者，会丢失这些消息。</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;172.28.203.172:9092&quot;</span>);        props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>);        props.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-number">0</span>);        props.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">16384</span>);        props.put(<span class="hljs-string">&quot;linger.ms&quot;</span>, <span class="hljs-number">1</span>);        props.put(<span class="hljs-string">&quot;buffer.memory&quot;</span>, <span class="hljs-number">33554432</span>);        props.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);        props.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);        Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(props);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;test&quot;</span>, Integer.toString(i), Integer.toString(i)));        &#125;        producer.close();    &#125;</code></pre></div><h4 id="配置参数-1"><a href="#配置参数-1" class="headerlink" title="配置参数"></a>配置参数</h4><p><code>Properties</code>各配置字段含义：</p><ul><li>bootstrap.servers：Kafka集群的地址，集群地址使用逗号隔开。</li><li>acks：指定分区中必须要有多少个副本收到这条消息，之后生产者认为这条消息是成功写入的。取值如下：<ul><li>1：只要Leader副本成功写入，就会收到来自服务端的成功响应。</li><li>0：生产者发送消息之后不需要等待任何服务器的响应，可以得到最大吞吐量，但是消息丢失无法得知。</li><li>-1&#x2F;all：消息发送后，需要等待所有副本都写入消息后才能收到服务器的响应，可以达到最强的可靠性。</li></ul></li><li>retries：请求发送失败，生产者会重试，设置为0禁止重试。</li><li>batch.size：缓冲区大小</li><li>linger.ms：生产者发送请求前等待一段时间，希望更多请求进入缓冲区。</li><li>buffer.memory：生产者可用的缓存大小。</li><li>key.serializer、value.serializer：将key和value对象ProducerRecord转换为字节。（broker端需要以<code>byte[]</code>形式存在）</li><li>max.request.size：限制生产者客户端能发送消息的最大值。默认值为1MB。</li><li>connections.max.idle.ms：指定多久之后关闭限制的连接。</li><li>compression.type: 压缩方式，默认为none</li></ul><p>实际使用过程中，可以使用<code>ProducerConfig</code>类来对Producer进行配置。</p><h4 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h4><ol><li>连接到任意broker，获取集群元数据</li><li>发送消息到指定分区leader副本所在的broker</li><li>其他broker上的副本向leader同步数据</li></ol><h4 id="消息对象字段"><a href="#消息对象字段" class="headerlink" title="消息对象字段"></a>消息对象字段</h4><p><code>ProducerRecord</code>作为消息对象，包含以下字段：</p><ul><li><p>topic：主题</p></li><li><p>partition：分区号</p></li><li><p>headers：消息头部，用于设定相关信息</p></li><li><p>key：指定消息的键，可以用来计算分区号从而发送给特定分区<strong>实现分类功能。</strong></p><ul><li>同一个key的消息会被划分到同一个分区。</li></ul></li><li><p>value：消息体</p></li><li><p>timestamp：消息时间戳</p></li></ul><h4 id="发送模式"><a href="#发送模式" class="headerlink" title="发送模式"></a>发送模式</h4><ul><li><p>fire-and-forget：发后即忘，发送后不关心消息是否正确到达，可能会导致消息丢失。</p><ul><li>适用场景：只关心消息的吞吐量，并允许少量消息发送失败。配合参数<code>acks = 0</code>使用</li></ul></li><li><p>sync：同步发送，可以通过在<code>send()</code>后链式调用<code>get()</code>等到Kafka响应。</p><ul><li>适用场景：业务要求消息必须按照<strong>顺序发送</strong>，并且数据只能存储在同一个Partition中。</li></ul></li><li><p>async：异步发送，<code>send()</code>为异步发送。</p><ul><li>可以在send方法中指定<code>Callback()</code>函数，在消息返回响应时调用。</li><li>适用场景：要求知道是否发送成功，并对消息顺序不关心。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//fire-and-forget 模式   </span>producer.send(record);<span class="hljs-comment">//sync 模式 调用future.get()</span>future = producer.send(record);<span class="hljs-type">RecordMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> future.get();<span class="hljs-comment">//async</span>Future&lt;RecordMetadata&gt; <span class="hljs-title function_">send</span><span class="hljs-params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span>;</code></pre></div><h4 id="生产者类型"><a href="#生产者类型" class="headerlink" title="生产者类型"></a>生产者类型</h4><p>生产者主要有两种类型：</p><ul><li>幂等生产者：要求多次交付结果一致。<ul><li>启动幂等，需要将<code>enable.idempotence</code>设置为<code>true</code>，并且<code>retries</code>会被默认配置为<code>Integer.MAX_VALUE</code>，acks默认配置为<code>all</code>。</li></ul></li><li>事务生产者：允许将消息原子性地发送给多个分区。</li></ul><h4 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h4><p>分区器用来确定消息发往的分区，如果指定了<code>partition</code>字段，则不需要分区器。<strong>若未指定，通过消息的key来计算partition值</strong>。默认的分区器<code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code>中的<code>partition</code>方法定义了分区逻辑如下：</p><ul><li>如果key不为null，那么分区器对key使用<code>MurmurHash2</code>算法进行哈希，从而得到分区号。</li><li>如果key为null，消息将以轮询的方式发往主题内的各个可用分区。</li></ul><p>选择分区的策略有以下几种方式：</p><ul><li>轮询策略：顺序分配消息</li><li>消息key指定分区策略：上述hash方式</li><li>随机策略：随机发送到某个分区上</li><li>自定义策略：实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口，重写 <code>partition</code>方法。</li></ul><h4 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h4><p>可以在消息发送之前做一些准备工作，例如：按照某个规则过滤不符合要求的消息、修改消息的内容等发送前的操作。<code>ProducerInterceptor</code>为默认拦截器。通过重写<code>onSend</code>来实现对消息的拦截修改等操作</p><h4 id="生产者客户端架构"><a href="#生产者客户端架构" class="headerlink" title="生产者客户端架构"></a>生产者客户端架构</h4><p>整个生产者客户端由两个线程协调运行，分别为主线程和Sender线程。其分工如下：</p><ul><li>主线程：创建消息，通过拦截器，序列化器、分区器作用后缓存到<code>RecordAccumulator</code>中。</li><li>Sender线程：负责从<code>RecordAccumulator</code>中获取消息并发送给Kafka服务端。</li></ul><p><strong>RecordAccumulator</strong>细节：</p><ul><li>缓存消息以便Sender线程可以批量发送，减少网络资源消耗。</li><li>缓存大小通过<code>buffer.memory</code>来设置，默认为32MB。</li><li>如果缓存空间被全部使用，send方法会被阻塞，可通过<code>max.block.ms</code>来控制阻塞时间。</li><li>消息都会被追加到累加器中的<code>Deque&lt;ProducerBatch&gt;</code>中，写入追加到双端队列尾部，Sender获取消息并发送时，从队列头部读取。<code>ProducerBatch</code>中包含多个<code>ProducerRecord</code>。</li><li>内部有一个<code>BufferPool</code>来实现对缓存的复用，使用<code>batch.size</code>对大小进行指定，该部分主要对发送给Kafka服务端消息之前进行保存。</li><li>当<code>ProducerRecord</code>传入累加器中，会首先寻找与消息分区对应的Deque，并获取尾部的<code>ProducerBatch</code> ，判断是否还可写入，不可写入则创建新的<code>ProducerBatch</code>。</li><li>一个Batch默认大小为16KB。</li></ul><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><ul><li>记录了：存在哪些主题、分区、分区的leader是哪个节点，副本节点是哪几个等元数据。</li><li>需要更新元数据时，会挑选出<code>leastLoadedNode</code>，然后向Node发出请求获取元数据，请求由Sender线程发出，会使用sync来保证线程安全。</li></ul><h3 id="消费者-API"><a href="#消费者-API" class="headerlink" title="消费者 API"></a>消费者 API</h3><p>消费者负责订阅Kafka中的<code>Topic</code>，并且从订阅的<code>Topic</code>上拉取消息。每个消费者都有一个对应的消费组，当消息发送到主题后，只会被投递给订阅它的消费组中的一个消费者。</p><p>当新消费者加入组中时，会通过分区分配策略去给消费者分配分区。</p><p>消费逻辑需要具备以下几个步骤：</p><ol><li>配置消费者客户端参数并创建消费者实例。</li><li>订阅主题。</li><li>拉取消息并消费。</li><li>提交消费位移。</li><li>关闭实例。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        props.setProperty(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;localhost:9092&quot;</span>);        props.setProperty(<span class="hljs-string">&quot;group.id&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);        props.setProperty(<span class="hljs-string">&quot;key.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);        props.setProperty(<span class="hljs-string">&quot;value.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);        props.setProperty(<span class="hljs-string">&quot;client.id&quot;</span>,<span class="hljs-string">&quot;consumer.client.id.demo&quot;</span>);        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(props);        consumer.subscribe(Arrays.asList(topic));        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">100</span>));            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)                System.out.printf(<span class="hljs-string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());        &#125;    &#125;</code></pre></div><h4 id="配置参数-2"><a href="#配置参数-2" class="headerlink" title="配置参数"></a>配置参数</h4><ul><li>bootstrap.servers：集群地址</li><li>group.id：隶属的消费组名称，默认为””</li><li>key.deserializer 和 value.deserializer：与生产者对应</li><li>client.id：消费者id</li><li>fetch.min(max).bytes：消费者一次拉取的最小（大）数据量。</li><li>max.poll.records：消费者一次拉取的最大消息数量。</li></ul><h4 id="消费过程"><a href="#消费过程" class="headerlink" title="消费过程"></a>消费过程</h4><ol><li>连接到任意Broker，获取Kafka集群元数据</li><li>通过上一步的元数据，找到自己所属Coordinator所在的broker</li><li>加入Consumer Group，获取分区消费方案</li><li>获取相关分区消费进度，从上次消费的offset开始继续拉取消息</li><li>提交消费进度到Coordinator</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><code>KafkaConsumer</code>提供了<code>subscribe</code>方法来订阅主题，若多次调用，以最后一次作为消费的主题。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribe</span><span class="hljs-params">(Collection&lt;String&gt; topics)</span> &#123;        subscribe(topics, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoOpConsumerRebalanceListener</span>());    &#125;</code></pre></div><p>还提供了<code>assign()</code>方法订阅主题中的特定分区，参数为<code>Collection&lt;TopicPartition&gt;</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assign</span><span class="hljs-params">(Collection&lt;TopicPartition&gt; partitions)</span>;</code></pre></div><p><code>TopicPartition</code>类有两个属性：topic和partition，分别代表分区所属的主题和自身的分区编号。</p><p><code>partitionsFor</code>用于查询指定主题的元数据，传入<code>topic</code>，返回<code>List&lt;PartitionInfo&gt;</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;PartitionInfo&gt; <span class="hljs-title function_">partitionsFor</span><span class="hljs-params">(String topic)</span></code></pre></div><p><code>PartitionInfo</code>包含如下字段：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//主题名称</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String topic;<span class="hljs-comment">//分区编号</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> partition;<span class="hljs-comment">//leader节点的位置</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node leader;<span class="hljs-comment">//AR集合</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node[] replicas;<span class="hljs-comment">//ISR集合</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node[] inSyncReplicas;<span class="hljs-comment">//OSR集合</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node[] offlineReplicas;</code></pre></div><p>提供了<code>unsubscribe</code>方法来取消主题的订阅，若将<code>subscribe</code>方法中参数设置为空集合，效果等同于取消订阅。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsubscribe</span><span class="hljs-params">()</span></code></pre></div><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>生产者对数据进行序列化， 消费者端用反序列化来恢复数据，其中包括ByteBufferDeserializer、ByteArrayDeserializer、BytesDeserializer、DoubleDeserializer、FloatDeserializer、IntegerDeserializer、LongDeserializer、ShortDeserializer、StringDeserializer，分别提供不同的类型反序列化。</p><p>可以考虑Thrift、Protocol Buffer等通用序列化工具来实现。</p><h4 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h4><ul><li>push：服务端主动将消息推送给消费者。</li><li>pull：消费者主动向服务端发起请求来拉取消息。提供的为<code>poll()</code>，Kafka采用的此种方式。</li></ul><p>为什么不使用Push：Push方式无法确定消费者的消费速度，并且推送效率是Broker进行控制的，容易发生<strong>消息堆积</strong>的情况。</p><p>对于<code>poll()</code>，若分区中没有可消费的消息，拉去的结果为空，需要传入超时时间，用来控制该方法的阻塞时间。</p><h4 id="Consumer-Group机制"><a href="#Consumer-Group机制" class="headerlink" title="Consumer Group机制"></a>Consumer Group机制</h4><p>为什么要设计<code>Consumer Group</code>？</p><ul><li>当Topic数据量非常大的时候，凭单个Consumer线程消费十分缓慢，需要用扩展性较好的机制来保证消费进度，Group机制是Kafka提供的消费者机制。</li></ul><h4 id="ConsumerRecord"><a href="#ConsumerRecord" class="headerlink" title="ConsumerRecord"></a>ConsumerRecord</h4><p>对于消费者取回的消息，封装成<code>ConsumerRecord</code>类，各字段含义如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//主题</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String topic;<span class="hljs-comment">//分区</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> partition;<span class="hljs-comment">//偏移量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> offset;<span class="hljs-comment">//时间戳</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timestamp;<span class="hljs-comment">//时间戳类型，CreateTime 和LogAppendTime</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimestampType timestampType;<span class="hljs-comment">//key被序列化之后的大小</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> serializedKeySize;<span class="hljs-comment">//value被序列化之后的大小</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> serializedValueSize;<span class="hljs-comment">//消息头部</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Headers headers;<span class="hljs-comment">//消息键值对</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> K key;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> V value;<span class="hljs-comment">//领导者节点任期</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Optional&lt;Integer&gt; leaderEpoch;</code></pre></div><h4 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h4><p>消息的<code>commited offset</code>用于表示消息在分区中的相应位置，同样有一个<code>consumed offset</code>用来保存消费者消费位置。一般情况下<code>position = commited offset = consumed offset + 1</code>。自动提交可能造成重复消费和消息丢失的现象。</p><p>位移提交的动作是消费完所有拉取到的信息之后执行的，如果消费过程中出现了异常，在故障恢复之后，会发生重复消费的现象，consumer需要做幂等性保障。</p><p>Kafka中消费位移的提交方式是自动提交，由消费者客户端参数<code>enable.auto.commit</code>控制，默认为true，定期提交的周期时间由<code>auto.commit.interval.ms</code>控制，默认为5s。</p><p>消费者每隔5秒会将拉取到的每个分区中最大的消息位移进行提交。自动位移提交的动作是在<code>poll()</code>方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。</p><p>服务端将<code>commited offset</code>保存在<code>__consumer_offsets</code>，它是由Kafka自动创建的，和普通的Topic存储格式相同。</p><h4 id="消费者拦截器"><a href="#消费者拦截器" class="headerlink" title="消费者拦截器"></a>消费者拦截器</h4><p>功能类似于生产者拦截器，可自定义。</p><h4 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h4><p><code>KafkaConsumer</code>是非线程安全的，<code>acquire</code>检测当前是否只有一个线程在操作，若有其他线程则会抛出<code>ConcurrentModificationException</code>。</p><p>由于Kafka消息保留机制的作用，有些消息消费前可能被清理，可以通过线程封闭的方式来实现多线程消费：每个线程实例化一个<code>KafkaConsumer</code>对象。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper论文阅读笔记</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/Zookeeper%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/Zookeeper%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Zookeeper是一个带有事件驱动的分布式系统缓存，提供了强大的分布式协调能力，结合了组播消息、分布式锁等内容。</p><p>Zookeeper提供了高性能服务，保证了对客户端请求FIFO顺序执行和线性化写，在给出了在2:1到100:1的读&#x2F;写比率下，ZooKeeper 每秒可以处理数万到数十万个事务。</p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>分布式系统需要不同形式的协调程序，<strong>配置</strong>是协调的最基本形式。</p><p>Zookeeper的API设计，移除了锁等阻塞原语来提高性能，使用<strong>wait-free的数据结构</strong>来实现对应的功能。</p><blockquote><p>注：wait-free：他保证任何线程都能在有限的过程内执行完成。</p></blockquote><p>Zookeeper可以用集群模式中的副本来实现高可用性和高性能，是西安了基于领导者的原子广播协议（ZAB：<strong>Zookeeper Atomic Broadcast</strong>），Zookeeper应用的主要负载是读操作，所以需要保证读吞吐量的可扩展。</p><p>Zookeeper使用<strong>watch机制</strong>使得客户端不需要直接管理客户端缓存，对于一个给定的数据对象，客户端可以监视到更新动作，当有更新的时候收到通知消息。而Chubby 直接操作客户端缓存，会阻塞更新直到所有的客户端缓存都被改变。如果任何客户端速度较慢或者故障，更新都会延迟。</p><p>本文主要讨论ZooKeeper的设计和实现，包括：</p><ul><li>协调内核：提出了一种可用于分布式系统的无等待、具有宽松的一致性保证的协调服务。</li><li>协调示例</li><li>协调相关的思路</li></ul><h2 id="2-Zookeeper服务"><a href="#2-Zookeeper服务" class="headerlink" title="2.Zookeeper服务"></a>2.Zookeeper服务</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Zookeeper将客户端抽象为<code>znodes</code>，并将其构造为树形结构，客户端可以创建两种znode：</p><ul><li>普通：client通过创建和删除显式操作普通节点。</li><li>临时：创建后可以显式删除或者系统在会话结束后自动删除。</li></ul><p>watch机制使得客户端无须轮询就可以接收到状态变换的通知信息。与一个会话关联的 watches 只会触发一次；一旦触发或者会话结束，就会被注销。</p><p>设计znode不是用来保存通用数据，而是用来映射客户端应用的抽象，主要是对于协调用途的元数据。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/zookeeper/paper/namespace.jpg"></p><h3 id="2-2-客户端API"><a href="#2-2-客户端API" class="headerlink" title="2.2 客户端API"></a>2.2 客户端API</h3><ul><li>**create(path, data, flags)**：使用 path 名称创建一个 znode 节点，保存 data，返回新创建的 znode 名称。 flags 用于创建普通或者临时节点，也可以设置顺序标识。</li><li>**delete(path, version)**： 删除指定 path 和 version 的 znode 节点。</li><li>**exists(path, watch)**： 如果指定 path 的 znode 存在则返回真，如果不存在则返回假。watch 标识用于在 znode 上设置监视器。</li><li>**getData(path, watch)**： 返回数据和元数据，如版本信息。watch 标识与 <code>exists()</code> 的 watch 标识一样，但如果 znode 不存在则不会设置监视器。</li><li>**setData(path, data, version)**： 根据 path 和 version 将数据写入到 znode。</li><li>**getChildren(path, watch)**： 返回 znode 所有子节点的名称集合。</li><li>**sync(path)**： 在操作开始时，等待所有挂起的更新操作发送到客户端连接的服务器。path 当前未使用。</li></ul><p>所有API都提供同步异步两个版本，无论同步异步，都会保证执行顺序按照FIFO进行。</p><h3 id="2-3-保证"><a href="#2-3-保证" class="headerlink" title="2.3 保证"></a>2.3 保证</h3><p>Zookeeper有两个顺序保证：</p><ul><li><strong>线性化写入</strong>：所有更新请求都是序列化并且遵循优先级。<ul><li>这里的线性化称为异步线性化，一个客户端有多个未完成的操作，因此需要FIFO顺序。</li></ul></li><li><strong>FIFO客户端顺序</strong>：对于客户端的所有请求，都会按客户端发送的顺序执行。</li></ul><p>两个活性和持久性保证：</p><ul><li>Zookeeper的大部分节点存活，则服务可用</li><li>Zookeeper响应了更新请求，只要多数节点恢复，更新则可以持久化</li></ul><h3 id="2-4-原语的例子"><a href="#2-4-原语的例子" class="headerlink" title="2.4 原语的例子"></a>2.4 原语的例子</h3><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>配置信息存放在znode中，进程读取znode的值，将watch设置为true。</p><h4 id="信息汇合"><a href="#信息汇合" class="headerlink" title="信息汇合"></a>信息汇合</h4><p>系统的最终的配置信息并不能提前知道。</p><p>主进程可创建一个znode来存储配置信息，工作进程读取znode，并设置watch为true。</p><h4 id="群组关系"><a href="#群组关系" class="headerlink" title="群组关系"></a>群组关系</h4><p>利用临时节点以及树形结构，可以动态管理群组成员的关系。</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>Zookeeper可用于实现分布式锁。</p><h2 id="3-Zookeeper应用"><a href="#3-Zookeeper应用" class="headerlink" title="3.Zookeeper应用"></a>3.Zookeeper应用</h2><ul><li>爬虫应用FS：存储爬虫服务的配置信息，选举主进程。</li><li>Katta（分布式索引）：注册节点，保存群组关系，提供领导者选举和配置管理服务。</li><li>YMB（分布式发布订阅系统）：配置管理、故障探测、群组关系</li></ul><h2 id="4-Zookeeper实现"><a href="#4-Zookeeper实现" class="headerlink" title="4.Zookeeper实现"></a>4.Zookeeper实现</h2><p>Zookeeper的组件如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/zookeeper/paper/component.jpg"></p><p>复制的数据库是一个内存级数据库，使用WAL日志保证一致性，并且会生成快照进行持久化。对于写请求只有leader进行处理，并且使用ZAB协议进行一致性的保证，读请求所有节点都可以处理。</p><h3 id="4-1-请求处理器"><a href="#4-1-请求处理器" class="headerlink" title="4.1 请求处理器"></a>4.1 请求处理器</h3><p>由于事务是幂等的，当leader收到写请求后，会计算写入后的状态，并将请求转化为一个包含这个新状态的entry。</p><p>例如<code>setData</code>的写操作，执行成功则会生成包含新数据、版本号、时间戳的<code>setDataTXN</code>，执行异常，则会生成<code>errorTXN</code>。</p><h3 id="4-2-ZAB"><a href="#4-2-ZAB" class="headerlink" title="4.2 ZAB"></a>4.2 ZAB</h3><p>所有的写请求都会被转发到leader节点进行处理，并使用ZAB协议广播更新信息，ZAB默认采用简单的多数服从原则，大部分服务器（2n+1，可以允许n个节点故障）正常时，Zookeeper正常工作。</p><ul><li>ZAB是<strong>强一致性</strong>的共识算法，是Paxos的一种</li><li>提供了高性能，使用TCP传输，消息顺序由网络保证</li><li>ZAB按顺序发送所有消息。</li></ul><h3 id="4-3-复制数据库"><a href="#4-3-复制数据库" class="headerlink" title="4.3 复制数据库"></a>4.3 复制数据库</h3><p>每个节点在内存中都有一份Zookeeper状态的拷贝，为了防止节点故障恢复影响效率，故采用<strong>周期性的快照</strong>来提高恢复效率。使用DFS遍历节点树，读取znode数据和元数据并写入磁盘。在生成快照过程中可能存在状态变化，但只要顺序写入状态变更信息，由于消息幂等，可以保证数据一致性。</p><h3 id="4-4-C-S交互"><a href="#4-4-C-S交互" class="headerlink" title="4.4 C&#x2F;S交互"></a>4.4 C&#x2F;S交互</h3><p>读请求：</p><ul><li>请求在各个节点的本地执行</li><li>每个读请求附加上zxid，等于最后一个服务端见到的事务。</li></ul><p>写请求：</p><ul><li>将更新相关的通知发出去，并将对应的watch清空。</li><li>写请求不会和任何请求并发执行，保证了数据的严格一致</li><li>通知在各个节点本地执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper入门教程</title>
    <link href="/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/Zookeeper%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2022/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/Zookeeper%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Zookeeper为分布式系统提供了高效可靠的分布式协调服务，其本质是一个键值存储系统，提供了诸如命名服务、配置管理、分布式锁等服务。其采用ZAB协议对集群数据的一致性进行管理。</p><p>它负责存储和管理一些数据，然后接受观察者的注册，一旦数据状态发生变化，Zookeeper负责通知观察者做出相应的反应。</p><p>几个特点：</p><ul><li>一个Leader，多个Follow组成的集群。</li><li>半数以上节点存活，集群即可正常服务，适合部署奇数台节点。</li><li>全局数据一致，每个节点都保存相同的数据副本。</li><li>所有客户端看到的数据都是一致的，并且请求按照顺序执行（FIFO）</li><li>数据更新原子性。</li><li>更新删除操作都是基于事务的，是用于<strong>读多写少</strong>环境。</li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Zookeeper的数据模型由一个树形结构构成，每个节点称为一个ZNode，由于设计目标是实现协调服务，而不是数据存储，故默认存储大小为1MB，每个ZNode可以通过其路径唯一标识。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>从官网下载Zookeeper的二进制发布版，解压后得到以下文件：</p><div class="code-wrapper"><pre><code class="hljs elixir">zero<span class="hljs-variable">@Pluto</span><span class="hljs-symbol">:~/Zookeeper/apache-zookeeper-</span><span class="hljs-number">3.5</span>.<span class="hljs-number">7</span>-bin<span class="hljs-variable">$ </span>ls<span class="hljs-title class_">LICENSE</span>.txt  <span class="hljs-title class_">NOTICE</span>.txt  <span class="hljs-title class_">README</span>.md  <span class="hljs-title class_">README_packaging</span>.txt  bin  conf  docs  lib</code></pre></div><p>执行<code>bin/zkServer.sh version</code>，看到版本信息说明正常运行。</p><div class="code-wrapper"><pre><code class="hljs elixir">zero<span class="hljs-variable">@Pluto</span><span class="hljs-symbol">:~/Zookeeper/apache-zookeeper-</span><span class="hljs-number">3.5</span>.<span class="hljs-number">7</span>-bin<span class="hljs-variable">$ </span>bin/zkServer.sh version/usr/bin/java<span class="hljs-title class_">ZooKeeper</span> <span class="hljs-title class_">JMX</span> enabled by default<span class="hljs-title class_">Using</span> <span class="hljs-symbol">config:</span> /home/zero/<span class="hljs-title class_">Zookeeper</span>/apache-zookeeper<span class="hljs-number">-3.5</span>.<span class="hljs-number">7</span>-bin/bin/../conf/zoo.cfg<span class="hljs-symbol">Usage:</span> bin/zkServer.sh [--config &lt;conf-dir&gt;] &#123;start|start-foreground|stop|restart|status|print-cmd&#125;</code></pre></div><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><p>创建一个zoo.cfg文件，内容如下：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">tickTime</span><span class="hljs-operator">=</span><span class="hljs-number">2000</span><span class="hljs-attribute">initLimit</span><span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-attribute">syncLimit</span><span class="hljs-operator">=</span><span class="hljs-number">5</span><span class="hljs-attribute">dataDir</span><span class="hljs-operator">=/</span>opt/Zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">7</span>/zkData<span class="hljs-attribute">clientPort</span><span class="hljs-operator">=</span><span class="hljs-number">2181</span></code></pre></div><p>执行<code>bin/zkServer.sh start</code>启动服务器节点。</p><div class="code-wrapper"><pre><code class="hljs elixir">zero<span class="hljs-variable">@Pluto</span><span class="hljs-symbol">:/opt/Zookeeper-</span><span class="hljs-number">3.5</span>.<span class="hljs-number">7</span><span class="hljs-variable">$ </span>bin/zkServer.sh start/usr/bin/java<span class="hljs-title class_">ZooKeeper</span> <span class="hljs-title class_">JMX</span> enabled by default<span class="hljs-title class_">Using</span> <span class="hljs-symbol">config:</span> /opt/<span class="hljs-title class_">Zookeeper</span><span class="hljs-number">-3.5</span>.<span class="hljs-number">7</span>/bin/../conf/zoo.cfg<span class="hljs-title class_">Starting</span> zookeeper ... <span class="hljs-title class_">STARTED</span>zero<span class="hljs-variable">@Pluto</span><span class="hljs-symbol">:/opt/Zookeeper-</span><span class="hljs-number">3.5</span>.<span class="hljs-number">7</span><span class="hljs-variable">$ </span>jps -l<span class="hljs-number">3892</span> sun.tools.jps.<span class="hljs-title class_">Jps</span><span class="hljs-number">3850</span> org.apache.zookeeper.server.quorum.<span class="hljs-title class_">QuorumPeerMain</span></code></pre></div><p>执行<code>bin/zkCli.sh</code>启动客户端。</p><div class="code-wrapper"><pre><code class="hljs routeros">zero@Pluto:/opt/Zookeeper-3.5.7$ bin/zkCli.sh/usr/bin/javaConnecting <span class="hljs-keyword">to</span> localhost:21812022-04-29 17:08:00,703 [myid:] - <span class="hljs-built_in">INFO</span>  [main<span class="hljs-keyword">:Environment</span>@109] -<span class="hljs-built_in"> Client </span>environment:zookeeper.<span class="hljs-attribute">version</span>=3.5.7-f0fdd52973d373ffd9c86b81d99842dc2c7f660e, built on 02/10/2020 11:30 GMT2022-04-29 17:08:00,705 [myid:] - <span class="hljs-built_in">INFO</span>  [main<span class="hljs-keyword">:Environment</span>@109] -<span class="hljs-built_in"> Client </span>environment:host.<span class="hljs-attribute">name</span>=Pluto.localdomain2022-04-29 17:08:00,705 [myid:] - <span class="hljs-built_in">INFO</span>  [main<span class="hljs-keyword">:Environment</span>@109] -<span class="hljs-built_in"> Client </span>environment:java.<span class="hljs-attribute">version</span>=1.8.0_3122022-04-29 17:08:00,707 [myid:] - <span class="hljs-built_in">INFO</span>  [main<span class="hljs-keyword">:Environment</span>@109] -<span class="hljs-built_in"> Client </span>environment:java.<span class="hljs-attribute">vendor</span>=Private Build2022-04-29 17:08:00,707 [myid:] - <span class="hljs-built_in">INFO</span>  [main<span class="hljs-keyword">:Environment</span>@109] -<span class="hljs-built_in"> Client </span>environment:java.<span class="hljs-attribute">home</span>=/usr/lib/jvm/java-8-openjdk-amd64/jre</code></pre></div><p>执行<code>bin/zkServer.sh stop</code>停止服务端。</p><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>配置参数如下：</p><ul><li>tickTime&#x3D;2000：通信心跳时间，作为Zookeeper的基本时间单位。单位为ms。</li><li>initLimit&#x3D;10：leader和follower的初始连接能容忍的最大心跳数量（tickTime的数量）。</li><li>syncLimit&#x3D;5：leader和follower同步通信时限，超过指定时间，leader认为follower宕机，从列表中删除follower。</li><li>dataDir：数据存储路径，包括快照和事务日志。</li><li>clientPort&#x3D;2181：客户端连接端口。</li></ul><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h3 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h3><ul><li>cZxid：创建节点的事务zxid<ul><li>zxid：每次修改Zookeeper状态都会产生一个事务id，每次修改都有唯一的zxid。</li></ul></li><li>ctime：znode被创建的毫秒数</li><li>mZxid：znode最后更新的事务zxid</li><li>mtime：znode最后修改的毫秒数</li><li>pZxid：znode最后更新的毫秒数zxid</li><li>cversion：znode节点修改次数</li><li>dataVersion：znode数据修改次数</li><li>aclVersion：访问控制列表修改次数</li><li>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id，不是临时则为0</li><li>dataLength：znode的数据长度</li><li>numChildren：znode子节点数量</li></ul><p>Znode有以下两种类型：</p><ul><li>持久（<strong>PERSISTENT</strong> ）：客户端与服务端断开连接后，节点不删除。除非主动执行删除操作。</li><li>临时（<strong>EPHEMERAL</strong> ）：客户端断开连接后，创建的节点被删除。</li></ul><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p>Zookeeper集群中各个服务器都会承担一种角色，分别有以下三种：</p><ul><li><strong>Leader</strong>：领导者节点，只有一个。<ul><li>会给其他节点发送心跳信息，通知其在线。</li><li>所有写操作都通过Leader完成再由ZAB协议将操作广播给其他服务器。</li></ul></li><li><strong>Follower</strong>：跟随者节点，可以有多个。<ul><li>响应Leader的心跳。</li><li>可以直接响应客户端的读请求。</li><li>将写请求转发给Leader进行处理。</li><li>负责在Leader处理写请求时进行投票。</li></ul></li><li><strong>Observer</strong>：观察者，无投票权。</li></ul><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p>Zookeeper采用ACL（Access Control Lists）机制来进行权限控制，每个Znode创建时都会有一个ACL列表，由此决定谁能进行何种操作。定义了以下五种权限：</p><ul><li><strong>CREATE：</strong>允许创建子节点；</li><li><strong>READ：</strong>允许从节点获取数据并列出其子节点；</li><li><strong>WRITE：</strong> 允许为节点设置数据；</li><li><strong>DELETE：</strong>允许删除子节点；</li><li><strong>ADMIN：</strong> 允许为节点设置权限。</li></ul><h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><ul><li><p>所有节点都可以直接处理读操作，从本地内存中读取数据并返回给客户端。</p></li><li><p>所有的写操作都会交给Leader进行处理，其余节点接收到写请求会转发给Leader，基本步骤如下：</p><ol><li>Leader为每个Follower分配了一个FIFO队列，Leader接收到请求，将请求封装成事务存放于队列中发送给Follower并等待ACK。</li><li>Follower接收到事务请求后返回ACK。</li><li>Leader收到超过半数的ACK后，向所有Follower和Observer发送Commit完成数据提交。</li><li>Leader将处理结果返回给客户端。</li></ol></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>为了实现<strong>顺序一致性</strong>，Zookeeper使用递增的事务id（zxid）来标识事务。zxid是一个64位的数字，高32位是<code>epoch </code>，该部分记录Leader是否改变（每一次选举都会有一个新的epoch），低32位用于递增计数。</p><h3 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h3><p>客户端可以注册监听znode状态，当其状态发生变化，监听器被触发，并主动向客户端推送相应的消息。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>几个要点：</p><ul><li>客户端通过<strong>TCP长连接</strong>连接到Zookeeper集群。</li><li>第一次连接开始就建立，之后通过<strong>心跳检测机制</strong>来保持有效的会话状态。</li><li>客户端中配置了集群列表，客户端启动时遍历列表尝试连接，失败则尝试连接下一个。</li><li>每个会话都有一个<strong>超时时间</strong>，<strong>如果服务器在超时时间内没有收到任何请求，则会话被认为过期</strong>，并将与该会话相关的临时znode删除。因此客户端通过心跳（ping）来保持会话不过期。</li><li>Zookeeper的会话管理通过<code>SessionTracker </code>完成，采用了<strong>分桶策略</strong>进行管理，以便对同类型的会话统一处理。<ul><li>分桶策略：将类似的会话放在同一区块中进行管理。</li></ul></li></ul><p>会话的四个属性：</p><ul><li><strong>sessionID</strong>：会话的全局唯一标识，每次创建新的会话，都会分配新的ID。</li><li><strong>TimeOut</strong>：超时时间，客户端会配置&#96;sessionTimeout，连接Zookeeper时会将此参数发送给Zookeeper服务端，服务端根据自己的超时时间确定最终的TimeOut。</li><li><strong>TickTime</strong>：下次会话超时时间点，便于Zookeeper检查超时会话。</li><li><strong>isClosing</strong>：标记会话是否被关闭。</li></ul><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB协议与Paxos算法类似，是一种保证数据一致性的算法，ZAB协议是ZK的数据一致性和高可用的解决方案。因此ZAB协议主要完成两个任务：</p><ul><li><strong>实现一致性</strong>：Leader通过ZAB协议给其他节点发送消息来实现<strong>主从同步</strong>，从而保证数据一致性。</li><li><strong>Leader选举</strong>：当ZK集群刚启动或Leader宕机，通过选举机制选出新的Leader，从而保证高可用。</li></ul><p>Zookeeper集群使用<strong>myid</strong>来标识节点的唯一ID，<code>myid</code>存放于ZK数据目录下的<code>myid</code>文件。</p><p>服务器存在四种状态，分别如下所述：</p><ul><li><strong>LOOKING</strong>：不确定Leader状态，节点认为集群中没有Leader，会发起Leader选举。</li><li><strong>FOLLOWING</strong>：跟随者状态，节点为Follower，知道Leader是哪个节点。</li><li><strong>LEADING</strong>：领导者状态，节点为Leader，并且会维护与Follower之间的心跳。</li><li><strong>OBSERVING</strong>：观察者状态，节点为Observer，不参加选举和投票。</li></ul><h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>每个服务器启动都会判断当前是否进行选举，若在恢复模式下，刚从崩溃状态恢复的服务器会从磁盘快照中恢复数据。</p><p>每个服务器进行选举时，会发送以下的信息：</p><ul><li><strong>logicClock</strong>：每个节点维护一个自增的整数，表明是该服务器进行的第多少轮投票。</li><li><strong>state</strong>：服务器状态。</li><li><strong>self_id</strong>：服务器的<code>myid</code>。</li><li><strong>self_zxid</strong>：当前服务器上保存数据的最大<code>zxid</code>。</li><li><strong>vote_id</strong>：投票对象的服务器<code>myid</code>。</li><li><strong>vote_zxid</strong>：投票对象的最大<code>zxid</code>。</li></ul><p><strong>投票流程</strong>：</p><ol><li>每个服务器在开始新一轮投票时，都会对自己的<code>logicClock</code>进行自增操作。</li><li>每个服务器清空投票箱中上一轮的投票数据。</li><li>每个服务器最开始都投票给自己，并广播。</li><li>服务器接收其他服务器的投票信息并计入投票箱。</li><li>判断投票信息中的<code>logicClock </code>，并做不同处理。<ul><li>若外部投票<code>logicClock </code> &gt; 本节点的<code>logicClock </code>，说明本节点轮次小于其他节点，立即清空投票箱，并更新<code>logicClock </code>为最新，并重新投票并广播。</li><li>若外部投票<code>logicClock </code> &lt; 本节点的<code>logicClock </code>，忽略此投票信息，处理下一个。</li><li>若外部投票<code>logicClock </code> &#x3D; 本节点的<code>logicClock </code>，比较<code>vote_zxid</code>，若小于外部节点，则将<code>vote_id</code>改为外部投票中的<code>vote_id</code>并广播。</li></ul></li><li>如果确定有过半服务器给自己投票，则终止投票，否则继续接收投票信息。</li><li>投票终止后，若服务器赢得投票，将状态改为<code>LEADING</code>，否则改为<code>FOLLOWING</code>。</li></ol><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>ZAB保证数据一致性的流程可以说是二阶段提交的简化版，其更新逻辑如下：</p><ul><li>所有写请求都要转发给Leader，Leader使用原子广播将事务通知给Follower。</li><li>Follower接收到信息后以<strong>事务日志</strong>的形式将数据写入，并返回ACK响应给Leader。</li><li>当<strong>半数以上</strong>的Follower更新完成后，Leader对更新进行Commit，然后给客户端返回一个更新成功的响应。</li></ul><p>ZAB对<strong>Leader发生故障</strong>而导致数据不一致问题做了相应的措施：</p><ul><li>已经在Leader上提交的事务，其他节点已经持久化，不做处理。</li><li>只在Leader上创建而Follower未ACK，Leader需要回滚。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>统一命名服务</strong>：通过顺序节点特性可以生成<strong>全局唯一ID</strong>，从而提供命名服务。</li><li><strong>统一配置管理</strong><ul><li>一般集群中，所有配置信息是一致的，例如Kafka集群。</li><li>对配置文件修改后，需要快速同步到各个节点上。</li></ul></li><li><strong>分布式锁</strong>：使用临时节点和Watch机制实现。举例说明：<ul><li>分布式系统中有三个节点：A，B，C，通过访问ZK实现分布式锁功能。</li><li>所有节点访问<code>/lock</code>，并创建<strong>带序号的临时节点</strong>。</li><li>节点尝试获取锁，并获取<code>/lock</code>下所有子节点，判断自己创建的节点是否为最小。<ul><li>是，认为拿到锁。</li><li>否，未获取到锁，监听节点变化，若其他线程释放，则可能拿到锁。</li></ul></li><li>释放锁时，将创建的节点删除。</li></ul></li><li><strong>统一集群管理</strong><ul><li>实时掌握每个节点的状态，并且做出一些相应的调整。</li><li>动态监听分布式系统中服务的上下线，从而实现动态扩容。</li><li>提供集群选主功能：让所有服务节点创建同一个Znode，由于路径唯一，因此只能有一个节点能创建成功，创建成功的为分布式系统中的Leader。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DDIA阅读笔记(一)-数据系统的基石</title>
    <link href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/DDIA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3/"/>
    <url>/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/DDIA%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章：可靠性、可伸缩性、可维护性"><a href="#第一章：可靠性、可伸缩性、可维护性" class="headerlink" title="第一章：可靠性、可伸缩性、可维护性"></a>第一章：可靠性、可伸缩性、可维护性</h2><p>应用的两个分类：</p><ul><li><strong>data-intensive</strong>：问题通常来自数据量、数据复杂性、以及数据的变更速度。</li><li><strong>compute-intensive</strong>：瓶颈在于CPU。</li></ul><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>可以把可靠性粗略理解为 “即使出现问题，也能继续正确工作”。</p><p>造成错误的原因叫做 <strong>故障（fault）</strong>，能预料并应对故障的系统特性可称为 <strong>容错（fault-tolerant）</strong> 或 <strong>韧性（resilient）</strong>。</p><p>fault种类：</p><ul><li><strong>硬件故障（hardware faults）</strong><ul><li>增加单个硬件的冗余度：磁盘可以组建RAID、服务器使用双路电源和热拔插CPU等。</li><li>云平台的设计就是优先考虑 <strong>灵活性（flexibility）</strong>和 <strong>弹性（elasticity）</strong>，而不是单机可靠性。</li><li>引入软件容错机制。</li></ul></li><li><strong>系统性错误（systematic error）</strong><ul><li>软件错误</li><li>修复问题代码、进程隔离、监控分析</li></ul></li><li><strong>人为错误</strong><ul><li>以最小化犯错机会的方式设计系统：精心设计的API</li><li>与最容易犯错的模块解耦</li><li>彻底的测试：单元测试、系统测试</li><li>允许从人为错误中简单快速地恢复：快速回滚配置变更、分批发布新代码。</li><li>配置详细地监控，比如性能指标和错误率。</li></ul></li></ul><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p><strong>可伸缩性（Scalability）</strong> 是用来描述系统应对负载增长能力的术语。</p><p>描述性能的指标：</p><ul><li><strong>吞吐量（throughput）</strong>：每秒可以处理的记录数量。或者在特定规模数据集上运行作业的总时间。</li><li><strong>响应时间（response time）</strong>：客户端发送请求到接收响应之间的时间。<ul><li>响应时间的高百分位点（尾部延迟）指标非常重要</li></ul></li></ul><p>处理方法：</p><ul><li>垂直伸缩：转向更强大的机器。</li><li>水平伸缩：负载分布到多台小机器。</li></ul><p><strong>弹性（elastic）</strong>：在检测到负载增加时自动增加计算资源</p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>三个设计原则来避免自己的软件系统变为遗留系统：</p><ul><li>可操作性</li><li>简单性</li><li>可演化性</li></ul><h4 id="可操作性"><a href="#可操作性" class="headerlink" title="可操作性"></a>可操作性</h4><ul><li>监控系统提供可见性</li><li>将系统与标准化工具集成</li><li>避免单机部署</li><li>提供良好的文档</li><li>提供良好的默认行为（配置参数？）</li><li>自我修复</li><li>行为可预测</li></ul><h4 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h4><p>消除<strong>额外复杂度</strong>的最好工具之一是<strong>抽象</strong>。</p><p>抽象帮助我们控制系统复杂度。</p><h4 id="可演化性"><a href="#可演化性" class="headerlink" title="可演化性"></a>可演化性</h4><p>系统的需求是变化的，使用敏捷工作模式来应对，例如TDD和重构。</p><h2 id="第二章：数据模型与查询语言"><a href="#第二章：数据模型与查询语言" class="headerlink" title="第二章：数据模型与查询语言"></a>第二章：数据模型与查询语言</h2><p>问题：需要将数据模型抽象成对应的概念。</p><p>每个层都通过提供一个明确的数据模型来隐藏更低层次中的复杂性。</p><h3 id="关系模型和文档模型"><a href="#关系模型和文档模型" class="headerlink" title="关系模型和文档模型"></a>关系模型和文档模型</h3><h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>常见分类：</p><ul><li>TP（事务性）：银行交易</li><li>AP（分析型）：数据报表</li><li>HTAP（混合型）</li></ul><p>问题：关系模型很难直观表达<strong>一对多的关系</strong>．</p><p>文档模型的优势：</p><ul><li>模式灵活：动态增删字段</li><li>更好的局部性：一个人的所有属性被集中访问</li><li>结构表达语义：JSON的树状结构能够表达语义</li></ul><h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>几个要点：</p><ul><li>树状结构，每个节点只允许一个父节点</li><li>节点存储数据，节点分类型</li><li>节点间使用指针连接</li></ul><h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>多对一和多对多都由路径来表示，访问记录的唯一方式是顺着元素路径访问。</p><h4 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h4><p>文档型数据库的使用场景：</p><ul><li>多种类型数据，放一张表不合适</li><li>数据类型和结构由外部决定，没办法控制数据的变化</li></ul><p>MySQL和PgSQL支持JSON。</p><h3 id="数据查询语言"><a href="#数据查询语言" class="headerlink" title="数据查询语言"></a>数据查询语言</h3><p>分为声明式语言（SQL）和命令式语言（通用编程语言）。</p><p>命令式语言的优点：</p><ul><li>描述目标复杂时，声明式表达能力不够。</li><li>可以通过抽象、编程范式等，让代码兼顾表达力和清晰性。</li></ul><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><p>MapReduce模型：</p><ul><li>借鉴自函数式编程</li><li>简单的编程模型</li></ul><p>特点：</p><ul><li>要求Map和Reduce是纯函数</li><li>非常底层，但是表达力强大，可基于其实现高级查询语言，例如Hive。</li></ul><p>注意点：</p><ul><li>不是所有的分布式SQL都基于MapReduce</li><li>不是只有MapReduce才能嵌入通用语言</li><li>MapReduce有一定的理解成本</li></ul><h3 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h3><p>典型案例：</p><ul><li>社交图谱</li><li>网络图谱</li><li>公路或铁路网络</li></ul><p>应用场景：</p><ul><li>文档数据库：数据都是自我包含的，文档之间的关系非常稀少</li><li>图数据库：任意事物都能其他事务相关联</li></ul><h2 id="第三章：存储与检索"><a href="#第三章：存储与检索" class="headerlink" title="第三章：存储与检索"></a>第三章：存储与检索</h2><h3 id="存储使用的数据结构"><a href="#存储使用的数据结构" class="headerlink" title="存储使用的数据结构"></a>存储使用的数据结构</h3><p>世界上最简单的数据库案例：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-function"><span class="hljs-title">db_set</span></span> () &#123;  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>&quot;</span> &gt;&gt; database&#125;<span class="hljs-function"><span class="hljs-title">db_get</span></span> () &#123;  grep <span class="hljs-string">&quot;^<span class="hljs-variable">$1</span>,&quot;</span> database | sed -e <span class="hljs-string">&quot;s/^<span class="hljs-variable">$1</span>,//&quot;</span> | <span class="hljs-built_in">tail</span> -n 1&#125;</code></pre></div><p>两个bash函数实现了键值存储的功能，该模式下更新旧版本时不会覆盖，而是向文件末尾追加记录，查找最新值时，找到文件中key出现的最后一次位置。</p><p>当数据量激增，需要使用<code>索引</code>对查询进行优化。</p><p>大致思想：通过保存一些额外的元数据作为index帮我们找到想要的数据。</p><p>需要权衡的点：索引加快了读查询的速度，拖慢了写入的速度。</p><h4 id="散列索引"><a href="#散列索引" class="headerlink" title="散列索引"></a>散列索引</h4><p>将每个键都进行一次哈希映射，并存储到相应的偏移量位置，当查询指定键时，使用哈希函数计算出相应的值，并读取指定偏移位置的数据。<code>Bitcask</code>存储模型使用的该种方式，该结构适合多次更新键对应的值的情况。</p><p>优化的点：每当日志增长到对应阈值时，开始写入一个新的日志文件，并对之前的日志进行compaction。（Bitcask的Merge策略是类似方案）</p><p>实现过程中要考虑的问题：</p><ul><li>文件格式：使用二进制最快，字节为单位进行编码</li><li>删除操作：删除操作向日志尾追加一个删除记录，当进行compaction时将被删除的数据都丢弃掉。</li><li>奔溃恢复：当数据库重新启动，需要从磁盘中的日志文件进行数据恢复。</li><li>部分写入记录：考虑写入校验和等信息</li><li>并发控制：保证线程安全</li></ul><p>Q：为什么删除操作设计成追加方式，而不是直接在日志中进行修改？</p><ul><li>追加操作是<strong>磁盘顺序写</strong>，比随机写入快</li><li>日志文件仅追加的话，并发和崩溃恢复更简单。’</li><li>merge操作可以避免文件碎片化。</li></ul><p>散列结构的局限性：</p><ul><li>所有key必须放内存，存在大量的随机IO</li><li>范围查询效率不高，需要逐个遍历</li></ul><h4 id="SSTables和LSM-Tree"><a href="#SSTables和LSM-Tree" class="headerlink" title="SSTables和LSM Tree"></a>SSTables和LSM Tree</h4><p>将上述的键值对按照键排序，这个结构被称为<code>Sorted String Table</code>，要求每个键只出现一次（merge保证），该结构有如下优势：</p><ol><li>文件大于可用内存，合并操作仍然有效。</li><li>可以通过类似二分查找的方式去查找（顺序列表特性）</li><li>可以将table分组为block，并将其写入磁盘。</li></ol><p><strong>如何构建和维护SSTables</strong>？</p><ul><li>构建：在内存中维护一个有序结构（MemTable），使用RB Tree、AVL Tree等<ul><li>达到指定阈值后全量dump到外存</li><li>查询逻辑：<ol><li>先去MemTable中查找，如果命中则返回。</li><li>否则再去SSTable按时间顺序由新到旧逐个查找。</li></ol></li></ul></li></ul><p>存在的问题：出现宕机，内存中数据结构会丢失，使用<strong>WAL</strong>解决该问题</p><p>将上述内容继续优化，就会得到<code>LevelDB</code>和<code>RocksDB</code>所有的存储引擎<code>LSM-Tree(Log-Structured Merge-Tree)</code>，<code>ElasticSearch</code>使用的<code>Lucene </code>也是使用类似结构。</p><p>优化：</p><ul><li><p>优化SSTable的查找：使用<code>Bloom Filter</code>做数据初筛。</p></li><li><p>层次化组织SSTable：控制Compaction的顺序和时间，常用的有：<code>size-tiered</code> 和 <code>leveled compaction</code></p><ul><li>size-tiered：较新、较小的SSTables合并到较大、较旧的SSTables中。</li><li>leveled compaction：key被按照范围拆分到较小的SSTables，较旧的数据被移动到单独的level。</li></ul></li></ul><p>LSM-Tree的<strong>核心思想</strong>：保存一组合理组织、后台合并的SSTables。</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h4><p>B Tree目前用于几乎所有的关系型数据库中，支持高效的定值查询和范围查询。</p><p>B Tree的优化：</p><ul><li>不使用WAL，在写入时利用<code>Copy On Write </code>技术。</li><li>对中间节点的key做压缩，增大了分支。</li><li>为了优化范围查询，有的B Tree将叶子节点存储时物理连续，但是数据插入时，维护有序性的代价很大。</li><li>为叶子节点增加兄弟指针（B+Tree），避免顺序查找时的回溯。</li></ul><h4 id="B-Tree-对比-LSM-Tree"><a href="#B-Tree-对比-LSM-Tree" class="headerlink" title="B Tree 对比 LSM Tree"></a>B Tree 对比 LSM Tree</h4><table><thead><tr><th align="center">存储引擎</th><th align="center">B-Tree</th><th align="center">LSM-Tree</th></tr></thead><tbody><tr><td align="center">优势</td><td align="center">读取快</td><td align="center">写入快</td></tr><tr><td align="center">写放大</td><td align="center">数据和WAL；更改数据时多次覆盖整个Page</td><td align="center">数据和WAL；Compaction</td></tr><tr><td align="center">写吞吐</td><td align="center">低，存在大量随机写</td><td align="center">顺序写入，写吞吐较高</td></tr><tr><td align="center">压缩率</td><td align="center">存在较多内部碎片</td><td align="center">更紧凑，没有内部碎片</td></tr><tr><td align="center">存储放大</td><td align="center">有些Page没有用满</td><td align="center">同一个key存储多遍</td></tr><tr><td align="center">并发控制</td><td align="center">同一个key只存在一个地方；树结构容易被范围锁</td><td align="center">同一个key存多变，使用MVCC控制</td></tr></tbody></table><h3 id="其他结构"><a href="#其他结构" class="headerlink" title="其他结构"></a>其他结构</h3><p>聚集索引和非聚集索引：</p><ul><li>数据本身按照某个字段有序存储，基于该字段的索引被称为<strong>聚集索引</strong>。</li><li>索引中只存数据的引用的被称为非聚集索引。</li><li>一部分列嵌到索引中存储，剩余列额外存储，称为<strong>覆盖索引</strong>。</li></ul><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>多个字段联合查询的场景十分常见：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> restaurants <span class="hljs-keyword">WHERE</span> latitude <span class="hljs-operator">&gt;</span> <span class="hljs-number">51.4946</span> <span class="hljs-keyword">AND</span> latitude <span class="hljs-operator">&lt;</span> <span class="hljs-number">51.5079</span>                            <span class="hljs-keyword">AND</span> longitude <span class="hljs-operator">&gt;</span> <span class="hljs-number">-0.1162</span> <span class="hljs-keyword">AND</span> longitude <span class="hljs-operator">&lt;</span> <span class="hljs-number">-0.1004</span>;</code></pre></div><p>方案：</p><ul><li>将latitude和longitude合并存储，转为一维</li><li>使用类似R Tree的地理空间索引存储</li><li>使用类似MySQL的联合索引解决</li></ul><h3 id="全文索引和模糊索引"><a href="#全文索引和模糊索引" class="headerlink" title="全文索引和模糊索引"></a>全文索引和模糊索引</h3><p><code>Lucene</code> 中索引是字符的有限自动机，类似于<code>Trie</code>，支持在给定编辑距离内搜索单词。</p><h3 id="全内存数据结构"><a href="#全内存数据结构" class="headerlink" title="全内存数据结构"></a>全内存数据结构</h3><p>内存数据库的优点：</p><ul><li>提供丰富的数据抽象</li><li>实现简单</li></ul><p>基于<strong>非易失性存储器（non-volatile memory，NVM）</strong>的存储引擎是最近的研究热点。</p><h2 id="事务性-or-分析性"><a href="#事务性-or-分析性" class="headerlink" title="事务性 or 分析性"></a>事务性 or 分析性</h2><p>两者对比：</p><table><thead><tr><th>属性</th><th>事务处理系统 OLTP</th><th>分析系统 OLAP</th></tr></thead><tbody><tr><td>主要读取模式</td><td>查询少量记录，按键读取</td><td>在大批量记录上聚合</td></tr><tr><td>主要写入模式</td><td>随机访问，写入要求低延时</td><td>批量导入（ETL）或者事件流</td></tr><tr><td>主要用户</td><td>终端用户，通过 Web 应用</td><td>内部数据分析师，用于决策支持</td></tr><tr><td>处理的数据</td><td>数据的最新状态（当前时间点）</td><td>随时间推移的历史事件</td></tr><tr><td>数据集尺寸</td><td>GB ~ TB</td><td>TB ~ PB</td></tr></tbody></table><p>一开始OLAP仍然使用传统数据库，但是传统数据库在AP负载表现较差，因此转向专门做AP查询的<strong>数据仓库</strong>。</p><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>数仓是一个独立的数据库，从OLTP数据库提取数据，转换成适合分析的结构，清理并加载到数仓中，这个过程称为：<strong>抽取-转换-加载</strong>（ETL）。</p><h4 id="分歧"><a href="#分歧" class="headerlink" title="分歧"></a>分歧</h4><p>数仓的数据模型通常是关系型的，但是查询引擎和存储格式优化方面，与OLTP数据库差别十分大。</p><h3 id="星状型-雪花型"><a href="#星状型-雪花型" class="headerlink" title="星状型 雪花型"></a>星状型 雪花型</h3><ul><li>星状型：包含一张事件表和多张维度表，数据表以事件流方式将数据组织起来，然后用外键指向不同的维度。</li><li>雪花型：会在上述的维度表中进行二次细分。</li></ul><h2 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h2><p>传统数据库按行存储，如果只查询一个字段，也必须从磁盘中取出剩余字段，浪费了IO带宽，增大了读放大。</p><p>如果将每一列的所有值存储在一起，查询效率大大增加。</p><h3 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h3><p>当列中存在大量重复的数据，可以考虑对其进行压缩存储，数仓中特别有效的技术是位图编码。</p><h4 id="列族"><a href="#列族" class="headerlink" title="列族"></a>列族</h4><p>这是HBase和Cassandra中的概念，从BigTable继承，每个列族中，将一行中所有列与行键一起存储，并且不使用列压缩。</p><p>因此BigTable在使用时主要面向行，可以理解为每个列族是一张子表。</p><h4 id="内存带宽和向量化处理"><a href="#内存带宽和向量化处理" class="headerlink" title="内存带宽和向量化处理"></a>内存带宽和向量化处理</h4><p>数仓的超大规模数据量带来的瓶颈：</p><ul><li>内存处理带宽</li><li>CPU分支预测错误</li></ul><p>解决：</p><ul><li>列式存储和压缩可以让数据缓存在L1中，结合位图快速处理</li><li>使用SIMD、在更少的时钟周期处理更多的数据。</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>可以像LSM-Tree那样，对所有行按某一列排序后存储。</p><h4 id="不同副本，不同排序"><a href="#不同副本，不同排序" class="headerlink" title="不同副本，不同排序"></a>不同副本，不同排序</h4><p>对数据的不同部分按照不同列进行有序存储，这样可以提供给不同查询需求，已有商用数仓Vertica 采用。</p><h3 id="列式存储的写入"><a href="#列式存储的写入" class="headerlink" title="列式存储的写入"></a>列式存储的写入</h3><p>类似于LSM-Tree的追加操作：</p><ul><li>新写入的数据在内存中Batch好，按行按列，具体结构看需求</li><li>达到指定阈值，批量刷到外存，并于老数据合并。</li></ul><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>数仓查询通常涉及聚合函数，每次即时计算都会存在巨大浪费，可以考虑将其缓存下来。</p><p>与关系型数据库的View差别较大，视图是逻辑存在的，当物理存储发生改变，视图需要重新生成，写多读少的情况，维护代价很大。</p><p>数仓中的<strong>物化视图</strong>将其持久化存储，维护代价较低。</p><h2 id="第四章：编码和演进"><a href="#第四章：编码和演进" class="headerlink" title="第四章：编码和演进"></a>第四章：编码和演进</h2><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>涉及到跨进程通信，都需要对数据进行编码（序列化），因为通信都是面向字节流的，编码涉及两方面问题：</p><ul><li>如何编码能够节省空间、提高性能。</li><li>如何编码以适应数据的演化和兼容。</li></ul><p>当应用程序更新后，系统要顺利运行，要保证<strong>双向兼容性</strong>：</p><ul><li>向后兼容：新代码读取旧数据</li><li>向前兼容：旧代码读取新数据</li></ul><p>程序使用两种形式的数据：</p><ul><li>内存中的数据结构</li><li>网络通信时，编码成的字节序列</li></ul><h3 id="语言特定格式"><a href="#语言特定格式" class="headerlink" title="语言特定格式"></a>语言特定格式</h3><p>编程语言内置了将内存对象编码为字节序列的组件：</p><ul><li>java.io.Serializable</li><li>Marshal</li><li>pickle</li><li>第三方库</li></ul><p>这类存在的问题：</p><ul><li>与编程语言深度绑定，其他语言很难读取这类数据</li><li>解码过程需要<strong>实例化任意类</strong>，存在安全问题：RCE</li><li>不存在数据版本控制</li><li>编解码效率低</li></ul><h3 id="JSON、XML等"><a href="#JSON、XML等" class="headerlink" title="JSON、XML等"></a>JSON、XML等</h3><p>存在的问题：</p><ul><li>数值的编码存在歧义：不能区分整数和浮点数</li><li>不支持二进制数据的字节序列</li><li>XML和JSON支持额外的模式，但是增加了复杂度</li></ul><h3 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h3><p>如果数据只被单一程序读取，而不进行交换，不需要易读性等问题，可以使用二进制编码，其空间、速度方面都很可观。</p><h3 id="Thrift与Protocol-Buffers"><a href="#Thrift与Protocol-Buffers" class="headerlink" title="Thrift与Protocol Buffers"></a>Thrift与Protocol Buffers</h3><p>上述两个是基于相同原理开发的二进制编码库</p><p>Protocol Buffers的接口定义语言（IDL）如下所示：</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> user_name       = <span class="hljs-number">1</span>;    <span class="hljs-keyword">optional</span> <span class="hljs-type">int64</span>  favorite_number = <span class="hljs-number">2</span>;    <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> interests       = <span class="hljs-number">3</span>;&#125;</code></pre></div><p>IDL与编程语言无关，可以利用代码生成工具，将上述IDL翻译为指定语言的代码。</p><p>Thrift还支持不同的编码格式：BinaryProtocol、CompactProtocol、JSON等</p><p>优势：</p><ul><li>省去字段名，更加紧凑</li><li>模式是数据的注释或文档，总是最新</li><li>数据模式允许不读取数据</li><li>对于静态类型来说 ，可以利用代码生成做编译时的类型检查</li></ul><h3 id="数据流模型"><a href="#数据流模型" class="headerlink" title="数据流模型"></a>数据流模型</h3><ul><li>经过数据库的数据流</li><li>经过服务的数据流：REST和RPC<ul><li>REST是一种设计哲学</li><li>RPC问题：<ul><li>请求出现请求丢失、相应丢失等情况，需要重试</li><li>重试需要考虑<strong>幂等性</strong></li><li>两端编程语言不同可能会有影响</li></ul></li></ul></li><li>经过消息传递的数据流</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迟到的2021总结：继续前行</title>
    <link href="/2022/%E9%9A%8F%E7%AC%94/2021-summary/"/>
    <url>/2022/%E9%9A%8F%E7%AC%94/2021-summary/</url>
    
    <content type="html"><![CDATA[<h2 id="回看2021"><a href="#回看2021" class="headerlink" title="回看2021"></a>回看2021</h2><p>曾在2020总结中说到，2021的主旋律应该是考研，我也确实投入进去了，报考的是南京航空航天大学的计算机学硕，很遗憾没有录取。主观原因是个人发挥失常，主要在数学一的大题计算。对于考研复习期间，认为付出了很大的精力投入其中，归根到底还是自己太菜了。</p><h3 id="面向2022"><a href="#面向2022" class="headerlink" title="面向2022"></a>面向2022</h3><p>1月、2月的后考研期间，陷入了舒适圈中，这应该是人生中的最后一次放纵。2月下旬开始准备春招，从基础知识到算法，都慢慢开始捡起，从小公司开始面，逐渐开始面试中厂，从最初的略微拘谨，到和面试官的谈笑风生，是我在面试中的不断磨砺的结果，春招也如愿以偿的拿到了期望的offer。</p><p>2022年完成以下任务：</p><ul><li>继续扎实Java方向的知识，包括集合、并发、JVM等方面。</li><li>继续刷算法题，达到一线大厂的面试要求。</li><li>扎实OS、网络、组成原理等基础知识，做到真正理解底层知识。</li><li>熟悉MySQL、redis、MQ、RPC等中间件的使用，并了解其中的底层原理。</li></ul><blockquote><p> “那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”</p><p>— 王小波 《黄金时代》</p></blockquote><p>愿自己能在未来的生活中，一往无前，继续前行，战胜一切困难，努力做到最好，拼尽全力闯出属于自己的辉煌。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL调优总结</title>
    <link href="/2022/MySQL/MySQL%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/MySQL/MySQL%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据库调优的几个维度：</p><ul><li>建立索引</li><li>SQL语句优化</li><li>服务器参数调优：包括缓冲区、线程数等</li><li>分库分表、集群模式</li></ul><p>调优目标：</p><ul><li>尽可能节省系统资源，以提高系统吞吐量。</li><li>合理的结构设计和参数调整，以提高用户操作响应的速度。</li><li>减少系统的瓶颈，提高MySQL整体性能。</li></ul><p>如何定位调优问题：</p><ul><li>用户反馈</li><li>日志分析</li><li>服务器资源监控</li></ul><p>调优维度：</p><ol><li>选择合适的DBMS</li><li>优化表设计<ol><li>遵循三范式的原则</li><li>多表联查可以考虑反范式化</li><li>表字段的数据类型选择</li></ol></li><li>优化SQL查询（逻辑）</li><li>使用索引（物理）</li><li>使用缓存</li><li>库级优化<ol><li>读写分离<ol><li>一主一从</li><li>双主双从</li></ol></li><li>数据分片：对数据库进行分库分表。</li></ol></li></ol><h1 id="MySQL服务器优化"><a href="#MySQL服务器优化" class="headerlink" title="MySQL服务器优化"></a>MySQL服务器优化</h1><p>两个方面：</p><ol><li>硬件优化</li><li>MySQL服务的参数优化</li></ol><h2 id="硬件调优"><a href="#硬件调优" class="headerlink" title="硬件调优"></a>硬件调优</h2><ul><li>配置较大的内存，增加缓冲区容量，减少磁盘IO。</li><li>配置高速磁盘系统，减少磁盘IO的时间。</li><li>合理分布磁盘IO，将磁盘IO分布在多个设备上，减少竞争。</li><li>配置多处理器。</li></ul><h2 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h2><p>通过优化MySQL可以提高资源利用率，从而提高MySQL服务器性能。</p><p>几个重要的参数：</p><ul><li>innodb_buffer_pool_size：表和索引的缓存区大小。</li><li>key_buffer_size：索引缓冲区大小，所有线程共享，值太大也会导致OS频繁换页。</li><li>table_cache：同时打开的表的个数。</li><li>query_cache_size：<strong>查询缓冲区</strong>大小，与query_cache_type配合使用。</li><li>query_cache_type：0代表所有查询不使用查询缓冲区，1表示所有都使用，当查询语句指定<code>SQL_NO_CACHE</code>则不使用。</li><li>sort_buffer_size：每个需要进行<strong>排序</strong>的线程分配的缓冲区大小，增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。</li><li>join_buffer_size：每个需要<strong>联合查询</strong>的线程所使用的缓冲区大小。</li><li>read_buffer_size：每个线程<strong>连续扫描时</strong>为扫描的每个表分配的缓冲区的大小。</li><li>innodb_flush_log_at_trx_commit：<strong>何时将redo log buffer的数据写入redo log file，并将日志文件写入磁盘中。</strong>默认为1。<ul><li>0：redo log buffer每隔一秒将其数据刷入page cache，该模式下事务提交不会触发刷盘操作。</li><li>1：每次事务提交都会将将redo log buffer中数据刷入page cache，并立刻刷入磁盘。效率较低也为安全。</li><li>2：每次事务提交都会将redo log buffer中数据刷入page cache，由OS同步到磁盘。（每秒一次）<ul><li>mysql进程崩溃不会有数据丢失，当时OS宕机会有数据丢失。</li></ul></li></ul></li><li>innodb_log_buffer_size：InnoDB存储引擎的<strong>事务日志缓冲区</strong>，为了提升性能，也是先将信息写入 <code>Innodb Log Buffer</code> 中，当满足 <code>innodb_flush_log_trx_commit</code> 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li>max_connections：允许连接到MySQL数据库的最大数量。如果<code>connection_errors_max_connections</code>不为0，并且一直增长，说明不断有连接因为数据库连接数已到最大值而失败，此时考虑增大<code>max_connections</code>的值。</li><li>back_log：用于<strong>控制MySQL监听TCP端口时设置的积压请求栈大小。</strong> 连接数达到<code>max_connections</code>，新来的请求将会被存在堆栈中，以等待某一连接释放资源，如果等待连接的数量超过back_log，将会报错。</li><li>thread_cache_size：线程池缓存线程数量的大小，当客户端断开连接后将当前线程缓存起来， 当在接到新的连接请求时快速响应无需创建新的线程 。这对于短链接的应用程序十分有用。</li><li>wait_timeout：一个连接的最大连接时间。</li><li>interactive_timeout：服务器在关闭连接前等待行动的秒数。</li></ul><h1 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h1><p>几个策略：</p><ol><li>拆分表：冷热数据分离</li><li>增加中间表</li><li>增加冗余字段</li><li>优化数据类型<ol><li>整数类型优化：使用INT类型。</li><li>避免使用TEXT、BLOB数据类型</li><li>避免使用ENUM类型：Order By效率较低</li><li>使用TIMESTAMP存储时间：存储空间小，4字节</li><li>用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</li></ol></li><li>优化插入记录的速度</li><li>使用非空约束</li><li>分析表：更新关键字的分布<ol><li>分析表过程中，会对表加上一个只读锁。</li><li>统计结果会反映在<strong>cardinality</strong>的值上，该值统计了某一个键所在列不重复值得个数，cardinality可以通过 <code>SHOW INDEX FROM 表名</code>查看。</li></ol></li><li>检查表：检查表中是否存在错误。<ol><li>检查表过程中，会对表加上一个只读锁。</li></ol></li><li>优化表：对于变长字段（VARCHAR、BLOB、TEXT等列）进行了更新，优化表可以来整理数据文件得碎片。</li></ol><h1 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h1><h2 id="查询性能分析"><a href="#查询性能分析" class="headerlink" title="查询性能分析"></a>查询性能分析</h2><h3 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h3><p>在MySQL中，可以使用 <code>SHOW STATUS</code> 语句查询一些MySQL数据库服务器的性能参数 、 执行频率 。</p><p>一些常用的性能参数如下： </p><ul><li>Connections：连接MySQL服务器的次数。</li><li>Uptime：MySQL服务器的上 线时间。</li><li>Slow_queries：慢查询的次数。</li><li>Innodb_rows_read：Select查询返回的行数 </li><li>Innodb_rows_inserted：执行INSERT操作插入的行数</li><li>Innodb_rows_updated：执行UPDATE操作更新的 行数</li><li>Innodb_rows_deleted：执行DELETE操作删除的行数</li><li>Com_select：查询操作的次数。</li><li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li><li>Com_update：更新操作 的次数。</li><li>Com_delete：删除操作的次数。</li></ul><h3 id="统计SQL的查询成本"><a href="#统计SQL的查询成本" class="headerlink" title="统计SQL的查询成本"></a>统计SQL的查询成本</h3><p>查上一次查询的代价，是IO和CPU开销的总和，可以作为评价一次查询的执行效率的常用指标。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;last_query_cost&#x27;</span>;</code></pre></div><h3 id="定位慢SQL"><a href="#定位慢SQL" class="headerlink" title="定位慢SQL"></a>定位慢SQL</h3><p>开启slow_query_log</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log<span class="hljs-operator">=</span><span class="hljs-string">&#x27;ON&#x27;</span>;</code></pre></div><p>修改long_query_time阈值</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%long_query_time%&#x27;</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><p>查询当前系统中有多少条慢查询记录</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Slow_queries%&#x27;</span>;</code></pre></div><h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>EXPLAIN返回SQL语句的执行计划。</p><div class="code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> select_options<span class="hljs-keyword">or</span><span class="hljs-keyword">DESCRIBE</span> <span class="hljs-keyword">SELECT</span> select_options</code></pre></div><p>查询结果列如下：</p><ul><li>id：决定每个表的加载和读取顺序。<ul><li>id相同，可以认为是一组，从上往下顺序执行</li><li>id越大，优先级越高，越先执行</li><li>不同id代表单独一趟查询，趟数越少越好</li></ul></li><li>table：一趟查询在哪个表中查询</li><li>select_type：查询类型<ul><li>SIMPLE：简单select查询，不包含子查询或者UNION</li><li>PRIMARY：嵌套查询最外层的部分</li><li>SUBQUERY：出现在select或者where后面中的子查询被标记为SUBQUERY</li><li>DERIVED：在from后面的子查询</li><li>UNION：将UNION后面的select标记位UNION</li><li>UNION RESULT：从 UNION表获取结果的select</li></ul></li><li>type：数据的访问方法，结果值从好到坏依次为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL，SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 const级别。（阿里巴巴 开发手册要求）<ul><li>system：表中只有一行记录</li><li>const：通过索引一次就找到了</li><li>eq_ref：唯一性索引扫描</li><li>ref：使用普通索引或者唯一索引的部分前缀</li><li>range：只检索给定范围的行，使用一个索引来选择行。</li><li>index：full index scan，index类型只遍历索引树</li><li>all：全表扫描</li></ul></li><li>possible_keys：可能使用的索引</li><li>key：实际使用的索引</li><li>key_len：索引中使用的字节数</li><li>ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息，取ref（字段）或const（常量）</li><li>rows：查询大约所需读取的行数</li><li>Extra：额外信息<ul><li>Using filesort：无法使用索引完成，只能在内存或磁盘中进行排序。</li><li>Using temporary：MySQL需要创建一张临时表来处理查询，常见于order by 和 group by。</li><li>Using index：使用了覆盖索引，效率高，如果同时出现<code>Using where</code></li><li>Using index condition：使用了索引下推</li></ul></li></ul><h3 id="optimizer-trace"><a href="#optimizer-trace" class="headerlink" title="optimizer trace"></a>optimizer trace</h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<span class="hljs-keyword">set</span> optimizer_trace_max_mem_size<span class="hljs-operator">=</span><span class="hljs-number">1000000</span>;<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.optimizer_trace\G</code></pre></div><h3 id="sys-schema"><a href="#sys-schema" class="headerlink" title="sys.schema"></a>sys.schema</h3><div class="code-wrapper"><pre><code class="hljs sql">#<span class="hljs-number">1.</span> 查询冗余索引<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys.schema_redundant_indexes;#<span class="hljs-number">2.</span> 查询未使用过的索引<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys.schema_unused_indexes;#<span class="hljs-number">3.</span> 查询索引的使用情况<span class="hljs-keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted<span class="hljs-keyword">from</span> sys.schema_index_statistics <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dbname&#x27;</span> ;# <span class="hljs-number">1.</span> 查询表的访问量<span class="hljs-keyword">select</span> table_schema,table_name,<span class="hljs-built_in">sum</span>(io_read_requests<span class="hljs-operator">+</span>io_write_requests) <span class="hljs-keyword">as</span> io <span class="hljs-keyword">from</span>sys.schema_table_statistics <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> table_schema,table_name <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> io <span class="hljs-keyword">desc</span>;# <span class="hljs-number">2.</span> 查询占用bufferpool较多的表<span class="hljs-keyword">select</span> object_schema,object_name,allocated,data<span class="hljs-keyword">from</span> sys.innodb_buffer_stats_by_table <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> allocated limit <span class="hljs-number">10</span>;# <span class="hljs-number">3.</span> 查看表的全表扫描情况<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys.statements_with_full_table_scans <span class="hljs-keyword">where</span> db<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dbname&#x27;</span>;#<span class="hljs-number">1.</span> 监控<span class="hljs-keyword">SQL</span>执行的频率<span class="hljs-keyword">select</span> db,exec_count,query <span class="hljs-keyword">from</span> sys.statement_analysis<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> exec_count <span class="hljs-keyword">desc</span>;#<span class="hljs-number">2.</span> 监控使用了排序的<span class="hljs-keyword">SQL</span><span class="hljs-keyword">select</span> db,exec_count,first_seen,last_seen,query<span class="hljs-keyword">from</span> sys.statements_with_sorting limit <span class="hljs-number">1</span>;#<span class="hljs-number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="hljs-keyword">SQL</span><span class="hljs-keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query<span class="hljs-keyword">from</span> sys.statement_analysis <span class="hljs-keyword">where</span> tmp_tables<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> <span class="hljs-keyword">or</span> tmp_disk_tables <span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (tmp_tables<span class="hljs-operator">+</span>tmp_disk_tables) <span class="hljs-keyword">desc</span>;#<span class="hljs-number">1.</span> 查看消耗磁盘IO的文件<span class="hljs-keyword">select</span> file,avg_read,avg_write,avg_read<span class="hljs-operator">+</span>avg_write <span class="hljs-keyword">as</span> avg_io<span class="hljs-keyword">from</span> sys.io_global_by_file_by_bytes <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> avg_read limit <span class="hljs-number">10</span>;#<span class="hljs-number">1.</span> 行锁阻塞情况<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sys.innodb_lock_waits;</code></pre></div><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>SQL优化大方向主要分为以下两块：</p><ul><li>物理查询优化：通过<strong>索引</strong>和<strong>表连接</strong>方式等技术来优化。</li><li>逻辑查询优化：通过<strong>SQL等价变换</strong>提升查询效率。</li></ul><h3 id="JOIN语句原理"><a href="#JOIN语句原理" class="headerlink" title="JOIN语句原理"></a>JOIN语句原理</h3><p>join本质就是<strong>各个表之间数据的循环匹配</strong>，MySQL5.5之前，使用嵌套循环方式（Nested Loop Join），在MySQL5.5之后，引入BNLJ算法来优化嵌套执行。</p><p>驱动表为主表，被驱动表为从表，小表驱动大表。通过<code>explain</code>关键字查看。</p><h4 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h4><p>从驱动表A取出数据，遍历扫描表B，将匹配到的数据放到result中，以此类推，驱动表A，直到所有记录被遍历结束。性能消耗很大。</p><h4 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h4><p>优化思路主要是为了<strong>减少内层表数据的匹配次数</strong>，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，减少了和内层表中每条记录去进行比较，这样大大提高了查询效率。</p><h4 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h4><p>BNLJ引入了<code>Join Buffer</code>缓冲区，将驱动表数据按块缓存在<code>buffer</code>中然后全表扫描被驱动表，被驱动表的每一条记录一次性和<code>buffer</code>中所有记录进行匹配，降低了被驱动表的访问频率。</p><div class="code-wrapper"><pre><code class="hljs sql"># 查看block_nested_loop状态，默认开启<span class="hljs-keyword">show</span> VARIABLES <span class="hljs-keyword">like</span> &quot;%optimizer_switch%&quot;;# 查看<span class="hljs-keyword">join</span> buffer的大小，默认为<span class="hljs-number">256</span>KB<span class="hljs-keyword">show</span> VARIABLES <span class="hljs-keyword">like</span> &quot;%join_buffer%&quot;;</code></pre></div><h4 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h4><ul><li><p>MySQL8.0.20开始废弃BNLJ，从MySQL8.0.18开始引入了Hash Join。</p></li><li><p>Hash Join是做<strong>大数据集连接时</strong>的常用方式，优化器将较小的表利用<code>Join Key</code>在内存中建立哈希表，然后扫描大表并且探测哈希表，找到和哈希表匹配的行。</p><ul><li>适用于小表可以完全放在内存中，总成本：访问两个表的成本之和。</li><li>表很大无法放入内存时，优化器将它分割成若干不同的分区，不能放入内存的部分写到磁盘的临时段。</li><li>能很好的工作于没有索引的大表和并行查询的环境，但是只适用于等值连接</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>整体效率：INLJ &gt; BNLJ &gt; SNLJ</p></li><li><p>用小结果集驱动大结果集，<strong>本质</strong>是：<strong>减少外层循环的数据层数</strong>。</p></li><li><p>被驱动表的JOIN字段已经创建了索引。</p></li><li><p>JOIN字段的数据类型保证绝对一致。</p></li><li><p>LEFT JOIN 时选择小表为驱动表，INNER JOIN 时MySQL自动选择小表为驱动表。</p></li></ul><h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>子查询可以一次完成逻辑上需要多个步骤才能完成的SQL操作，但是子查询的执行效率不高，原因如下：</p><ul><li>执行子查询时，MySQL需要为内层语句的结果建立一张临时表，然后外层语句从该表继续查询，完毕后再撤销临时表，这样会消耗很多系统资源。</li><li>子查询产生的临时表不存在索引，故查询性能受限。</li></ul><p>使用JOIN查询代替子查询，并且可以考虑使用索引优化JOIN查询。</p><blockquote><p>尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>在MySQL中，支持<code>FileSort</code>和<code>Index</code>两种排序方式。</p><ul><li><code>Index</code>排序中，索引可以保证有序性，不需要再进行排序。</li><li><code>FileSort</code>一般在内存中进行排序，效率较低。</li></ul><p>优化策略：</p><ol><li>在ORDER BY子句中使用索引，避免<code>FileSort</code>排序。</li><li>无法使用<code>Index</code>时，需要对<code>FileSort</code>进行调优。</li><li>where和order by使用最左前缀原则，且order by的多列同DESC或者ASC顺序</li></ol><p>filesort的两种算法：</p><ul><li>双路排序：读取行指针和order by列，对它们进行排序，然后扫描已经排序好的数据，再次读取其他所需字段。需要两次磁盘IO。</li><li>单路排序：从磁盘读取查询需要的所有列，按照order by列进行排序，然后再输出。<ul><li>单路排序存在的问题：<code>sort_buffer</code>需要占用较多空间。</li><li>优化策略：<ul><li><ol><li>尝试提高<code>sort_buffer_size</code></li><li>尝试提高<code>max_length_for_sort_data</code></li><li>order by时写清楚所需要的字段，禁止<code>*</code></li></ol></li></ul></li></ul></li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>优化原则：</p><ul><li>group by使用索引的原则和order by几乎一致。</li><li>group by先排序再分组，遵循最左前缀原则。</li><li>where效率高于having，尽量使用where进行数据过滤</li><li>包含了group by的查询语句，where过滤后的结果集尽量保持在1000行左右。</li></ul><h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p>当<code>limit 2000000,10</code>时，MySQL获取前2000010条数据，但是只返回后十条记录，其他全部丢弃，查询的代价特别大。</p><p>优化思路主要有以下几种方案：</p><p>在索引上完成分页操作，最后根据主键回表查询其他列内容。</p><div class="code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student t,(<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a <span class="hljs-keyword">WHERE</span> t.id <span class="hljs-operator">=</span> a.id;</code></pre></div><p>将<code>limit</code>查询转换到指定主键的查询（需要主键自增的要求）</p><div class="code-wrapper"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">2000000</span> LIMIT <span class="hljs-number">10</span>;</code></pre></div><h3 id="优先考虑覆盖索引"><a href="#优先考虑覆盖索引" class="headerlink" title="优先考虑覆盖索引"></a>优先考虑覆盖索引</h3><p>覆盖索引：一个索引包含了查询所需要的数据，避免了回表操作。</p><ul><li>优点<ul><li>避免了InnoDB的回表操作</li><li>可以将随机IO变成顺序IO加快查询效率</li></ul></li><li>缺点：<ul><li>建立覆盖型的索引可能造成冗余。</li></ul></li></ul><h3 id="字符串添加索引"><a href="#字符串添加索引" class="headerlink" title="字符串添加索引"></a>字符串添加索引</h3><p>MySQL支持前缀索引，不指定前缀长度时，索引默认包含整个字符串。</p><div class="code-wrapper"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> index index1(email);mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> index index2(email(<span class="hljs-number">6</span>));</code></pre></div><p>前缀索引和整个字符串索引的区别如下：</p><ol><li>使用前缀索引更加节省空间，定义长度时考虑区分度。</li><li>前缀索引不支持覆盖索引，需要综合考虑。</li></ol><h3 id="索引下推-ICP"><a href="#索引下推-ICP" class="headerlink" title="索引下推(ICP)"></a>索引下推(ICP)</h3><p><strong>Index Condition Pushdown</strong>是MySQL 5.6中引入的新特性。</p><p>未使用ICP的工作过程：</p><ol><li>storage层将满足index key条件的索引记录对应的整行取出，返回给server层。</li><li>对返回的数据，使用where条件进行过滤。</li></ol><p>ICP工作过程：</p><ol><li>将满足index key条件满足的索引记录取出，使用<code>index filter</code>对where条件进行过滤，将满足条件的记录返回给server层。</li><li>server层对返回的数据使用<code>table filter</code>条件进行过滤。</li></ol><p>成本差别在于：<strong>ICP在存储引擎层通过ICP筛选掉不符合条件的数据，减少了回表成本。</strong></p><p>使用条件：</p><ul><li>只能用于二级索引</li><li>ICP仅适用于索引列（通常是联合索引）</li><li>ICP可以用于MyISAM和InnnoDB存储引擎</li></ul><h3 id="其他优化策略"><a href="#其他优化策略" class="headerlink" title="其他优化策略"></a>其他优化策略</h3><ul><li>EXISTS和IN的区分：小表驱动大表原则，A表小用EXISTS，B表小用IN。</li><li>COUNT(*)、COUNT(column)、COUNT(1)的效率对比<ul><li>COUNT(*)、COUNT(1)：两者没有本质区别，都是对所有结果进行COUNT。<ul><li>MyISAM只需要$O(1)$复杂度，因为每张数据表都有<code>row_count</code>存储行数，一致性由表级锁保证。</li><li>InnoDB存储引擎采用行级锁+MVCC机制，故需要<strong>扫描全表</strong>，需要$O(n)$复杂度。</li></ul></li><li>COUNT(column)：尽量采用二级索引，二级索引的空间比聚簇索引小。</li></ul></li><li>SELECT(*)：禁止使用<ul><li>无法使用覆盖索引</li><li>增加查询分析器解析成本：通过查询数据字典将<code>*</code>转换为所有列名。</li><li>无用字段增加消耗，例如BLOB等类型会有行溢出额外查询消耗。</li></ul></li><li>LIMIT 1：针对全表扫描的情况，确定结果集只有一条，可以使用<code>LIMIT 1</code>优化，如果字段已经存在唯一索引，可以通过索引进行查询，则不需要<code>LIMIT 1</code>进行优化。</li><li>使用COMMIT释放资源<ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo、undo中的buffer空间</li></ul></li></ul><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="主键的设计"><a href="#主键的设计" class="headerlink" title="主键的设计"></a>主键的设计</h3><p>自增ID存在的问题：</p><ul><li>可靠性不高：存在自增ID回溯问题，MySQL8.0修复</li><li>安全性不高：<code>/user/&#123;id&#125;</code>这样的接口会导致恶意请求爬取相应数据。</li><li>性能消耗：在服务器端生成</li><li>交互多：业务还需要额外执行一次类似<code>last_insert_id()</code>的行数才能知道刚才插入的自增值，需要额外的网络交互。</li><li>局部唯一性：自增ID只能在当前数据库实例中唯一，不能保证分布式系统中的唯一性。</li></ul><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>UUID占用36字节，MySQL中UUID由以下几部分组成：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">UUID</span> = 时间+<span class="hljs-type">UUID</span>版本（<span class="hljs-number">16</span>字节）- 时钟序列（<span class="hljs-number">4</span>字节）- MAC地址（<span class="hljs-number">12</span>字节）另外加上<span class="hljs-number">4</span>个短横线，共<span class="hljs-number">36</span>字节</code></pre></div><p>MySQL8.0将时间低位和高位互换位置，构成了有序UUID。同时将UUID改为二进制存储，只需16字节存储。</p><p>可以通过<code>uuid_to_bin(@uuid, true)</code>将原来的UUID转换为有序递增UUID。</p><h3 id="开源组件"><a href="#开源组件" class="headerlink" title="开源组件"></a>开源组件</h3><p>例如美团开发的Leaf分布式ID生成等。</p><h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><ul><li>为了满足性能目标，性能比规范化更重要。</li><li>在表中增加冗余字段，以大量减少从中搜索的时间。</li><li>存储空间增加，一个表的字段修改，另一个表的冗余字段也需要同步修改，否则数据不一致。</li><li>只有大幅度提高查询效率，才考虑反范式化。</li><li>常用于数仓设计，数仓通常用于存储历史数据，增删改的要求不高。</li></ul><h1 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h1><h2 id="限制查询范围"><a href="#限制查询范围" class="headerlink" title="限制查询范围"></a>限制查询范围</h2><p><strong>禁止使用不带任何限制数据范围条件的查询语句。</strong></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ul><li>一主一从模式</li><li>双主双从模式</li></ul><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>当数据量级达到<strong>千万级</strong>以上时，可以键数据库切分成多块，放到多台数据库服务器中。</p><ul><li><p>垂直分库：将关联的数据表放在同一台数据库中。</p></li><li><p>垂直分表：将一张数据表拆分成多张数据表，按列划分。</p></li><li><p><strong>优点</strong>：可以使得列数据变小，在查询时减少读取的Block数量，减少IO次数。</p></li><li><p><strong>缺点</strong>：主键会冗余，并且会引起JOIN操作，增加业务复杂度。</p></li></ul><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><ul><li>尽量控制单表数据量大小，保持在<strong>1000万条</strong>以内。</li><li>水平分表仅是解决<strong>单一表数据量过大</strong>的问题。</li><li>尽量不要对数据分片，拆分会带来逻辑、部署、运维的复杂度。</li></ul><h3 id="代理方案"><a href="#代理方案" class="headerlink" title="代理方案"></a>代理方案</h3><ul><li><p>客户端代理：分片逻辑在应用层，封装在JAR中，通过修改或封装JDBC层来实现，例如Sharding-JDBC等。</p></li><li><p>中间件代理：在应用层和数据层中间加了个代理层，分片逻辑统一维护在中间件中，例如Mycat等。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络IO模型总结</title>
    <link href="/2022/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="网络IO流程"><a href="#网络IO流程" class="headerlink" title="网络IO流程"></a>网络IO流程</h2><p>网络IO中的一次请求和响应的流程基本如下：</p><ol><li>内核通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。数据从网卡到内核空间；</li><li>从内核缓冲区读取数据到应用进程缓冲区。数据从内核空间到用户空间；</li><li>服务端进程在自己的用户空间中，处理客户端的请求。数据在用户空间中被处理；</li><li>处理完数据并构建好的响应之后，将数据从用户缓冲区写入内核缓冲区。</li><li>内核将内核缓冲区中的响应写入网卡，网卡通过底层的通讯协议，会将数据发送给目标客户端。</li></ol><p>两组概念：</p><ul><li><strong>同步</strong>：请求被逐个地处理，无法并发执行。</li><li><strong>异步</strong>：多个请求可以并发执行，内核IO操作完成后会通知用户线程，或者调用用户进程的回调函数。</li><li><strong>阻塞</strong>：请求发出后，由于该请求操作需要的条件不满足，请求操作一直阻塞，不会返回，直到条件满足。</li><li><strong>非阻塞</strong>：请求发出后，若该请求需要的条件不满足，则立即返回一个标志信息告知条件不满足，而不会一直等待。一般需要通过循环判断请求条件是否满足来获取请求结果。</li></ul><p>在《UNIX网络编程》中，将UNIX的IO模型分为了以下五种：</p><ul><li>阻塞式IO</li><li>非阻塞式IO</li><li>IO多路复用</li><li>信号驱动式IO</li><li>异步IO</li></ul><h2 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h2><p>该模型中，用户空间的应用程序通过执行read调用（底层是recvfrom系统调用）来从socket中读取数据，在应用程序发起read调用后，会一直阻塞，直到数据包到达网卡上并复制到内核空间中，随后从内核空间拷贝到用户空间之后才会返回。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/blocking-io.jpg"></p><p>BIO在实现异步操作时，只能使用多线程进行处理，一个请求对应一个线程，该模型对于高并发环境，开销十分巨大，需要考虑其他的IO处理模型。</p><h2 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h2><p>应用程序发起系统调用，如果内核数据暂未准备好，进程可以做其他事，然后再次轮询内核获取请求结果。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/nonblocking-io.jpg"></p><p>简单的NIO需要不断的重复发起IO系统调用，这种不断地询问内核的操作，这将占用大量的 CPU 时间，并导致<strong>上下文切换</strong>，系统资源利用率较低。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用模型通过一个<strong>监听线程</strong>发起另一种形式的系统调用，由一个线程监听多个文件描述符（fd，linux系统把所有网络请求以一个fd来标识），一旦某个fd的操作就绪（一般是内核缓冲区可读&#x2F;可写），该系统调用就会返回，随后监听线程可以通知程序对准备好了的fd进行对应的IO系统调用，比如通过recvfrom读取数据。</p><p>在Linux中select、poll、epoll函数就是IO多路复用的具体实现。Java4新增的NIO包中引入的选择器Selector，使用的就是IO多路复用模型，通过它，只需要一个线程便可以管理多个客户端连接。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/multiplexing.jpg"></p><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>应用程序通过sigaction系统调用安装一个信号处理函数，应用程序继续工作，当数据准备好后，内核给进程发送一个<code>SIGIO</code>信号，应用程序开始<strong>执行系统调用</strong>执行IO操作。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/signal-io.jpg"></p><p>这种模型的优势在于等待数据达到期间，进程不被阻塞。只需要等待信号处理函数的通知。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>AIO的基本流程是：用户线程通过系统调用，告知内核启动某个IO操作，用户线程随即返回。内核在整个IO操作（包括数据准备、数据复制）完成后，会通知用户程序，用户执行后续的业务操作。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/network-io/aio.jpg"></p><p>与信号驱动式IO的区别：信号驱动模型是由内核通知我们<strong>何时可以启动一个IO操作</strong>，而异步IO模型由内核通知我们<strong>IO操作何时完成</strong>。信号驱动IO更像半异步IO。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《UNIX网络编程》</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft论文阅读笔记</title>
    <link href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/raft-note/"/>
    <url>/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/raft-note/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Paxos算法较为复杂，并且不易于应用到工业界，因此诞生了Raft算法，其首要目标是可理解性，Raft算法主要分解为几个部分：领导者选举、日志复制、安全性、成员变更等。Raft算法有一些独特的特性：</p><ul><li>强领导者：日志entry只从领导者发送给其他服务器</li><li>领导者选举：Raft算法采用一个随即计时器来选举领导人</li><li>成员关系调整：Raft算法采用一种共同一致的方法来处理集群成员变换的问题，此时集群依然可以工作。</li></ul><h3 id="属性解释"><a href="#属性解释" class="headerlink" title="属性解释"></a>属性解释</h3><p><strong>状态</strong></p><h4 id="所有服务器上的持久性状态"><a href="#所有服务器上的持久性状态" class="headerlink" title="所有服务器上的持久性状态"></a>所有服务器上的持久性状态</h4><p>(在响应 RPC 请求之前，已经更新到了稳定的存储设备)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）</td></tr><tr><td>votedFor</td><td>当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空</td></tr><tr><td>log[]</td><td>日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1）</td></tr></tbody></table><h4 id="所有服务器上的易失性状态"><a href="#所有服务器上的易失性状态" class="headerlink" title="所有服务器上的易失性状态"></a>所有服务器上的易失性状态</h4><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知已提交的最高的日志条目的索引（初始值为0，单调递增）</td></tr><tr><td>lastApplied</td><td>已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><h4 id="领导人（服务器）上的易失性状态"><a href="#领导人（服务器）上的易失性状态" class="headerlink" title="领导人（服务器）上的易失性状态"></a>领导人（服务器）上的易失性状态</h4><p>(选举后已经重新初始化)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1）</td></tr><tr><td>matchIndex[]</td><td>对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><h4 id="追加条目（AppendEntries）RPC："><a href="#追加条目（AppendEntries）RPC：" class="headerlink" title="追加条目（AppendEntries）RPC："></a><strong>追加条目（AppendEntries）RPC</strong>：</h4><p>由leader调用，用于日志条目的复制，同时也被当做心跳使用</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期</td></tr><tr><td>leaderId</td><td>领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人）</td></tr><tr><td>prevLogIndex</td><td>紧邻新日志条目之前的那个日志条目的索引</td></tr><tr><td>prevLogTerm</td><td>紧邻新日志条目之前的那个日志条目的任期</td></tr><tr><td>entries[]</td><td>需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个）</td></tr><tr><td>leaderCommit</td><td>领导人的已知已提交的最高的日志条目的索引</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期，对于领导人而言 它会更新自己的任期</td></tr><tr><td>success</td><td>如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true</td></tr></tbody></table><h5 id="receiver的实现"><a href="#receiver的实现" class="headerlink" title="receiver的实现"></a>receiver的实现</h5><ul><li>如果<code>term &lt; currentTerm</code>， return false</li><li>在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则return false</li><li>如果一个已经存在的条目和新条目发生了冲突，那么就删除这个已经存在的条目以及它之后的所有条目</li><li>追加的条目暂未存在日志中</li><li>如果<code>leaderCommit &gt; commitIndex</code>，设置commitIndex &#x3D; min(leaderCommit, index of last new entry)</li></ul><h4 id="请求投票（RequestVote）RPC："><a href="#请求投票（RequestVote）RPC：" class="headerlink" title="请求投票（RequestVote）RPC："></a><strong>请求投票（RequestVote）RPC</strong>：</h4><p>由候选人负责调用用来征集选票（5.2 节）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>候选人的任期号</td></tr><tr><td>candidateId</td><td>请求选票的候选人的 ID</td></tr><tr><td>lastLogIndex</td><td>候选人的最后日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最后日志条目的任期号</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号，以便于候选人去更新自己的任期号</td></tr><tr><td>voteGranted</td><td>候选人赢得了此张选票时为真</td></tr></tbody></table><h5 id="receiver的实现-1"><a href="#receiver的实现-1" class="headerlink" title="receiver的实现"></a>receiver的实现</h5><ul><li>如果<code>term &lt; currentTerm</code>， return false</li><li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他</li></ul><h4 id="服务器规则"><a href="#服务器规则" class="headerlink" title="服务器规则"></a>服务器规则</h4><h5 id="所有服务器"><a href="#所有服务器" class="headerlink" title="所有服务器"></a>所有服务器</h5><ul><li>如果<code>commitIndex &gt; lastApplied</code>，则 lastApplied 递增，并将<code>log[lastApplied]</code>应用到状态机中</li><li>如果接收到的 RPC 请求或响应中，任期号<code>T &gt; currentTerm</code>，则令 <code>currentTerm = T</code>，并切换为跟随者状态</li></ul><h5 id="跟随者"><a href="#跟随者" class="headerlink" title="跟随者"></a>跟随者</h5><ul><li>响应来自候选人和领导人的请求</li><li>如果在超过选举超时时间的情况之前没有收到<strong>当前领导人</strong>（即该领导人的任期需与这个跟随者的当前任期相同）的心跳&#x2F;附加日志，或者是给某个候选人投了票，就自己变成候选人</li></ul><h5 id="候选者"><a href="#候选者" class="headerlink" title="候选者"></a>候选者</h5><ul><li>在转变成候选人后就立即开始选举过程<ul><li>自增当前的任期号（currentTerm）</li><li>给自己投票</li><li>重置选举超时计时器</li><li>发送请求投票的 RPC 给其他所有服务器</li></ul></li><li>如果接收到大多数服务器的选票，那么就变成领导人</li><li>如果接收到来自新的领导人的附加日志（AppendEntries）RPC，则转变成跟随者</li><li>如果选举过程超时，则再次发起一轮选举</li></ul><h5 id="领导者"><a href="#领导者" class="headerlink" title="领导者"></a>领导者</h5><ul><li>一旦成为领导者，发送空的AppendEntries RPC给其他所有服务器，在一定的空余时间之后不停的重复发送，以防止跟随者超时。</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端</li><li>对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（<code>lastLogIndex ≥ nextIndex</code>），则发送从 nextIndex 开始的所有日志条目：<ul><li>如果成功，更新相应跟随者的nextIndex和matchIndex</li><li>如果因为日志不一致而失败，则nextIndex递减并重试</li></ul></li><li>假设存在 N 满足<code>N &gt; commitIndex</code>，使得大多数的 <code>matchIndex[i] ≥ N</code>以及<code>log[N].term == currentTerm</code> 成立，则令 <code>commitIndex = N</code></li></ul><h2 id="服务器节点状态"><a href="#服务器节点状态" class="headerlink" title="服务器节点状态"></a>服务器节点状态</h2><p>Raft集群中只有三种角色：领导者、候选者、跟随者。Raft算法中每一段任期只有一个领导者节点，每一段任期从一次选举开始，一个或多个候选者参加选举，赢得选举将在接下来的任期充当领导者。跟随者只响应其他服务器的请求。下图为三种状态的转换关系：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/raft-%E5%9B%BE4.png" alt="Raft节点状态变更关系"></p><h2 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h2><p>Raft 使用一种心跳机制来触发领导人选举。领导者节点会定期向其他节点发送心跳包，如果一个跟随者在一段时间没有接收到信息，这被称为选举超时，此时认为集群中没有可用领导者，并且该节点会发出选举。</p><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>跟随者增加自己的当前任期并且切换到候选者状态，然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选者会继续保持此状态直到出现以下三种事件：</p><ol><li>此候选者赢得了本次选举</li><li>其他服务器节点赢得本次选举</li><li>无节点赢得选举</li></ol><h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><ul><li>每个服务器最多会对一个任期号投出一次选票，按照先来先服务的原则，但是要求大多数的选票规则确保最多只有一个候选者赢得选举。</li><li>在等待投票的时候，候选者可能会从其他服务器接收到声明它为领导者的AppendEntries RPC，如果这个节点的任期号大于当前候选者的任期号，那么候选者承认领导者合法并回到跟随者状态，如果，否则拒绝本次RPC，并且保持候选者状态。</li><li>如果出现候选者票数一样，则增加当前任期号来开始一轮新的选举。（Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况）</li></ul><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>客户端的每一个请求，领导者节点都需要将该请求封装成一个entry，并且附加到日志中去，然后发起AppendEntries RPC给其他节点，让他们复制这个entry，复制完成后，领导者会将这个entry应用到它的状态机中，然后将执行结果返回给客户端。如果跟随者因为自身原因未完成，领导者会不断尝试发送RPC，直至所有跟随者存储了该entry。</p><p>每个entry由任期号和请求组成，任期号用于检查是否出现不一致的情况。如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/raft-%E5%9B%BE6.png"></p><p>领导者节点对每一个跟随者维护了一个 <strong>nextIndex</strong>参数，这表示下一个要发送给跟随者的日志entry的index值，当一个候选者成为领导者节点时，它将初始化所有的 <strong>nextIndex</strong>值为自己的最后一条entry的index + 1。当领导者一致性检查失败后，领导者就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导者和跟随者的日志达成一致。</p><blockquote><p>优化：算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以(返回)冲突条目的任期号和该任期号对应的最小索引地址。借助这些信息，领导人可以减小 nextIndex 一次性越过该冲突任期的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。</p></blockquote><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>Raft算法要求选举产生的新领导者拥有最全的日志entry，RequestVote RPC中包含了候选者的日志信息，通过相应的策略选择最全entry的候选者。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>集群需要满足以下条件：</p><blockquote><p>广播时间（broadcastTime）  &lt;&lt;  选举超时时间（electionTimeout） &lt;&lt;  平均故障间隔时间（MTBF）</p></blockquote><ul><li>广播时间：从一个服务器并行的发送RPC给集群中的其他服务器并接受响应的平均时间</li><li>选举超时时间：一次选举活动允许的最大时间</li><li>平均故障间隔时间：两次故障之间的平均时间</li></ul><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>几个方法：</p><ul><li>快照：将整个系统的状态以快照的形式写入到持久化存储中。然后到那个时间点之前的日志全部丢弃，快照技术被使用在 Chubby 和 ZooKeeper 中。</li><li>增量压缩：每次只对一小部分数据进行操作</li></ul><p><strong>安装快照 RPC</strong>：</p><p>由领导人调用以将快照的分块发送给跟随者。领导人总是按顺序发送分块。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 ID，以便于跟随者重定向请求</td></tr><tr><td>lastIncludedIndex</td><td>快照中包含的最后日志条目的索引值</td></tr><tr><td>lastIncludedTerm</td><td>快照中包含的最后日志条目的任期号</td></tr><tr><td>offset</td><td>分块在快照中的字节偏移量</td></tr><tr><td>data[]</td><td>从偏移量开始的快照分块的原始字节</td></tr><tr><td>done</td><td>如果这是最后一个分块则为 true</td></tr></tbody></table><table><thead><tr><th>结果</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号（currentTerm），便于领导人更新自己</td></tr></tbody></table><p><strong>接收者实现</strong>：</p><ol><li>如果<code>term &lt; currentTerm</code>就立即回复</li><li>如果是第一个分块（offset 为 0）就创建一个新的快照</li><li>在指定偏移量写入数据</li><li>如果 done 是 false，则继续等待更多的数据</li><li>保存快照文件，丢弃具有较小索引的任何现有或部分快照</li><li>如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复</li><li>丢弃整个日志</li><li>使用快照重置状态机（并加载快照的集群配置）</li></ol><h2 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h2><p>所有请求全部发送给领导者节点，如果请求的不是领导者节点，那么该节点会拒绝客户端请求，并且提供他最近接收到的领导者信息，如果领导者节点崩溃，那么客户端请求则超时，客户端之后重新挑选服务器。</p><p>其中只读的操作直接处理而不需要记录日志，需要几个措施防止脏读：</p><ul><li>领导者在任期开始的时候，需要在它的任期里提交一次entry，以保证自己的日志是最新的。</li><li>领导者节点在处理只读请求前需要检查自己是否被解除领导者身份。</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一致性算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bitcask论文阅读笔记</title>
    <link href="/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/bitcask/"/>
    <url>/2022/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/bitcask/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Bitcask是Riak分布式数据库使用的日志型存储模型，主要有以下几点特性：</p><ul><li>读写低延迟</li><li>高吞吐量，尤其是随机写</li><li>能处理大量的数据集而不降低性能</li><li>故障时快速恢复且不丢失数据</li><li>易于备份和恢复</li><li>易于理解的代码结构和数据格式</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="硬盘结构"><a href="#硬盘结构" class="headerlink" title="硬盘结构"></a>硬盘结构</h3><p>在给定的一段时间内，只有一个<code>active data file</code>能提供<code>append</code>（写入）功能，当该文件大小达到指定阈值时，则会创建一个新的<code>active data file</code>。每一个写入到file的entry结构如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/bitcask/entry.jpg" alt="Entry结构"></p><p>包括以下内容：</p><ul><li>crc：校验值</li><li>tstamp：记录写入该数据的时间</li><li>ksz：key_size</li><li>value_sz：value_size</li><li>key：key</li><li>value：value</li></ul><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>在写入之后，一个被称为<code>keydir</code>（hash table）的内存结构将被更新，每一个键映射到固定大小的结构中，包括了以下内容：</p><ul><li>file_id：去哪个文件查询</li><li>value_size：读取value多长的字节</li><li>value_position：value在文件中的位置</li></ul><p>每一次写操作发生，<code>keydir</code>都会进行原子性的更新。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>读取value的过程：</p><ol><li>查找keydir中的key，并读取<code>file_id</code>，<code>position</code>，<code>size</code>。</li><li>通过<code>file_id</code>找到对应的<code>data file</code>，再通过<code>position</code>和<code>size</code>字段找到entry中的value。</li></ol><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>由于删除操作并不会真正删除掉entry，只是将删除操作封装成entry写入文件，因此需要<code>merge</code>操作将所有的非<code>active</code>文件中entry遍历，并重组为一个新文件。同时生成一个<code>hint file</code>，用于存储<code>data file</code>的位置和大小。</p><blockquote><p>Q：hint file的作用是什么？</p></blockquote><p>A：每次进程重启时需要重建<code>keydir</code>，需要扫描所有的数据文件，因此使用<code>hint file </code>加速构建<code>keydir</code>的速度。</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储模型</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年6月</title>
    <link href="/2021/%E9%9A%8F%E7%AC%94/2021-6-summary/"/>
    <url>/2021/%E9%9A%8F%E7%AC%94/2021-6-summary/</url>
    
    <content type="html"><![CDATA[<h2 id="七月计划"><a href="#七月计划" class="headerlink" title="七月计划"></a>七月计划</h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul><li>概率论基础一轮</li><li>线代滚动复习，做880基础</li><li>高数强化，今年完成数二部分，做严选题并订正</li></ul><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><ul><li>每日单词400个 + 上一天阅读积累的单词短语，逐渐删除简单词。</li><li>每日一篇阅读理解，保证正确率，标记错误达到3个的文章。</li><li>每天一句阅读理解中的长难度翻译，提高翻译能力</li></ul><h3 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h3><ul><li>OS一轮结束</li><li>CA开头</li><li>有时间复习DS</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2021年5月</title>
    <link href="/2021/%E9%9A%8F%E7%AC%94/2021-5-summary/"/>
    <url>/2021/%E9%9A%8F%E7%AC%94/2021-5-summary/</url>
    
    <content type="html"><![CDATA[<h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><ul><li><del>每日复习单词400个</del></li><li><del>线代基础过两遍</del></li><li><del>高数二轮结束，准备第三轮。</del></li><li><del>880基础第一轮结束。</del></li><li>唐迟老师阅读方法论：进行到第五节课</li><li><del>王道数据结构第一轮结束。</del></li></ul><p>具体时间分配如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/2021/5/todo.jpg"></p><p>六月学习计划：</p><ul><li><p>巩固高数，每天做题，开始第三轮基础复习</p></li><li><p>巩固线代，每天做题，开始第三轮基础复习</p></li><li><p>完成校内期末考试（共七门）</p></li><li><p>中旬后，每天一篇阅读理解</p></li><li><p>中旬后，开始概率论基础学习</p></li><li><p>操作系统尽量完成第一轮复习</p></li><li><p>每日复习单词400个</p></li></ul><h3 id="锻炼计划"><a href="#锻炼计划" class="headerlink" title="锻炼计划"></a>锻炼计划</h3><ul><li><del>减到72KG</del></li><li><del>每次跑步3km以上，总里程达75km以上。</del></li><li><del>俯卧撑次数逐渐增加</del></li><li><del>卷腹</del></li><li><del>跑完拉伸</del></li><li><del>11:00-11:30睡觉</del></li></ul><p>目前体重71.5kg，五月跑步里程数100KM。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/2021/5/keep.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2021年4月</title>
    <link href="/2021/%E9%9A%8F%E7%AC%94/2021-4-summary/"/>
    <url>/2021/%E9%9A%8F%E7%AC%94/2021-4-summary/</url>
    
    <content type="html"><![CDATA[<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h2 id="工作-or-考研"><a href="#工作-or-考研" class="headerlink" title="工作 or 考研"></a>工作 or 考研</h2><p>还是考个研究生吧！</p><p>磨刀不误砍柴工 读完硕士再打工。</p><h2 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h2><h3 id="选择-1"><a href="#选择-1" class="headerlink" title="选择"></a>选择</h3><p>浙大这种级别的学校不太敢冲，本来春节期间想考科软，然后21届分数劝退。思考了很久，还是考学硕，看是否有机会读博。</p><p>选了几个学校：</p><ul><li>电子科技大学<ul><li>专业课：DS + OS，录取均分366</li><li>政英数专：</li><li>复试：C语言 + 面试（六门，包括编译原理）</li></ul></li><li>南京航空航天大学<ul><li>专业课：DS  + OS + 计组，均分352</li><li>计算机：70，67，105，107</li><li>软件工程：70，62，105，113</li><li>网络安全：69，62，109，112</li><li>复试：离散数学 + 编译原理</li></ul></li></ul><p>南航初试复试各占一半，复试挺重要。</p><p><strong>目标分数：70，70，120，120</strong></p><p>还是挺想去南京读书的。</p><h3 id="四月进度："><a href="#四月进度：" class="headerlink" title="四月进度："></a>四月进度：</h3><ul><li>5500单词开始第二轮</li><li>高数基础第二轮到多元微分学</li><li>线代开头</li><li>王道数据结构学完第三章</li></ul><p>具体时间分布如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/2021/4/todo.jpg"></p><p>五月计划：</p><ul><li>每日复习单词400个</li><li>线代基础过两遍</li><li>高数二轮结束，准备第三轮。</li><li>880基础第一轮结束。</li><li>唐迟老师阅读方法论。</li><li>王道数据结构第一轮结束。</li></ul><h2 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h2><p>四月天气较冷，总共跑了八次步。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/2021/4/keep.jpg"></p><p>五月锻炼计划：</p><ul><li>减到72KG</li><li>每次跑步3km以上，总里程达75km以上。</li><li>俯卧撑次数逐渐增加</li><li>卷腹</li><li>跑完拉伸</li><li>11:00-11:30睡觉</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-字符串刷题记录</title>
    <link href="/2021/%E7%AE%97%E6%B3%95/leetcode-string/"/>
    <url>/2021/%E7%AE%97%E6%B3%95/leetcode-string/</url>
    
    <content type="html"><![CDATA[<h3 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520. 检测大写字母"></a>520. 检测大写字母</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">detectCapitalUse</span><span class="hljs-params">(String word)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">char</span>[] arr = word.toCharArray();        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, low = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &lt; arr.length)&#123;            <span class="hljs-keyword">if</span>(arr[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span>)&#123;                low++;            &#125;<span class="hljs-keyword">else</span>&#123;                up++;            &#125;            i++;        &#125;        <span class="hljs-keyword">if</span>(up == arr.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(low == arr.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(up == <span class="hljs-number">1</span> &amp;&amp; arr[<span class="hljs-number">0</span>] &lt; <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;</code></pre></div><h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h3><p>经典问题，需要过滤非字符非数字。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        s = s.toLowerCase();        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s.length());        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span> ((c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)) &#123;                str.append(c);            &#125;        &#125;        <span class="hljs-keyword">return</span> str.toString().equals(str.reverse().toString());    &#125;</code></pre></div><h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h3><ul><li>首先计算出最短字符串的长度，这个长度就是外层循环的遍历次数。</li><li>内层逐个比较字符串的指定位置的值。</li><li>通过StringBuilder拼接公共前缀。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>)             <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">minLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;        <span class="hljs-comment">//计算最短字符串长度</span>        <span class="hljs-keyword">for</span>(String str : strs)&#123;            <span class="hljs-keyword">if</span>(str.length() &lt; minLength)&#123;                minLength = str.length();            &#125;        &#125;        <span class="hljs-type">String</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; minLength; i++)&#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> demo.charAt(i);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; strs.length; j++)&#123;                <span class="hljs-keyword">if</span>(strs[j].charAt(i) != c)&#123;                    <span class="hljs-comment">//不等于</span>                    flag = <span class="hljs-literal">false</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(flag)&#123;                sb.append(c);                flag = <span class="hljs-literal">true</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;</code></pre></div><h3 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a>434. 字符串中的单词数</h3><p>一轮遍历即可，判断依据是：<strong>当前值是空格，前一位非空格</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSegments</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        s = s.trim();        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;            <span class="hljs-comment">// 当前值是空格，前一位非空格</span>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-number">32</span> &amp;&amp; s.charAt(i - <span class="hljs-number">1</span>) != <span class="hljs-number">32</span>) &#123;                count++;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre></div><h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLastWord</span><span class="hljs-params">(String s)</span> &#123;        String[] s1 = s.split(<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">if</span>(s1.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> s1[s1.length -<span class="hljs-number">1</span>].length() == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : s1[s1.length -<span class="hljs-number">1</span>].length();    &#125;</code></pre></div><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            swap(s , left, right);            left++;            right--;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;        <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s[i];        s[i] = s[j];        s[j] = tmp;    &#125;</code></pre></div><h3 id="541-反转字符串Ⅱ"><a href="#541-反转字符串Ⅱ" class="headerlink" title="541 反转字符串Ⅱ"></a>541 反转字符串Ⅱ</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;        <span class="hljs-type">char</span>[] arr = s.toCharArray();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i+= <span class="hljs-number">2</span>*k)&#123;            <span class="hljs-comment">//每隔2k反转一次</span>            <span class="hljs-comment">//判断剩余字符</span>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> arr.length - i;            <span class="hljs-keyword">if</span>(rest &lt; k)&#123;               reverse(arr,i, arr.length - <span class="hljs-number">1</span>);             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rest &lt; <span class="hljs-number">2</span> * k &amp;&amp; rest &gt;= k)&#123;                reverse(arr,i, i + k - <span class="hljs-number">1</span>);            &#125;<span class="hljs-keyword">else</span>&#123;                reverse(arr,i, i+k - <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> String.valueOf(arr);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = j;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            swap(s , left, right);            left++;            right--;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;        <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s[i];        s[i] = s[j];        s[j] = tmp;    &#125;</code></pre></div><h3 id="557-反转字符串中的单词Ⅲ"><a href="#557-反转字符串中的单词Ⅲ" class="headerlink" title="557. 反转字符串中的单词Ⅲ"></a>557. 反转字符串中的单词Ⅲ</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;        String[] strs = s.split(<span class="hljs-string">&quot; &quot;</span>);        String[] reverseString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> [strs.length];        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(String str : strs)&#123;            reverseString[index++] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(str).reverse().toString();        &#125;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; strs.length; i++)&#123;            sb.append(reverseString[i]);            <span class="hljs-keyword">if</span>(i != reverseString.length - <span class="hljs-number">1</span>) sb.append(<span class="hljs-string">&quot; &quot;</span>);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;</code></pre></div><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;        s = s.trim();        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="hljs-string">&quot;\\s+&quot;</span>));        Collections.reverse(wordList);        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, wordList);    &#125;</code></pre></div><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-type">int</span>[] letter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c:s.toCharArray()) &#123;            letter[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;s.length() ; i++) &#123;            <span class="hljs-keyword">if</span>(letter[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre></div><h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a>389. 找不同</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(string s, string t)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s)&#123;            count[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : t)&#123;            count[ch - <span class="hljs-string">&#x27;a&#x27;</span>]--;            <span class="hljs-keyword">if</span>(count[ch - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ch;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;    &#125;</code></pre></div><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : magazine)&#123;            count[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : ransomNote)&#123;            count[ch - <span class="hljs-string">&#x27;a&#x27;</span>]--;            <span class="hljs-keyword">if</span>(count[ch - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;</code></pre></div><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s) cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : t) cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>]--;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> count : cnt) <span class="hljs-keyword">if</span>(count != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;</code></pre></div><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><div class="code-wrapper"><pre><code class="hljs C++">vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;        vector&lt;vector&lt;string&gt;&gt; res;        map&lt;string, vector&lt;string&gt;&gt; map;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); i++)&#123;            string key = strs[i];            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());            map[key].<span class="hljs-built_in">push_back</span>(strs[i]);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ite = map.<span class="hljs-built_in">begin</span>(); ite != map.<span class="hljs-built_in">end</span>(); ite++) res.<span class="hljs-built_in">push_back</span>(ite-&gt;second);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="451-根据字符出现频率排序"><a href="#451-根据字符出现频率排序" class="headerlink" title="451. 根据字符出现频率排序"></a>451. 根据字符出现频率排序</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; map;        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s) map[c]++;        <span class="hljs-comment">//sort</span>        vector&lt;pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vec</span>(map.<span class="hljs-built_in">begin</span>(), map.<span class="hljs-built_in">end</span>());        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> &amp; a, <span class="hljs-keyword">auto</span> &amp; b)&#123;            <span class="hljs-keyword">return</span> a.second &gt; b.second;        &#125;);        string res;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : vec) res += <span class="hljs-built_in">string</span>(v.second,v.first);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="657-机器人能否返回原点"><a href="#657-机器人能否返回原点" class="headerlink" title="657. 机器人能否返回原点"></a>657. 机器人能否返回原点</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeCircle</span><span class="hljs-params">(string moves)</span> </span>&#123;        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> updown = <span class="hljs-number">0</span>, rightleft = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(index &lt;= moves.<span class="hljs-built_in">length</span>())&#123;            <span class="hljs-keyword">switch</span>(moves[index])&#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:                    rightleft++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:                    rightleft--;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;U&#x27;</span>:                    updown++;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:                    updown--;                    <span class="hljs-keyword">break</span>;            &#125;            index++;        &#125;        <span class="hljs-keyword">if</span>(updown == <span class="hljs-number">0</span> &amp;&amp; rightleft == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;</code></pre></div><h3 id="551-学生出勤记录Ⅰ"><a href="#551-学生出勤记录Ⅰ" class="headerlink" title="551. 学生出勤记录Ⅰ"></a>551. 学生出勤记录Ⅰ</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkRecord</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> late = <span class="hljs-number">0</span>, absent = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++)&#123;            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;                <span class="hljs-comment">//absent</span>                absent++;                late = <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span>(absent &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;                late++;                <span class="hljs-keyword">if</span>(late &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//P</span>                late = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;</code></pre></div><h3 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr()"></a>28. 实现strStr()</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;        <span class="hljs-keyword">if</span> ( needle == <span class="hljs-string">&quot;&quot;</span> )            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> hlen = haystack.<span class="hljs-built_in">length</span>();        <span class="hljs-type">int</span> nlen = needle.<span class="hljs-built_in">length</span>();        <span class="hljs-type">int</span> i,j;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;hlen;i++)&#123;            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;nlen;j++)                <span class="hljs-keyword">if</span>(haystack[i+j]!=needle[j])                    <span class="hljs-keyword">break</span>;      <span class="hljs-comment">//不符合就结束本轮匹配</span>            <span class="hljs-keyword">if</span>(j==nlen)                <span class="hljs-keyword">return</span> i;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;</code></pre></div><h3 id="8-字符串转换整数"><a href="#8-字符串转换整数" class="headerlink" title="8. 字符串转换整数"></a>8. 字符串转换整数</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; <span class="hljs-comment">// 遍历的游标</span>        <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;s[i]==<span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">// 去掉空白字符</span>        <span class="hljs-keyword">if</span>(i==s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果s为全空</span>                <span class="hljs-comment">// 处理第一个非空字符</span>        <span class="hljs-type">int</span> sign=<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;            sign=<span class="hljs-number">-1</span>;            i++;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;+&#x27;</span>)            i++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isdigit</span>(s[i]))            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 处理第一个数字字符</span>        <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(s[i])&amp;&amp;i&lt;s.<span class="hljs-built_in">size</span>())&#123;            <span class="hljs-keyword">if</span>((INT_MAX-(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>))/<span class="hljs-number">10.0</span>&lt;n) <span class="hljs-keyword">return</span> sign==<span class="hljs-number">-1</span>?sign*INT_MAX<span class="hljs-number">-1</span>:INT_MAX; <span class="hljs-comment">// 如果溢出</span>            n=<span class="hljs-number">10</span>*n+(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);            i++;        &#125;        <span class="hljs-keyword">return</span> sign*n;    &#125;</code></pre></div><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;        string result;        <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>() ? a.<span class="hljs-built_in">size</span>() : b.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());        <span class="hljs-built_in">reverse</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            <span class="hljs-type">int</span> ai = i &lt; a.<span class="hljs-built_in">size</span>() ? a[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;            <span class="hljs-type">int</span> bi = i &lt; b.<span class="hljs-built_in">size</span>() ? b[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;            <span class="hljs-type">int</span> val = (ai + bi + carry) % <span class="hljs-number">2</span>;            carry = (ai + bi + carry) / <span class="hljs-number">2</span>;            result.<span class="hljs-built_in">insert</span>(result.<span class="hljs-built_in">begin</span>(), val + <span class="hljs-string">&#x27;0&#x27;</span>);        &#125;        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) result.<span class="hljs-built_in">insert</span>(result.<span class="hljs-built_in">begin</span>(), <span class="hljs-string">&#x27;1&#x27;</span>);        <span class="hljs-keyword">return</span> result;    &#125;</code></pre></div><h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fizzBuzz</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        vector&lt;string&gt; res;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;            string tmp;            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">15</span> == <span class="hljs-number">0</span>)&#123;                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;FizzBuzz&quot;</span>);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)&#123;                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Buzz&quot;</span>);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)&#123;                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Fizz&quot;</span>);            &#125;<span class="hljs-keyword">else</span>&#123;                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(i));            &#125;                    &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a>299. 猜数字游戏</h3><p>需要注意数字出现的次数。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">getHint</span><span class="hljs-params">(string secret, string guess)</span> </span>&#123;        <span class="hljs-type">int</span> bull = <span class="hljs-number">0</span>, cow = <span class="hljs-number">0</span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; guess.<span class="hljs-built_in">size</span>(); i++)&#123;            <span class="hljs-keyword">if</span>(guess[i] == secret[i])&#123;                bull++;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//当前位置不一致，需要判断当前字符是否出现在secret里面</span>                <span class="hljs-comment">//通过vector存储数字出现次数</span>                <span class="hljs-keyword">if</span>(num[secret[i] - <span class="hljs-string">&#x27;0&#x27;</span>]++ &lt; <span class="hljs-number">0</span>) cow++;                <span class="hljs-keyword">if</span>(num[guess[i] - <span class="hljs-string">&#x27;0&#x27;</span>]-- &gt; <span class="hljs-number">0</span>) cow++;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(bull) + <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-built_in">to_string</span>(cow) + <span class="hljs-string">&#x27;B&#x27;</span>;    &#125;</code></pre></div><h3 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="506. 相对名次"></a>506. 相对名次</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findRelativeRanks</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; org = score;        <span class="hljs-built_in">sort</span>(score.<span class="hljs-built_in">rbegin</span>(), score.<span class="hljs-built_in">rend</span>());        unordered_map&lt;<span class="hljs-type">int</span>, string&gt; order;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; score.<span class="hljs-built_in">size</span>(); i++)&#123;            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">3</span>) order[score[i]] = <span class="hljs-built_in">to_string</span>(i+ <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) order[score[i]] = <span class="hljs-string">&quot;Gold Medal&quot;</span>;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) order[score[i]] = <span class="hljs-string">&quot;Silver Medal&quot;</span>;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) order[score[i]] = <span class="hljs-string">&quot;Bronze Medal&quot;</span>;        &#125;        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">res</span><span class="hljs-params">(score.size(), <span class="hljs-string">&quot;&quot;</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++)&#123;            res[i] = order[org[i]];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="539-最小时间差"><a href="#539-最小时间差" class="headerlink" title="539. 最小时间差"></a>539. 最小时间差</h3><ul><li>将时间转换成分钟。</li><li>注意钟表是模运算。</li></ul><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinDifference</span><span class="hljs-params">(vector&lt;string&gt;&amp; timePoints)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; q;        <span class="hljs-type">int</span> res = INT_MAX;        <span class="hljs-keyword">for</span>(string t : timePoints)&#123;            <span class="hljs-type">int</span> hour = <span class="hljs-number">10</span> * (t[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + t[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;            <span class="hljs-type">int</span> min = <span class="hljs-number">10</span> * (t[<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) + t[<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;            q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span> * hour + min);        &#125;        <span class="hljs-built_in">sort</span>(q.<span class="hljs-built_in">begin</span>(), q.<span class="hljs-built_in">end</span>());        q.<span class="hljs-built_in">push_back</span>(q[<span class="hljs-number">0</span>] + <span class="hljs-number">24</span> * <span class="hljs-number">60</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; q.<span class="hljs-built_in">size</span>(); i++)&#123;            res = <span class="hljs-built_in">min</span>(res, q[i] - q[i - <span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="553-最优除法"><a href="#553-最优除法" class="headerlink" title="553. 最优除法"></a>553. 最优除法</h3><p>题解：<strong>被除数不变，除数最小</strong>，如果能理解这个数学知识，那么就是一道easy难度的题目。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">optimalDivision</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">0</span>]);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">0</span>]) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">to_string</span>(nums[<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(to_string(nums[<span class="hljs-number">0</span>]) + <span class="hljs-string">&quot;/(&quot;</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;            res += <span class="hljs-built_in">to_string</span>(nums[i]) + <span class="hljs-string">&quot;/&quot;</span>;        &#125;        res += <span class="hljs-built_in">to_string</span>(nums.<span class="hljs-built_in">back</span>()) + <span class="hljs-string">&quot;)&quot;</span>;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        String res = <span class="hljs-string">&quot;1&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;            StringBuilder temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; res.<span class="hljs-built_in">length</span>(); j++)&#123;                <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span>(j + <span class="hljs-number">1</span> &lt; res.<span class="hljs-built_in">length</span>() &amp;&amp; res.<span class="hljs-built_in">charAt</span>(j) == res.<span class="hljs-built_in">charAt</span>(j + <span class="hljs-number">1</span>))&#123;                    j++;                    count++;                &#125;                temp.<span class="hljs-built_in">append</span>(count).<span class="hljs-built_in">append</span>(res.<span class="hljs-built_in">charAt</span>(j));            &#125;            res = temp.<span class="hljs-built_in">toString</span>();        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统理论笔记</title>
    <link href="/2021/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>分布式系统面临的问题：</p><ul><li><strong>数据一致性</strong>：数据均匀分布到多个存储节点，如何保证多个副本的数据一致性问题。</li><li><strong>集群可用性</strong>：集群的服务是否可用。</li><li><strong>分区容错性</strong>：当发生故障，集群如何快速恢复从而提供正常服务。</li></ul><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><p>存在恶意节点行为的场景中（数字货币的区块链技术中）：必须使用拜占庭容错算法（BFT）。常用的有PBFT算法、PoW算法。</p><p>计算机分布式系统中，最常用的是非拜占庭容错算法，即故障容错算法（CFT）。<strong>CFT解决的是分布式系统中存在故障，但不存在恶意节点的场景下的共识问题</strong>。这个场景可能会丢失信息、消息重复问题，但是不存在错误消息，或者伪造消息的情况。常见算法有Paxos算法、Raft算法、ZAB协议。</p><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><blockquote><p>Q：如何设计分区容错一致性模型？</p></blockquote><h3 id="CAP三指标"><a href="#CAP三指标" class="headerlink" title="CAP三指标"></a>CAP三指标</h3><ul><li><p>一致性（Consistency）</p><ul><li>强调的是数据在集群中的一致性。</li><li>客户端每次的读操作，无论访问哪个节点，要么读到同一份数据，要么读取失败。</li></ul></li><li><p>可用性（Availability）</p><ul><li>强调的是服务可用，但不保证数据的一致。</li><li>无论客户端访问哪个节点，都能得到响应数据，但是不保证数据是最新的。</li></ul></li><li><p>分区容错性（Partition Tolerance）</p><ul><li><p>强调的是集群对分区故障的容错能力。</p></li><li><p>节点出现任意数量的消息丢失或高延迟，系统仍然可以继续提供服务。</p></li></ul></li></ul><h3 id="CAP不可能三角"><a href="#CAP不可能三角" class="headerlink" title="CAP不可能三角"></a>CAP不可能三角</h3><p>对于一个分布式系统而言，一致性、可用性、分区容错性三个指标不可兼得，只能进行三选二。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/CAP/CAP-triangle.jpg" alt="CAP不可能三角"></p><h3 id="如何使用CAP理论"><a href="#如何使用CAP理论" class="headerlink" title="如何使用CAP理论"></a>如何使用CAP理论</h3><p>节点之间的分区故障是必然发生的，因此分区容错性（P）是必须要保证的。那么只剩下两种选择：</p><ul><li>CP：选择一致性（C）的时候，如果因为消息丢失、延迟过高发生了网络分区，部分节点无法保持一致，这时集群节点拒绝客户端的写操作。</li><li>AP：选择可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点无法返回最新特定信息。</li></ul><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>单机上实现ACID可以通过锁、时间序列等机制保障操作的顺序执行。分布式系统的ACID实现需要掌握分布式事务协议，比如二阶段提交协议、TCC（Try-Confirm-Cancel）。</p><p>可以将ACID特性理解为CAP中一致性的边界（最强的一致性），但是大部分场景对一致性的要求不是特别高，<strong>如果不是必须，尽量不要实现事务，可以考虑采用强一致性或最终一致性。</strong></p><h3 id="二阶段提交协议"><a href="#二阶段提交协议" class="headerlink" title="二阶段提交协议"></a>二阶段提交协议</h3><p>用于保证多个节点操作的原子性，也就是：<strong>要么多个节点的操作全部执行成功，要么全部失败。</strong></p><p>节点分为：</p><ul><li>协调者</li><li>参与者</li></ul><p>执行过程如下：</p><ul><li>提交请求阶段（投票阶段）<ul><li>每一个参与者投票表决事务是放弃还是提交，一旦参与者投票要求提交事务，那么不允许中途放弃事务，这个特性需要代码实现时保障的。</li></ul></li><li>提交执行阶段（完成阶段）<ul><li>事务的每个参与者执行最终统一的决定，提交事务或者放弃事务，这个约定是为了实现ACID中的原子性。</li></ul></li></ul><p>存在的问题：</p><ul><li>提交请求阶段，需要预留资源，在资源预留时期，其他人不能操作。</li><li>数据库是独立的系统。无法动态调整锁的粒度，并发性能下降。</li></ul><h3 id="TCC（Try-Confirm-Cancel）"><a href="#TCC（Try-Confirm-Cancel）" class="headerlink" title="TCC（Try-Confirm-Cancel）"></a>TCC（Try-Confirm-Cancel）</h3><ul><li>Try（预留）：预留相关资源</li><li>Confirm（确认）：确认操作，完成分布式事务。</li><li>Cancel（撤销）：如果无法操作，则进行撤销操作。</li></ul><p>TCC本质上是补偿事务，核心思想是针对每个操作都要注册一个与之对应的确认操作和撤销操作。它是一个业务层面的协议。在业务中实现分布式事务。对业务代码的侵入性较高。实现的复杂度更高。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论是CAP理论中的AP的延伸，是互联网大规模分布式系统的实践总结，强调可用性。BASE理论的核心就是：</p><ul><li>基本可用（Basically Available）</li><li>最终一致性（Eventually Consistent）</li></ul><h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>当分布式系统出现不可预知的故障时，允许损失部分功能的可用性，保证核心功能的可用性。例如：</p><ul><li><strong>延迟响应</strong>：12306购票系统出现突发流量时，会将购票请求放入队列中进行排队等待处理，通过牺牲响应时间的可用性，保障核心功能的运行。</li><li><strong>流量削峰</strong>：在不同的时间，出售不同的票，将请求错开，削弱请求峰值。</li><li><strong>体验降级</strong>：大流量情况，通过降低图片的清晰度和大小，提升系统的处理能力。</li><li><strong>过载保护</strong>：请求排队时，如果请求等待时间超时，这时直接拒绝超时请求。或者队列满了之后，清除队列中一定数量的排队请求，保证系统不过载，实现系统的基本可用。</li></ul><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>​系统中所有的数据副本在经过一段时间的同步后，最终能达到一个一致的状态。这存在一个短暂的延迟。几乎所有的互联网系统采用的都是最终一致性，只有实在无法使用最终一致性，才使用强一致性或分布式事务。对于金融系统，需要考虑分布式事务。</p><p>​如何实现最终一致性？</p><ul><li>以最新写入的数据为准，比如AP模型的KV存储采用的是这种方式。</li><li>以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准。</li></ul><p>​如何实现最终一致性？</p><ul><li>读时修复：在读取数据时，检测数据的不一致，进行修复。</li><li>写时修复：在写入数据，检测数据的不一致，进行修复。<ul><li>写时修复不需要做数据一致性对比，性能消耗较低，对系统运行影响不大，推荐使用。</li></ul></li><li>异步修复：最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul><h2 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h2><p>分布式系统中存在以下问题：</p><ol><li><strong>服务器宕机</strong>：内存错误、停电等原因，服务器重启后需要进行数据恢复，因此需要考虑对数据进行持久化。</li><li><strong>网络异常</strong>：消息丢失、消息乱序（UDP）等原因。<ul><li><strong>网络分区</strong>：集群中的节点被划分成多个区域，每个区域内可以通信，区域间不乏通信。</li><li>设计原则：网络不可靠，任何消息都要收到回复才能认为发送成功。</li></ul></li><li>磁盘故障：磁盘损坏和磁盘数据错误。<ul><li>数据需要冗余存储，防止磁盘损坏。</li><li>使用<strong>校验和机制</strong>来解决数据错误问题。</li></ul></li><li>超时：RPC通信时，指定时间未收到信息而判断超时。<ul><li>设计原则：需要将操作设计为<strong>幂等</strong>的（执行一次和执行多次结果相同），这样发生超时重试不会出现错误。</li></ul></li></ol><h2 id="一致性定义"><a href="#一致性定义" class="headerlink" title="一致性定义"></a>一致性定义</h2><p>两个角度思考一致性：</p><ul><li>用户：客户端读写操作是否一致。</li><li>服务：系统中多个副本之间数据是否一致。</li></ul><h3 id="客户端角度"><a href="#客户端角度" class="headerlink" title="客户端角度"></a>客户端角度</h3><p>主要有三种一致性：</p><ul><li>强一致性：节点A写入了一个值，后续节点读取到都将返回最新值。</li><li>弱一致性：无法保证后续读操作能读取到最新值。</li><li>最终一致性：能保证在一段时间后，读取到最新值。</li></ul><h3 id="服务端角度"><a href="#服务端角度" class="headerlink" title="服务端角度"></a>服务端角度</h3><ul><li>副本一致性：多个副本之间的数据保证一致性。</li><li>更新顺序一致性：多个副本之间是否按照相同顺序执行更新操作。</li></ul><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><ul><li>哈希分区</li><li>一致性哈希</li><li>顺序分布</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当前最常用的一批共识算法是基于该算法改进的。例如Fast Paxos算法、Cheap Paxos算法、Raft算法、ZAB协议等。</p><p>兰伯特提出的Paxos算法包含两个部分：</p><ul><li>Basic Paxos：描述的是多节点之间如何就某个Value达成共识。</li><li>Multi-Paxos：描述的是执行多个Basic Paxos实例，就一系列值达成共识。</li></ul><p>Basic Paxos是Multi-Paxos思想的核心，Multi-Paxos是多执行几次Basic Paxos。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们要实现一个分布式集群，集群有节点A、B、C构成，提供只读KV存储服务。一个节点创建只读变量后就无法修改它。所有节点必须对只读变量的值达成共识，然后所有节点一起创建这个只读变量。</p><p>那么当多个客户端试图创建同一个只读变量，例如client 1执行<code>set x = 3</code>，client 1执行<code>set x = 7</code>，那么分布式集群如何达成共识？</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/question.jpg"></p><h3 id="Basic-Paxos中的三种角色"><a href="#Basic-Paxos中的三种角色" class="headerlink" title="Basic Paxos中的三种角色"></a>Basic Paxos中的三种角色</h3><ul><li>提议者（Proposer）：提议一个值，用于投票表决。一般是集群中接收到客户端请求的节点。</li><li>接收者（Acceptor）：对每个提议的值进行投票，并存储接受的值。一般来说，集群中所有节点都是扮演接受者的角色，参与共识协商，并接受和存储数据。</li><li>学习者（Learner）：被告知投票的结果，接受达成共识的值，存储保存，不参与投票的过程。一般来说，学习者是数据备份节点，容灾备份。</li></ul><p>三种角色代表三种功能：</p><ul><li>提议者代表的是接入和协调功能，收到客户端请求后，发起二阶段提交，进行共识协商。</li><li>接受者代表投票协商和存储数据，对提议的值进行投票，并接受达成共识的值，进行存储保存。</li><li>学习者代表存储数据，不参与共识协商，只接受达成共识的值，存储保存。</li></ul><h3 id="如何达成共识？"><a href="#如何达成共识？" class="headerlink" title="如何达成共识？"></a>如何达成共识？</h3><p>在Basic Paxos中，用提案代表一个提议，除了提案编号，还包括提议值。使用<code>[n, v]</code>代表一个提案，其中n为提案编号，v为提议值。</p><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>client 1、2作为提议者，分别向所有接受者发送包含提案编号的请求。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/prepare.jpg"></p><p>当节点A、B接收到提案编号为1的准备请求，C收到提案编号为5的准备请求，将这样处理：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/prepare-2.jpg"></p><ul><li>由于之前未通过任何提案，节点A、B将返回一个<strong>尚无提案</strong>的响应，这是告诉提议者，之前没有通过任何提案，并承诺以后不再响应提案编号小于等于1的准备请求，不会通过小于5的提案。</li><li>节点C也是入磁，返回一个<strong>尚无提案</strong>的响应，并承诺不响应提案编号小于等于5的请求，不会通过编号小于5的提案。</li></ul><p>当节点A、B接收到提案编号为5的准备请求，节点C收到提案编号为1的准备请求时，将这样处理：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/prepare-3.jpg"></p><ul><li>A、B接收到编号为5的提案时，因为编号5大于之前的编号1，并且两个节点都没有通过任何提案，所以返回一个<strong>尚无提案</strong>的响应，并承诺以后响应提案编号小于等于5的准备请求，不会通过编号小于5的提案。</li><li>C收到编号为1的准备请求时，由于小于编号5，所以丢弃该请求。</li></ul><h3 id="接受阶段"><a href="#接受阶段" class="headerlink" title="接受阶段"></a>接受阶段</h3><p>client1、2收到节点的响应后，会发送接受请求。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/accept.jpg"></p><ul><li>客户端1根据响应中提案编号最大的提案的值，设置接受请求中的值，由于响应是暂无提案，就把自己的提议值设置为提案的值，发送接受请求<code>[1,3]</code></li><li>客户端2收到准备响应后，根据响应中提案最大的值，设置请求中的值，由于A、B、C都是响应暂无提案，则将自己的提议值7作为提案值，发送接受请求<code>[5,7]</code>。</li></ul><p>当三个节点接收到客户端的接受请求后，会这样处理：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/accept-2.jpg"></p><ul><li>当节点A、B、C收到接受请求<code>[1,3]</code>的时候，由于提案编号1小于三个节点中能通过的提案的最小提案编号5，所以<code>[1,3]</code>将被拒绝。</li><li>当A、B、C收到接受请求<code>[5,7]</code>时，由于提案编号不小于三个节点承诺的能通过的提案的最小编号5，则通过提案<code>[5, 7]</code>。</li></ul><p>当提案被通过后，会通知给所有的学习者，当学习者发现大多数接受者都通过某个提案，那么它将接受该提案的值。</p><ul><li>Basic Paxos的容错能力，源自于大多数的约定。</li><li>Basic Paxos是通过二阶段提交的方式来达成共识的。</li><li>Basic Paxos还实现了容错，在少于一半节点出现故障时，集群也能工作。</li><li>本质上：提案编号的大小代表着<strong>优先级</strong>。</li><li>Basic Paxos只能就单个值达成共识。</li></ul><h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>由于Multi Paxos并没有提供实现细节，导致每个人实现的不一样，例如Chubby的Multi-Paxos实现、Raft算法、ZAB协议等。</p><p><strong>Multi Paxos是一种思想，它指的是基于Multi Paxos思想，通过多个Basic Paxos实例实现一系列值的共识算法。</strong></p><p>多次执行Basic Paxos实例，实现共识的问题：</p><ul><li>如果多个提议者同时提交提案，可能出现提案冲突，在准备阶段没有提议者接收到大多数准备响应，需要重新协商。</li><li>两轮RPC通信往返消息多、延迟大，需要考虑优化。</li></ul><h3 id="领导者"><a href="#领导者" class="headerlink" title="领导者"></a>领导者</h3><p>可以引入领导者节点，它作为唯一提议者，这样就不存在提案冲突的现象。</p><p><strong>在论文中，作者并没有说如何选举领导者，需要我们实现Multi Paxos算法时自己实现。</strong></p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/leader.jpg"></p><h3 id="优化Basic-Paxos执行"><a href="#优化Basic-Paxos执行" class="headerlink" title="优化Basic Paxos执行"></a>优化Basic Paxos执行</h3><p><strong>当leader处于稳定状态，省略掉准备阶段，直接进入接受阶段。</strong>leader节点中，序列中的命令都是最新的。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/leader-1.jpg"></p><h3 id="Chubby的Multi-Paxos实现"><a href="#Chubby的Multi-Paxos实现" class="headerlink" title="Chubby的Multi Paxos实现"></a>Chubby的Multi Paxos实现</h3><p>在Chubby中，主节点通过执行Basic Paxos算法，进行投票选举产生的，并且在运行过程中，主节点会通过不断续租的方式来延长租期。如果主节点出现故障，其他节点又会投票选举出新的主节点。</p><p>Chubby也实现了上述的优化机制。实现了成员变更（Group membership），以此保证节点变更的时候集群的平稳运行。</p><p>在Chubby中，为了实现强一致性，操作只能在主节点上执行。</p><ul><li>所有的读写请求都在主节点处理，当主节点接收到写请求时，作为提议者，执行Basic Paxos实例，将数据发送给所有的节点，并且大多数节点接受了这个写请求之后，再响应给客户端成功。</li><li>当主节点接收到读请求，只需要主节点查询本地数据。</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/paxos/chubby.jpg"></p><h2 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h2><p>Raft算法属于Multi-Paxos算法，做了简化和限制。Raft算法是现在分布式系统开发首选的共识算法。本质上说：<strong>Raft算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。</strong></p><blockquote><p>Q：如何保证同一个时间，集群中只有一个领导者？</p></blockquote><h3 id="节点身份"><a href="#节点身份" class="headerlink" title="节点身份"></a>节点身份</h3><ul><li>Leader：一切以领导者为准，主要工作为三部分：<ol><li>处理写请求</li><li>管理日志复制</li><li>发送心跳信息，告知其他节点自己还活着。</li></ol></li><li>Follower：默默接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，会主动站出来，推荐自己当候选人。</li><li>Candidate：候选人向其他节点发送请求投票RPC消息，通知其他节点来投票，如果赢得了投票，就晋升为领导者。</li></ul><h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><p>初始状态如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/status.jpg"></p><p>Raft算法实现了<strong>随机超时时间</strong>（每个节点等待leader节点心跳信息的超时时间间隔是随机的）。</p><p>当节点超过自己的随机超时时间，节点会增加自己的任期编号，并推举自己为候选人，先给自己投一张选票，然后向其它节点发送请求投票的RPC消息。请他们选举自己为leader。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/vote.jpg"></p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/vote2.jpg"></p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/success.jpg"></p><h4 id="节点之间如何通信？"><a href="#节点之间如何通信？" class="headerlink" title="节点之间如何通信？"></a>节点之间如何通信？</h4><p>通信采用RPC，在领导者选举过程中。通常用到两类RPC：</p><ul><li>请求投票RPC，由候选人在选举期间发起，通知各节点进行投票。</li><li>日志复制RPC：由领导者发起，用来复制日志和提供心跳信息。</li></ul><h4 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h4><p>Raft算法中的领导者有任期，每个任期由单调递增的数字标识（任期编号）.</p><ul><li>Follower在等待leader心跳信息超时后，推举自己为candidate时，会增加自己的任期号，比如节点A的当前任期编号为0，那么推举自己为candidate时，会将自己的任期编号增加为1.</li><li>如果一个节点发现自己的任期编号比其他节点小，那么它会更新自己的编号到较大的编号值，比如B的任期编号为0，当收到A的请求投票RPC消息时，因为消息中包含了A的任期编号，并且编号为1，那么B将自己的任期编号更改为1.</li></ul><p>Raft算法中的任期不只是时间段，会影响领导者选举和请求的处理。</p><ol><li>如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随着状态，比如分区错误恢复后，任期编号为3的领导者节点B，收到来自新领导者的任期编号为4的心跳信息，节点B会立即恢复成跟随者。</li><li>如果一个节点接收到包含任期较小的请求，那么它会直接拒绝这个请求。</li></ol><h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><p>主要有以下几点规则：</p><ol><li>领导者周期性发送心跳信息，阻止跟随者发送新的选举。</li><li>指定时间内，跟随着没有接收到领导者信息，它会认为当前没有领导者，并推举自己为候选人，发起领导者选举。</li><li>在选举中，赢得大多数投票的候选人，晋升为领导者。</li><li>在一个任期内，除非领导者心跳消息未接收到，其他节点才能发出新一轮的选举。</li><li>一次选举中，一个节点最多会对一个任期编号投出一张选票，按照先来先服务的规则进行投票。</li><li>任期编号相同时，日志完整性高的跟随者（最后一条日志项对应的任期编号更大）拒绝投票给日志完整性低的候选者。（<strong>换而言之：日志最完整的节点才能当选领导者</strong>）</li></ol><h4 id="随机超时时间"><a href="#随机超时时间" class="headerlink" title="随机超时时间"></a>随机超时时间</h4><p>Raft算法如何处理选举无效的问题？（未达到半数票，需要重新选举）</p><p>Raft算法巧妙使用随机选举超时时间的方法，把超时时间分散开来，在大多数情况下只有一个服务器节点先发起选举，这样能减少因为同时选举而导致选票被瓜分导致选举失败的情况。</p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>Raft算法中，副本数据是以日志的形式存在的，领导者接收到来自客户端写请求后，处理写请求的过程就是一个复制和提交日志项的过程。</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>日志由日志项构成，日志项是一种数据格式，主要包含用户指令，还包括一些附加信息，例如日志索引、任期编号。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/log-entry.jpg"></p><h4 id="如何复制日志"><a href="#如何复制日志" class="headerlink" title="如何复制日志"></a>如何复制日志</h4><ul><li><p>接收到客户端请求，领导者创建一个日志项，并附加到本地日志中。</p></li><li><p>领导者通过日志复制RPC消息，将日志项复制到集群其他节点上。</p></li><li><p>在复制到其他节点上时，领导者会将这条日志项提交到它的状态机中。</p></li><li><p>领导者将执行的结果返回给客户端。</p></li><li><p>当跟随者接收到心跳消息，或者新的日志复制RPC消息后，如果跟随着发现领导者已经提交某条日志项，而它还没提交，那么跟随着就将这条日志项提交到本地的状态机中。</p></li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/log.jpg"></p><h4 id="如何实现日志的一致"><a href="#如何实现日志的一致" class="headerlink" title="如何实现日志的一致"></a>如何实现日志的一致</h4><p>Raft算法中，以领导者的日志为准，来实现各节点日志的一致性。主要有以下两个步骤：</p><ul><li>首先，领导者通过日志复制RPC的一致性检查，找到跟随者节点上，与自己相同日志项的最大索引值，这个索引值之后的日志是不一致的。</li><li>然后领导者强制跟随者更新覆盖不一致的日志项。</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/process.jpg"></p><p>上图中PrevLogEntry表示<strong>当前要复制的日志项，前一条日志项的索引值</strong>，PrevLogTerm表示<strong>当前要复制的日志项，前一条日志项的任期编号。</strong></p><ol><li>领导者通过日志复制RPC消息，发送当前最新日志项到跟随者，消息的PrevLogEntry为7，PrevLogTerm为4</li><li>如果跟随者在它的日志中，找不到PrevLogEntry为7，PrevLogTerm为4的日志项，那么跟随者就会拒收新的日志项，并返回失败消息给领导者。</li><li>这时，领导者会递减要复制的日志项的索引值，发送新日志项给跟随者，这个消息的PrevLogEntry为6，PrevLogTerm为3。</li><li>如果跟随者在日志中，发现了[6,3]这个日志项，那么返回成功消息，这样领导者知道跟随者在这个位置与自己日志相同。</li><li>领导者通过日志复制RPC，复制并更新覆盖索引值之后的日志，最终实现各节点的日志一致。</li></ol><h3 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h3><p>当集群成员变更时，可能会出现多个领导者，Raft算法通过<strong>单节点变更</strong>来解决。</p><h4 id="单节点变更"><a href="#单节点变更" class="headerlink" title="单节点变更"></a>单节点变更</h4><p>通过一次变更一个节点实现成员变更，如果需要变更多个节点，那么则需要执行多次单节点变更。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/raft/single-node.jpg"></p><p>但是如果并发执行单节点变更，坑里出现一次单节点变更尚未完成，新的单节点变更又在执行，导致集群出现两个领导者的情况。</p><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>Q：Raft算法实现了分布式存储，但是集群性能约等于单机性能，，如果通过分集群来提升性能，那么会存在数据迁移的过程，一致性哈希主要解决数据迁移成本高的问题。</p><p>一致性哈希算法具有较好的容错性和可扩展性。</p><h4 id="哈希寻址"><a href="#哈希寻址" class="headerlink" title="哈希寻址"></a>哈希寻址</h4><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/hashing/hashing-1.jpg"></p><p>当需要对指定key的值进行读写的时候，通过下面两步进行寻址：</p><ul><li>首先：将key作为参数执行<code>c - hash()</code>计算哈希值，并确定此key在环上的位置。</li><li>然后，从这个位置沿着哈希环顺时针走，遇到第一个节点就是key对应的节点。</li></ul><p>如果现在一个节点存在故障，如上图，假设C出现故障，那么key-03的寻址将被重定位到A。</p><p>如果在B、C之前扩容一个D节点，那么受影响的仅仅是key-03会被重定位到D。</p><p>在哈希寻址中，如果节点过少，可能会导致节点分布不均匀，造成数据访问的冷热不均，如下图：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/hashing/pic.jpg"></p><p>该问题主要通过<strong>虚拟节点</strong>来解决。</p><p>对每个节点计算多个哈希值，在每个计算结果位置上，都放置一个虚拟节点，并将虚拟节点映射到实际节点。如下图：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/hashing/pic1.jpg"></p><ul><li>一致性哈希是一种特殊的哈希算法，节点增减变化时只影响到部分数据的路由寻址，因此只需要迁移部分数据。</li><li>节点数量较少时，可能出现节点在哈希环上分布不均匀的情况，导致节点的访问冷热不均。</li><li>一致性哈希算法本质是一种路由寻址算法，适合简单的路由寻址场景。</li></ul><h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p>用于实现最终一致性。利用一种随机、带有传染性的方式，将消息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p><p>三个主要功能：</p><ul><li>直接邮寄（Direct Mail）：直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。<ul><li>可能因为缓存队列满了而丢失数据。无法实现最终一致性。</li></ul></li><li>反熵（Anti-entropy）：本质上是通过异步修复实现最终一致性。<ul><li>本意是指集群中的节点，每隔一段时间就随机选择某个其它节点，然后通过交换自己所有数据来消除两者之间的差异，实现数据的最终一致性。</li><li>推、拉、推拉三种方式。</li><li>反熵需要节点两两交换数据，成本较高。可以通过引入校验和等机制，降低需要对比的数据量和通讯消息。</li><li>但是如果在节点数量动态变化的分布式环境下，反熵不适用。</li></ul></li><li>谣言传播（Rumor mongering）：一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其它节点向其发送新数据，直到所有的节点都存储了该数据。</li></ul><h2 id="Quorum-NWR算法"><a href="#Quorum-NWR算法" class="headerlink" title="Quorum NWR算法"></a>Quorum NWR算法</h2><p>Quorum NWR算法可以通过组合NWR三个元素来实现自定义一致性级别的。</p><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ul><li>N：代表集群中同一份数据有多少个副本。</li><li>W：写一致性级别，表示成功完成W个副本的更新，才完成写操作。</li><li>R：读一致性级别，表示读取一个数据对象时需要读R个副本。换而言之，读取R副本时，返回R个副本中最新的那份数据。</li></ul><p>NWR三者的不同组合，会产生不同的一致性效果：</p><ol><li>W + R &gt; N时，对于客户端来讲，一定能保证强一致性。</li><li>W + R &lt; N时，对于客户端来讲，能保证最终一致性。</li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-数组刷题记录</title>
    <link href="/2021/%E7%AE%97%E6%B3%95/leetcode-array/"/>
    <url>/2021/%E7%AE%97%E6%B3%95/leetcode-array/</url>
    
    <content type="html"><![CDATA[<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485. 最大连续1的个数"></a>485. 最大连续1的个数</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-comment">//res存储最长的子数组</span>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">//count记录的是每个被0隔断的子数组</span>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-comment">//如果当前元素是1，更新当前子数组的长度</span>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;                count++;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//遇到0，比较res, count的大小，并将count重置为0</span>                res = Math.max(res, count);                count = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-comment">//避免最后一个子数组是最大的情况，例如：1,0,1,1,0,1,1,1,1</span>        <span class="hljs-keyword">return</span> Math.max(res, count);    &#125;</code></pre></div><h3 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a>495. 提莫攻击</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPoisonedDuration</span><span class="hljs-params">(<span class="hljs-type">int</span>[] timeSeries, <span class="hljs-type">int</span> duration)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; timeSeries.length; i ++)&#123;            <span class="hljs-comment">//当前能持续的时间</span>            <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> timeSeries[i] + duration -<span class="hljs-number">1</span>;            <span class="hljs-comment">//超过下一次攻击的时间</span>            <span class="hljs-keyword">if</span>(i != timeSeries.length -<span class="hljs-number">1</span> &amp;&amp; time &gt;= timeSeries[i + <span class="hljs-number">1</span>])&#123;                res += (timeSeries[i + <span class="hljs-number">1</span>] - timeSeries[i]);            &#125;<span class="hljs-keyword">else</span>&#123;                res += duration;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="第三大的数"><a href="#第三大的数" class="headerlink" title="第三大的数"></a>第三大的数</h3><p>时间复杂度要求$O(n)$，也就是只能通过一趟遍历完成。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">thirdMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] &gt;= nums[<span class="hljs-number">1</span>] ? nums[<span class="hljs-number">0</span>] : nums[<span class="hljs-number">1</span>];        &#125;        <span class="hljs-type">long</span> <span class="hljs-variable">firstMax</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;        <span class="hljs-type">long</span> <span class="hljs-variable">secondMax</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;        <span class="hljs-type">long</span> <span class="hljs-variable">thirdMax</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;    <span class="hljs-comment">//判断相等情况是避免相同数字,例如：[2, 2, 3, 1]</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;            <span class="hljs-keyword">if</span>(num &gt; firstMax) &#123;                thirdMax = secondMax;                secondMax = firstMax;                firstMax = num;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == firstMax) &#123;                <span class="hljs-keyword">continue</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &gt; secondMax)&#123;                thirdMax = secondMax;                secondMax = num;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == secondMax) &#123;                <span class="hljs-keyword">continue</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &gt; thirdMax)&#123;                thirdMax = num;            &#125;        &#125;        <span class="hljs-keyword">if</span>(thirdMax == Long.MIN_VALUE)&#123;            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)firstMax;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) thirdMax;        &#125;    &#125;</code></pre></div><h3 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a>628. 三个数的最大乘积</h3><p>偷🐔解法，需要注意考虑负数的情况。</p><p>时间复杂度为$O(nlogN)$。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        Arrays.sort(nums);        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;                <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">1</span>] * nums[nums.length - <span class="hljs-number">1</span>],                                 nums[nums.length - <span class="hljs-number">1</span>] * nums[nums.length - <span class="hljs-number">2</span>] * nums[nums.length - <span class="hljs-number">3</span>]);    &#125;</code></pre></div><p>如果使用一趟遍历的方法，那么需要使用五个变量，分别保存最大的三个数，和最小的两个数。</p><h2 id="统计数组中的元素"><a href="#统计数组中的元素" class="headerlink" title="统计数组中的元素"></a>统计数组中的元素</h2><h3 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a>645. 错误的集合</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findErrorNums(<span class="hljs-type">int</span>[] nums) &#123;        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;            count[num - <span class="hljs-number">1</span>]++;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; count.length;i++)&#123;            <span class="hljs-keyword">if</span>(count[i] == <span class="hljs-number">2</span>)&#123;                res[<span class="hljs-number">0</span>] = i + <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count[i] == <span class="hljs-number">0</span>)&#123;                res[<span class="hljs-number">1</span>] = i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a>697. 数组的度</h3><p>三个<strong>HashMap</strong>的作用分别如下：</p><ul><li>left：数字第一次出现的索引</li><li>right：数字最后一次出现的索引</li><li>count：数字出现的次数</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findShortestSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        Map&lt;Integer, Integer&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(),            right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(), count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];            <span class="hljs-keyword">if</span> (left.get(x) == <span class="hljs-literal">null</span>) left.put(x, i);            right.put(x, i);            count.put(x, count.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums.length;        <span class="hljs-type">int</span> <span class="hljs-variable">degree</span> <span class="hljs-operator">=</span> Collections.max(count.values());        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: count.keySet()) &#123;            <span class="hljs-keyword">if</span> (count.get(x) == degree) &#123;                ans = Math.min(ans, right.get(x) - left.get(x) + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;</code></pre></div><h3 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h3><p><strong>HashMap</strong>做记录，再通过一轮遍历找到不存在的数字。</p><p>时间复杂度$O(n)$，空间复杂度$O(n)$。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        HashMap&lt;Integer, Boolean&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Boolean&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            map.put(nums[i], <span class="hljs-literal">true</span>);        &#125;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (!map.containsKey(i)) &#123;                res.add(i);            &#125;        &#125;          <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><p>如果使用时间复杂度$O(n)$，并不用额外的空间，可以通过添加标记来解决。</p><p>一轮遍历添加标记：能标识该数字出现过。</p><p>第二轮遍历查找没有做标记的数字。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (nums[i] - <span class="hljs-number">1</span>) % nums.length;            nums[index] += nums.length;        &#125;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &lt;= nums.length)&#123;                res.add(i + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h3><p>与上面一题异曲同工。使用标记法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (nums[i] - <span class="hljs-number">1</span>) % nums.length;            nums[index] += nums.length;        &#125;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; nums.length * <span class="hljs-number">2</span>)&#123;                res.add(i + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h3><p>通过索引交换元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">while</span>((nums[i] &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] &lt;= nums.length) &amp;&amp; (nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]))&#123;                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];                nums[i] = nums[temp -<span class="hljs-number">1</span>];                nums[temp -<span class="hljs-number">1</span>] = temp;            &#125;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums.length + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span> (nums[i] != (i + <span class="hljs-number">1</span>)) &#123;                res = i + <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="274-H指数"><a href="#274-H指数" class="headerlink" title="274. H指数"></a>274. H指数</h3><p>偷🐔了一下，直接sort解决。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> citations.length;        Arrays.sort(citations);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> len - i;            <span class="hljs-keyword">if</span>(citations[i] &gt;= count)&#123;                <span class="hljs-keyword">return</span> count;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre></div><h2 id="数组的改变、移动"><a href="#数组的改变、移动" class="headerlink" title="数组的改变、移动"></a>数组的改变、移动</h2><h3 id="453-最小操作次数使数组元素相等"><a href="#453-最小操作次数使数组元素相等" class="headerlink" title="453. 最小操作次数使数组元素相等"></a>453. 最小操作次数使数组元素相等</h3><p>每次操作会使$n-1$个元素增加1  &#x3D;&#x3D; &gt;  每次操作让一个元素减去1</p><p>因此需要计算的次数就是：<strong>数组中所有元素（除去最小值）与最小值之间的差值。</strong></p><p>（Python的API用的舒服）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">minMoves</span>(<span class="hljs-params">self, nums</span>):        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>        minnum = <span class="hljs-built_in">min</span>(nums)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:            <span class="hljs-built_in">sum</span> += i - minnum        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span></code></pre></div><h3 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a>665. 非递减数列</h3><p>拐点不能出现两次，修复会有两种情况：</p><ul><li>nums[i - 2] &gt; nums[i]：将nums[i]改为nums[i - 1]</li><li>nums[i - 2] &lt;&#x3D; nums[i]：将nums[i - 1]改为nums[i]</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPossibility</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i&lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] &gt; nums[i])&#123;                count++;                <span class="hljs-keyword">if</span>(count &gt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">2</span>] &gt; nums[i])&#123;                    nums[i] = nums[i - <span class="hljs-number">1</span>];                &#125;<span class="hljs-keyword">else</span>&#123;                    nums[i - <span class="hljs-number">1</span>] = nums[i];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><p>通过<code>index</code>存储有效位。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;                nums[index++] = nums[i];            &#125;        &#125;        <span class="hljs-keyword">while</span> (index &lt; nums.length) &#123;            nums[index++] = <span class="hljs-number">0</span>;        &#125;    &#125;</code></pre></div><h2 id="二维数组及滚动数组"><a href="#二维数组及滚动数组" class="headerlink" title="二维数组及滚动数组"></a>二维数组及滚动数组</h2><h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;       List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++)&#123;            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();            list.add(<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++)&#123;                List&lt;Integer&gt; front = ans.get(i - <span class="hljs-number">1</span>);                list.add(front.get(j) + front.get(j -<span class="hljs-number">1</span>));            &#125;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;                list.add(<span class="hljs-number">1</span>);            &#125;            ans.add(list);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;</code></pre></div><h3 id="119-杨辉三角Ⅱ"><a href="#119-杨辉三角Ⅱ" class="headerlink" title="119. 杨辉三角Ⅱ"></a>119. 杨辉三角Ⅱ</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> rowIndex)</span> &#123;        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= rowIndex; i++)&#123;            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();            list.add(<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++)&#123;                List&lt;Integer&gt; front = ans.get(i - <span class="hljs-number">1</span>);                list.add(front.get(j) + front.get(j -<span class="hljs-number">1</span>));            &#125;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;                list.add(<span class="hljs-number">1</span>);            &#125;            ans.add(list);        &#125;        <span class="hljs-keyword">return</span> ans.get(rowIndex);    &#125;</code></pre></div><h3 id="598-范围求和Ⅱ"><a href="#598-范围求和Ⅱ" class="headerlink" title="598. 范围求和Ⅱ"></a>598. 范围求和Ⅱ</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] ops)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">minX</span> <span class="hljs-operator">=</span> m , minY = n;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ops.length; i++)&#123;            minX = Math.min(minX, ops[i][<span class="hljs-number">0</span>]);            minY = Math.min(minY, ops[i][<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> minX * minY;    &#125;</code></pre></div><h3 id="419-甲板上的战舰"><a href="#419-甲板上的战舰" class="headerlink" title="419. 甲板上的战舰"></a>419. 甲板上的战舰</h3><p>暴力判断：如果当前点是X，判断其左边和上边是否有X，没有则不连通，增加计数。</p><div class="code-wrapper"><pre><code class="hljs C">public <span class="hljs-type">int</span> <span class="hljs-title function_">countBattleships</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;board.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[i].length; j++)&#123;                <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;X&#x27;</span>)&#123;                    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; board[i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span> || j &gt; <span class="hljs-number">0</span> &amp;&amp; board[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) <span class="hljs-keyword">continue</span>;                    count++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre></div><h3 id="189-数组的旋转"><a href="#189-数组的旋转" class="headerlink" title="189. 数组的旋转"></a>189. 数组的旋转</h3><p>三轮reverse。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;        <span class="hljs-comment">//如果数组长度小于旋转次数，那么执行k次和执行k % length次结果一样</span>        k %= nums.length;        reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);        reverse(nums, k, nums.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;        <span class="hljs-keyword">while</span> (start &lt; end) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[start];            nums[start] = nums[end];            nums[end] = tmp;            start++;            end--;        &#125;    &#125;</code></pre></div><h3 id="396-旋转函数"><a href="#396-旋转函数" class="headerlink" title="396. 旋转函数"></a>396. 旋转函数</h3><p>可通过数学归纳法得到$F[k]&#x3D; F[k-1] + sum - n*A[n-k]$</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxRotateFunction</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> A.length;        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 统计数组所有数的和</span>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 计算 F(1) 的值</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : A) &#123;            max += count++ * i;            sum += i;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> max;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            tmp = tmp + sum - n * A[n - i];            max = Math.max(tmp, max);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;</code></pre></div><h2 id="特定顺序遍历二维数组"><a href="#特定顺序遍历二维数组" class="headerlink" title="特定顺序遍历二维数组"></a>特定顺序遍历二维数组</h2><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h3><p>抓住两个index的变化趋势，按照规律变化就行。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, down = m - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) res.add(matrix[up][i]);            <span class="hljs-keyword">if</span>(++up &gt; down) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> up; i &lt;= down; i++) res.add(matrix[i][right]);            <span class="hljs-keyword">if</span> (--right &lt; left) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) res.add(matrix[down][i]);            <span class="hljs-keyword">if</span> (--down &lt; up) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> down; i &gt;= up; i--) res.add(matrix[i][left]);            <span class="hljs-keyword">if</span>(++left &gt; right) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><h3 id="59-螺旋矩阵Ⅱ"><a href="#59-螺旋矩阵Ⅱ" class="headerlink" title="59. 螺旋矩阵Ⅱ"></a>59. 螺旋矩阵Ⅱ</h3><p>和上题一样。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, down = n - <span class="hljs-number">1</span>, left = <span class="hljs-number">0</span>, right = n -<span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) matrix[up][i] = num++;            <span class="hljs-keyword">if</span>(++up &gt; down) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> up; i &lt;= down; i++) matrix[i][right] = num++;            <span class="hljs-keyword">if</span> (--right &lt; left) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) matrix[down][i] = num++;            <span class="hljs-keyword">if</span> (--down &lt; up) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> down; i &gt;= up; i--) matrix[i][left] = num++;            <span class="hljs-keyword">if</span>(++left &gt; right) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> matrix;    &#125;</code></pre></div><h3 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a>498. 对角线遍历</h3><h2 id="二维数组变换"><a href="#二维数组变换" class="headerlink" title="二维数组变换"></a>二维数组变换</h2><h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a>566. 重塑矩阵</h3><p>笨方法，放入队列中，然后逐个按序取出。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrixReshape(<span class="hljs-type">int</span>[][] nums, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r][c];        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span> || r * c != nums.length * nums[<span class="hljs-number">0</span>].length)            <span class="hljs-keyword">return</span> nums;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        Queue &lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span> &lt; &gt; ();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums[<span class="hljs-number">0</span>].length; j++) &#123;                queue.add(nums[i][j]);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; r; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; c; j++) &#123;                res[i][j] = queue.remove();            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div><p>原地算法：</p><ul><li>$count$用于保存当前到第几个元素</li><li>$count &#x2F; c$用于计算当前是第几行，$count % c$用于计算当前是第几个。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrixReshape(<span class="hljs-type">int</span>[][] nums, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r][c];        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span> || r * c != nums.length * nums[<span class="hljs-number">0</span>].length)            <span class="hljs-keyword">return</span> nums;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums[<span class="hljs-number">0</span>].length; j++) &#123;                res[count / c][count % c] = nums[i][j];                count++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020总结</title>
    <link href="/2020/%E9%9A%8F%E7%AC%94/2020-summary/"/>
    <url>/2020/%E9%9A%8F%E7%AC%94/2020-summary/</url>
    
    <content type="html"><![CDATA[<h2 id="回首2020"><a href="#回首2020" class="headerlink" title="回首2020"></a>回首2020</h2><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>书籍主要包括：</p><ul><li><p>《深入理解Java虚拟机》</p></li><li><p>《MySQL技术内幕：InnoDB存储引擎》</p></li><li><p>《我的第一本算法书》</p></li><li><p>《算法图解》</p></li><li><p>《淘宝技术这十年》</p></li><li><p>《OSTEP》</p></li><li><p>《设计模式》</p></li><li><p>《Java并发编程的艺术》</p></li><li><p>《Redis设计与实现》</p></li><li><p>《漫画算法》</p></li><li><p>《CS:APP》</p></li></ul><p>其中看《SICP》的时候过于浮躁，没有坚持读下去。会在后续的空闲时间读完这部经典。</p><p>CSAPP阅读过程中并没有做出相应地阅读笔记，会准备在后续过程中读英文版，一方面强化专业知识，一方面提高英语阅读能力。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出主要是博客文章，主要是个人的学习笔记，包括以下几个系列：</p><ul><li>JVM</li><li>设计模式</li><li>MySQL</li><li>Redis底层原理</li><li>Java并发</li><li>Java集合源码分析</li><li>OSTEP阅读笔记</li></ul><h3 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h3><p>暑假前在Boss直聘上投了一家外包公司的暑期实习，通过两个月的<del>实习</del>（摸鱼），上午半天把当天的指派的任务完成，下午半天进行学习。通过实习了解了公司的开发流程，主要做了ES Client的API封装，提供给业务层调用。参与了直播APP的后端开发。完成了其中一个核心业务功能的代码重构。并完成了后期Bug修复任务。</p><p>可以说，这两个月的实习，一方面是专业技能上的提升，另一方面体会到了职场的无聊。上班通勤来回共两小时，赶地铁等，甚至可以说这次实习毁掉了我对工作的期待。有了此次的实习经历，甚至想从后端开发转到其它方向。</p><p>总结了一下产生这种心态的主要原因：</p><ul><li>重复工作产生无聊感</li><li>工作中的技术没有挑战性</li></ul><h3 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h3><p>今年接触了有关于政治、经济、哲学、历史方面的相关知识，这里要感谢一些老师：司马南老师、艾跃进老师、王德峰老师、温铁军老师、黄奇帆老师等。</p><p>曾经不能理解这些领域的重要性，做一个傻傻的工科男，在我21岁时，才发现：只有理解了这些方面的相关知识，才能更好的理解这个世界。</p><blockquote><p>世界是你们的，也是我们的，但是归根结底是你们的。你们青年人朝气蓬勃，正在兴旺时期，好像早晨八九点钟的太阳。希望寄托在你们身上。</p></blockquote><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><p>除去技术类书籍，今年还读了以下书籍：</p><ul><li>《亮剑》</li></ul><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><ul><li>《让子弹飞》</li><li>《大决战》系列</li></ul><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>今年主要在听：周杰伦、粤语、核、小雨乐队（点名表扬，粤剧+金属）、葬尸湖、俄语民谣、美国乡村民谣、Rap、国摇等。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>在2020-2021中，面临一种重要的选择：<strong>工作 or 考研</strong>。在看了无辄的栈（SJTU大佬），张天昀（NJU大佬 CS特奖）等博客时，其实有一些学历上的自卑，毕竟人家的选择是建立在华五的基础上的。</p><p>如果以双非本科的身份在大三下努力去拿个二三线公司的实习，并能在明年暑假前拿到提前批次的offer，那么其实也不错。只是，学历可能会成为以后职场上的一道坎。</p><p>考研对于我而言，主要还是学历镀金。父母也一直劝我先考研。而目前的我暂时无法量化考研难度，所以一直没能做出最终的选择。</p><p>可以说这学期一直在这两个选择中反复横跳。目前2020年12月份做的选择是：<strong>英语单词先背，重拾高数。复习408理论知识。</strong></p><h2 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h2><h3 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h3><p>寒假主要任务：</p><ul><li>水一篇EI论文</li><li>考研英语词汇</li><li>高等数学基础 + 做题</li><li>NJU ICS</li></ul><p>2021的主旋律应该是<strong>考研</strong>，只能说尽力弥补高考的遗憾吧，努力总不会白费。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce论文阅读笔记</title>
    <link href="/2020/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MapReduce-note/"/>
    <url>/2020/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MapReduce-note/</url>
    
    <content type="html"><![CDATA[<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>Google所面临的问题：大数据处理任务庞大，如何通过分布式系统完成并行计算、分发数据、处理错误？</p><p>为了解决这个问题，需要设计一个新的抽象模型，用来表述我们需要执行的计算。不用关心底层的实现细节，包括并行计算、容错、数据分布、负载均衡等方面。</p><h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><p>MapReduce编程模型的原理：利用一个输入的<strong>key&#x2F;value pair</strong>集合来产生一个输出的<strong>key&#x2F;value pair</strong>集合。</p><p>自定义的Map函数接受一个<strong>key&#x2F;value pair</strong>输入，然后产生一个中间<strong>key&#x2F;value pair</strong>集合。会将相同key和对应多个value值集合在一起传递给reduce函数。</p><p>自定义的Reduce函数接受上面的集合，合并这些value值，形成一个新的value值集合。</p><p>下面是一个计算大文档集合中每个单词出现的次数的案例：</p><div class="code-wrapper"><pre><code class="hljs processing"><span class="hljs-built_in">map</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-built_in">String</span> value):<span class="hljs-comment">//key : document name</span><span class="hljs-comment">//value: document contents</span>foreach word w in value:<span class="hljs-title function_">emitintermediate</span>(w, <span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-title function_">reduce</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, Iterator values):<span class="hljs-comment">//key : a word</span><span class="hljs-comment">//values: a list of counts</span><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;foreach v in values:result += <span class="hljs-title function_">ParseInt</span>(v);<span class="hljs-title function_">emit</span>(<span class="hljs-title function_">AsString</span>(result));</code></pre></div><p>Map计函数计算文档中<code>(word,count)</code>这样的<strong>key&#x2F;value pair</strong>，Reduce函数把Map函数产生的计数累加起来。</p><p>Map Reduce函数可以抽象成以下形式：</p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-keyword">map</span><span class="hljs-function"><span class="hljs-params">(k1, v1)</span> -&gt;</span> <span class="hljs-keyword">list</span>(k2, v2)reduce<span class="hljs-function"><span class="hljs-params">(k2, <span class="hljs-keyword">list</span>(v2))</span> -&gt;</span> <span class="hljs-keyword">list</span>(v2)</code></pre></div><h3 id="其他案例"><a href="#其他案例" class="headerlink" title="其他案例"></a>其他案例</h3><ul><li>分布式的grep：Map输出匹配某个模式的一行，Reduce将中间数据处理再输出。</li><li>计算URL访问频率：Map处理日志，输出<code>(URL, 1)</code>，Reduce将中间数据累加处理，产生<code>(URL, totalCount)</code>再输出。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>将输入数据自动分割成M块数据片段，Map函数在多台机器上并行处理。Reduce调用也是在多台机器上并行处理。MapReduce实现的全部流程如图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/distribute%20system/MapReduce/execution-overview.jpg"></p><h3 id="master数据结构"><a href="#master数据结构" class="headerlink" title="master数据结构"></a>master数据结构</h3><p>Master存储每个Map和Reduce任务的状态，以及Worker机器的标识。</p><p>Master像一个数据管道，存储已完成的Map任务的计算结果。并将这些信息推送给Reduce任务。</p><h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><ul><li>worker故障<ul><li>master会对worker进行心跳检测，如果在指定时间内没有收到返回信息，会将worker标记为失效。</li><li>所有由这个失效worker完成的Map任务需要重新分配给其他的worker。</li><li>当这个Map任务被调度到worker B执行时，会通知执行Reduce任务的worker从这台机器上读取数据。</li></ul></li><li>master故障<ul><li>让master定期的将上述的数据结构写入磁盘，如果master出现故障，可以让新的master从这个<strong>checkpoint</strong>恢复。</li><li>由于只有一个master进程，如果master失效，需要中止MapReduce运算。</li></ul></li></ul><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>MapReduce的master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在有数据拷贝的机器上执行。这样可以减少网络带宽的消耗。</p><h3 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h3><p>Map拆分成 M个片段，Reduce拆分成R个片段执行。</p><p>但是实际上对M和R的取值有一定的客观限制：</p><ul><li>master必须执行$O(M + R)$次调度</li><li>需要在内存中保存$O(M * R)$个状态</li></ul><p>R由用户指定的，实际使用时需要选择合适的M，以使得每一个独立任务都处理大约16M~64M的输入数据。R值应该设置为worker机器数量的倍数。</p><h3 id="备用任务"><a href="#备用任务" class="headerlink" title="备用任务"></a>备用任务</h3><p>如果一个worker花了很长时间才完成最后几个Map或Reduce任务，会导致MapReduce操作总的执行时间超过预期。产生以上现象的原因有很多。</p><p>因此需要使用一个通用的机制来减少这种现象，当一个MapReduce操作接近完成的时候，master调度备用任务进程来处理剩下的任务。</p><h2 id="改良的功能"><a href="#改良的功能" class="headerlink" title="改良的功能"></a>改良的功能</h2><h3 id="分区函数"><a href="#分区函数" class="headerlink" title="分区函数"></a>分区函数</h3><p>选择什么函数来进行对数据进行分区？</p><p><code>hash(key) mod R</code>能产生非常平衡的分区，但是，其它分区函数对一些key的分区效果较好，例如输入的key值是URL，我们希望每个主机的所有条目保持在同一个输出文件中。</p><h3 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h3><p>需要保证Reduce的生成顺序。</p><h3 id="Combiner函数"><a href="#Combiner函数" class="headerlink" title="Combiner函数"></a>Combiner函数</h3><p>某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，因此，允许用户指定一个可选的combiner函数，该函数首先在本地将重复数据进行一次合并，然后再通过网络发送出去。</p><h3 id="输入和输出的类型"><a href="#输入和输出的类型" class="headerlink" title="输入和输出的类型"></a>输入和输出的类型</h3><p>可以预定义输入&#x2F;输出的数据类型。</p><h3 id="跳过损坏的记录"><a href="#跳过损坏的记录" class="headerlink" title="跳过损坏的记录"></a>跳过损坏的记录</h3><p>有时，用户程序中的Bug会导致Map&#x2F;Reduce函数在处理记录的时候发生crash，常用的做法是修复Bug后再执行MapReduce操作。</p><p>但是很多时候，忽略一些有问题的记录是可以接受的，因此提供了一种执行模式，MapReduce会检测哪些记录导致了crash，并且会跳过这些记录不做处理。</p><p>每个worker进程都设置了信号处理函数来捕获内存段错误和总线错误。在执行MapReduce之前，通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数会通过UDP向master发送处理的最后一条记录的序号，当master看到处理某条记录失败多次后，master标记此条记录将不会被处理。</p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>需要本地进行debug来测试。</p><h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p>master可以使用HTTP服务器来显示状态信息，用户可以监控各类信息。包括任务完成数量、任务处理数量、执行时间、资源占用等。</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>MapReduce提供计数功能，需要用户在程序中创建一个计数器对象，在Map&#x2F;Reduce函数中相应的增加计数器的值。</p><p>计数器机制对于MapReduce操作的完整性检查十分有用。某些时候，用户需要确保输出的<strong>key&#x2F;value pair</strong>精确等于输入的<strong>key&#x2F;value pair</strong></p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP阅读笔记-Persistence（三）</title>
    <link href="/2020/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OS/ostep-persistence/"/>
    <url>/2020/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OS/ostep-persistence/</url>
    
    <content type="html"><![CDATA[<h2 id="Chapter-I-O设备"><a href="#Chapter-I-O设备" class="headerlink" title="Chapter I&#x2F;O设备"></a>Chapter I&#x2F;O设备</h2><blockquote><p>Q：如何将I&#x2F;O集成进计算机系统中？</p></blockquote><h3 id="36-1-系统架构"><a href="#36-1-系统架构" class="headerlink" title="36.1 系统架构"></a>36.1 系统架构</h3><p>典型的系统架构如图所示：CPU通过<strong>memory bus</strong>连接到系统内存。显卡或者其它高速I&#x2F;O设备通过常规的IO总线（I&#x2F;O bus，例如PCI）连接到系统。最后是外围总线（peripheral bus，例如SCSI、SATA、USB），他们将最慢的设备连接到系统，包括磁盘、鼠标等。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-36/36.1.jpg"></p><h3 id="36-2-标准设备"><a href="#36-2-标准设备" class="headerlink" title="36.2 标准设备"></a>36.2 标准设备</h3><p>标准设备包括两部分，分别是：</p><ul><li>向系统其他部分展现的硬件&#x2F;软件接口</li><li>内部结构，包括设备相关的特定实现，负责具体实现设备展现给系统的抽象接口。</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-36/36.2.jpg"></p><h3 id="36-3-标准协议"><a href="#36-3-标准协议" class="headerlink" title="36.3 标准协议"></a>36.3 标准协议</h3><p>一个简化的设备接口包括三个寄存器：</p><ul><li>一个状态（<strong>status</strong>）寄存器：读取并查看设备的当前状态</li><li>一个命令（<strong>command</strong>）寄存器：用于通知设备执行某个具体任务。</li><li>一个数据（<strong>data</strong>）寄存器：将数据传给设备或从设备接收数据。</li></ul><p>通过读写这些寄存器，OS可以控制设备的行为。</p><p>因此可以将操作步骤设置为如下：</p><ol><li>OS反复读取状态寄存器，等待设备进入可以接受命令的就绪状态。（轮询）</li><li>OS将数据发送到数据寄存器。</li><li>OS将命令写入命令寄存器。</li><li>OS再次通过不断轮询设备，等待并判断设备是否执行完成命令。</li></ol><blockquote><p>Q：如何减少频繁轮询，从而降低管理设备的CPU的开销？</p></blockquote><h3 id="36-4-利用中断减少CPU开销"><a href="#36-4-利用中断减少CPU开销" class="headerlink" title="36.4 利用中断减少CPU开销"></a>36.4 利用中断减少CPU开销</h3><p>设备可以抛出一个硬件中断，引发CPU跳转执行OS预先定义好的中断服务例程（ISR）或者更为简单的中断处理程序（interrupt handler）。</p><p>使用中断并非是最佳方案，假如有一个高性能的设备，在CPU第一次轮询时就可以返回结果，那么使用中断反而效率更低。如果设备的速度未知，可以考虑混合策略，先尝试轮询一小段事件，如果设备没有完成操作，此时再使用中断。</p><p>如果是网络环境中，那么不要使用中断，因为每个数据包都会发生一次中断，那么可能导致OS发生活锁（一直处理中断程序而不处理用户的请求）。</p><p>另一个基于中断的优化就是合并（coalescing），设备在抛出中断之前往往会等待一小段时间，在此期间如果有其他请求的中断，会将多次中断合并为一次中断抛出。从而降低处理中断的代价。</p><h3 id="36-5-DMA方式"><a href="#36-5-DMA方式" class="headerlink" title="36.5 DMA方式"></a>36.5 DMA方式</h3><blockquote><p>Q：如何减少Programming IO的开销？</p></blockquote><p>使用DMA（<strong>Direct Memory Access</strong>）：DMA引擎是一种特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。</p><p>工作过程如下：为了能够将数据传送给设备，OS通过programming告诉DMA引擎数据在内存的位置，要拷贝的大小以及拷贝到哪个设备。在此之后，OS就可以处理其他请求了。当DMA的任务完成后，DMA控制器会抛出一个中断来告诉OS自己完成了数据传输。</p><h3 id="36-6-设备交互的方法"><a href="#36-6-设备交互的方法" class="headerlink" title="36.6 设备交互的方法"></a>36.6 设备交互的方法</h3><blockquote><p>Q：如何与设备通信？</p></blockquote><ul><li>使用明确的I&#x2F;O指令。</li><li>内存映射I&#x2F;O（memory-mapped I&#x2F;O）<ul><li>通过这种方式，硬件将设备寄存器映射到指定的内存地址中。</li></ul></li></ul><h3 id="36-7-纳入OS：设备驱动程序"><a href="#36-7-纳入OS：设备驱动程序" class="headerlink" title="36.7 纳入OS：设备驱动程序"></a>36.7 纳入OS：设备驱动程序</h3><p>每个设备都有非常具体的接口，如何将它们纳入OS，而我们希望OS尽可能通用。</p><blockquote><p>Q：如何实现一个设备无关的OS？</p></blockquote><p>操作系统将与IO设备交互的软件称为设备驱动程序。（封装，向上层展现接口即可）</p><h3 id="36-8-IDE磁盘驱动程序"><a href="#36-8-IDE磁盘驱动程序" class="headerlink" title="36.8 IDE磁盘驱动程序"></a>36.8 IDE磁盘驱动程序</h3><p>基本逻辑如下：</p><ol><li><strong>等待驱动就绪</strong>：当驱动READY，读取状态寄存器（0x1F7）</li><li><strong>向命令寄存器写入参数</strong>：写入扇区数，待访问扇区对应的逻辑块地址（LBA），并将驱动编号（master&#x3D; 0x00，slave &#x3D; 0x10，因为IDE允许接入两个硬盘）写入命令寄存器（0x1F2- 0x1F6）。</li><li><strong>开启I&#x2F;O</strong>：发送读写命令到命令寄存器。向命令寄存器（0x1F7）中写入<code>READ-WRITE</code>命令。</li><li><strong>数据传送</strong>（针对写请求）：等待直到驱动状态为<code>READY</code>和<code>DRQ</code>（驱动请求数据），向数据端口写入数据。</li><li><strong>中断处理</strong>：每个扇区的数据传送结束后都会触发一次中断处理程序，可以合并中断。</li><li><strong>错误处理</strong>：每次操作之后读取状态寄存器，如果ERROR位被置位。可以读取错误寄存器来获取详细信息。</li></ol><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-36/36.5.jpg"></p><p>四个主要函数：</p><ul><li>**ide_rw()**：将一个请求加入队列，或者直接将请求发送到磁盘（通过<code>ide_start_request()</code>）</li><li>**ide_start_request()**：将请求发送到磁盘</li><li>**ide_wait_ready()**：确保驱动处于就绪状态</li><li>**ide_intr()**：发生中断时，该函数会被调用，会从设备中读取数据，并且结束后唤醒等待的进程。如果队列中还有未处理的请求，会调用第二个函数接着处理下一个IO请求。</li></ul><h2 id="Chapter-37-磁盘驱动器"><a href="#Chapter-37-磁盘驱动器" class="headerlink" title="Chapter 37 磁盘驱动器"></a>Chapter 37 磁盘驱动器</h2><blockquote><p>Q：现代磁盘驱动器如何存储数据？接口是什么？数据是如何存储和访问的？磁盘调度如何提高性能？</p></blockquote><h3 id="37-1-接口"><a href="#37-1-接口" class="headerlink" title="37.1 接口"></a>37.1 接口</h3><p>现代驱动器的基本接口非常简单，驱动器由大量扇区组成，可以进行多扇区操作，但是写入操作只能保证单扇区是原子性的。无法在断电情况下保证完整写入。</p><h3 id="37-2-基本几何形状"><a href="#37-2-基本几何形状" class="headerlink" title="37.2 基本几何形状"></a>37.2 基本几何形状</h3><ul><li><strong>盘片（platter）</strong>：磁盘有一个或多个盘片，每个盘片有两面，都称为表面（surface），盘片由一些硬质材料制成，然后涂上薄薄的磁性层，从而持久存储数据位。</li><li><strong>主轴（spindle）</strong>：所有盘片围绕主轴连接在一起，主轴连接到电机，以一个恒定的速度旋转盘片，旋转速度以每分钟转数（Rotations Per Minute, RPM）来测量。</li><li><strong>扇区（sector）</strong>：将磁道划分成若干个弧段，每个弧段称为一个扇区。</li><li><strong>磁道（track）</strong>：一个表面由磁道构成，是同心圆的结构。</li><li><strong>磁头（disk head）</strong>：要从表面进行读写操作，需要一种机制，能感应磁盘上的磁性数据，读写操作由磁头完成。</li><li><strong>磁盘臂（disk arm）</strong>：每个表面都有一个磁头，磁头连接到单个磁盘臂，磁盘臂在表面移动，将磁头定位到期望的磁道上。</li></ul><h3 id="37-3-简单的磁盘驱动器"><a href="#37-3-简单的磁盘驱动器" class="headerlink" title="37.3 简单的磁盘驱动器"></a>37.3 简单的磁盘驱动器</h3><h4 id="单磁道延迟：旋转延迟"><a href="#单磁道延迟：旋转延迟" class="headerlink" title="单磁道延迟：旋转延迟"></a>单磁道延迟：旋转延迟</h4><p>旋转延迟（<strong>rotation delay</strong>）：磁头移动的时间</p><h4 id="寻道时间"><a href="#寻道时间" class="headerlink" title="寻道时间"></a>寻道时间</h4><p>寻道时间包括以下阶段：</p><ol><li>磁盘臂移动时的加速阶段</li><li>随着磁盘臂全速移动而惯性移动</li><li>随着磁盘臂减速，最后磁道在正确的磁道上停下来，停放时间通常不小，例如<code>0.5 ~ 2ms</code>。</li></ol><h4 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h4><ul><li><p>磁道偏斜（track skew）：确保即使在跨越磁道边界时，顺序读取也能方便地服务。</p></li><li><p>多区域（multi-zoned）：外圈磁道比内圈磁道具有更多扇区，磁盘被组织成多个区域，区域是表面上连续的一组磁道。每个区域每个磁道具有相同的扇区数量。</p></li><li><p>磁道缓冲区（track buffer）：少量的内存空间，通常大小位8MB或16MB。例如：从磁盘读取扇区时，驱动器可能决定读取该磁道上的所有扇区并将其缓存在其驱动器上，这样可以让驱动器快速响应所有后续的同一磁道的请求。</p></li></ul><p>写入操作分为以下几种：</p><ul><li>后写（write back）：将数据放入内存中，在一段时间后写入。</li><li>直写（write through）：直接写入磁盘。</li></ul><h3 id="37-4-I-O时间"><a href="#37-4-I-O时间" class="headerlink" title="37.4 I&#x2F;O时间"></a>37.4 I&#x2F;O时间</h3><p>$$T_{I&#x2F;O} &#x3D; T_{寻道} + T_{旋转}$ + T_{传输}$$</p><h3 id="37-5-磁盘调度"><a href="#37-5-磁盘调度" class="headerlink" title="37.5 磁盘调度"></a>37.5 磁盘调度</h3><h4 id="SSTF：最短寻道时间优先"><a href="#SSTF：最短寻道时间优先" class="headerlink" title="SSTF：最短寻道时间优先"></a>SSTF：最短寻道时间优先</h4><p>会导致饥饿问题，距离长的始终无法调度。</p><h4 id="SCAN电梯算法"><a href="#SCAN电梯算法" class="headerlink" title="SCAN电梯算法"></a>SCAN电梯算法</h4><h4 id="SPTF：最短定位时间优先"><a href="#SPTF：最短定位时间优先" class="headerlink" title="SPTF：最短定位时间优先"></a>SPTF：最短定位时间优先</h4><h2 id="Chapter-38-RAID"><a href="#Chapter-38-RAID" class="headerlink" title="Chapter 38 RAID"></a>Chapter 38 RAID</h2><blockquote><p>Q：如何构建大型、快速、可靠的存储系统？</p></blockquote><p>RAID（Redundant Array of Inexpensive Disks）：廉价冗余磁盘阵列。</p><p>从外部看：RAID看起来像一个磁盘：一组可以读取或写入的块。</p><p>在内部：RAID是由多个磁盘、内存以及多个处理器来管理系统，更像一个计算机系统，专门管理一组磁盘。</p><p>RAID优点：</p><ul><li>性能高：并行使用多个磁盘可以大大加快I&#x2F;O时间</li><li>容量大</li><li>可靠性：RAID通过redundancy，可以增加数据可靠性。</li><li>透明部署：向系统添加新功能时，不需要对其余部分进行修改</li></ul><h3 id="38-1-接口和RAID内部"><a href="#38-1-接口和RAID内部" class="headerlink" title="38.1 接口和RAID内部"></a>38.1 接口和RAID内部</h3><p>提供接口给上层调用。</p><p>RAID内部包括一个微控制器，运行固件以指导RAID的操作。某些情况下，还包括非易失性存储器，安全地缓冲写入。</p><h3 id="38-2-故障模型"><a href="#38-2-故障模型" class="headerlink" title="38.2 故障模型"></a>38.2 故障模型</h3><ul><li><strong>fail-stop</strong>：故障停止模型，在这种模式下，磁盘可以处于两种状态之一：工作状态或故障状态，使用工作状态的磁盘时，所有块都可以读写，相反，磁盘出现故障时，将不提供服务。</li></ul><h3 id="38-3-如何评估RAID"><a href="#38-3-如何评估RAID" class="headerlink" title="38.3 如何评估RAID"></a>38.3 如何评估RAID</h3><p>三个方面：</p><ol><li>容量</li><li>可靠性</li><li>性能</li></ol><h3 id="38-4-RAID-0：条带化"><a href="#38-4-RAID-0：条带化" class="headerlink" title="38.4 RAID 0：条带化"></a>38.4 RAID 0：条带化</h3><p>实际上不是RAID级别，因为没有冗余。</p><p>基本思想：以轮转方式将磁盘阵列的块分布在磁盘上。目的是对数组的连续块请求时，从阵列中获得最大的并行性。将同一行中的块称为条带。</p><p>RAID映射问题：给定一个逻辑块地址A，RAID如何确定物理磁盘和偏移量？</p><p>使用一些映射关系进行计算。</p><h4 id="大块大小"><a href="#大块大小" class="headerlink" title="大块大小"></a>大块大小</h4><p>大块大小影响针列地性能，大小较小的大块意味着许多文件将多个磁盘进行条带化，从而增加了对单个文件的读取和写入的并行性。但是，跨多个磁盘访问块的定位时间会增加。因为整个请求的定位时间由所有驱动器上请求的最大定位时间决定。</p><h3 id="38-5-RAID-1：镜像"><a href="#38-5-RAID-1：镜像" class="headerlink" title="38.5 RAID 1：镜像"></a>38.5 RAID 1：镜像</h3><p>只需要生成系统中每个块的多个副本。</p><p>一致性更新问题：可以通过预写日志解决，首先记录RAID简要执行的操作，采用这种办法，可以在发生崩溃时，通过运行恢复程序，将数据恢复到最新状态。</p><h3 id="38-6-RAID-4：通过奇偶校验节省空间"><a href="#38-6-RAID-4：通过奇偶校验节省空间" class="headerlink" title="38.6 RAID 4：通过奇偶校验节省空间"></a>38.6 RAID 4：通过奇偶校验节省空间</h3><p>对于每一条数据，都添加一个奇偶校验（parity）块，用于存储该条块的冗余信息。</p><p>为了计算奇偶性，需要使用一个数学函数，可以使用XOR。</p><p>存在小写入问题（small-write problem），导致性能下降。</p><h3 id="38-7-RAID-5：旋转奇偶校验"><a href="#38-7-RAID-5：旋转奇偶校验" class="headerlink" title="38.7 RAID 5：旋转奇偶校验"></a>38.7 RAID 5：旋转奇偶校验</h3><p>为了解决小写入问题，推出了RAID-5。RAID-5的工作原理与RAID-4几乎完全相同，只是RAID-5将奇偶校验块跨驱动器旋转。</p><h2 id="Chapter-39-文件和目录"><a href="#Chapter-39-文件和目录" class="headerlink" title="Chapter 39 文件和目录"></a>Chapter 39 文件和目录</h2><blockquote><p>Q：OS如何管理持久设备？</p></blockquote><h3 id="39-1-文件和目录"><a href="#39-1-文件和目录" class="headerlink" title="39.1 文件和目录"></a>39.1 文件和目录</h3><p>存储虚拟化形成了两个关键的抽象：</p><ul><li>文件：线性字节数组，每个文件都有一个<strong>low-level name</strong>。通常这个name被称为inode number。</li><li>目录：也存在inode number，包括一个<code>(用户可读名字,low-level name)</code>键值对列表</li></ul><h3 id="39-2-文件系统接口"><a href="#39-2-文件系统接口" class="headerlink" title="39.2 文件系统接口"></a>39.2 文件系统接口</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> fd = open(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * pathname, <span class="hljs-type">int</span> flags);</code></pre></div><p>flags部分含义如下：</p><ul><li>O_CREAT：创建文件</li><li>O_WRONLY：以只读方式打开文件</li><li>O_WRONLY：以只写方式打开文件</li></ul><h3 id="39-4-读写文件"><a href="#39-4-读写文件" class="headerlink" title="39.4 读写文件"></a>39.4 读写文件</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span> <span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * buf, <span class="hljs-type">size_t</span> count)</span>;</code></pre></div><p>write()会把buf所指的内存写入count个字节到参数fd所指的文件内. 当然, 文件读写位置也会随之移动。</p><p>返回值：如果顺利write()会返回实际写入的字节数. 当有错误发生时则返回-1, 错误代码存入errno中.</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> * buf, <span class="hljs-type">size_t</span> count)</span>;</code></pre></div><p>read()会把参数fd 所指的文件传送count 个字节到buf 指针所指的内存中. 若参数count 为0, 则read()不会有作用并返回0. 返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据,此外文件读写位置会随读取到的字节移动。</p><h3 id="39-6-fsync"><a href="#39-6-fsync" class="headerlink" title="39.6 fsync()"></a>39.6 fsync()</h3><p>当程序调用<code>write()</code>时，只是将数据写入内存缓冲区中，等过一段时间写入存储设备。可以调用<code>fsync()</code>以确保立即强制写入磁盘。</p><h3 id="39-7-文件重命名"><a href="#39-7-文件重命名" class="headerlink" title="39.7 文件重命名"></a>39.7 文件重命名</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">char</span> * oldname, <span class="hljs-type">char</span> * newname)</span>;</code></pre></div><h3 id="39-8-获取文件信息"><a href="#39-8-获取文件信息" class="headerlink" title="39.8 获取文件信息"></a>39.8 获取文件信息</h3><p>这些信息通常称为metadata，通过<code>stat()</code>或<code>fstat()</code>系统调用完成。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * file_name, <span class="hljs-keyword">struct</span> stat *buf)</span>;</code></pre></div><p>stat结构体如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-type">dev_t</span> st_dev; <span class="hljs-comment">//device 文件的设备编号</span>    <span class="hljs-type">ino_t</span> st_ino; <span class="hljs-comment">//inode 文件的i-node</span>    <span class="hljs-type">mode_t</span> st_mode; <span class="hljs-comment">//protection 文件的类型和存取的权限</span>    <span class="hljs-type">nlink_t</span> st_nlink; <span class="hljs-comment">//number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span>    <span class="hljs-type">uid_t</span> st_uid; <span class="hljs-comment">//user ID of owner 文件所有者的用户识别码</span>    <span class="hljs-type">gid_t</span> st_gid; <span class="hljs-comment">//group ID of owner 文件所有者的组识别码</span>    <span class="hljs-type">dev_t</span> st_rdev; <span class="hljs-comment">//device type 若此文件为装置设备文件, 则为其设备编号</span>    <span class="hljs-type">off_t</span> st_size; <span class="hljs-comment">//total size, in bytes 文件大小, 以字节计算</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> st_blksize; <span class="hljs-comment">//blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> st_blocks; <span class="hljs-comment">//number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span>    <span class="hljs-type">time_t</span> st_atime; <span class="hljs-comment">//time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、utime、read、write 与tructate 时改变.</span>    <span class="hljs-type">time_t</span> st_mtime; <span class="hljs-comment">//time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write 时才会改变</span>    <span class="hljs-type">time_t</span> st_ctime; <span class="hljs-comment">//time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新</span>&#125;;</code></pre></div><h3 id="39-9-删除文件"><a href="#39-9-删除文件" class="headerlink" title="39.9 删除文件"></a>39.9 删除文件</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * pathname)</span>;</code></pre></div><h3 id="39-10-创建目录"><a href="#39-10-创建目录" class="headerlink" title="39.10 创建目录"></a>39.10 创建目录</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;</code></pre></div><h3 id="39-13-硬链接"><a href="#39-13-硬链接" class="headerlink" title="39.13 硬链接"></a>39.13 硬链接</h3><p>link()系统调用，在创建链接的目录中创建了另一个名称，并将其指向原有的文件的inode number。</p><h3 id="39-14-符号链接"><a href="#39-14-符号链接" class="headerlink" title="39.14 符号链接"></a>39.14 符号链接</h3><p>也称为软链接，硬链接有些局限：不能创建目录的硬链接（担心会在目录树中创建一个环），不能硬链接到其他磁盘分区中的文件（inode在文件系统中唯一，不能跨文件系统）</p><p>符号链接实际上与硬链接完全不同，其本身实际上是一个不同类型的文件。符号链接指向文件的路径作为链接文件的数据。</p><h2 id="Chapter-40-文件系统实现"><a href="#Chapter-40-文件系统实现" class="headerlink" title="Chapter 40 文件系统实现"></a>Chapter 40 文件系统实现</h2><blockquote><p>Q：如何构建一个简单的文件系统？磁盘上需要什么结构？</p></blockquote><h3 id="40-1-思考方式"><a href="#40-1-思考方式" class="headerlink" title="40.1 思考方式"></a>40.1 思考方式</h3><ul><li>文件系统的结构：文件系统在磁盘上使用哪些类型的结构来组织数据和元数据。</li><li>访问方法：如何将进程发出的调用映射到它的结构上。</li></ul><h3 id="40-2-整体组织"><a href="#40-2-整体组织" class="headerlink" title="40.2 整体组织"></a>40.2 整体组织</h3><p>首先将磁盘分成一系列的块，每块大小4KB，在N个4KB的块中，分出大部分空间存储用户数据，这部分被称为<strong>data region</strong>。还有一部分磁盘空间需要存放元数据，这部分被称为<strong>inode table</strong>。</p><p>还需要一些空间记录inode或者数据块是空闲还是已分配。可以使用空闲列表（free list），或者使用位图（bitmap）。</p><p>还需要一块留给superblock，其中包含一些特定的文件系统信息，包括文件系统中有多少个inode和数据块、inode表的开始位置。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-40/disk-structure.jpg"></p><h3 id="40-3-文件组织：inode"><a href="#40-3-文件组织：inode" class="headerlink" title="40.3 文件组织：inode"></a>40.3 文件组织：inode</h3><p><code>inode</code>用于保存元数据结构，例如其长度、权限以及其组成块的位置。每个<code>inode</code>都由一个数字隐式引用。</p><p><code>inode</code>表大小为20KB，由80个<code>inode</code>组成。每个<code>inode</code>大小为<code>256 bytes</code>。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-40/inode-table.jpg"></p><p>要读取<code>inode 32</code>，文件系统首先计算inode区域的偏移量（32 * inode大小 &#x3D; 8192），将其加商inode表的起始地址（inodeStartAddr &#x3D; 12KB） ，从而可以得到希望的inode块的正确地址。</p><p>inode块的扇区地址<code>iaddr</code>可以计算如下：</p><div class="code-wrapper"><pre><code class="hljs C">blk = (inumber * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">inode_t</span>)) / blockSize;sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;</code></pre></div><h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>为了支持更大的文件，文件系统的设计者必须在inode中引入不同的结构，一种常见的思路是用一个称为间接指针，它指向包含更多指针的块，每个指针再指向用户数据。</p><h3 id="40-4-目录组织"><a href="#40-4-目录组织" class="headerlink" title="40.4 目录组织"></a>40.4 目录组织</h3><p>目录基本上只包含一个二元组<code>(条目名称, inode号)</code>。但是线性存储不是存储这些信息的唯一方法，任何数据结构都可以，XFS使用B树存储目录。</p><h3 id="40-5-空闲空间管理"><a href="#40-5-空闲空间管理" class="headerlink" title="40.5 空闲空间管理"></a>40.5 空闲空间管理</h3><p>文件系统需要记录哪些inode和数据块是空闲的，哪些不是。当创建一个文件时，需要为该文件分配一个inode，文件系统将通过位图搜索一个空闲的内容，将其分配给文件，文件系统将inode标记为已使用。</p><h3 id="40-6-访问路径：读取和写入"><a href="#40-6-访问路径：读取和写入" class="headerlink" title="40.6 访问路径：读取和写入"></a>40.6 访问路径：读取和写入</h3><h4 id="从磁盘读取文件"><a href="#从磁盘读取文件" class="headerlink" title="从磁盘读取文件"></a>从磁盘读取文件</h4><p>发出<code>open(&quot;/foo/bar&quot;, O_RDONLY)</code>调用时，文件系统首先需要找到文件bar的inode，从而获得文件的基本信息，通过遍历路径名查找。从根目录开始遍历。找到inode后，读取包含foo的inode以及目录数据的块，最后找到bar的inode号，通过<code>open()</code>系统调用将该inode读入内存。打开后，通过<code>read()</code>系统调用，从文件中读取。</p><h4 id="写入磁盘"><a href="#写入磁盘" class="headerlink" title="写入磁盘"></a>写入磁盘</h4><p>写入文件是一个类似的过程，首先文件必须打开，然后通过<code>write()</code>系统调用以新内容更新文件，最后关闭文件。</p><p>写入文件可能会分配一个块，当写入一个新文件时，不仅需要将数据写入磁盘，还需要决定将哪个块分配给文件，从而相应地更新磁盘的其他结构。每次更新会导致五个I&#x2F;O，分别是：</p><ul><li>读取数据位图，然后更新以标记新分配的块被使用</li><li>一个写入位图（将新状态存入磁盘）</li><li>两次读取，然后写入inode</li><li>最后一次写入真正的数据块本身</li></ul><blockquote><p>Q：如何降低文件系统I&#x2F;O成本？</p></blockquote><h3 id="40-7-缓存和缓冲"><a href="#40-7-缓存和缓冲" class="headerlink" title="40.7 缓存和缓冲"></a>40.7 缓存和缓冲</h3><p>大多数文件系统使用DRAM来缓存重要的块。</p><p>早期文件系统引入一个固定大小的缓存来保存常用的块。然而静态的内存划分可能导致浪费。</p><p>现代系统采用动态划分方法，具体来说，许多现代操作系统将虚拟内存页面和文件系统集成到统一页面缓存中（unified page cache）通过这种方式，可以在虚拟内存和文件系统中更灵活的分配内存。</p><h2 id="Chapter-44-数据完整性和保护"><a href="#Chapter-44-数据完整性和保护" class="headerlink" title="Chapter 44 数据完整性和保护"></a>Chapter 44 数据完整性和保护</h2><blockquote><p>Q：系统如何确保数据完整性？</p></blockquote><h3 id="44-1-磁盘故障模式"><a href="#44-1-磁盘故障模式" class="headerlink" title="44.1 磁盘故障模式"></a>44.1 磁盘故障模式</h3><p>分为两种类型：</p><ul><li>潜在扇区错误（latent-sector errors , LSE）</li><li>块讹误（block corruption）</li></ul><p>当扇区以某种方式发生block corruption时，会出现LSE。例如磁头由于某种原因接触到表面（磁头碰撞，head crash），则会使得数据位不可读。</p><p>驱动器会使用<strong>Error Correcting Code</strong>来确定磁盘位是否良好，会修复错误位。</p><h3 id="44-2-处理潜在的扇区错误"><a href="#44-2-处理潜在的扇区错误" class="headerlink" title="44.2 处理潜在的扇区错误"></a>44.2 处理潜在的扇区错误</h3><blockquote><p>Q：如何处理潜在的扇区错误？</p></blockquote><p>如果存储系统尝试访问块，并且磁盘块返回错误时，需要用它的冗余机制来返回正确数据。</p><p>但是，LSE的增长影响了RAID的设计。当全盘故障核LSE接连发生时，RAID-4&#x2F;5会尝试读取奇偶校验组中的所有磁盘，并重新计算缺失值，来重建磁盘。</p><h3 id="44-3-检查讹误：校验和"><a href="#44-3-检查讹误：校验和" class="headerlink" title="44.3 检查讹误：校验和"></a>44.3 检查讹误：校验和</h3><blockquote><p>Q：如何检测出现了讹误？</p></blockquote><p>现代存储系统用于保持数据完整性的主要机制称为校验和（checksum），校验和是一个函数的结果。该函数以一块数据作为输入，输出数据内容的概要（4字节或8字节），此摘要称为校验和。</p><p>通过将数据和校验和一起存储，然后再访问时确定数据是否被破坏或改变。</p><h3 id="44-5-错误的写入"><a href="#44-5-错误的写入" class="headerlink" title="44.5 错误的写入"></a>44.5 错误的写入</h3><p>错误位置的写入（misdirected write）：写入位置出错。</p><blockquote><p> Q：如何解决错误的写入？</p></blockquote><p>在每个校验和中添加更多的信息，例如：添加物理ID。</p><h3 id="44-6-丢失的写入"><a href="#44-6-丢失的写入" class="headerlink" title="44.6 丢失的写入"></a>44.6 丢失的写入</h3><p>丢失写入（lost write）：实际上没写入。</p><blockquote><p> Q：如何处理丢失写入？</p></blockquote><p>执行写入验证（write verify），或者写入后读取验证（read-after-write）。</p><h3 id="44-7-擦净"><a href="#44-7-擦净" class="headerlink" title="44.7 擦净"></a>44.7 擦净</h3><blockquote><p>校验和何时得到实际检查？</p></blockquote><p>大多数数据很少访问，因此将保持未检查状态。未检查的数据对于可靠的存储系统是一个问题，因为数据位衰减最终可能影响特定数据的副本。</p><p>为了解决这个问题，许多系统利用各种形式的磁盘擦净（disk scrubbing），定期去读取系统的每个块，并检查校验和是否有效。</p><h3 id="44-8-校验和的开销"><a href="#44-8-校验和的开销" class="headerlink" title="44.8 校验和的开销"></a>44.8 校验和的开销</h3><p>空间开销：</p><ul><li>磁盘本身需要存储校验和</li></ul><p>时间开销：</p><ul><li>CPU需要计算每个块的校验和，存储&#x2F;访问时都需要计算。</li></ul><h2 id="Chapter-47-分布式系统"><a href="#Chapter-47-分布式系统" class="headerlink" title="Chapter 47 分布式系统"></a>Chapter 47 分布式系统</h2><blockquote><p>Q：如何构建在出现故障时仍能工作的系统？</p></blockquote><p>其他问题：</p><ul><li>系统性能</li><li>安全</li></ul><h3 id="47-1-通信基础"><a href="#47-1-通信基础" class="headerlink" title="47.1 通信基础"></a>47.1 通信基础</h3><p>丢包是网络的基本现象。问题：如何处理丢包？</p><h3 id="47-5-RPC"><a href="#47-5-RPC" class="headerlink" title="47.5 RPC"></a>47.5 RPC</h3><p>RPC是分布式系统中的通信方式。</p><p>RPC系统分成两部分：</p><ul><li>stub generator&#x2F;protocol compiler<ul><li>通过自动化，简化将函数参数和结果打包成消息的过程。</li><li>优化代码，提高性能。</li></ul></li><li>runtime library</li></ul><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">interface</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg1)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2)</span></span>;&#125;</code></pre></div><h4 id="stub-generator"><a href="#stub-generator" class="headerlink" title="stub generator"></a>stub generator</h4><p>stub generator接收接口，并生成不同的代码片段，对于client，生成client stub，其中包含接口中的每个函数。希望使用此RPC服务的客户端程序将链接此client stub，调用它进行RPC。</p><p>在内部，client stub中每个函数都执行RPC的核心业务代码。主要分为以下步骤：</p><ol><li><strong>创建消息缓冲区</strong>。</li><li><strong>将所需信息打包到消息缓冲区中。</strong>包括函数名，参数。也称为消息的序列化。</li><li><strong>将消息发送到目标RPC服务器。</strong>，与RPC服务器的通信，由RPC的runtime library处理。</li><li><strong>等待回复。</strong></li><li><strong>解包返回代码和其他参数。</strong>也称为反序列化。</li><li><strong>返回给调用者。</strong></li></ol><p>其它问题：</p><ul><li>复杂参数如何封装</li><li>并发编程</li></ul><h4 id="runtime-library"><a href="#runtime-library" class="headerlink" title="runtime library"></a>runtime library</h4><p>首要挑战：如何找到远程服务？</p><p>建立命名系统，存储对应的RPC服务名称和主机IP地址、端口等。</p><p>下一个问题：选择TCP&#x2F;UDP传输协议？</p><p>根据系统功能做抉择。</p><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul><li>超时机制</li><li>大参数的过程调用</li><li>字节序，有些机器使用大端序，有些机器使用小端序。</li><li>异步同步问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP阅读笔记- Concurrency（二）</title>
    <link href="/2020/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OS/ostep-concurrency/"/>
    <url>/2020/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OS/ostep-concurrency/</url>
    
    <content type="html"><![CDATA[<h2 id="Chapter-26-并发介绍"><a href="#Chapter-26-并发介绍" class="headerlink" title="Chapter 26 并发介绍"></a>Chapter 26 并发介绍</h2><p>本章介绍为单个运行进程提供的新抽象：thread。线程共享地址空间。</p><p>每个线程都有自己的PC与自己用于计算的<code>register</code>。如果有两个线程运行在同一个处理器上，发生<code>context switch</code>时，与进程不同的是，使用PCB保存进程状态，使用TCB保存线程状态。区别是：地址空间保持不变（不需要切换当前使用的页表）。</p><p>另一个主要区别在于栈，传统进程只有一个栈，如图26.1所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-26/26.1.jpg"></p><p>多线程中，每个线程拥有自己的栈，位于栈上的变量、参数、返回值是无法共享的。</p><h3 id="26-1-实例：线程创建"><a href="#26-1-实例：线程创建" class="headerlink" title="26.1 实例：线程创建"></a>26.1 实例：线程创建</h3><p>示例：使用<code>pthead_create()</code>创建了两个线程，主程序调用<code>pthread_join()</code>等待指定线程执行完成。</p><p>线程的执行顺序取决于系统调度。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-26/26.2.jpg"></p><h3 id="26-2-共享数据导致的问题"><a href="#26-2-共享数据导致的问题" class="headerlink" title="26.2 共享数据导致的问题"></a>26.2 共享数据导致的问题</h3><p>多线程对共享数据进行操作会导致非预期结果。</p><h3 id="26-3-核心问题：不可控的调度"><a href="#26-3-核心问题：不可控的调度" class="headerlink" title="26.3 核心问题：不可控的调度"></a>26.3 核心问题：不可控的调度</h3><p>竞态条件（<strong>race condition</strong>）：结果取决于代码的执行顺序。运气不好会导致错误的结果。</p><h3 id="26-4-原子性"><a href="#26-4-原子性" class="headerlink" title="26.4 原子性"></a>26.4 原子性</h3><blockquote><p>Q：如何构建有用的同步原语？需要从硬件中获取那些支持？</p></blockquote><h3 id="26-5-等待另一个线程"><a href="#26-5-等待另一个线程" class="headerlink" title="26.5 等待另一个线程"></a>26.5 等待另一个线程</h3><p>需要研究多线程中的<code>wait/signal</code>机制。</p><h2 id="Chapter-27-线程API"><a href="#Chapter-27-线程API" class="headerlink" title="Chapter 27 线程API"></a>Chapter 27 线程API</h2><blockquote><p>Q：如何创建和控制线程？</p></blockquote><h3 id="27-1-pthread-create"><a href="#27-1-pthread-create" class="headerlink" title="27.1 pthread_create"></a>27.1 pthread_create</h3><p>在POSIX中：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">( <span class="hljs-type">pthread_t</span> * thread,</span><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> * attr,</span><span class="hljs-params"><span class="hljs-type">void</span> * (*start_routine)(<span class="hljs-type">void</span>*),</span><span class="hljs-params"><span class="hljs-type">void</span> * arg)</span>;</code></pre></div><p>参数：</p><ul><li><strong>thread</strong>：指向pthread_t结构类型的指针，利用它与线程交互。</li><li><strong>attr</strong>：用于指定该线程可能具有的任何属性，包括设置栈大小、调度优先级。属性通过调用<code>pthread_attr_init()</code>初始化。</li><li><strong>start_routine</strong>：一个函数指针，指示线程应该在哪个函数上运行。</li><li><strong>arg</strong>：传递给线程的参数</li></ul><h3 id="27-2-pthread-join"><a href="#27-2-pthread-join" class="headerlink" title="27.2 pthread_join"></a>27.2 pthread_join</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span>;</code></pre></div><p>参数：</p><ul><li><strong>thread</strong>：指定需要等待的线程</li><li><strong>retval</strong>：指向你希望得到的返回值，定义为一个指向void的指针。</li></ul><h3 id="27-3-锁"><a href="#27-3-锁" class="headerlink" title="27.3 锁"></a>27.3 锁</h3><p>互斥进入临界区：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;</code></pre></div><p>使用：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_lock(&amp;lock);x = x + <span class="hljs-number">1</span>; <span class="hljs-comment">// or whatever your critical section is</span>pthread_mutex_unlock(&amp;lock);</code></pre></div><h3 id="27-4-条件变量"><a href="#27-4-条件变量" class="headerlink" title="27.4 条件变量"></a>27.4 条件变量</h3><p>当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond, <span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;</code></pre></div><p>要使用条件变量，还需要一个与条件相关的锁。</p><ul><li>pthread_cond_wait：使调用线程进入休眠状态，等待其他线程发出信号。</li><li>pthread_cond_signal：唤醒线程</li></ul><h3 id="补充：线程API使用指导"><a href="#补充：线程API使用指导" class="headerlink" title="补充：线程API使用指导"></a>补充：线程API使用指导</h3><ul><li>保持简洁</li><li>让线程交互减到最少</li><li>初始化锁和条件变量</li><li>检查返回值</li><li>注意传给线程的参数和返回指</li><li>每个线程都有自己的栈</li><li>线程之间通过条件变量发送信号</li><li>多查手册</li></ul><h2 id="Chapter-28-锁"><a href="#Chapter-28-锁" class="headerlink" title="Chapter 28 锁"></a>Chapter 28 锁</h2><p>并发编程的基本问题：希望原子式执行一系列指令，但是由于处理器中断，无法做到。</p><p>锁可以保证在临界区能够保证原子性。</p><h3 id="28-1-锁的基本思想"><a href="#28-1-锁的基本思想" class="headerlink" title="28.1 锁的基本思想"></a>28.1 锁的基本思想</h3><p>锁就是一个变量，因此需要声明才能使用，锁变量保存了锁在某一时刻的状态，要么是可用的：表示没有线程持有锁，要么是被占用的：表示有线程持有锁。也可以访问其他信息：比如查询持有锁的线程，或请求获取锁的线程队列。</p><ul><li>lock：尝试获取锁，如果没有其他线程持有锁，该线程会获得锁，进入临界区，并成为锁的持有者。</li><li>unlock：持有者一旦调用<code>unlock()</code>，锁就会变成可用，如果没有其他等待线程。</li></ul><h3 id="28-4-评价锁"><a href="#28-4-评价锁" class="headerlink" title="28.4 评价锁"></a>28.4 评价锁</h3><p>如何评价一种锁实现的效果？</p><p>标准：</p><ul><li>第一：锁是否能实现互斥</li><li>第二：公平性</li><li>第三：性能</li></ul><h3 id="28-5-控制中断"><a href="#28-5-控制中断" class="headerlink" title="28.5 控制中断"></a>28.5 控制中断</h3><p>最早提供的互斥解决方案之一就是在临界区关闭中断。这个解决方案是为单处理器系统开发的。优点是简单。</p><p>缺点：</p><ul><li>不安全的操作，允许任何线程进行关中断</li><li>不支持多处理器，如果多个线程运行在不同的CPU上，每个线程都试图进入同一临界区。</li><li>关闭中断导致中断丢失，比如磁盘设备完成读取任务，但是CPU无法识别到中断</li><li>效率低</li></ul><h3 id="28-6-测试并设置指令-原子交换"><a href="#28-6-测试并设置指令-原子交换" class="headerlink" title="28.6 测试并设置指令 原子交换"></a>28.6 测试并设置指令 原子交换</h3><p>由于关中断方式无法在多处理器上运行，所以需要让硬件支持，最简单的硬件支持是测试并设置（<strong>test-and-set</strong>），也称为原子交换（<strong>atomic exchange</strong>）。</p><p>通过自旋等待，直到持有锁的线程释放资源。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-28/28.1.jpg"></p><p>上述代码有两个问题：</p><ul><li>正确性<ul><li>无法互斥</li></ul></li><li>性能<ul><li>自旋等待性能开销大</li></ul></li></ul><h3 id="28-7-实现可用的自旋锁"><a href="#28-7-实现可用的自旋锁" class="headerlink" title="28.7 实现可用的自旋锁"></a>28.7 实现可用的自旋锁</h3><p>没有硬件支持是无法实现的，因此产生了一些指令，在<code>x86</code>中，是<code>xchg</code>指令。其功能是返回旧值，更新为新值，C代码描述如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">testAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> *old_ptr, <span class="hljs-type">int</span> new)</span>&#123;    <span class="hljs-type">int</span> old = * old_ptr;    *old_ptr = new;    <span class="hljs-keyword">return</span> old;&#125;</code></pre></div><p>可以利用这个指令完成一个简单的<code>spin lock</code>。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-28/28.3.jpg"></p><p>此方法与28.1中的实现区别在于：<strong>获取并更新两个操作是原子性的，并不会存在同时进入临界区的时机。</strong></p><p>这也是此方法能完成互斥功能的关键。</p><h3 id="28-8-评价自旋锁"><a href="#28-8-评价自旋锁" class="headerlink" title="28.8 评价自旋锁"></a>28.8 评价自旋锁</h3><ul><li>正确性：能够互斥</li><li>公平性：自旋锁没有公平性，会导致线程饥饿</li><li>性能<ul><li>单处理器：性能开销大</li><li>多处理器：性能不错</li></ul></li></ul><h3 id="28-9-CAS"><a href="#28-9-CAS" class="headerlink" title="28.9 CAS"></a>28.9 CAS</h3><p>比较并交换指令（compare-and-set），C代码描述如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> * ptr, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> new)</span>&#123;    <span class="hljs-type">int</span> actual = *ptr;    <span class="hljs-keyword">if</span>(actual == expected)        *ptr = new;    <span class="hljs-keyword">return</span> actual;&#125;</code></pre></div><p>可以使用该指令改写<code>lock()</code>。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;    <span class="hljs-keyword">while</span>(compareAndSet(&amp;lock-&gt;flag,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)        ;<span class="hljs-comment">//spin</span>&#125;</code></pre></div><p>X86的CAS指令如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-28/CAS-X86.jpg"></p><h3 id="28-10-链接的加载和条件式存储指令"><a href="#28-10-链接的加载和条件式存储指令" class="headerlink" title="28.10 链接的加载和条件式存储指令"></a>28.10 链接的加载和条件式存储指令</h3><p>链接的加载指令：从内存中取出值。</p><p>条件式存储指令：只有上一次加载的地址在期间都没有更新时，才会成功。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-28/28.5.jpg"></p><p>使用这两个指令如何实现一个锁？</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-28/28.6.jpg"></p><h3 id="28-11-获取并增加"><a href="#28-11-获取并增加" class="headerlink" title="28.11 获取并增加"></a>28.11 获取并增加</h3><p>获取并增加：它能原子性的返回特定地址的旧值，并将值自增1，C代码如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">fetchAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> * ptr)</span>&#123;    <span class="hljs-type">int</span> old = *ptr;    *ptr = old + <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> old;&#125;</code></pre></div><p>可以通过此指令完成一个ticket锁：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_t</span>&#123;</span>    <span class="hljs-type">int</span> ticket;    <span class="hljs-type">int</span> turn;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">lock_init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;    lock-&gt;ticket = <span class="hljs-number">0</span>;    lock-&gt;turn = <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;    <span class="hljs-type">int</span> myturn = fetchAndAdd(&amp;lock-&gt;ticket);    <span class="hljs-keyword">while</span>(lock-&gt;turn!= myturn)        ;<span class="hljs-comment">//spin</span>&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;    fetchAndAdd(&amp;lock-&gt;turn);&#125;</code></pre></div><p>通过检查<code>turn</code>字段与获取的<code>ticket</code>是否相等，判断是否可以进入临界区。</p><p>不同于之前的方法，本方法能保证所有线程都能获取锁，而不会导致某一个线程饥饿。</p><h3 id="28-12-自旋过多：怎么办"><a href="#28-12-自旋过多：怎么办" class="headerlink" title="28.12 自旋过多：怎么办"></a>28.12 自旋过多：怎么办</h3><blockquote><p>Q：这样避免自旋浪费CPU时间？</p></blockquote><h3 id="28-13-简单方法：让出CPU"><a href="#28-13-简单方法：让出CPU" class="headerlink" title="28.13 简单方法：让出CPU"></a>28.13 简单方法：让出CPU</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">while</span>(testAndSet(&amp;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)        yield();&#125;</code></pre></div><p>调用<code>yield()</code>让线程主动放弃CPU。</p><p>但是如果线程数量多，采用此方法会导致<code>context switch</code>成本提高。</p><p>同时还会有线程饥饿问题，一个线程可能一直处在让出CPU的循环，而其他线程反复进入临界区。</p><h3 id="28-14-使用队列：休眠代替自旋"><a href="#28-14-使用队列：休眠代替自旋" class="headerlink" title="28.14 使用队列：休眠代替自旋"></a>28.14 使用队列：休眠代替自旋</h3><p>如图28.9所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-28/28.9.jpg"></p><h3 id="28-15-Linux的fulex锁"><a href="#28-15-Linux的fulex锁" class="headerlink" title="28.15 Linux的fulex锁"></a>28.15 Linux的fulex锁</h3><p>利用一个整数，同时利记录锁是否被持有（整数的最高位），以及等待者的个数（整数的其它位）。</p><p>因此整数如果是负数，则处于被持有状态（有符号整数，高位为1为负数）。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-28/28.10.jpg"></p><h3 id="28-16-两阶段锁"><a href="#28-16-两阶段锁" class="headerlink" title="28.16 两阶段锁"></a>28.16 两阶段锁</h3><p>两阶段锁的第一阶段会先自旋一段时间，希望可以获得锁。但是如果自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用。</p><h2 id="Chapter-29-基于锁的并发数据结构"><a href="#Chapter-29-基于锁的并发数据结构" class="headerlink" title="Chapter 29 基于锁的并发数据结构"></a>Chapter 29 基于锁的并发数据结构</h2><blockquote><p>Q：如何给数据结构加锁，能够保证高性能，并实现线程安全？</p></blockquote><h3 id="29-1-并发计数器"><a href="#29-1-并发计数器" class="headerlink" title="29.1 并发计数器"></a>29.1 并发计数器</h3><p>如何实现一个线程安全的计数器？</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-29/29.2.jpg"></p><p>但是通过锁保护线程安全影响性能。</p><p>如果多线程运行下的速率和单线程下一样，就将其称为完美扩展（perfect scaling）。</p><blockquote><p>注：下文的扩展性是指，程序在并发环境下的性能优劣。</p></blockquote><p>人们提出了懒惰计数器（<strong>sloopy counter</strong>），懒惰计数器通过多个局部计数器和一个全局计数器来实现一个逻辑计数器，其中每个CPU核心都有一个局部计数器，每个计数器都有一个锁保护线程安全。</p><p>基本思想：如果一个CPU上的线程想增加计数器，增加自己的局部计数器，访问局部计数器通过对应的局部锁同步的。全局计数器的值会定期更新，通过获取全局锁，然后加上局部计数器的值，并将其清空。</p><p>更新的频率取决去阈值$S$，$S$越小，懒惰计数器越趋向于非扩展的计数器，$S$越大，扩展性越强，但是全局计数器和局部计数器的偏差较大。图29.5是懒惰计数器的基本实现：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-29/29.5.jpg"></p><h3 id="29-2-并发List"><a href="#29-2-并发List" class="headerlink" title="29.2 并发List"></a>29.2 并发List</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-29/29.7.jpg"></p><p>插入时检查是否发生内存分配错误，但是异常控制流容易产生错误。如何重写插入和查找函数？</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-29/29.8.jpg"></p><p>上述的写法，在插入时，缩小了锁的粒度。但是扩展性不好。</p><p><strong>hand-over-hand locking</strong>。：每个节点都有一个锁，代替了原来整个链表共享一个锁。遍历链表时，首先抢占下一个节点的锁，然后释放当前节点的锁。</p><p>但是这种方法的性能并不比单锁快。</p><h3 id="29-3-并发Queue"><a href="#29-3-并发Queue" class="headerlink" title="29.3 并发Queue"></a>29.3 并发Queue</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-29/29.9.jpg"></p><p>特点：</p><ul><li>入队只获取tail锁</li><li>出队只获取head锁</li></ul><h3 id="29-4-并发Hash"><a href="#29-4-并发Hash" class="headerlink" title="29.4 并发Hash"></a>29.4 并发Hash</h3><p>并发Hash中，每个桶都有一个锁。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-29/29.10.jpg"></p><h2 id="Chapter-30-条件变量"><a href="#Chapter-30-条件变量" class="headerlink" title="Chapter 30 条件变量"></a>Chapter 30 条件变量</h2><p>很多情况下，线程需要检查某一condition满足之后，才会继续运行。</p><blockquote><p>Q：线程应该如何等待一个条件？</p></blockquote><h3 id="30-1-定义和程序"><a href="#30-1-定义和程序" class="headerlink" title="30.1 定义和程序"></a>30.1 定义和程序</h3><p>线程可以使用<code>condition variable</code>，来等待一个条件变为真，条件变量是一个显式队列，当条件不满足时，线程把自己加入阻塞队列，进入阻塞状态，另外某个线程，当它改变了上述状态时，就可以唤醒一个或多个等待线程。</p><p>POSIX调用如图30.3所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-30/30.3.jpg"></p><p>那么done变量是否需要，下面的代码是否正确？</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-30/30.3-1.jpg"></p><p>假设子线程立即运行，并且调用<code>thr_exit()</code>，在这种情况下，子线程发送信号，但是没有在条件变量上等待的线程，父线程运行时，就会调用<code>wait()</code>进入阻塞状态，并且没有其它线程唤醒它。</p><h3 id="30-2-生产者-消费者问题"><a href="#30-2-生产者-消费者问题" class="headerlink" title="30.2 生产者&#x2F;消费者问题"></a>30.2 生产者&#x2F;消费者问题</h3><p>假设有一个或多个生产者线程和一个或多个消费者线程，生产者把生产的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式进行消费。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-30/30.12.jpg"></p><h3 id="30-3-覆盖条件"><a href="#30-3-覆盖条件" class="headerlink" title="30.3 覆盖条件"></a>30.3 覆盖条件</h3><p>下面是一个多线程内存分配库的覆盖条件的例子：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-30/30.13.jpg"></p><p>当线程进入内存分配中时，它可能会因为内存不足而等待。线程释放内存后，会发出信号通知会有更多的内存空间，但是有一个问题：应该唤醒那个等待线程？</p><p>场景：线程$Ta$申请100 bytes内存，线程$Tb$申请10 bytes内存，但是当前无空闲内存可分配，$Ta$和$Tb$都等待在条件变量上。此时线程$Tc$调用了<code>free(50)</code>，但是$Tc$如果唤醒$Ta$，那么$Ta$会因为内存不够继续等待。</p><p>因此可以使用<code>pthread_cond_broadcast()</code>代替上面的<code>pthread_cond_signal()</code>唤醒所有的等待线程。当然也有缺点：影响性能，不必要地唤醒了其他等待的线程。</p><p>这种条件变量称为覆盖条件（<strong>covering condition</strong>）。</p><h2 id="Chapter-31-信号量"><a href="#Chapter-31-信号量" class="headerlink" title="Chapter 31 信号量"></a>Chapter 31 信号量</h2><blockquote><p>Q：如何使用信号量代替锁和条件变量？信号量的概念，不用锁和条件变量，如何实现信号量？</p></blockquote><h3 id="31-1-信号量的定义"><a href="#31-1-信号量的定义" class="headerlink" title="31.1 信号量的定义"></a>31.1 信号量的定义</h3><p>信号量是一个整数型的对象，可以用两个函数来操作它，在POSIX标准中，分别是<code>sem_wait()</code>和<code>sem_post()</code>。含义分别如下：</p><ul><li><strong>sem_wait</strong>：<ul><li>decrement the value of semaphore s by one</li><li>wait it value of semaphore s is negative</li></ul></li><li><strong>sem_post</strong>：<ul><li>increment the value of semphore s by one</li><li>if there are one or more threads waiting, wake one</li></ul></li></ul><p>信号量如果为负数，那么绝对值就是等待线程的个数。</p><h3 id="31-2-二值信号量"><a href="#31-2-二值信号量" class="headerlink" title="31.2 二值信号量"></a>31.2 二值信号量</h3><p>二值信号量就是锁。</p><h3 id="31-3-信号量用作条件变量"><a href="#31-3-信号量用作条件变量" class="headerlink" title="31.3 信号量用作条件变量"></a>31.3 信号量用作条件变量</h3><p>信号量也可以用在一个线程暂停执行，等待某一条件成立的场景。例如：一个线程要等待一个链表非空，才能删除一个元素。此时可以将信号量作为条件变量。</p><h3 id="31-4-生产者消费者问题"><a href="#31-4-生产者消费者问题" class="headerlink" title="31.4 生产者消费者问题"></a>31.4 生产者消费者问题</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-31/31.12.jpg"></p><h3 id="31-5-读写锁"><a href="#31-5-读写锁" class="headerlink" title="31.5 读写锁"></a>31.5 读写锁</h3><p>如果某个线程需要进行更新操作，需要调用<code>rwlock_acquire_lock()</code>获得写锁，调用<code>rwlock_release_writelock()</code>释放锁，内部通过一个信号量保证只有一个写者能进入临界区。</p><p>读锁会通过<code>reader</code>变量追踪当前有多少个读者在访问该数据结构。</p><p>一旦一个读者获得了读锁，其他的读者也可以获得这个读锁。当时想要获取写锁的线程，必须等待所有的读者都结束。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-31/30.13.jpg"></p><h3 id="31-6-哲学家就餐问题"><a href="#31-6-哲学家就餐问题" class="headerlink" title="31.6 哲学家就餐问题"></a>31.6 哲学家就餐问题</h3><p>基本问题：假设又五位哲学家围着一个圆桌，每两位哲学家之间有一把叉子，一位哲学家只有同时拿到了左手边和右手边的两把叉子才能吃到东西。如何解决同步问题。</p><p>每位哲学家的基本操作：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">think</span>();<span class="hljs-built_in">getforks</span>();<span class="hljs-built_in">eat</span>();<span class="hljs-built_in">putforks</span>();&#125;</code></pre></div><p>如何保证没有死锁，并且不会有哲学家饿死？</p><p>需要一些辅助函数：例如哲学家P希望用左手边的叉子，他会调用left(p)，右手边的叉子调用right(p)。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<span class="hljs-keyword">return</span> p&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<span class="hljs-keyword">return</span> (p + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span> ;&#125;</code></pre></div><h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><p>将每个信号量都设置为1</p><div class="code-wrapper"><pre><code class="hljs scss">void <span class="hljs-built_in">getforks</span>()&#123;<span class="hljs-built_in">sem_wait</span>(forks[left(p)]);<span class="hljs-built_in">sem_wait</span>(forks[right(p)]);&#125;void <span class="hljs-built_in">putforks</span>() &#123;<span class="hljs-built_in">sem_post</span>(forks[left(p)]);<span class="hljs-built_in">sem_post</span>(forks[right(p)]);&#125;</code></pre></div><p>步骤是依次获取每把叉子的锁，先获取左手边的。</p><p>这个方案是有问题的，如果每个哲学家都拿到了左手边的叉子，他们会被阻塞，并一直等待另一只叉子。</p><h4 id="破除依赖"><a href="#破除依赖" class="headerlink" title="破除依赖"></a>破除依赖</h4><p>如何解决？ 修改某个哲学家的取叉子顺序。</p><div class="code-wrapper"><pre><code class="hljs scss">void <span class="hljs-built_in">getforks</span>() &#123;<span class="hljs-built_in">if</span>(p == <span class="hljs-number">4</span>)&#123;<span class="hljs-built_in">sem_wait</span>(forks[right(p)]);<span class="hljs-built_in">sem_wait</span>(forks[left(p)]);&#125;else&#123;<span class="hljs-built_in">sem_wait</span>(forks[left(p)]);<span class="hljs-built_in">sem_wait</span>(forks[right(p)]);&#125;&#125;</code></pre></div><h3 id="31-7-如何实现信号量"><a href="#31-7-如何实现信号量" class="headerlink" title="31.7 如何实现信号量"></a>31.7 如何实现信号量</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-31/31.16.jpg"></p><h2 id="Chapter-32-常见并发问题"><a href="#Chapter-32-常见并发问题" class="headerlink" title="Chapter 32 常见并发问题"></a>Chapter 32 常见并发问题</h2><blockquote><p>Q：如何处理常见的并发缺陷？</p></blockquote><h3 id="32-1-有哪些类型的缺陷"><a href="#32-1-有哪些类型的缺陷" class="headerlink" title="32.1 有哪些类型的缺陷"></a>32.1 有哪些类型的缺陷</h3><p>死锁和非死锁。</p><h3 id="32-2-非死锁缺陷"><a href="#32-2-非死锁缺陷" class="headerlink" title="32.2 非死锁缺陷"></a>32.2 非死锁缺陷</h3><ul><li>反原子性</li><li>错误顺序缺陷</li></ul><h4 id="违反原子性缺陷"><a href="#违反原子性缺陷" class="headerlink" title="违反原子性缺陷"></a>违反原子性缺陷</h4><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-32/mysql_concurrency.jpg"></p><p>这是MySQL中出现的例子，两个线程都要访问<code>thd</code>中的<code>proc_info</code>，第一个线程检查<code>proc_info</code>非空，然后打印值，第二个线程设置其为空，当第一个线程恢复执行时，会由于空指针而报错。</p><p>解决方案很简单，将共享变量的访问加锁，确保串行化访问变量。</p><h4 id="违反顺序缺陷"><a href="#违反顺序缺陷" class="headerlink" title="违反顺序缺陷"></a>违反顺序缺陷</h4><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-32/2.jpg"></p><p>线程2假定已经初始化了，然而如果线程1没有首先执行，线程2则会因为空指针报错。</p><p>如何解决？ 保证执行顺序不被打破。</p><p>可以使用条件变量解决。</p><h3 id="32-3-死锁缺陷"><a href="#32-3-死锁缺陷" class="headerlink" title="32.3 死锁缺陷"></a>32.3 死锁缺陷</h3><p>线程1持有锁L1，线程2持有锁L2，线程1请求L2，线程2请求L1。</p><blockquote><p>Q：如何应对死锁？</p></blockquote><h4 id="发生的原因"><a href="#发生的原因" class="headerlink" title="发生的原因"></a>发生的原因</h4><ul><li>大型项目中，组件之间有复杂的依赖。</li><li>封装会隐藏实现细节，会让人忽视。</li></ul><h4 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h4><ul><li>互斥：线程对于需要的资源进行互斥访问。</li><li>持有并等待：线程持有了资源。</li><li>非抢占：线程获得的资源，不能被抢占。</li><li>循环等待：线程之间存在一个环路，环路上的每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</li></ul><h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><ul><li><p>从循环等待条件解决：让代码不会产生循环等待，最直接的方法就是获取锁时提供一个全序，偏序也是一种有用的方法，Linux中内存映射就是一个偏序锁的好例子。</p></li><li><p>从持有并等待条件解决：通过原子性地抢锁来避免。</p></li><li><p>从非抢占条件解决：可以通过<code>tryLock()</code>解决问题。</p></li><li><p>从互斥条件解决：方法是完全避免互斥，但是代码总会存在临界区，因此很难避免互斥。</p><ul><li>可以使用lock-free，通过强大地硬件指令，可以构造出不需要锁的数据结构。</li></ul></li></ul><h4 id="通过调度避免死锁"><a href="#通过调度避免死锁" class="headerlink" title="通过调度避免死锁"></a>通过调度避免死锁</h4><h4 id="检查和恢复"><a href="#检查和恢复" class="headerlink" title="检查和恢复"></a>检查和恢复</h4><p>允许死锁偶尔发生，检查到死锁时再采取行动。</p><p>很多数据库系统使用了死锁检测和恢复技术，死锁检测器会定期运行，通过构建资源图来检查循环。</p><h2 id="Chapter-33-基于事件的并发"><a href="#Chapter-33-基于事件的并发" class="headerlink" title="Chapter 33 基于事件的并发"></a>Chapter 33 基于事件的并发</h2><blockquote><p>Q：不用线程，同时保证对并发的控制，如何构建并发服务器？</p></blockquote><h3 id="33-1-基本想法：事件循环"><a href="#33-1-基本想法：事件循环" class="headerlink" title="33.1 基本想法：事件循环"></a>33.1 基本想法：事件循环</h3><p>使用的基本的方法是<strong>基于事件的并发</strong>。该方法很简单：等待某事发生。当它发生时，检查事件类型，然后做少量的相应工作。</p><p>想看一个典型的基于事件的服务器，这种应用被称为事件循环：</p><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-number">1</span>) &#123;</span><span class="hljs-function"><span class="hljs-variable">events</span> = <span class="hljs-title">getEvents</span>();</span><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-variable">e</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">events</span>)</span><span class="hljs-function"><span class="hljs-title">processEvent</span>(<span class="hljs-variable">e</span>);</span><span class="hljs-function">&#125;</span></code></pre></div><p>这也带来了问题：基于事件的服务器如何决定哪个事件发生，尤其是对于网络和磁盘IO？时间服务器如何确定是否有它的消息已经到达？</p><h3 id="33-2-重要API：select"><a href="#33-2-重要API：select" class="headerlink" title="33.2 重要API：select()"></a>33.2 重要API：select()</h3><p>大多数OS提供了基本的API决定如何接收事件。即通过<code>select()</code>或<code>poll()</code>系统调用。</p><p>这些接口对程序的支持很简单：检查是否有任何应该关注的进入I&#x2F;O。假定网络程序希望检查是否有网络数据包已到达，以便为它们提供服务，</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,</span><span class="hljs-params">          fd_set *<span class="hljs-keyword">restrict</span> readfds,</span><span class="hljs-params">          fd_set *<span class="hljs-keyword">restrict</span> writefds,</span><span class="hljs-params">          fd_set *<span class="hljs-keyword">restrict</span> errorfds,</span><span class="hljs-params">          <span class="hljs-keyword">struct</span> timeval *<span class="hljs-keyword">restrict</span> timeout)</span>;</code></pre></div><p><code>select()</code>检查I&#x2F;O描述符集合，它们的地址通过<code>readfds</code>、<code>writefds</code>、<code>errorfds</code>传入，分别查看它们中的某些描述符是否已准备好读取，是否准备好写入，或者异常情况待处理。在每个集合中检查前nfds个描述符，返回时，<code>select()</code>用给定请求操作准备好的描述符组成的子集替换给定的描述符集合。<code>select()</code>返回所有集合中就绪描述符的总数。</p><ul><li>阻塞接口：在返回给调用者之前完成所有工作。</li><li>非阻塞接口：开始一些工作后立即返回，从而让所有需要完成的工作都在后台完成。</li></ul><h3 id="33-3-使用select"><a href="#33-3-使用select" class="headerlink" title="33.3 使用select()"></a>33.3 使用select()</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-32/33.1.jpg"></p><ol><li>使用<code>FD_ZERO()</code>宏首先清除文件描述符集合。</li><li>使用<code>FD_SET()</code>将所有从<code>minFD</code>到<code>maxFD</code>的文件描述符包含到集合中。<ul><li>例如，这组描述符可能表示服务器正在关注的所有网络套接字。</li></ul></li><li>最后，服务器调用<code>select()</code>来查看哪些连接有可用的数据。</li><li>然后通过在循环中使用<code>FD_ISSET()</code>，事件服务器可以查看哪些描述符已准备好数据并处理传入的数据。</li></ol><h3 id="33-4-无需锁"><a href="#33-4-无需锁" class="headerlink" title="33.4 无需锁"></a>33.4 无需锁</h3><p>使用单个CPU和基于事件的应用程序，也就不存在并发问题。具体来说，因为一次只处理一个事件，所以不需要锁来保护指定对象。</p><h3 id="33-5-阻塞系统调用"><a href="#33-5-阻塞系统调用" class="headerlink" title="33.5 阻塞系统调用"></a>33.5 阻塞系统调用</h3><p>如果某个事件要求你发出可能会阻塞的系统调用，该怎么办？</p><p>例如：一个请求进入服务器，要求磁盘读取文件并将内容返回到客户端。为了处理这样的请求，需要发出<code>open()</code>系统调用打开文件，<code>read()</code>读取文件。</p><p>由于IO操作远慢于CPU，因此需要很长时间才能提供服务。</p><p>在基于事件的方法中，事件循环阻塞时，系统会处于闲置状态，并不会读取新事件。曹诚资源浪费。</p><p>因此，在基于事件的系统中必须：不允许阻塞调用。</p><h3 id="33-6-解决方案：异步I-O"><a href="#33-6-解决方案：异步I-O" class="headerlink" title="33.6 解决方案：异步I&#x2F;O"></a>33.6 解决方案：异步I&#x2F;O</h3><p>异步I&#x2F;O（<strong>asynchronous I&#x2F;O</strong>）：发出I&#x2F;O请求后，在I&#x2F;O完成之前立即将控制权返回给调用者，另外的接口让应用程序能够确定各种I&#x2F;O是否已完成。</p><p>macOS中提供了AIO的接口，这些API围绕着一个基本结构：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span>&#123;</span>    <span class="hljs-type">int</span> aio_fildes;    <span class="hljs-type">off_t</span> aio_offset;    <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> *aio_buf;    <span class="hljs-type">size_t</span> aio_nbytes;&#125;</code></pre></div><p>要发起AIO请求，应用程序首先用相关信息填充此结构：</p><ul><li><strong>aio_fildes</strong>：要读取文件的文件描述符</li><li><strong>aio_offset</strong>：文件内的偏移量</li><li><strong>aio_buf</strong>：复制读取结果的目标内存位置</li><li><strong>aio_nbytes</strong>：读取长度</li></ul><p>通过<code>aio_read()</code>进行异步读取。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">aio_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> aiocb * aiocbp)</span>;</code></pre></div><p>如何知道IO何时完成，并且缓冲区现在有了请求的数据？</p><p><code>aio_error()</code>检查aiocbp应用的请求是否已完成。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">aio_error</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> aiocb * aiocbp)</span>;</code></pre></div><p>因此，检查AIO是否已经完成需要轮询。为了解决这个问题，一些系统提供了基于中断的方法，此方法使用UNIX信号（signal）在异步IO完成时通知应用程序，从而消除了轮询的需要。</p><h3 id="33-7-另一个问题：状态管理"><a href="#33-7-另一个问题：状态管理" class="headerlink" title="33.7 另一个问题：状态管理"></a>33.7 另一个问题：状态管理</h3><p>基于事件的方法存在另一个问题：代码比传统的基于线程的复杂。</p><p>原因在于：需要手动的管理事件IO状态，基于线程的程序不需要，因为时线程栈自动管理。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSTEP阅读笔记-Virtuallization（一）</title>
    <link href="/2020/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OS/ostep-virtualization/"/>
    <url>/2020/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/OS/ostep-virtualization/</url>
    
    <content type="html"><![CDATA[<h1 id="进程虚拟化"><a href="#进程虚拟化" class="headerlink" title="进程虚拟化"></a>进程虚拟化</h1><h2 id="Chapter-4-进程"><a href="#Chapter-4-进程" class="headerlink" title="Chapter 4 进程"></a>Chapter 4 进程</h2><blockquote><p>Q：如何提供有许多CPU的假象？</p></blockquote><p>OS通过<code>Visualizing</code>  CPU来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其它进程，这样就提供了存在多个虚拟CPU的假象。</p><ul><li>时分共享：典型的就是时间片划分，将一小段时间分配给不同的进程。</li><li>空分共享：典型的就是磁盘空间，将空间分配给不同的文件。</li></ul><p>Qustions：</p><ul><li>如何实现<code>context switch</code></li><li>OS如何执行<code>scheduling policy</code></li></ul><h3 id="4-1-抽象：进程"><a href="#4-1-抽象：进程" class="headerlink" title="4.1 抽象：进程"></a>4.1 抽象：进程</h3><blockquote><p>OS为正在运行的程序提供的抽象，就是所谓的进程。</p></blockquote><p>进程的<code>machine state</code>：</p><ul><li>进程可访问的内存（<code>address space</code>）：指令和数据存储在<code>address space</code>。</li><li>寄存器（<code>register</code>）</li></ul><h3 id="4-2-进程API"><a href="#4-2-进程API" class="headerlink" title="4.2 进程API"></a>4.2 进程API</h3><ul><li>create</li><li>destroy</li><li>wait</li><li>miscellaneous control</li><li>status</li></ul><h3 id="4-3-进程创建的细节"><a href="#4-3-进程创建的细节" class="headerlink" title="4.3 进程创建的细节"></a>4.3 进程创建的细节</h3><blockquote><p>Q: 程序如何转换为进程？换而言之，OS如何启动并运行一个程序？</p></blockquote><ol><li>OS将代码和静态数据<code>load</code>到内存中，加载到进程的<code>address space</code>。如图4.1所示：</li></ol><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-4/program-to-process.jpg" alt="从程序到进程"></p><ol start="2"><li>加载后，OS在运行前需要执行初始化操作。<ul><li>为程序的<strong>运行时栈（run-time stack）</strong>分配一些内存。C程序使用栈存放局部变量，函数参数和返回地址。</li><li>为<strong>堆（heap）</strong>分配一些内存，C程序中，堆用于显式请求的动态分配数据（<code>malloc &amp; free</code>）</li><li><code>I/O</code>相关的任务。UNIX中每个进程都会有三个打开的文件描述符（<code>file descriptor</code>）</li></ul></li></ol><h3 id="4-4-进程状态"><a href="#4-4-进程状态" class="headerlink" title="4.4 进程状态"></a>4.4 进程状态</h3><ul><li>运行</li><li>就绪</li><li>阻塞</li></ul><p>进程的状态转化图如图4.2所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-4/process-state.jpg" alt="进程：状态转换"></p><h3 id="4-5-数据结构"><a href="#4-5-数据结构" class="headerlink" title="4.5 数据结构"></a>4.5 数据结构</h3><p>对于停止的进程，上下文将保存寄存器的内容，通过上下文切换可以使OS恢复运行该进程。</p><p>下图中的<code>context</code>就是上下文的数据结构，<code>proc</code></p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-4/proc.jpg" alt="xv6的proc结构"></p><h2 id="Chapter-5-进程API"><a href="#Chapter-5-进程API" class="headerlink" title="Chapter 5 进程API"></a>Chapter 5 进程API</h2><p>本章讨论在UNIX系统中的进程创建。</p><blockquote><p>Q：如何创建并控制进程？</p></blockquote><h3 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork() 系统调用"></a>fork() 系统调用</h3><p><code>fork()</code>用于创建新进程，<code>fork</code>的子进程从<code>fork</code>处开始执行。示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());    <span class="hljs-type">int</span> rc = fork();    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// fork failed</span>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I&#x27;am child (pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (pid: %d)\n&quot;</span>, rc, (<span class="hljs-type">int</span>)getpid());    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes !!\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行结果如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">hello world (pid:</span> <span class="hljs-number">13360</span><span class="hljs-string">)</span><span class="hljs-string">hello,</span> <span class="hljs-attr">I am parent of 13361 (pid:</span> <span class="hljs-number">13360</span><span class="hljs-string">)</span><span class="hljs-literal">yes</span> <span class="hljs-string">!!</span><span class="hljs-string">hello,</span> <span class="hljs-string">I&#x27;am</span> <span class="hljs-attr">child (pid:</span> <span class="hljs-number">13361</span><span class="hljs-string">)</span><span class="hljs-literal">yes</span> <span class="hljs-string">!!</span></code></pre></div><h3 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait() 系统调用"></a>wait() 系统调用</h3><p>父进程等待子进程执行完毕。示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());    <span class="hljs-type">int</span> rc = fork();    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// fork failed</span>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I&#x27;am child (pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">int</span> wc = wait(<span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (wc: %d)(pid: %d)\n&quot;</span>, rc, wc,               (<span class="hljs-type">int</span>)getpid());    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes !!\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行结果如下：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">hello</span> world (pid: <span class="hljs-number">13787</span>)<span class="hljs-attribute">hello</span>, I&#x27;am child (pid: <span class="hljs-number">13788</span>)<span class="hljs-attribute">yes</span> !!<span class="hljs-attribute">hello</span>, I am parent of <span class="hljs-number">13788</span> (wc: <span class="hljs-number">13788</span>)(pid: <span class="hljs-number">13787</span>)<span class="hljs-attribute">yes</span> !!</code></pre></div><h3 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec() 系统调用"></a>exec() 系统调用</h3><p>子进程调用<code>execvp()</code>来运行字符计数程序<code>wc</code>。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world (pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());    <span class="hljs-type">int</span> rc = fork();    <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// fork failed</span>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;fork failed\n&quot;</span>);        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I&#x27;am child (pid: %d)\n&quot;</span>, (<span class="hljs-type">int</span>)getpid());        <span class="hljs-type">char</span> *myargs[<span class="hljs-number">3</span>];        myargs[<span class="hljs-number">0</span>] = strdup(<span class="hljs-string">&quot;wc&quot;</span>);        myargs[<span class="hljs-number">1</span>] = strdup(<span class="hljs-string">&quot;p3.c&quot;</span>);        myargs[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;        execvp(myargs[<span class="hljs-number">0</span>], myargs);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this shouldn&#x27;t print out\n&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">int</span> wc = wait(<span class="hljs-literal">NULL</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, I am parent of %d (wc: %d)(pid: %d)\n&quot;</span>, rc, wc,               (<span class="hljs-type">int</span>)getpid());    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>运行结果如下：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">hello</span> world (pid: <span class="hljs-number">14384</span>)<span class="hljs-attribute">hello</span>, I&#x27;am child (pid: <span class="hljs-number">14385</span>) <span class="hljs-attribute">36</span> <span class="hljs-number">115</span> <span class="hljs-number">906</span> p3.c<span class="hljs-attribute">hello</span>, I am parent of <span class="hljs-number">14385</span> (wc: <span class="hljs-number">14385</span>)(pid: <span class="hljs-number">14384</span>)</code></pre></div><h2 id="Chapter-6-受限直接执行"><a href="#Chapter-6-受限直接执行" class="headerlink" title="Chapter 6 受限直接执行"></a>Chapter 6 受限直接执行</h2><blockquote><p> Q：如何高效、可控地虚拟化CPU？</p></blockquote><h3 id="6-1-基本技巧：受限直接执行"><a href="#6-1-基本技巧：受限直接执行" class="headerlink" title="6.1 基本技巧：受限直接执行"></a>6.1 基本技巧：受限直接执行</h3><p>直接执行：直接在CPU上运行程序。</p><p>下表展示了基本的直接执行协议：</p><table><thead><tr><th align="center">OS</th><th align="center">Program</th></tr></thead><tbody><tr><td align="center">为进程列表创建条目；为程序分配内存；将程序加载到内存；将参数设置到程序栈</td><td align="center"></td></tr><tr><td align="center">清楚寄存器；执行call main()</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">执行main()；从main中执行return</td></tr><tr><td align="center">释放进程的内存；将进程从进程列表中清除</td><td align="center"></td></tr></tbody></table><p>但是这会产生问题：</p><ul><li>OS如何确保程序不做不安全的操作</li><li>OS如何进行进程切换</li></ul><h3 id="6-2-问题1：受限制的操作"><a href="#6-2-问题1：受限制的操作" class="headerlink" title="6.2 问题1：受限制的操作"></a>6.2 问题1：受限制的操作</h3><blockquote><p> Q：如何执行受限制的操作？</p></blockquote><p>引入用户态&#x2F;内核态的概念，程序在用户态下运行的代码会受到限制。OS以内核态运行，特权指令在这个模式下运行。</p><blockquote><p>Q：用户希望执行特权操作，如何实现？</p></blockquote><p>硬件提供了用户执行系统调用的能力，允许内核向用户进程暴露一些系统调用，例如访问文件系统、创建和销毁进程、与其他进程通信以及内存分配等操作。</p><p>要执行系统调用，程序必须执行特殊的<code>trap</code>指令。该指令同时跳入内核，转为内核态进行系统调用，完成后，OS调用<code>return-from-trap</code>指令，返回到发出调用的用户程序中，同时将级别转为用户态。</p><p>为了保证<code>return-from-trap</code>正确返回，需要将进程<code>trap</code>之前的状态保存起来。</p><blockquote><p>Q：陷阱如何知道在OS内运行哪些代码？</p></blockquote><p>内核通过在启动时设置<code>trap table</code>（中断向量表）来实现。</p><h3 id="6-3-在进程之间切换"><a href="#6-3-在进程之间切换" class="headerlink" title="6.3 在进程之间切换"></a>6.3 在进程之间切换</h3><blockquote><p>Q：OS如果重新获得CPU的控制权，以便它可以在进程之间切换？</p></blockquote><h4 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h4><p>这是一种被动获取方式，还不能确保。</p><h4 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h4><p>进行时钟中断（timer interrupt），时钟设备可以设置为每隔几毫秒产生一次中断，中断时，当前正在运行的进程 停止，OS中预先准备的中断处理程序会运行，此时OS重新获得CPU的控制权。</p><h4 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h4><p><code>context switch</code>：为当前正在执行的进程保存一些寄存器的值，并为即将运行的进程恢复一些寄存器的值。</p><p>需要注意：<strong>上下文的切换不仅仅来自于保存和恢复少量的寄存器的操作。</strong>程序运行时，会在<code>CPU Cache</code>、<code>TLB</code>、分支预测器和其它片上硬件中建立大量的状态。</p><p>图6.1是xv6的上下文切换代码：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-4/switch.jpg"></p><h2 id="Chapter-7-进程调度"><a href="#Chapter-7-进程调度" class="headerlink" title="Chapter 7 进程调度"></a>Chapter 7 进程调度</h2><blockquote><p>Q：如何开发一个考虑调度的基本框架？</p></blockquote><h3 id="7-1-工作负载假设"><a href="#7-1-工作负载假设" class="headerlink" title="7.1 工作负载假设"></a>7.1 工作负载假设</h3><p>我们对OS中运行的进程做出如下的工作负载假设（这些假设是不现实）：</p><ul><li>每一个工作运行相同的时间。</li><li>所有的工作同时到达。</li><li>一旦开始，每个工作保持运行直到完成。</li><li>所有的工作只是用CPU。（不执行IO操作）</li><li>每个工作的运行时间是已知的。</li></ul><h3 id="7-2-调度指标"><a href="#7-2-调度指标" class="headerlink" title="7.2 调度指标"></a>7.2 调度指标</h3><p>只用一个指标：周转时间（turnaround time），定义是任务完成时间减去任务到达时间。正式定义：</p><p>$$T周转时间 &#x3D; T完成时间 - T到达时间$$</p><p>公平是另一个性能指标，但是性能和公平在调度系统中是矛盾的。</p><h3 id="7-3-FIFO"><a href="#7-3-FIFO" class="headerlink" title="7.3 FIFO"></a>7.3 FIFO</h3><p>先进先出调度，也称为先来先服务（FCFS），特性：简单并易于实现。</p><p>如果存在护航效应（convoy effect）：即前面的任务运行时间长，一些耗时较少的进程排在耗时较长的进程之后。</p><p>Q：如何开发以中更好的算法来处理这个情况？</p><h3 id="7-4-最短任务优先（SJF）"><a href="#7-4-最短任务优先（SJF）" class="headerlink" title="7.4 最短任务优先（SJF）"></a>7.4 最短任务优先（SJF）</h3><p>如果所有任务同时到达，，SJF是一个最优的调度算法。</p><p>但是如果不是同时到达，存在饥饿问题。</p><h3 id="7-5-最短完成时间优先（STCF）"><a href="#7-5-最短完成时间优先（STCF）" class="headerlink" title="7.5 最短完成时间优先（STCF）"></a>7.5 最短完成时间优先（STCF）</h3><p>如果对SJF添加抢占，则被称为最短完成时间优先（STCF）。每当新进程进入系统，它会确认所有的进程，谁的剩余完成时间最少，然后调度它。</p><h3 id="7-6-新度量指标：响应时间"><a href="#7-6-新度量指标：响应时间" class="headerlink" title="7.6 新度量指标：响应时间"></a>7.6 新度量指标：响应时间</h3><p>对于早期的批处理系统来说，STCF可能是一个很好的策略。但是，引入分时系统之后，用户会对系统的交互性能有所要求。因此诞生了一个新的调度程序度量标准：<strong>响应时间</strong>。</p><p>$$T响应时间 &#x3D; T首次运行时间 - T到达时间$$</p><p>STCF和相关方法在响应时间的表现上并不是很好。例如：如果3个进程同时到达，第三个工作必须等待前两个工作全部运行后才能运行。</p><h3 id="7-7-轮转（Round-Robin）"><a href="#7-7-轮转（Round-Robin）" class="headerlink" title="7.7 轮转（Round-Robin）"></a>7.7 轮转（Round-Robin）</h3><p>基本思想：RR在一个时间片内运行工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束，反复执行，直到所有任务完成。</p><p>注意点：</p><ul><li>时间片长度必须是时钟中断周期的倍数。</li><li>时间片长度对于RR至关重要，时间片越短，在响应时间上表现越好，但是会增加上下文切换的性能开销。因此需要权衡时间片的大小。</li></ul><p>两种调度程序：</p><ul><li>SJF、STCF：优化周转时间，对响应时间不利。</li><li>RR：优化响应时间，对周转时间不利。</li></ul><h3 id="7-8-结合I-O"><a href="#7-8-结合I-O" class="headerlink" title="7.8 结合I&#x2F;O"></a>7.8 结合I&#x2F;O</h3><p>调度程序会在工作时发起I&#x2F;O请求，OS会根据具体情况来选择执行顺序，以便更好地交互使用资源。</p><h3 id="7-9-无法预知"><a href="#7-9-无法预知" class="headerlink" title="7.9 无法预知"></a>7.9 无法预知</h3><p>在通用的OS中，操作系统无法预知每个作业的长度，因此我们如何能够将已经看到的一些想法与RR调度程序结合起来，以便响应时间变得不错？</p><h2 id="Chapter-8-多级反馈队列"><a href="#Chapter-8-多级反馈队列" class="headerlink" title="Chapter 8 多级反馈队列"></a>Chapter 8 多级反馈队列</h2><p>多级反馈队列（MLFQ）应用于兼容时分共享系统。主要解决两方面问题：</p><ul><li>优化周转时间：先执行短作业来实现。</li><li>降低响应时间：如何降低？</li></ul><blockquote><p>Q： 没有工作长度的前提条件，如何设计一个能同时减少响应时间和周转时间的调度程序？</p></blockquote><h3 id="8-1-基本规则"><a href="#8-1-基本规则" class="headerlink" title="8.1 基本规则"></a>8.1 基本规则</h3><p>MLFQ中有许多独立的队列，每个队列有不同的优先级，任何时刻，一个任务只能存在于一个队列中，MLFQ总是执行优先级较高的工作。</p><p>MLFQ会根据观察到的行为调整它的优先级。例如：一个工作不断放弃CPU去等待键盘输入，MLFQ则推断它是交互式进程，并让它保留高优先级。相反，如果一个工作长时间占用CPU，MLFQ则会降低其优先级。</p><h3 id="8-2-尝试1：如何改变优先级"><a href="#8-2-尝试1：如何改变优先级" class="headerlink" title="8.2 尝试1：如何改变优先级"></a>8.2 尝试1：如何改变优先级</h3><blockquote><p> Q：MLFQ如何改变任务的优先级？</p></blockquote><p>既有很多运行时间很短、频繁放弃CPU的交互式进程，也有需要很多CPU时间、响应时间不重要的计算密集型进程。优先级调整算法：</p><ul><li>任务进入系统，放在最高优先级的队列。</li><li>任务用完整个时间片，降低其优先级，下移一个队列。</li><li>如果任务在其时间片内主动释放CPU，则优先级不变。</li></ul><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>饥饿问题：如果系统有很多交互式进程，就会不断占用CPU，导致长任务永远无法得到CPU。</li><li>如何阻止调度程序被欺骗？</li></ul><h3 id="8-3-尝试2：提升优先级"><a href="#8-3-尝试2：提升优先级" class="headerlink" title="8.3 尝试2：提升优先级"></a>8.3 尝试2：提升优先级</h3><p>上面存在的问题需要解决，一个简单的思路就是周期性的提升所有任务的优先级。规则如下：</p><ul><li>经过一段时间S，就将系统中所有任务重新加入最高优先级队列中。</li></ul><blockquote><p> Q：时间S如何设置？</p></blockquote><p>太高会导致长任务饥饿，太低会让交互式任务得不到合适的CPU时间。</p><h3 id="8-4-尝试3：更好的计时方式"><a href="#8-4-尝试3：更好的计时方式" class="headerlink" title="8.4 尝试3：更好的计时方式"></a>8.4 尝试3：更好的计时方式</h3><blockquote><p>Q：如何阻止调度程序被欺骗？</p></blockquote><p>解决：为每层队列提供更完善的CPU计时方式，调度程序应该记录一个进程在某一层中消耗的总时间。而不是在调度时重新计时。规则如下：</p><ul><li>一旦任务用完了其在某一层的时间配额，则降低其优先级。</li></ul><h3 id="8-5-MLFQ调优及其他问题"><a href="#8-5-MLFQ调优及其他问题" class="headerlink" title="8.5 MLFQ调优及其他问题"></a>8.5 MLFQ调优及其他问题</h3><p>MLFQ调度算法的参数如何设置？</p><p><code>Solaris</code>的MLFQ提供了一组表来决定进程在其生命周期中如何调整优先级，每层的时间片大小、时间S都由管理员动态调整。</p><h3 id="8-6-MLFQ-小结"><a href="#8-6-MLFQ-小结" class="headerlink" title="8.6 MLFQ 小结"></a>8.6 MLFQ 小结</h3><ul><li>规则1：如果A优先级 &gt; B优先级，运行A</li><li>规则2：如果A优先级 &#x3D; B优先级，轮转运行A和B</li><li>规则3：任务进入系统时，放在最高优先级。</li><li>规则4：一旦任务用完了其在某一层的时间配额，就降低其优先级。</li><li>规则5：经过一段时间S，就将系统中所有任务重新加入最高优先级队列。</li></ul><h2 id="Chapter-9-比例份额"><a href="#Chapter-9-比例份额" class="headerlink" title="Chapter 9 比例份额"></a>Chapter 9 比例份额</h2><p>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。</p><blockquote><p>Q：如何按比例分配CPU？关键机制与效率如何？</p></blockquote><h3 id="9-1-基本概念：彩票数代表份额"><a href="#9-1-基本概念：彩票数代表份额" class="headerlink" title="9.1 基本概念：彩票数代表份额"></a>9.1 基本概念：彩票数代表份额</h3><p>彩票调度（<strong>lottery scheduling</strong>）背后是一个基本概念：彩票数（<strong>ticket</strong>）代表了进程占有某个资源的份额。一个进程拥有的<code>ticket</code>占总<code>ticket</code>的百分比，就是它占有资源的份额。</p><p>例如：进程A拥有75张<code>ticket</code>，B拥有25张，则将CPU时间按<code>3:1</code>分配给A、B进程。</p><p>通过定时地抽取<code>ticket</code>，由于程序知道总<code>ticket</code>，因此每次通过随机数对进程占用时间进行分配。</p><h3 id="9-2-彩票机制"><a href="#9-2-彩票机制" class="headerlink" title="9.2 彩票机制"></a>9.2 彩票机制</h3><p>该机制提供了一些有效的方式来调度彩票。</p><ul><li>利用彩票货币（<strong>ticket currency</strong>）的概念，允许拥有一组<code>ticket</code>的用户以他们喜欢的某种货币，将<code>ticket</code>分给自己的不同工作。之后OS再自动将这种货币兑换成正确的全局<code>ticket</code>。</li><li>彩票转让（<strong>ticket transfer</strong>）：一个进程可以临时将自己拥有的彩票交给另一个进程。</li><li>彩票通胀（<strong>ticket inflation</strong>）：一个进程可以临时提升或降低自己拥有的彩票数量。</li></ul><h3 id="9-3-实现"><a href="#9-3-实现" class="headerlink" title="9.3 实现"></a>9.3 实现</h3><p>需要一个随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（链表），以及所有彩票的总数。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> winner = getrandom(<span class="hljs-number">0</span>, totalTickets);<span class="hljs-type">node_t</span> * current = head;<span class="hljs-keyword">while</span>(current)&#123;    counter = counter + current-&gt;tickets;    <span class="hljs-keyword">if</span> (counter &gt; winner)        <span class="hljs-keyword">break</span>;    current = current-&gt;next;&#125;</code></pre></div><h2 id="Chapter-10-多处理器调度"><a href="#Chapter-10-多处理器调度" class="headerlink" title="Chapter 10 多处理器调度"></a>Chapter 10 多处理器调度</h2><blockquote><p>Q：OS如何在多CPU上进行调度工作？会遇到什么新问题？</p></blockquote><h3 id="10-1-多处理器架构"><a href="#10-1-多处理器架构" class="headerlink" title="10.1 多处理器架构"></a>10.1 多处理器架构</h3><p>与单CPU之间的基本区别：对硬件缓存的使用，以及多处理器之间共享数据的方式。</p><p>如果系统有多个处理器，并共享同一个内存，会出现什么问题？</p><blockquote><p>案例：如果一个运行在CPU1上的程序从内存地址A读取数据，由于未命中缓存，系统直接访问内存，得到值D，然后修改了地址A处的值，但实际上h只是将缓存修改为新值D’。系统会在一段时间之后再将数据从缓存更新到内存。假设此时，CPU2中的程序读取地址A处的值，然而得到了旧值D。</p></blockquote><p>以上问题被称为缓存一致性（<strong>cache coherence</strong>）问题。</p><p>硬件提供了 这个问题的基本解决方案：<strong>通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性。</strong>在基于总线的系统中，一种方式是使用<strong>bus snooping</strong>。每个缓存都通过监听链接所有缓存和内存的总线。如果发现内存访问，则对缓存中的对应数据进行更新。</p><h3 id="10-2-同步"><a href="#10-2-同步" class="headerlink" title="10.2 同步"></a>10.2 同步</h3><p>跨CPU访问共享数据时，需要使用互斥原语或其他方法（lock-free）才能保证正确性。</p><h3 id="10-3-缓存亲和度"><a href="#10-3-缓存亲和度" class="headerlink" title="10.3 缓存亲和度"></a>10.3 缓存亲和度</h3><p><strong>cache affinity</strong>：一个进程在CPU上运行时，会在该CPU的缓存中维护许多状态。下次该进程在相同CPU上运行时，由于缓存中的数据而执行的更快。相反，在不同的CPU上执行，会由于需要重新加载数据而很慢。因此多处理器调度应该考虑这种缓存亲和性，尽量将进程保持在同一个CPU上执行。</p><h3 id="10-4-单队列调度"><a href="#10-4-单队列调度" class="headerlink" title="10.4 单队列调度"></a>10.4 单队列调度</h3><blockquote><p>Q：如何设计一个多处理器系统的调度程序？</p></blockquote><p>最基本的方式是简单地复用单处理器调度的基本架构。将所有进程放到一个队列中。将此称为单队列多处理器调度（SQMS）。</p><p>缺点：</p><ul><li>缺乏可扩展性</li><li>缓存亲和性</li></ul><h3 id="10-5-多队列调度"><a href="#10-5-多队列调度" class="headerlink" title="10.5 多队列调度"></a>10.5 多队列调度</h3><p>每个CPU一个队列。将此称为多队列多处理器调度（MQMS）。每个队列使用不同的调度规则。当进程进入系统后，会根据一些启发性原则（随机或选择较空的队列）将其放入某个调度队列。</p><p>优点：</p><ul><li>可扩展性</li><li>有良好的缓存亲和性</li></ul><p>缺点：</p><ul><li>负载不均</li></ul><blockquote><p>Q：如何应对负载不均？</p></blockquote><p><strong>migration</strong>：将工作跨CPU移动。如果CPU1的队列无任务，CPU1的队列中有两个任务，OS会将CPU1队列中的一个任务migration到CPU0的队列。</p><p><strong>work stealing</strong>：较少任务的队列会从其它队列中steal任务。缺点：频繁检查会引起较高的开销。需要设置合理的检查间隔。</p><h3 id="10-6-Linux多处理器调度"><a href="#10-6-Linux多处理器调度" class="headerlink" title="10.6 Linux多处理器调度"></a>10.6 Linux多处理器调度</h3><p>Linux存在三种不同的调度程序：</p><ul><li>O(1)调度程序<ul><li>基于优先级，随着时间推移改变进程的优先级</li></ul></li><li>完全公平调度程序（CFS）<ul><li>使用多队列</li><li>确定的比例调度方法</li></ul></li><li>BF调度程序（BFS）<ul><li>使用单队列</li><li>基于比例调度</li></ul></li></ul><h1 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h1><h2 id="Chapter-13-地址空间"><a href="#Chapter-13-地址空间" class="headerlink" title="Chapter 13 地址空间"></a>Chapter 13 地址空间</h2><h3 id="13-1-早期系统"><a href="#13-1-早期系统" class="headerlink" title="13.1 早期系统"></a>13.1 早期系统</h3><p>早期的机器物理内存看起来如图13.1所示。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-13/os-early.jpg"></p><h3 id="13-2-多道程序和时分共享"><a href="#13-2-多道程序和时分共享" class="headerlink" title="13.2 多道程序和时分共享"></a>13.2 多道程序和时分共享</h3><p>多道程序系统时代开启后，多个进程运行时，如果一个进程等待IO操作，操作系统会切换进程，以提高CPU的有效利用率。</p><p>分时系统中交互性变得很重要，因为许多用户可能同时在使用机器，每个人都在等待任务及时响应。一种实现时分共享的方法，是让一个进程单独占用全部内存运行一小段时间。然后停止它，并将它所有的状态信息保存在磁盘上，进行其他进程的调度，这样可以实现比较粗糙的机器共享。</p><p>但是这样操作会使得进程切换变得十分缓慢。可以选择将进程数据保存在内存中。</p><h3 id="13-3-地址空间"><a href="#13-3-地址空间" class="headerlink" title="13.3 地址空间"></a>13.3 地址空间</h3><p>OS需要提供一个易用的物理内存抽象模型，这个抽象模型叫做<strong>address space</strong>。是运行的程序看到的内存。</p><p>一个进程的地址空间包括运行的程序的所有内存状态，图13.3是一个简单的例子。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-13/address-space.jpg"></p><blockquote><p>Q：OS如何在单一的物理内存上为多个运行的进程构建一个地址空间？</p></blockquote><h3 id="13-4-目标"><a href="#13-4-目标" class="headerlink" title="13.4 目标"></a>13.4 目标</h3><p>虚拟内存的目标：</p><ul><li>透明（transparency）<ul><li>OS实现虚拟内存的方式，应该让运行的程序看不见。</li></ul></li><li>效率（efficiency）<ul><li>追求虚拟化尽可能高效。</li></ul></li><li>保护（protection）<ul><li>当一个进程执行加载、存储等操作不会受其它进程影响，也不能以任何方式访问或影响其他的进程。进程之间需要隔离。</li></ul></li></ul><h2 id="Chapter-14-内存操作API"><a href="#Chapter-14-内存操作API" class="headerlink" title="Chapter 14 内存操作API"></a>Chapter 14 内存操作API</h2><blockquote><p>Q：在UNIX&#x2F;C系统中，如何分配和管理内存？</p></blockquote><h3 id="14-1-内存类型"><a href="#14-1-内存类型" class="headerlink" title="14.1 内存类型"></a>14.1 内存类型</h3><p>在运行一个C程序的时候，会分配两种类型的内存：</p><ul><li>栈内存：申请和释放是编译器来隐式管理的，有时也称为自动内存。<ul><li>int x &#x3D; 1;</li></ul></li><li>堆内存：申请和释放是由程序员显式地完成，长期内存<ul><li>int *x &#x3D; (int *) malloc(sizeof(int))<ul><li>指针存储在栈内存，malloc申请的空间在堆内存</li></ul></li></ul></li></ul><h3 id="14-2-malloc调用"><a href="#14-2-malloc调用" class="headerlink" title="14.2 malloc调用"></a>14.2 malloc调用</h3><blockquote><p>void malloc(size_t size)</p></blockquote><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-type">double</span> *d = (<span class="hljs-type">double</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>));</code></pre></div><h3 id="14-3-free调用"><a href="#14-3-free调用" class="headerlink" title="14.3 free调用"></a>14.3 free调用</h3><p>释放内存通过调用<code>free()</code>来实现。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> *x = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))<span class="hljs-built_in">free</span>(x);</code></pre></div><h3 id="14-4-常见错误"><a href="#14-4-常见错误" class="headerlink" title="14.4 常见错误"></a>14.4 常见错误</h3><ul><li>忘记分配内存<ul><li>没有<code>malloc</code>就使用指针</li></ul></li><li>没有分配足够的内存</li><li>忘记初始化分配的内存<ul><li>遇到未初始化的读取，会读取到一些未知值得数据。</li></ul></li><li>忘记释放内存<ul><li>内存泄露（<strong>memory leak</strong>）</li></ul></li><li>在用完之前释放内存<ul><li>悬挂指针（<strong>dangling pointer</strong>）</li></ul></li><li>反复释放内存</li><li>错误调用free()<ul><li>并没有传入指针，错误了传入其他值。</li></ul></li></ul><h2 id="Chapter-15-地址转换"><a href="#Chapter-15-地址转换" class="headerlink" title="Chapter 15 地址转换"></a>Chapter 15 地址转换</h2><blockquote><p>Q：如何实现高效的内存虚拟化？如何提供应用程序所需的灵活性？如何保持控制程序可访问的内存位置，从而确保应用程序的内存访问收到合理的限制？</p></blockquote><p>通过基于硬件的地址转换，它可以看成是受限直接执行这种一般方式的补充。</p><p>通过地址转换，硬件对每次对内存的访问进行处理，将指令中的虚拟地址转换为数据实际存储的物理地址。</p><h3 id="15-1-假设"><a href="#15-1-假设" class="headerlink" title="15.1 假设"></a>15.1 假设</h3><p>我们先假设用户的地址空间必须连续地放在物理内存中。同时，为了简单，我们假设地址空间不是很大，小于物理内存，假设每个地址空间的大小完全一样。</p><h3 id="15-2-一个例子"><a href="#15-2-一个例子" class="headerlink" title="15.2 一个例子"></a>15.2 一个例子</h3><p>C程序如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> x;    x = x + <span class="hljs-number">3</span>;&#125;</code></pre></div><p>程序编译成汇编代码后：</p><div class="code-wrapper"><pre><code class="hljs assembly">128: movl 0x0(%ebx), %eax132: addl $0x03, %eax135: movl %eax, 0x0(%ebx)</code></pre></div><p>以上的程序在进行内存访问时，OS会根据内部机制，将对应的虚拟地址转换成物理地址再进行内存访问。</p><h3 id="15-3-动态重定位"><a href="#15-3-动态重定位" class="headerlink" title="15.3 动态重定位"></a>15.3 动态重定位</h3><p>第一次应用：基址加界限机制（也称为动态重定位 <strong>dynamic relocation</strong>）。</p><p>含义：每个CPU需要两个硬件寄存器，基址寄存器和界限寄存器。</p><p>采用这种方式，在编写和编译程序时假设地址空间从零开始，但是当程序真正执行时，OS会决定其在物理内存中的实际加载地址，并将起始地址记录在基址寄存器上。</p><div class="code-wrapper"><pre><code class="hljs excel">physical <span class="hljs-built_in">address</span> = virtual <span class="hljs-built_in">address</span> + <span class="hljs-built_in">base</span></code></pre></div><p>如果虚拟地址超过界限寄存器，CPU将触发异常。</p><p>通常将CPU中负责地址转换的部分统称为内存管理单元（<strong>MMU</strong>）。</p><h3 id="15-4-硬件支持"><a href="#15-4-硬件支持" class="headerlink" title="15.4 硬件支持"></a>15.4 硬件支持</h3><p>动态重定位的硬件要求：</p><table><thead><tr><th align="center">硬件要求</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">特权模式</td><td align="center">需要，以访用户模式的进程执行特权操作</td></tr><tr><td align="center">基址&#x2F;界限寄存器</td><td align="center">每个CPU需要一对寄存器来支持地址转换和界限检查</td></tr><tr><td align="center">能够转换虚拟地址并检查是否越界</td><td align="center">电路来完成转换和检查界限</td></tr><tr><td align="center">修改基址&#x2F;界限寄存器的特权指令</td><td align="center">在用户程序运行前，OS必须能设置这些值</td></tr><tr><td align="center">注册异常处理程序的特权指令</td><td align="center">OS必须能告诉硬件，异常发生需要执行哪些代码</td></tr><tr><td align="center">能够触发异常</td><td align="center">如果进程试图使用特权指令或越界的内存</td></tr></tbody></table><h2 id="Chapter-16-分段"><a href="#Chapter-16-分段" class="headerlink" title="Chapter 16 分段"></a>Chapter 16 分段</h2><p>简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费，那么就存在了问题。</p><blockquote><p>Q：怎样支持大地址空间？堆栈之间有大量空闲空间的问题如何解决？</p></blockquote><h3 id="16-1-分段：泛化的基址-界限"><a href="#16-1-分段：泛化的基址-界限" class="headerlink" title="16.1 分段：泛化的基址&#x2F;界限"></a>16.1 分段：泛化的基址&#x2F;界限</h3><p>为了解决上述问题，引入分段概念。一个段是地址空间里的一个连续定长的区域。一般有三个逻辑段：代码、栈和堆。分段机制使得OS能够将不同的段放到不同的物理内存区域。从而避免了虚拟地址空间中的未使用部分占用物理内存。</p><h3 id="16-2-引用哪个段"><a href="#16-2-引用哪个段" class="headerlink" title="16.2 引用哪个段"></a>16.2 引用哪个段</h3><p>硬件在地址转换时如何知道段内偏移量？以及地址引用了哪个段？</p><p>显式方式：用虚拟地址的前几位标识不同的段。如图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-16/segment1.jpg"></p><p>硬件获取物理地址的操作：</p><div class="code-wrapper"><pre><code class="hljs stylus">segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFTOffset = VirtualAddress &amp; OFFSET_MASK<span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(Offset &gt;= Bounds[Segment])</span></span><span class="hljs-built_in">Exception</span>(FAULT)<span class="hljs-keyword">else</span>PhysAddr = Base<span class="hljs-selector-attr">[Segment]</span> + OffsetRegister = <span class="hljs-built_in">AccessMemory</span>(PhysAddr)</code></pre></div><p>硬件还有其它方法来确定特定地址在哪个段，在隐式方式中，硬件通过地址产生的方式来确定段。例如，如果地址由PC产生，那么地址在代码段，如果基于栈或基址指针，它一定在栈段，其他地址在堆段。</p><h3 id="16-3-栈怎么办"><a href="#16-3-栈怎么办" class="headerlink" title="16.3 栈怎么办"></a>16.3 栈怎么办</h3><p>由于栈模型在内存中是反向增长的，例如：在物理内存中，开始于28KB，增长到26KB，相应虚拟地址从16KB到14KB，地址转换与正向增长略微不同。</p><p>首先需要硬件支持，硬件需要知道段的增长方向。</p><h3 id="16-4-支持共享"><a href="#16-4-支持共享" class="headerlink" title="16.4 支持共享"></a>16.4 支持共享</h3><p>随着分段机制的不断改进，人们意识到通过再多一点的硬件支持，就能实现新的效率提升。为了节省内存，在地址空间里共享某些内存段是有必要的。</p><p>为了支持共享，需要增加一些额外的硬件支持，通过保护位（<strong>protection bit</strong>），标识程序是否能读写该段，</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-16/register1.jpg"></p><h3 id="16-5-细粒度与细粒度的分段"><a href="#16-5-细粒度与细粒度的分段" class="headerlink" title="16.5 细粒度与细粒度的分段"></a>16.5 细粒度与细粒度的分段</h3><p>上述方式的分段是粗粒度的，它将地址空间分成较大的、粗粒度的块。一些早期系统更灵活，允许将地址空间划分为大量较小的段。</p><p>段的数量增加需要进一步的硬件支持，并在内存中保存<strong>segment table</strong>。</p><h3 id="16-6-操作系统支持"><a href="#16-6-操作系统支持" class="headerlink" title="16.6 操作系统支持"></a>16.6 操作系统支持</h3><p>分段带来了新的问题：</p><ul><li>OS在context switch时应该做什么？<ul><li>各个段寄存器中内容的保存和恢复</li></ul></li><li>管理物理内存的空闲空间</li><li>内存碎片<ul><li>紧凑（<strong>compact</strong>）物理内存，重新安排原有的段<ul><li>OS先终止运行进程，将它们的数据重新移动到新的段</li><li>成本高，拷贝段是内存密集型，会占用大量的处理器时间</li></ul></li><li>分配算法可以适当解决该问题</li></ul></li></ul><h2 id="Chapter-17-空闲空间管理"><a href="#Chapter-17-空闲空间管理" class="headerlink" title="Chapter 17 空闲空间管理"></a>Chapter 17 空闲空间管理</h2><blockquote><p>Q：如何管理空闲空间？什么策略可以让碎片最小化？不同方法的时空开销如何？</p></blockquote><h3 id="17-1-假设"><a href="#17-1-假设" class="headerlink" title="17.1 假设"></a>17.1 假设</h3><p>我们假设基本的接口像<code>malloc()</code>和<code>free()</code>那样，在堆上管理空闲空间。</p><p>进一步假设，我们主要关心的是外部碎片（<strong>external fragmentation</strong>），分配程序也可能出现内部碎片问题。如果分配程序给出的内存块超出请求的大小，在这种情况下会被称为内部碎片。</p><p>还假设：内存一旦分配给用户，就不可以被重定位到其他位置。也就是不能进行compaction操作，但是OS在实现分段时，可以通过紧凑来减少碎片。</p><p>最后假设：分配程序所管理的是连续的一块字节区域。在一些情况下，分配程序可以要求这块区域增长，例如：用户级的内存分配库在空间即将用完时，可以向内核申请增加堆空间。</p><h3 id="17-2-底层机制"><a href="#17-2-底层机制" class="headerlink" title="17.2 底层机制"></a>17.2 底层机制</h3><p>分割与合并：</p><ul><li>如果请求的空间大小小于某块空闲块，分配程序通常会进行分割</li><li>如果回收一块空闲内存时，如果回收的内存块地址与其它空闲块地址邻近，就将它们合并为一个较大的空闲块。</li></ul><blockquote><p> Q：如何追踪已分配空间的大小？</p></blockquote><p>用户请求N字节的内存，库分配的是<code>N+header</code>大小的空闲块。</p><p>header中保存一些额外的信息：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">header_t</span> &#123;</span>    <span class="hljs-type">int</span> size;    <span class="hljs-type">int</span> magic;&#125;<span class="hljs-type">header_t</span>;</code></pre></div><p>用户在调用<code>free(ptr)</code>时，库会通过简单的指针运算得到header的位置：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> &#123;    <span class="hljs-type">header_t</span> *hptr = (<span class="hljs-type">void</span> *) ptr - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">header_t</span>);&#125;</code></pre></div><p>获得header的指针后，库可以很容易的确定幻数是否符合预期值，简单计算释放的空间大小（header大小 + 分配给用户的空间的大小）。</p><blockquote><p>Q：如何在空闲内存内部建立一个列表？</p></blockquote><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> &#123;</span>    <span class="hljs-type">int</span> size;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> *<span class="hljs-title">next</span>;</span>&#125;<span class="hljs-type">node_t</span>;</code></pre></div><p>如何初始化列表？</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">node_t</span> *head = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ|PROT_WRITE,                   MAP_ANON|MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);head-&gt;size = <span class="hljs-number">4096</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>);head-&gt;next = <span class="hljs-literal">NULL</span>;</code></pre></div><p>假设此时有一个100字节的内存请求，，堆中空间如图17.4所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-16/heap1.jpg"></p><h3 id="17-3-基本策略"><a href="#17-3-基本策略" class="headerlink" title="17.3 基本策略"></a>17.3 基本策略</h3><h4 id="最优匹配-best-fit"><a href="#最优匹配-best-fit" class="headerlink" title="最优匹配 best fit"></a>最优匹配 best fit</h4><p>遍历整个空闲链表，找到和请求大小一样或更大的空闲块，然后返回当中符合要求最小的一块。</p><p>能减少空间浪费，但是要付出较高的性能代价。</p><h4 id="最差匹配-worst-fit"><a href="#最差匹配-worst-fit" class="headerlink" title="最差匹配 worst fit"></a>最差匹配 worst fit</h4><p>遍历整个空闲链表，找到满足要求最大的空闲块。</p><p>碎片不仅多，还有很好的性能代价。</p><h4 id="首次匹配-first-fit"><a href="#首次匹配-first-fit" class="headerlink" title="首次匹配 first fit"></a>首次匹配 first fit</h4><p>找到第一个足够大的块，将请求的空间返回给用户。</p><p>有速度优势，但是会让空闲链表开头部分有很多小块。可以基于地址排序，通过合并操作减少内存碎片。</p><h4 id="下次匹配-next-fit"><a href="#下次匹配-next-fit" class="headerlink" title="下次匹配 next fit"></a>下次匹配 next fit</h4><p>维护一个指针，指向上一次查找结束的位置。从该指针开始查找合适的节点。</p><p>避免了对链表开头的频繁操作。</p><h3 id="17-4-其他方式"><a href="#17-4-其他方式" class="headerlink" title="17.4 其他方式"></a>17.4 其他方式</h3><h4 id="分离空闲链表"><a href="#分离空闲链表" class="headerlink" title="分离空闲链表"></a>分离空闲链表</h4><p>如果应用程序经常申请一种或几种大小的内存空间，那就用一个独立的链表，管理这些大小的对象，其它大小的请求都交给更通用的内存分配程序。</p><p>例如：在内核启动时，它为可能频繁请求的内核对象创建一些对象缓存，比如锁和文件系统inode等。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>binary buddy allocator：空闲空间首先从概念上被看成为$2^N$大小，当有一个内存分配请求时，空闲空间被递归地一分为二，直至刚好满足请求的大小。</p><p>这种分配策略只允许分配2的整数次幂大小的空闲块。</p><p>如果回收内存时，会检查对应伙伴（与其相等大小的另一半）是否空闲，如果空闲则进行合并，直至整个内存区域。</p><h4 id="其它想法"><a href="#其它想法" class="headerlink" title="其它想法"></a>其它想法</h4><p>查询链表的时间复杂度较高，可以采用查询性能更为高效的数据结构来优化开销哦啊，例如平衡二叉树、伸展树等。</p><h2 id="Chapter-18-分页介绍"><a href="#Chapter-18-分页介绍" class="headerlink" title="Chapter 18 分页介绍"></a>Chapter 18 分页介绍</h2><p>分段技术随着时间推移，分配内存会变得比较困难。</p><p>还可以考虑第二种方法：<strong>将空间分割成固定长度的分片。</strong>这种思想成为分页。分页是将一个进程的地址空间分割成几个不同长度的逻辑段（代码、堆、段），而是分割成固定大小的党员，每个单元成为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫做页帧（<strong>page frame</strong>）。每个这样的页帧包含一个虚拟内存页。</p><blockquote><p>Q：如何通过页来实现虚拟内存？从而避免分段产生的问题？基本技术是什么？</p></blockquote><h3 id="18-1-一个简单例子"><a href="#18-1-一个简单例子" class="headerlink" title="18.1 一个简单例子"></a>18.1 一个简单例子</h3><p>如图所示，物理内存由一组固定大小的槽块组成。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-18/page-model.jpg"></p><p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（<strong>page table</strong>），主要作用是为地址空间的每个虚拟页面保存地址转换（<strong>address translation</strong>），从而让我们知道每一页在物理内存中的位置。</p><p>分页如何进行地址转换？</p><p>虚拟地址的格式如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-18/page-address.jpg"></p><p>分成：</p><ul><li>虚拟页面号（virtual page number VPN）</li><li>页内的偏移量（offset）</li></ul><h3 id="18-2-页表存在哪里"><a href="#18-2-页表存在哪里" class="headerlink" title="18.2 页表存在哪里"></a>18.2 页表存在哪里</h3><p>页面会变得非常大，例如：典型的32位地址空间，带有4KB的页，这个虚拟地址分成20位VPN和VPN的12位偏移量。20位的VPN意味着操作系统需要管理$2^{20}$个地址转换，假设每个页表条目（Page Table Entry）需要4个字节，那么每个页表则需要4MB内存。</p><p>图18.4是OS内存中的页表：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-18/page-table.jpg"></p><h3 id="18-3-Page-Table-Entry"><a href="#18-3-Page-Table-Entry" class="headerlink" title="18.3 Page Table Entry"></a>18.3 Page Table Entry</h3><p>PTE中有什么？</p><ul><li>有效位（<strong>valid bit</strong>）：通常用于指示特定地址转换是否有效<ul><li>例如：一个程序开始运行时，它的代码和堆在其地址空间的一端，栈在另一端。所有未使用的中间空间都会被标记为无效，如果进程访问这部分，则会<code>trap</code>，导致进程终止。</li><li>有效位对于支持稀疏地址空间至关重要，通过简单地将地址空间中所有未使用的页面标记为无效。我们不需要再为这些页面分配物理帧，从而节省大量内存。</li></ul></li><li>保护位（<strong>protection bit</strong>）：表明页是否可以读取、写入或执行。<ul><li>以不允许的方式来访问页，会<code>trap</code>。</li></ul></li><li>存在位（<strong>present bit</strong>）：表明该页是在内存中还是在磁盘上（是否被换出）</li><li>脏位（<strong>dirty bit</strong>）：表明页面被带入内存后是否被修改过</li><li>参考位（<strong>reference bit</strong>）：表明用于追踪页是否被访问，也用于确定哪些页很受欢迎。<ul><li>在<strong>page replacement</strong>时十分重要。</li></ul></li></ul><p>X86架构的示例PTE如图18.5所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-18/x86-pte.jpg"></p><p>主要包含：</p><ul><li>存在位P</li><li>是否允许读写R&#x2F;W</li><li>确定用户是否可以访问该页面的用户&#x2F;超级用户位U&#x2F;S</li><li>确定硬件缓存如何为这些页面工作PWT、PCD、PAT、G</li><li>访问位A</li><li>脏位D</li><li>页帧号PFN</li></ul><h3 id="18-3-分页：也很慢"><a href="#18-3-分页：也很慢" class="headerlink" title="18.3 分页：也很慢"></a>18.3 分页：也很慢</h3><p>分页模式中进行地址转换，硬件必须知道正在运行的进程的页表的位置，现在假设一个页表基址寄存器（page-table base register）包含了页表的起始位置的物理地址，为了找到想要的PTE位置，硬件将执行以下功能：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">VPN_MASK</span> = <span class="hljs-number">0</span>x30 //<span class="hljs-number">110000</span><span class="hljs-attr">SHIFT</span> = <span class="hljs-number">4</span>  //偏移量的位数<span class="hljs-attr">VPN</span> = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT<span class="hljs-attr">PTEAddr</span> = PageTableBaseRegister + (VPN * sizeof(PTE))</code></pre></div><p>主要是：</p><ul><li>将VPN向右移动以形成正确的整数虚拟页码。<ul><li>例如21（010101）掩码将此值转换为010000，移位将它变为01，或虚拟页1</li></ul></li><li>使用此值作为页表基址寄存器指向的PTE数组的索引</li></ul><p>一旦知道了PTE的物理地址，硬件就可以从内存中获取PTE，提取PFN，将其与虚拟地址的偏移量连接起来，形成所需的物理地址。</p><p>其流程如图18.6所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-18/page-access-memory.jpg"></p><p>最后，硬件可以从内存中获取所需的数据放入寄存器中。</p><h2 id="Chapter-19-快速地址转换（TLB）"><a href="#Chapter-19-快速地址转换（TLB）" class="headerlink" title="Chapter 19 快速地址转换（TLB）"></a>Chapter 19 快速地址转换（TLB）</h2><p>使用分页作为核心机制来实现虚拟内存，可能会带来较高的性能开销，因为页表存储在物理内存，需要额外多处一次内存访问。</p><blockquote><p>Q：如何加速地址转换，尽量避免额外的内存访问？需要什么样的硬件支持？操作系统如何支持？</p></blockquote><p>地址转换旁路缓冲寄存器（translation-lookaside buffer TLB）：它是频繁发生的虚拟到物理地址转换的硬件cache。对于每次的内存访问，硬件先检查TLB，看其中是否有期望的转换映射。如果有，就完成转换，不用访问页表。</p><h3 id="19-1-TLB的基本算法"><a href="#19-1-TLB的基本算法" class="headerlink" title="19.1 TLB的基本算法"></a>19.1 TLB的基本算法</h3><p>TLB的基本算法如图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-19/TLB-algo.jpg"></p><p>主要步骤如下：</p><ol><li>首先容虚拟地址中提取页号（VPN）</li><li>然后检查TLB中是否有该VPN的转换映射</li><li>如果TLB命中，这意味着TLB有该页的转换映射。那么去除对应的页帧号（PFN），与原来的虚拟地址中的偏移量组合形成期望的物理地址，并访问内存。</li><li>如果CPU没有在TLB中找到转换映射，那么访问页表来寻找转换映射，并用该转换映射更新TLB。</li></ol><h3 id="19-2-示例：访问数组"><a href="#19-2-示例：访问数组" class="headerlink" title="19.2 示例：访问数组"></a>19.2 示例：访问数组</h3><p>为了弄清TLB的操作，我们来看一个简单的虚拟地址追踪。本案例中，假设有一个由10个4字节整型组成的数组，起始虚地址是100，进一步假设，有一个8位的小虚地址空间，页大小为16B，那么我们可以将虚地址划分为4位的VPN（那么总共有16个虚拟内存页）和4位的偏移量（每个页中有16个字节）</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-19/example.jpg"></p><p>图19.2展示了数组的布局。</p><p>那么考虑一个简单的程序：访问数组的每个元素</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;    sum += a[i];&#125;</code></pre></div><p>那么程序的执行步骤如下：</p><ul><li>首先访问<code>a[0]</code>，CPU会看到虚拟地址100，硬件从中提取VPN &#x3D; 06，然后检查TLB，此时TLB未命中</li><li>访问<code>a[1]</code>，TLB命中，因为和第一个元素位于同一页</li><li><code>a[2]</code>命中，同理</li><li><code>a[3]</code>未命中，和上述同理</li><li>……</li></ul><p>通过TLB的表现来看，命中率为70%。得益于空间局部性。同时，页大小也会影响本例的结果。</p><p>如果这次循环不久，再次访问，TLB的命中率会大大提高，这是因为时间局部性，所以TLB的命中率会提高。</p><h3 id="19-3-谁来处理TLB未命中"><a href="#19-3-谁来处理TLB未命中" class="headerlink" title="19.3 谁来处理TLB未命中"></a>19.3 谁来处理TLB未命中</h3><p>两个答案：硬件或OS</p><p>以前硬件的复杂指令集（CISC）全权处理TLB未命中，为了做到这一点，硬件必须知道页表在内存中的确切位置（通过页表基址寄存器）以及页表的确切格式，发生未命中时，硬件会遍历页表，找到正确的entry，取出想要的地址映射。用它更新TLB。</p><p>RISC有所谓的软件管理TLB，发生TLB未命中时，硬件会抛出一个异常，这时会暂停当前的指令流，将特权级提升至内核模式，跳转至陷阱处理程序（trap handler），这段代码用于处理TLB未命中的情况。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-19/tlb-miss-os-handle.jpg"></p><ul><li>先查找页表中的转换映射</li><li>然后用特权指令更新TLB，并从陷阱返回</li><li>此时硬件会重试该指令</li></ul><p>几个细节：</p><ul><li>从陷阱返回指令于不用于系统调用从陷阱返回<ul><li>系统调用返回是，会继续执行此调用之后的语句</li><li>TLB未命中时，陷阱返回后，硬件必须从导致陷阱的指令继续执行。那么此次会命中TLB。</li></ul></li><li>运行TLB未命中的处理代码时，OS需要避免引起TLB未命中的无限递归<ul><li>可以将TLB未命中的陷阱处理程序直接放入物理内存中。</li><li>或者在TLB中保留一些项，记录永久有效的地址转换，并将其中一些永久地址转换槽块留给处理代码本身。</li></ul></li></ul><h3 id="19-4-TLB的内容"><a href="#19-4-TLB的内容" class="headerlink" title="19.4 TLB的内容"></a>19.4 TLB的内容</h3><p>典型的TLB有32项、64项或128项，并且是全相联的（<strong>fully associative</strong>）。基本上这意味着一条地址映射可能存在TLB中的任意位置。一条TLB的entry内容可能如下：</p><div class="code-wrapper"><pre><code class="hljs gherkin">VPN |<span class="hljs-string"> FPN </span>|<span class="hljs-string"> 其它位</span></code></pre></div><p>注意：TLB的有效位 !&#x3D; 页表的有效位</p><ul><li>页表中，如果PTE被标为无效，意味着该页不能被进程申请使用。</li><li>TLB有效位只是指出TLB的entry不是有效的地址映射。</li></ul><h3 id="19-5-上下文切换时对TLB的处理"><a href="#19-5-上下文切换时对TLB的处理" class="headerlink" title="19.5 上下文切换时对TLB的处理"></a>19.5 上下文切换时对TLB的处理</h3><p>TLB中包含的地址映射只是对当前线程有效，因此发生进程切换时，OS或硬件需要确保即将运行的进程不要错误读取了之前进程的地址映射。</p><blockquote><p>Q：进程切换时如何管理TLB的内容？</p></blockquote><p>可能的解决方案：上下文切换时，简单地flush TLB。但是此方案有一定开销。</p><p>因此一些系统中增加了硬件支持，实现跨上下文切换的TLB共享。比如有的系统在TLB中添加一个地址空间标识符（Address Space Identifier ASID），可以将ASID看成是进程标识符（PID）。该位标识该地址映射是哪个进程所持有的。如图19.3所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-19/context-switch-with-tlb-content.jpg"></p><h3 id="19-6-TLB替换策略"><a href="#19-6-TLB替换策略" class="headerlink" title="19.6 TLB替换策略"></a>19.6 TLB替换策略</h3><blockquote><p>Q：如何设计TLB替换策略？</p></blockquote><ul><li>LRU</li><li>random</li></ul><h3 id="19-7-实际系统的TLB表项"><a href="#19-7-实际系统的TLB表项" class="headerlink" title="19.7 实际系统的TLB表项"></a>19.7 实际系统的TLB表项</h3><p>MIPS R4000采用软件管理TLB，图19.4展示了简化的MIPS TLB表项：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-19/tlb.jpg"></p><p>支持32位的地址空间，页大小为4KB，因此有20位的VPN和12位偏移量。</p><p>MIPS TLB还有一些标识位：</p><ul><li>全局位（Global G）：指示这个页是不是所有进程共享的，如果是，则忽略ASID</li><li>一致性位（Coherence C）：决定硬件如何缓存该页</li><li>脏位（Dirty D）：表示该页是否被写入新数据</li><li>有效位（valid）：告诉硬件该项的地址映射是否有效</li></ul><h2 id="Chapter-20-分页：较小的表"><a href="#Chapter-20-分页：较小的表" class="headerlink" title="Chapter 20 分页：较小的表"></a>Chapter 20 分页：较小的表</h2><p>上述方案会有一个问题：页表太大，消耗太多内存，那么问题来了：</p><blockquote><p>Q： 如何让页表更小？</p></blockquote><h3 id="20-1-简单的解决方案：更大的页"><a href="#20-1-简单的解决方案：更大的页" class="headerlink" title="20.1 简单的解决方案：更大的页"></a>20.1 简单的解决方案：更大的页</h3><p>如果32位的地址空间为例：如每页大小为16KB，则会有18位的VPN，14位的偏移量。假设页表项大小为4字节，那么线性页表中有218项，则每个页表的总大小为1MB。</p><p>但是大内存页面会导致每页内部的浪费（内部碎片），因此大部分OS通常使用较小的页：4KB。</p><h3 id="20-2-混合方法：分页和分段"><a href="#20-2-混合方法：分页和分段" class="headerlink" title="20.2 混合方法：分页和分段"></a>20.2 混合方法：分页和分段</h3><p>将分页和分段结合，减少页表的内存开销。</p><p>分段中，有一个基址寄存器，告诉我们每个段在物理内存中的位置，还有一个界限寄存器，告诉我们段的大小。</p><p>但是分页分段结合的模式下，使用基址寄存器保存该段的页表的物理地址，界限寄存器用于指示一共有多少页。</p><p>虚拟地址示例如下：</p><div class="code-wrapper"><pre><code class="hljs coq">Seg  | <span class="hljs-type">VPN</span> | <span class="hljs-type">Offset</span>x bit | <span class="hljs-type">y</span> bit | <span class="hljs-type">z</span> bit</code></pre></div><p>TLB未命中时，硬件使用分段位（SN）来确定要用哪个基址和界限对，然后硬件将其中的物理地址与VPN结合起来，形成页表项的地址。</p><p>使用分段会存在问题：</p><ul><li>例如：如果有一个大而稀疏的堆，仍然可能导致大量的页表浪费。</li></ul><h3 id="20-3-多级页表"><a href="#20-3-多级页表" class="headerlink" title="20.3 多级页表"></a>20.3 多级页表</h3><p>如何去掉页表中无效区域？而不是将它们全部保存在内存中。</p><p>使用多级页表，将线性页表变成了类似树的东西。</p><p>在一个简单的二级页表中，页目录中每个页目录项（Page Directory Entries PDE）包括：有效位和页帧号（page frame number PFN），类似于PTE。</p><p>多级页表的基本思想很简单，将页表分成页大小的单元，如果页目录项无效，就不分配该页的页表。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-20/20.3.jpg"></p><p>问题：</p><ul><li>多级页表是有成本的，在TLB未命中时，需要从内存加载两次，才能从页表中获得正确的地址转换信息。（一次用于页目录，另一次用于PTE本身）</li><li>复杂性</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>假设有一个大小为16KB的地址空间，每个页大小为64byte，因此需要一个14位的虚拟地址，其中VPN8位，偏移量6位。</p><p>那么即使只有一小部分地址空间正在使用，线性页表也会有$2 ^ 8$个项。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-20/20.4.jpg"></p><p>要为这个地址空间构建一个二级页表，我们从完整的线性页表开始，将他分解为页大小的单元。</p><p>假设PTE大小为4 bytes，那么页表大小为1KB（256 * 4 bytes）,页表可以被分成16个 64byte大小的页，每个页有16个PTE。</p><p>那么如何获取VPN并且用它索引到页目录中，然后索引到页表的页中。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-20/address.jpg"></p><p>首先通过4位VPN来索引Page Directory，那么可以通过简单的计算得到PDE的地址。</p><p>$$PDEAddr &#x3D; PageDirBase + (PDIndex * sizeof(PDE))$$</p><p>如果获取的页目录项标记为无效，则会引发异常，有效则通过页目录项指向的页表中获得PTE。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-20/page-table-index.jpg"></p><p>通过page table index可以得到PTE地址。</p><p>$$PTEAddr &#x3D; (PDE.PFN) &lt;&lt; SHIFT + (PTIndex * sizeof(PTE))$$</p><p>最后根据PTE中的映射地址加上偏移量得到物理地址。</p><h3 id="20-4-反向页表"><a href="#20-4-反向页表" class="headerlink" title="20.4 反向页表"></a>20.4 反向页表</h3><p>只保留一个页表，其中的项代表系统的每个物理页，而不是每个进程一个页表，页表项告诉我们哪个进程正在使用该页，以及该进程的哪个虚拟页映射到此物理页。</p><p>如果进行线性扫描，性能开销较高，因此通常使用散列表来加速查找。</p><h3 id="20-5-将页表交换到磁盘"><a href="#20-5-将页表交换到磁盘" class="headerlink" title="20.5 将页表交换到磁盘"></a>20.5 将页表交换到磁盘</h3><p>一些系统在内存压力较大时，允许将页表swap到磁盘中。</p><h2 id="Chapter-21-超越物理内存：机制"><a href="#Chapter-21-超越物理内存：机制" class="headerlink" title="Chapter 21 超越物理内存：机制"></a>Chapter 21 超越物理内存：机制</h2><blockquote><p>Q：如何利用大而慢的设备，透明地提供巨大虚拟地址空间的假象？</p></blockquote><p>为了支持更大的地址空间，就需要更大的内存存储页表，一般可以通过swap，将暂时没用的页表swap到磁盘中。</p><h3 id="21-1-交换空间"><a href="#21-1-交换空间" class="headerlink" title="21.1 交换空间"></a>21.1 交换空间</h3><p>在OS中，一般将硬盘中存储换入换出的空间称为交换空间。</p><h3 id="21-2-存在位"><a href="#21-2-存在位" class="headerlink" title="21.2 存在位"></a>21.2 存在位</h3><p>如果页表项的存在位为1，则表示该页存在于物理内存中，如果为0，则在硬盘上，访问为0的页会有page fault。</p><h3 id="21-3-page-fault"><a href="#21-3-page-fault" class="headerlink" title="21.3 page fault"></a>21.3 page fault</h3><p>如果一个页不存在，它已被交换到硬盘，那么在处理该错误的时候，OS需要将该页交换到内存中。</p><blockquote><p>Q：OS如何知道需要的页在哪？</p></blockquote><p>可以用PTE存储硬盘地址。</p><p>当硬盘I&#x2F;O完成时，操作系统会更新页表，将此页标记为存在，更新PTE的PFN字段以记录新获取页的内存位置，并重试指令，将PTE更新到TLB中。</p><h3 id="21-4-内存满了怎么办"><a href="#21-4-内存满了怎么办" class="headerlink" title="21.4 内存满了怎么办"></a>21.4 内存满了怎么办</h3><p>OS希望先交换出一个或多个页，以便为操作系统即将交换新页留出空间。这被称为页交换策略（page-replacement policy）。</p><h3 id="21-5-页错误处理流程"><a href="#21-5-页错误处理流程" class="headerlink" title="21.5 页错误处理流程"></a>21.5 页错误处理流程</h3><ul><li>当TLB未命中会有三种情景：<ol><li>present and valid：TLB未命中处理程序从PTE中获取PFN，然后重试指令更新TLB，然后继续前面的流程</li><li>页不存在于内存中，抛出page fault</li><li>访问的是无效页的话，抛出segment fault</li></ol></li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-21/21.2.jpg"></p><p>那么page fault处理程序的流程是什么样呢？</p><ul><li>OS必须为换出的页找到一个物理帧</li><li>如果没有这样的物理帧，等待置换算法从内存中换出一些页</li><li>处理程序通过IO请求从swap space中读取页</li><li>OS更新页表并重试指令来更新TLB</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/os/ostep/chapter-21/21.3.jpg"></p><h3 id="21-6-交换的时机"><a href="#21-6-交换的时机" class="headerlink" title="21.6 交换的时机"></a>21.6 交换的时机</h3><p>如果是等OS发现内存满了之后，才执行置换算法，有点不切实际。OS是更主动地预留了一小部分空闲内存。</p><p>为了保证有少量地空闲内存，大部分OS会设置高水位线（HW）和低水位线（LW），来帮助决定何时从内存中清除页。</p><p>如果OS发现有少于LW个页可用时，后台负责释放内存的线程会开始运行，直到有HW个可用物理页。这个后台线程有时被称为swap daemon或者page daemon。</p><h2 id="Chapter-22-超越物理内存：策略"><a href="#Chapter-22-超越物理内存：策略" class="headerlink" title="Chapter 22 超越物理内存：策略"></a>Chapter 22 超越物理内存：策略</h2><blockquote><p>Q： 如何决定置换哪个页？</p></blockquote><h3 id="22-1-缓存管理"><a href="#22-1-缓存管理" class="headerlink" title="22.1 缓存管理"></a>22.1 缓存管理</h3><p>选择置换策略时，我们的目标是让cache miss最少。程序的平均内存访问时间（Average Memory Access Time， AMAT），这是衡量硬件缓存的指标。可按照如下公式计算AMAT：</p><p>$$AMAT &#x3D; (P_{Hit} * T_M) + (P_{miss} * P_D)$$</p><p>其中$T_M$表示访问内存的成本，$T_D$表示访问磁盘的成本，$T_{Hit}$表示缓存命中率，$T_{miss}$表示缓存未命中率。</p><h3 id="22-2-最优替换策略"><a href="#22-2-最优替换策略" class="headerlink" title="22.2 最优替换策略"></a>22.2 最优替换策略</h3><p><strong>optional</strong>：是Belady发明的，最优替换策略能达到总体未命中数量最少。</p><p>基本策略：替换内存中在最远将来才会被访问的页。</p><p>这个策略不存在，因为无法预知用户使用哪个页面。</p><p>Belady异常：缓存大小变大时，命中率反而下降。</p><h3 id="22-3-简单策略：FIFO"><a href="#22-3-简单策略：FIFO" class="headerlink" title="22.3 简单策略：FIFO"></a>22.3 简单策略：FIFO</h3><p>一些系统使用FIFO替换策略，发生替换时，替换最先进入的页。</p><h3 id="22-4-随机"><a href="#22-4-随机" class="headerlink" title="22.4 随机"></a>22.4 随机</h3><p>随机置换页面。</p><h3 id="22-5-LRU"><a href="#22-5-LRU" class="headerlink" title="22.5 LRU"></a>22.5 LRU</h3><p>最近最久未使用</p><h3 id="22-9-考虑脏页"><a href="#22-9-考虑脏页" class="headerlink" title="22.9 考虑脏页"></a>22.9 考虑脏页</h3><p>如果内存中的页已经被修改，那么替换该页会引起写磁盘操作，性能开销大。因此可以优先选择未修改的页面。</p><h3 id="22-11-抖动"><a href="#22-11-抖动" class="headerlink" title="22.11 抖动"></a>22.11 抖动</h3><p>频繁换入换出。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal解析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/java-threadlocal/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/java-threadlocal/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its <code>get</code> or <code>set</code> method) has its own, independently initialized copy of the variable. <code>ThreadLocal</code> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p></blockquote><p>简而言之，<code>ThreadLocal</code>可以创建一个只能被当前线程访问或修改的变量。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote><p>Q：如何实现线程隔离？</p></blockquote><p>使用<code>Thread</code>对象中的<code>ThreadLocalMap</code>进行数据存储。也就是<code>ThreadLocal</code>将数据存储到当前的线程对象中，通过<code>Thread.currentThread()</code>来获取线程，再通过<code>getMap(t)</code>来获取<code>ThreadLocalMap</code>。具体内容通过阅读源码来逐步分析。</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>返回当前线程存储的<code>ThreadLocal</code>值，如果不存在，会进行初始化并返回。通过<code>map.getEntry(this)</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Returns the value in the current thread&#x27;s copy of this</span><span class="hljs-comment"> * thread-local variable.  If the variable has no value for the</span><span class="hljs-comment"> * current thread, it is first initialized to the value returned</span><span class="hljs-comment"> * by an invocation of the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125; method.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the current thread&#x27;s value of this thread-local</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//获取当前对象</span>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-comment">//通过getMap获取ThreadLocalMap</span>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//获取entry</span>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-comment">//不存在则进行初始化</span>    <span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre></div><h2 id="getMap"><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h2><p>返回指定线程的<code>ThreadLocalMap</code>。</p><div class="code-wrapper"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;        <span class="hljs-keyword">return</span> t.threadLocals;&#125;</code></pre></div><p><code>Thread</code>中关于<code>ThreadLocalMap</code>的部分：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><span class="hljs-comment">     * by the ThreadLocal class. */</span>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h2><p>get方法获取不到值时，通过该方法设置初始值。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Variant of set() to establish initialValue. Used instead</span><span class="hljs-comment"> * of set() in case user has overridden the set() method.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the initial value</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)        map.set(<span class="hljs-built_in">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);    <span class="hljs-keyword">return</span> value;&#125;</code></pre></div><h2 id="createMap"><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h2><p><code>ThreadLocalMap</code>不存在时，通过该方法创建，这里有一个疑惑：</p><blockquote><p> Q：为什么在<code>get</code>和<code>setInitialValue</code>进行两次为空检查才进行<code>createMap</code>？</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;        t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);&#125;</code></pre></div><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>通过调用<code>map.set(this,value)</code>实现。map中的key是当前<code>ThreadLocal</code>对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)            map.set(<span class="hljs-built_in">this</span>, value);        <span class="hljs-keyword">else</span>            createMap(t, value);    &#125;</code></pre></div><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>内部类和成员变量代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * The entries in this hash map extend WeakReference, using</span><span class="hljs-comment">         * its main ref field as the key (which is always a</span><span class="hljs-comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><span class="hljs-comment">         * == null) mean that the key is no longer referenced, so the</span><span class="hljs-comment">         * entry can be expunged from table.  Such entries are referred to</span><span class="hljs-comment">         * as &quot;stale entries&quot; in the code that follows.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>            Object value;            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;                <span class="hljs-built_in">super</span>(k);                value = v;            &#125;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * The initial capacity -- MUST be a power of two.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * The table, resized as necessary.</span><span class="hljs-comment">         * table.length MUST always be a power of two.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> Entry[] table;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * The number of entries in the table.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * The next size value at which to resize.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold; <span class="hljs-comment">// Default to 0</span>&#125;</code></pre></div><h3 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h3><p>流程：</p><ul><li>计算下标，得到下标i</li><li>进行遍历，如果i对应的key和传入相等，直接返回。如果对象已被回收，调用<code>replaceStaleEntry()</code>并返回。</li><li>如果i对应的不相等，则从i开始从table数组完后找。</li><li>能找到则返回，找不到新建entry进行存储。</li><li>检查是否需要<code>rehash()</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">         * Set the value associated with key.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> key the thread local object</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> value the value to be set</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;            <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span>            <span class="hljs-comment">// least as common to use set() to create new entries as</span>            <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span>            <span class="hljs-comment">// path would fail more often than not.</span>            Entry[] tab = table;            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;            <span class="hljs-comment">//获取hash后的下标</span>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<span class="hljs-comment">//遍历</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];                 e != <span class="hljs-literal">null</span>;                 e = tab[i = nextIndex(i, len)]) &#123;                ThreadLocal&lt;?&gt; k = e.get();<span class="hljs-comment">//如果对应下标的ThreadLocal与当前的相等，直接更新</span>                <span class="hljs-keyword">if</span> (k == key) &#123;                    e.value = value;                    <span class="hljs-keyword">return</span>;                &#125;<span class="hljs-comment">//如果ThreadLocal对象已被回收，调用replaceStaleEntry</span>                <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;                    replaceStaleEntry(key, value, i);                    <span class="hljs-keyword">return</span>;                &#125;            &#125;<span class="hljs-comment">//如果遍历一圈还是找不到，新建entry进行存储</span>            tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;            <span class="hljs-comment">//检查是否需要rehash</span>            <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)                rehash();        &#125;</code></pre></div><p>下标计算方式：</p><p>通过<code>AtomicInteger + 0x61c88647 &amp; (len-1)</code>来获取下标。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);&#125;</code></pre></div><h3 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h3><p>流程：</p><ul><li>计算下标，得到下标i</li><li>判断对应下标的entry是否存在，key是否相等，符合要求则直接返回。</li><li>不符合则调用<code>getEntryAfterMiss()</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get the entry associated with key.  This method</span><span class="hljs-comment"> * itself handles only the fast path: a direct hit of existing</span><span class="hljs-comment"> * key. It otherwise relays to getEntryAfterMiss.  This is</span><span class="hljs-comment"> * designed to maximize performance for direct hits, in part</span><span class="hljs-comment"> * by making this method readily inlinable.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  key the thread local object</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the entry associated with key, or null if no such</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;    <span class="hljs-comment">//计算下标</span>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)        <span class="hljs-keyword">return</span> e;    <span class="hljs-keyword">else</span>        <span class="hljs-comment">//entry不存在或key不相等</span>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);&#125;</code></pre></div><h4 id="getEntryAfterMiss"><a href="#getEntryAfterMiss" class="headerlink" title="getEntryAfterMiss"></a>getEntryAfterMiss</h4><p>也就是对table数组进行遍历查找，找一圈还没有则返回<code>null</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;    Entry[] tab = table;    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;        ThreadLocal&lt;?&gt; k = e.get();        <span class="hljs-keyword">if</span> (k == key)            <span class="hljs-keyword">return</span> e;        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)            expungeStaleEntry(i);        <span class="hljs-keyword">else</span>            i = nextIndex(i, len);        e = tab[i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>流程：</p><ul><li>计算下标</li><li>判断key是否相等，符合要求则调用<code>e.clear()</code>来清除key，并调用<code>expungeStaleEntry</code>清除value。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">         * Remove the entry for key.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;            Entry[] tab = table;            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;            <span class="hljs-comment">//计算下标</span>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];                 e != <span class="hljs-literal">null</span>;                 e = tab[i = nextIndex(i, len)]) &#123;                <span class="hljs-comment">//如果key相等</span>                <span class="hljs-keyword">if</span> (e.get() == key) &#123;                    e.clear();                    expungeStaleEntry(i);                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;</code></pre></div><h1 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>从上文可以看到，<strong>Entry</strong>继承自<strong>WeakReference</strong>，弱引用指向的对象会在下一次GC时被回收。</p><div class="code-wrapper"><pre><code class="hljs java">Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;                <span class="hljs-built_in">super</span>(k);                value = v;&#125;</code></pre></div><p>​在初始化时，将弱引用指向<code>ThreadLocal</code>实例。如果外部没有强引用指向ThreadLocal的话，那么Thread Local实例就没有一条引用链路可达，则会被回收。此时entry的key未null，但是有value，但是不能通过key找到value，这样就会存在<strong>内存泄漏问题</strong>。但是如果线程结束，以上内存都会被回收，也就不存在上述问题。</p><p>​如果使用线程池去维护线程，线程池并不会主动销毁内部的线程，总会存在着强引用，那么还是会存在问题。</p><p>总结问题出现的原因：</p><ol><li>线程一直运行，不终止（线程池）</li><li>null-value：某个弱引用key被回收</li></ol><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>上述的<code>getEntryAfterMiss()</code>如果判断到了<code>key == null</code>则会调用<code>expungeStaleEntry()</code>将value删除。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;    Entry[] tab = table;    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;    <span class="hljs-comment">// expunge entry at staleSlot</span>    tab[staleSlot].value = <span class="hljs-literal">null</span>;    tab[staleSlot] = <span class="hljs-literal">null</span>;    size--;    <span class="hljs-comment">// Rehash until we encounter null</span>    Entry e;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);         (e = tab[i]) != <span class="hljs-literal">null</span>;         i = nextIndex(i, len)) &#123;        ThreadLocal&lt;?&gt; k = e.get();        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;            e.value = <span class="hljs-literal">null</span>;            tab[i] = <span class="hljs-literal">null</span>;            size--;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (h != i) &#123;                tab[i] = <span class="hljs-literal">null</span>;                <span class="hljs-comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span>                <span class="hljs-comment">// null because multiple entries could have been stale.</span>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)                    h = nextIndex(h, len);                tab[h] = e;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> i;&#125;</code></pre></div><p>该方法在<code>set</code>、<code>get</code>、<code>remove</code>中都会调用。因此还有一个问题：如果创建了<code>ThreadLocal</code>但不调用以上方法，还是会存在问题。</p><p>所以最能解决办法的就是用完<code>ThreadLocal</code>之后显式执行<code>ThreadLocal.remove()</code>。</p><h2 id="为什么key不设置为强引用"><a href="#为什么key不设置为强引用" class="headerlink" title="为什么key不设置为强引用"></a>为什么key不设置为强引用</h2><p>既然弱引用会存在内存泄露问题，为什么不使用强引用呢？</p><p>如果将key设置为强引用，当<code>ThreadLocal</code>实例释放后，但是ThreadLocal强引用指向threadLocalMap，threadLocalMap.Entry又强引用指向ThreadLocal，这样会导致ThreadLocal无法回收。也就会出现更为严重的问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Java SE 8 Docs API</p><p><a href="https://www.jianshu.com/p/dde92ec37bd1">https://www.jianshu.com/p/dde92ec37bd1</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几个Java并发工具类解析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/%E5%87%A0%E4%B8%AAJava%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/%E5%87%A0%E4%B8%AAJava%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><p>只有当N个线程执行完毕，并且进行<code>countDown</code>操作时，才允许<code>await</code>的线程继续执行。否则该线程挂起。</p><p>适用情况：一个线程需要等待其他N个线程执行完毕，再继续执行，是join的替代。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>参数<code>count</code>为计数值，传入<code>AQS</code>的实现类<code>Sync</code>设置成AQS的<code>state</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);        <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);&#125;</code></pre></div><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>通过继承<code>AQS</code>从而完成同步的核心功能。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4982264981922014374L</span>;    <span class="hljs-comment">//构造方法</span>        Sync(<span class="hljs-type">int</span> count) &#123;            setState(count);        &#125;        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> getState();        &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;            <span class="hljs-comment">// Decrement count; signal when transition to zero</span>            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;</code></pre></div><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><ul><li><strong>countDown</strong>：将count值减1</li><li><strong>await</strong>：调用<strong>await</strong>的线程会被挂起，直到<code>count</code>为0才继续执行，允许中断</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;        sync.releaseShared(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>        <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));&#125;</code></pre></div><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123; <span class="hljs-comment">// ...</span>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;     <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">startSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);     <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(N);     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i) <span class="hljs-comment">// create and start threads</span>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(startSignal, doneSignal)).start();     doSomethingElse();            <span class="hljs-comment">// don&#x27;t let run yet</span>     startSignal.countDown();      <span class="hljs-comment">// let all threads proceed</span>     doSomethingElse();     doneSignal.await();           <span class="hljs-comment">// wait for all to finish</span>   &#125; &#125; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch startSignal;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneSignal;   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;      <span class="hljs-built_in">this</span>.startSignal = startSignal;      <span class="hljs-built_in">this</span>.doneSignal = doneSignal;   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;      <span class="hljs-keyword">try</span> &#123;        startSignal.await();        doWork();        doneSignal.countDown();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="hljs-comment">// return;</span>   &#125;   <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123; ... &#125; &#125;</code></pre></div><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called <em>cyclic</em> because it can be re-used after the waiting threads are released.</p></blockquote><p>一组线程到达barrier时会被阻塞，直到最后一个线程到达barrier，被阻塞的线程才会继续执行。</p><p>与CountDownLatch的作用类似，CyclicBarrier可以执行reset方法进行重用。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p>参数含义如下：</p><ul><li><strong>parties</strong>：拦截的线程数量</li><li><strong>barrierAction</strong>：所有线程到达<code>barrier</code>后执行的任务</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;        <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();        <span class="hljs-built_in">this</span>.parties = parties;        <span class="hljs-built_in">this</span>.count = parties;        <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;&#125;</code></pre></div><h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><ul><li><strong>lock</strong>：可重入锁，用于进行<code>dowait</code>时锁定</li><li><strong>parties</strong>：参与的线程数量</li><li><strong>trip</strong>：实际进行<code>await()</code>的<code>condition</code></li><li><strong>barrierCommand</strong>：最后一个线程到达时执行的任务</li><li><strong>count</strong>：等待进入屏障的线程数量</li><li><strong>generation</strong>：当前的generation<ul><li><strong>broken</strong>，表示当前屏障是否被破坏。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">/** The lock for guarding barrier entry */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();    <span class="hljs-comment">/** Condition to wait on until tripped */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();    <span class="hljs-comment">/** The number of parties */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;    <span class="hljs-comment">/* The command to run when tripped */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;    <span class="hljs-comment">/** The current generation */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;</code></pre></div><h2 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>可响应中断，通过调用<code>dowait(false, 0L)</code>实现</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);        &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span>        &#125;&#125;</code></pre></div><h4 id="dowait"><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h4><p><code>await</code>的具体实现。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span>        <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,               TimeoutException &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<span class="hljs-comment">//屏障被破坏，抛出异常</span>            <span class="hljs-keyword">if</span> (g.broken)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<span class="hljs-comment">//检查中断</span>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;                <span class="hljs-comment">//损坏屏障，唤醒所有线程</span>                breakBarrier();                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();            &#125;<span class="hljs-comment">//减少等待进入屏障的线程数量</span>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;            <span class="hljs-comment">//index == 0表示 所有进程都已经进入</span>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span>                <span class="hljs-comment">//运行的动作标识</span>                <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//运行任务</span>                    <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;                    <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)                        command.run();                    ranAction = <span class="hljs-literal">true</span>;                    <span class="hljs-comment">//进入下一代</span>                    nextGeneration();                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">//如果没有改成功，损坏当前屏障</span>                    <span class="hljs-keyword">if</span> (!ranAction)                        breakBarrier();                &#125;            &#125;            <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span>            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//如果没有设置等待时间</span>                    <span class="hljs-comment">//调用condition.await()进行等待</span>                    <span class="hljs-keyword">if</span> (!timed)                        trip.await();                    <span class="hljs-comment">//否则调用awaitNanos()进行等待</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)                        nanos = trip.awaitNanos(nanos);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;                    <span class="hljs-comment">//如果被中断，并且当前代的屏障没有被损坏</span>                    <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;                        <span class="hljs-comment">//损坏当前屏障</span>                        breakBarrier();                        <span class="hljs-keyword">throw</span> ie;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">//不是当前代，进行中断</span>                        Thread.currentThread().interrupt();                    &#125;                &#125;<span class="hljs-comment">//检查损坏标识</span>                <span class="hljs-keyword">if</span> (g.broken)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<span class="hljs-comment">//不等于当前代损坏表示</span>                <span class="hljs-keyword">if</span> (g != generation)                    <span class="hljs-keyword">return</span> index;                <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;                    breakBarrier();                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;</code></pre></div><h3 id="nextGeneration"><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h3><p>线程进入屏障后会进行调用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// signal completion of last generation</span>    <span class="hljs-comment">//唤醒所有线程</span>        trip.signalAll();        <span class="hljs-comment">// set up next generation</span>    <span class="hljs-comment">//恢复正在等待进入屏障的线程数量</span>        count = parties;        generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();&#125;</code></pre></div><h3 id="breakBarrier"><a href="#breakBarrier" class="headerlink" title="breakBarrier"></a>breakBarrier</h3><p>损坏当前屏障，会唤醒所有在屏障中的线程。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//设置损坏标志</span>        generation.broken = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//恢复正在等待进入屏障的线程</span>        count = parties;    <span class="hljs-comment">//唤醒所有线程</span>        trip.signalAll();&#125;</code></pre></div><h2 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solver</span> &#123;   <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N;   <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[][] data;   <span class="hljs-keyword">final</span> CyclicBarrier barrier;   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;     <span class="hljs-type">int</span> myRow;     Worker(<span class="hljs-type">int</span> row) &#123; myRow = row; &#125;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;       <span class="hljs-keyword">while</span> (!done()) &#123;         processRow(myRow);         <span class="hljs-keyword">try</span> &#123;           barrier.await();         &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;           <span class="hljs-keyword">return</span>;         &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException ex) &#123;           <span class="hljs-keyword">return</span>;         &#125;       &#125;     &#125;   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solver</span><span class="hljs-params">(<span class="hljs-type">float</span>[][] matrix)</span> &#123;     data = matrix;     N = matrix.length;     barrier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(N,                                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                                   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                                     mergeRows(...);                                   &#125;                                 &#125;);     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i)       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(i)).start();     waitUntilDone();   &#125; &#125;</code></pre></div><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html#acquire--"><code>acquire()</code></a> blocks if necessary until a permit is available, and then takes it. Each <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html#release--"><code>release()</code></a> adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the <code>Semaphore</code> just keeps a count of the number available and acts accordingly.</p></blockquote><p>线程执行acquire()后，会判断permit是否可用，不可用则阻塞，可用则permit - 1。线程执行<code>release()</code>后，则permit + 1，并且释放一个阻塞线程。</p><p>适用场景：控制同时访问特定资源的线程数量。保证公共资源合理使用，与OS的信号量核心理念相同。</p><p>Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. For example, here is a class that uses a semaphore to control access to a pool of items:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(MAX_AVAILABLE, <span class="hljs-literal">true</span>);  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;    available.acquire();    <span class="hljs-keyword">return</span> getNextAvailableItem();  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putItem</span><span class="hljs-params">(Object x)</span> &#123;    <span class="hljs-keyword">if</span> (markAsUnused(x))      available.release();  &#125;  <span class="hljs-comment">// Not a particularly efficient data structure; just for demo</span>  <span class="hljs-keyword">protected</span> Object[] items = ... whatever kinds of items being managed  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX_AVAILABLE];  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title function_">getNextAvailableItem</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;      <span class="hljs-keyword">if</span> (!used[i]) &#123;         used[i] = <span class="hljs-literal">true</span>;         <span class="hljs-keyword">return</span> items[i];      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// not reached</span>  &#125;  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markAsUnused</span><span class="hljs-params">(Object item)</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;      <span class="hljs-keyword">if</span> (item == items[i]) &#123;         <span class="hljs-keyword">if</span> (used[i]) &#123;           used[i] = <span class="hljs-literal">false</span>;           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;         &#125; <span class="hljs-keyword">else</span>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;&#125;</code></pre></div><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><p>两个构造方法：默认创建非公平策略的信号量，另一个构造方法可以选择公平策略的信号量。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;     sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);&#125;</code></pre></div><h2 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h2><p><code>Semaphore</code>主要通过<code>sync</code>（AQS的实现类）来实现核心功能。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;</code></pre></div><h3 id="Sync-1"><a href="#Sync-1" class="headerlink" title="Sync"></a>Sync</h3><p><code>Sync</code>代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1192457210091910933L</span>;<span class="hljs-comment">//构造方法</span>        Sync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;            setState(<span class="hljs-keyword">permits</span>);        &#125;<span class="hljs-comment">//返回permit</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPermits</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> getState();        &#125;<span class="hljs-comment">//共享模式下的非公平策略获取</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();                <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;                <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||                    compareAndSetState(available, remaining))                    <span class="hljs-keyword">return</span> remaining;            &#125;        &#125;<span class="hljs-comment">//共享模式下的释放</span>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;                <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);                <span class="hljs-keyword">if</span> (compareAndSetState(current, next))                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;<span class="hljs-comment">//根据指定数量减少可用许可数量</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reducePermits</span><span class="hljs-params">(<span class="hljs-type">int</span> reductions)</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current - reductions;                <span class="hljs-keyword">if</span> (next &gt; current) <span class="hljs-comment">// underflow</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Permit count underflow&quot;</span>);                <span class="hljs-keyword">if</span> (compareAndSetState(current, next))                    <span class="hljs-keyword">return</span>;            &#125;        &#125;<span class="hljs-comment">//permit不为0则更新permit，并返回permit</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">drainPermits</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();                <span class="hljs-keyword">if</span> (current == <span class="hljs-number">0</span> || compareAndSetState(current, <span class="hljs-number">0</span>))                    <span class="hljs-keyword">return</span> current;            &#125;        &#125;    &#125;</code></pre></div><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p>非公平策略直接调用<code>tryAcquireShared</code>完成获取资源的操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2694183684443567898L</span>;        NonfairSync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;            <span class="hljs-built_in">super</span>(<span class="hljs-keyword">permits</span>);        &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);        &#125;    &#125;</code></pre></div><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><p>公平策略中，获取共享状态时，会判断<code>Sync Queue</code>中是否有前驱元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">2014338818796000944L</span>;        FairSync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;            <span class="hljs-built_in">super</span>(<span class="hljs-keyword">permits</span>);        &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">if</span> (hasQueuedPredecessors())                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;                <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();                <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;                <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||                    compareAndSetState(available, remaining))                    <span class="hljs-keyword">return</span> remaining;            &#125;        &#125;&#125;</code></pre></div><h2 id="核心方法-2"><a href="#核心方法-2" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>获取一个<code>permit</code>，在<code>permit</code>有效之前，将会阻塞，响应中断。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="acquireUninterruptibly"><a href="#acquireUninterruptibly" class="headerlink" title="acquireUninterruptibly"></a>acquireUninterruptibly</h3><p>不接受中断的<code>acquire()</code>.</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span> &#123;    sync.acquireShared(<span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>释放一个<code>permits</code>。通过<code>AQS.releaseShared()</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();    sync.releaseShared(<span class="hljs-keyword">permits</span>);&#125;</code></pre></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Java SE 8 Docs API</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析线程池ThreadPoolExecutor</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/%E8%A7%A3%E6%9E%90%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/%E8%A7%A3%E6%9E%90%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><p><code>Thread Pool</code>是一种基于池化思想管理线程的工具，经常出现在多线程程序中。</p><p>线程池的优点：</p><ul><li>降低资源消耗：通过池化技术重复利用已创建线程。</li><li>提高响应速度：任务到达时，无需等待进程创建即可执行。</li><li>提高线程的可管理性：使用线程池进行统一的分配、调优和监控。</li><li>提供更多强大的功能：线程池具备可扩展性，允许开发人员向其中增加更多功能。</li></ul><h1 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h1><p>直接创建线程存在性能开销：</p><ul><li>Java中线程是基于内核线程实现的，线程的创建和销毁需要进行系统调用，性能开销较高。</li><li>Java8中，每个<code>Thread</code>都需要有一个内核线程的支持，这意味着每个<code>Thread</code>都需要消耗一定的内核资源。Java8中每个线程栈大小是1M，Java11中，对创建线程操作进行优化，创建一个线程只需要40KB左右。</li><li>线程切换引起<code>context switch</code>。</li></ul><p>​使用线程池解决的核心问题就是<strong>资源管理问题</strong>，多线程环境下，不确定性会带来一些问题：频繁申请&#x2F;销毁线程会带来额外的开销、存在资源耗尽的风险等。</p><p>​使用池化思想将资源统一在一起管理的一种思想，可以最大化收益最小化风险，</p><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><code>ThreadPoolExecutor</code>类的继承关系如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/pool/ThreadPoolExecutor.jpg" alt="ThreadPoolExecutor继承关系"></p><ul><li>Executor：顶层的<code>Executor</code>仅提供一个<code>execute()</code>接口，实现了提交任务与执行任务的解耦。</li><li>ExecutorService：继承自<code>Executor</code>，实现了添加了其他接口，例如：<ul><li>为一个或一批异步任务生成Future的方法</li><li>提供了管控线程池的方法，例如停止线程池运行。</li></ul></li><li>AbstractExecutorService：实现了<code>ExecutorService</code>，实现了除<code>execute()</code>以外的所有方法，将最重要的<code>execute()</code>交给<code>ThreadPoolExecutor</code>实现。</li></ul><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><code>ThreadPoolExecutor</code>的基本运行机制如下图所示（图片来源：美团技术团队）：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/pool/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor"></p><p>线程池内部相当于一个生产者消费者模型，将线程池分成两个部分：任务管理、线程管理。</p><ul><li>任务管理相当于生产者，任务提交后，线程池判断该任务的后续操作。<ol><li>直接申请线程执行该任务</li><li>存放到阻塞队列中等待</li><li>拒绝该任务。</li></ol></li><li>线程管理部分是消费者，根据任务请求进行线程分配工作，当线程执行完任务后会继续获取新的任务去执行，最终当线程获取不到任务时，线程会进行回收。</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>核心的构造方法如下，主要参数有：</p><ul><li><p><strong>corePoolSize</strong>：核心线程数量</p></li><li><p><strong>maximumPoolSize</strong>：最大线程数量</p></li><li><p><strong>workQueue</strong>：BlockingQueue类型，保存等待执行任务的阻塞队列，当提交一个新的任务到线程池时，线程池根据当前状态决定后续处理。可选择以下几种：</p><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue：Executors.newFixedThreadPool使用该队列</li><li>SynchronousQueue：同步队列，容量为0，put必须等待take，take等待put，Executors.newCachedThreadPool使用该队列。</li></ul></li><li><p><strong>keepAliveTime</strong>：线程池维护线程所允许的时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime。</p></li><li><p><strong>threadFactory</strong>：它是<code>ThreadFactory</code>类型的变量，用来创建新线程。</p></li><li><p><strong>handler</strong>：<code>RejectedExecutionHandler</code>类型，表示线程池的拒绝策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><span class="hljs-params">                              TimeUnit unit,</span><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><span class="hljs-params">                              ThreadFactory threadFactory,</span><span class="hljs-params">                              RejectedExecutionHandler handler)</span> &#123;        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();        <span class="hljs-built_in">this</span>.acc = System.getSecurityManager() == <span class="hljs-literal">null</span> ?                <span class="hljs-literal">null</span> :                AccessController.getContext();        <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;        <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;        <span class="hljs-built_in">this</span>.workQueue = workQueue;        <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;        <span class="hljs-built_in">this</span>.handler = handler;    &#125;</code></pre></div><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>线程池的运行状态，由<code>AtomicInteger ctl</code>维护，其中分为两个参数：<code>runState</code>和<code>workerCount</code>，高3位存储<code>runState</code>，低29位存储<code>workerCount</code>，提供了位运算的方法来获取对应的参数。线程池的运行状态，通过内部进行调整。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<span class="hljs-comment">// runState is stored in the high-order bits</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<span class="hljs-comment">//获取运行状态</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<span class="hljs-comment">//获取活动线程数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<span class="hljs-comment">//获取运行状态和活动线程数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;</code></pre></div><p>线程池状态表如下：</p><table><thead><tr><th align="center">运行状态</th><th align="center">状态描述</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">能接受新提交的任务，并且能处理阻塞队列中的任务</td></tr><tr><td align="center">SHUTDOWN</td><td align="center">关闭状态，不再接受新提交的任务，但是可以继续处理阻塞队列中的任务。</td></tr><tr><td align="center">STOP</td><td align="center">不能接受新的任务，也不处理队列中的任务，会中断正在处理任务的线程。</td></tr><tr><td align="center">TIDYING</td><td align="center">如果所有的任务都终止了，<code>workerCount</code>位0，线程池会调用<code>terminated()</code>进入TERMINATED状态。</td></tr><tr><td align="center">TERMINATED</td><td align="center">执行完<code>terminated()</code>方法后进入该状态。</td></tr></tbody></table><p>线程池的状态转换过程如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/pool/pool-status.jpg" alt="线程池状态转换过程"></p><h2 id="任务调度机制"><a href="#任务调度机制" class="headerlink" title="任务调度机制"></a>任务调度机制</h2><p>用户提交一个任务给线程池，线程池如何进行调度，如何对任务进行管理。这是这部分的核心问题。</p><p>调度工作是由<code>execute</code>方法完成，由此可以看出该方法的重要性。</p><p>其基本执行过程如下：</p><ol><li>首先检查线程池运行状态，如果不是<code>RUNNING</code>，则直接拒绝。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新任务。</li><li>如果workerCount &gt;&#x3D; corePoolSize，且线程池内的阻塞队列未满，则将任务添加到阻塞队列中。</li><li>如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workCount &lt; maximumPoolSize，且线程池内阻塞队列已满，则创建并启动一个线程来执行新任务</li><li>如果workerCount &gt;&#x3D; maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();    <span class="hljs-comment">//workerCount &lt; corePoolSize</span>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;            <span class="hljs-comment">//创建一个新的线程放入线程池，并将任务加到该线程。</span>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))                <span class="hljs-keyword">return</span>;            <span class="hljs-comment">//如果添加失败，更新c</span>            c = ctl.get();        &#125;    <span class="hljs-comment">//判断当前线程池是RUNNING状态，并且将任务添加到workQueue成功</span>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;            <span class="hljs-comment">//重新获取ctl的值</span>            <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();            <span class="hljs-comment">//再次判断线程池的状态，如果不是运行状态，将任务移出队列成功后，进行拒绝</span>            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))                reject(command);            <span class="hljs-comment">//如果workCount == 0，则添加新线程</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)                addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);        &#125;    <span class="hljs-comment">//1. 线程不是RUNNING状态 2.线程池是RUNNING状态，但是workerCount &gt;= corePoolSize &amp;&amp; workerCount已满</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))            <span class="hljs-comment">//失败则进行拒绝</span>            reject(command);    &#125;</code></pre></div><p>其执行流程如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/execute.png" alt="任务调度流程"></p><h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3><p>该方法主要是在线程池中新建一个<code>worker</code>线程并执行任务，两个参数的含义如下：</p><ul><li><code>firstTask</code>：执行新增的线程执行的第一个任务</li><li><code>core</code>：检测标识<ul><li><code>true</code>：新增线程时会判断当前活动线程是否小于<code>corePoolSize</code></li><li><code>false</code>：新增线程时会判断当前活动线程是否少于<code>maximumPoolSize</code></li></ul></li></ul><p>方法的具体含义参考代码注释。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;        retry:        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">//获取线程池运行状态</span>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);            <span class="hljs-comment">//如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务</span>            <span class="hljs-comment">//再检查三个条件，其中一个不满足则添加失败</span>            <span class="hljs-comment">//1. rs == SHUTDOWN：关闭状态则不接受新任务</span>            <span class="hljs-comment">//2. firstTask为空</span>            <span class="hljs-comment">//3. 阻塞队列不为空</span>            <span class="hljs-comment">//队列中没有任务则不需要再添加线程</span>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;                ! (rs == SHUTDOWN &amp;&amp;                   firstTask == <span class="hljs-literal">null</span> &amp;&amp;                   ! workQueue.isEmpty()))                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-comment">//获取线程数量</span>                <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);                <span class="hljs-comment">//检查线程数量是否超过CAPACITY（二进制为29个1）</span>                <span class="hljs-comment">//根据传入的core判断与哪个参数进行对比</span>                <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||                    wc &gt;= (core ? corePoolSize : maximumPoolSize))                    <span class="hljs-comment">//如果条件成立，则拒绝创建线程</span>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">//CAS尝试增加workerCount，成功则跳出外层循环</span>                <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                    <span class="hljs-keyword">break</span> retry;                c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span>                <span class="hljs-comment">//当前运行状态不等于rs，说明状态已改变，则返回内层循环继续执行</span>                <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                    <span class="hljs-keyword">continue</span> retry;                <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>            &#125;        &#125;        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//根据firstTask创建Worker对象</span>            w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);            <span class="hljs-comment">//获取worker的thread</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">//上一个可重入锁</span>                <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;                mainLock.lock();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// Recheck while holding lock.</span>                    <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                    <span class="hljs-comment">// shut down before lock acquired.</span>                    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<span class="hljs-comment">//rs &lt; SHUTDOWN表示是RUNNING状态</span>                    <span class="hljs-comment">//或者是RUNING状态并且firstTask为null</span>                    <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;                        <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();                        <span class="hljs-comment">//将worker加入工作线程集合中。</span>                        workers.add(w);                        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();                        <span class="hljs-comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span>                        <span class="hljs-comment">//如果添加之后的工作线程集合size &gt; largestPoolSize</span>                        <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                            <span class="hljs-comment">//更新线程池中出现的最大线程数量</span>                            largestPoolSize = s;                        workerAdded = <span class="hljs-literal">true</span>;                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    mainLock.unlock();                &#125;                <span class="hljs-keyword">if</span> (workerAdded) &#123;                    <span class="hljs-comment">//添加成功，启动线程执行任务</span>                    t.start();                    workerStarted = <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (! workerStarted)                addWorkerFailed(w);        &#125;        <span class="hljs-keyword">return</span> workerStarted;    &#125;</code></pre></div><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>线程池提供了如下四种策略：</p><ol><li><strong>AbortPolicy</strong>：直接抛出异常，这是默认策略。</li><li><strong>CallerRunsPolicy</strong>：用调用者所在的线程来执行任务。</li><li><strong>DiscardOldestPolicy</strong>：丢弃阻塞队列中靠最前的任务，并执行当前任务。</li><li><strong>DiscardPolicy</strong>：直接丢弃任务。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;                <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;                r.run();            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +                                                 <span class="hljs-string">&quot; rejected from &quot;</span> +                                                 e.toString());        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;                e.getQueue().poll();                e.execute(r);            &#125;        &#125;    &#125;</code></pre></div><h2 id="任务阻塞机制"><a href="#任务阻塞机制" class="headerlink" title="任务阻塞机制"></a>任务阻塞机制</h2><p>任务阻塞机制是线程池管理任务的核心机制。线程池将任务和线程进行解耦，以生产者消费者模式，通过一个阻塞队列来实现的。任务缓存到阻塞队列，线程从阻塞队列中获取任务。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><blockquote><p> Q：线程池如何管理进程？</p></blockquote><p>线程池中每一个线程被封装成<code>Worker</code>对象，通过对<code>Worker</code>对象的管理，从而达到对进程管理的目的。下面这个<code>HashSet</code>存储的是<code>Worker</code>集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Worker&gt;();</code></pre></div><p><code>Worker</code>继承了<code>AQS</code>，使用<code>AQS</code>实现了独占锁的功能，从<code>tryAcquire</code>可以看出禁止重入。其主要含义如下：</p><ul><li>独占状态：表示当前线程正在执行任务，则不应该中断线程。</li><li>空闲状态：没有在处理任务，可以对线程中断。</li></ul><p>其它注意点：</p><ul><li>线程池在执行<code>shutdown</code>方法或<code>tryTerminate</code>方法时会调用<code>interruptIdleWorkers</code>方法来中断空闲的线程，<code>interruptIdleWorkers</code>方法会使用<code>tryLock</code>方法来判断线程池中的线程是否是空闲状态；</li><li>设置成不可重入的原因：不希望任务在运行时重新获得锁，从而调用一些会中断运行时线程的方法。</li></ul><p><code>Worker</code>代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>    &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * This class will never be serialized, but we provide a</span><span class="hljs-comment">         * serialVersionUID to suppress a javac warning.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;       <span class="hljs-comment">//worker持有的线程</span>        <span class="hljs-keyword">final</span> Thread thread;       <span class="hljs-comment">//初始化的任务，可以为null</span>        Runnable firstTask;        <span class="hljs-comment">//任务计数器</span>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Creates with given first task and thread from ThreadFactory.</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><span class="hljs-comment">         */</span>        Worker(Runnable firstTask) &#123;            <span class="hljs-comment">//AQS默认为0，设置为-1是为了禁止执行任务前对线程进行中断</span>            setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span>            <span class="hljs-built_in">this</span>.firstTask = firstTask;            <span class="hljs-comment">//通过ThreadFactory创建线程</span>            <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);        &#125;        <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            runWorker(<span class="hljs-built_in">this</span>);        &#125;        <span class="hljs-comment">// Lock methods</span>        <span class="hljs-comment">//</span>        <span class="hljs-comment">// The value 0 represents the unlocked state.</span>        <span class="hljs-comment">// The value 1 represents the locked state.</span>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;        &#125;<span class="hljs-comment">//不可重入</span>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;                setExclusiveOwnerThread(Thread.currentThread());                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);            setState(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;        <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;            Thread t;            <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;                <span class="hljs-keyword">try</span> &#123;                    t.interrupt();                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;                &#125;            &#125;        &#125;    &#125;</code></pre></div><h3 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3><p>在<code>Worker</code>类中的<code>run()</code>调用该方法来执行任务，主要逻辑如下：</p><ol><li>while循环通过<code>getTask()</code>获取任务。</li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态（因为需要继续运行）。</li><li>调用<code>task.run()</code>运行任务</li><li>如果阻塞队列中没有任务可执行则跳出循环，执行<code>processWorkerExit()</code>回收线程。</li></ol><p>其代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;    <span class="hljs-comment">//获取线程</span>        <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-comment">//获取第一个任务</span>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;        w.firstTask = <span class="hljs-literal">null</span>;    <span class="hljs-comment">//允许中断</span>        w.unlock();    <span class="hljs-comment">//是否因为异常退出循环</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//task为空，则通过getTask来获取任务</span>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">//禁止中断</span>                w.lock();                <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span>                <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span>                <span class="hljs-comment">// requires a recheck in second case to deal with</span>                <span class="hljs-comment">// shutdownNow race while clearing interrupt</span>                <span class="hljs-comment">//如果线程池正在停止，保证当前线程是中断状态</span>                <span class="hljs-comment">//如果不是，确保当前线程不是中断状态</span>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||                     (Thread.interrupted() &amp;&amp;                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                    !wt.isInterrupted())                    wt.interrupt();                <span class="hljs-keyword">try</span> &#123;                    beforeExecute(wt, task);                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;                    <span class="hljs-keyword">try</span> &#123;                        task.run();                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;                        thrown = x; <span class="hljs-keyword">throw</span> x;                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;                        thrown = x; <span class="hljs-keyword">throw</span> x;                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);                    &#125; <span class="hljs-keyword">finally</span> &#123;                        afterExecute(task, thrown);                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    task = <span class="hljs-literal">null</span>;                    w.completedTasks++;                    w.unlock();                &#125;            &#125;            completedAbruptly = <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;            processWorkerExit(w, completedAbruptly);        &#125;    &#125;</code></pre></div><h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h3><p>该方法在runWorker中被调用，用于取出workQueue中的任务，代码与注释如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><span class="hljs-comment">//死循环获取队列任务</span>        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<span class="hljs-comment">//判断线程池状态</span>            <span class="hljs-comment">// Check if queue empty only if necessary.</span>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;                <span class="hljs-comment">//若已经停止，控制工作线程数量，并return null</span>                decrementWorkerCount();                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;            &#125;            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);            <span class="hljs-comment">// Are workers subject to culling?</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<span class="hljs-comment">//控制线程数量</span>            <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))                &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;                <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//取出任务</span>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                    workQueue.take();                <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">return</span> r;                timedOut = <span class="hljs-literal">true</span>;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;                timedOut = <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;</code></pre></div><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantReadWriteLock源码分析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/ReentrantReadWriteLock/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/ReentrantReadWriteLock/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ReentrantReadWriteLock分为读锁和写锁两个实例，读锁是共享锁，可被多个读线程同时使用，写锁是独占锁。持有写锁的线程可以继续获取读锁，反之不行。</p><p>Doug Lea 将持有写锁的线程，去获取读锁，之后释放读锁，最后释放写锁，从写锁降级为读锁的过程称为<strong>锁降级（Lock downgrading）</strong>。</p><p>但是，<strong>锁升级</strong>是不可以的。线程持有读锁的话，在没释放的情况下不能去获取写锁，因为会发生<strong>死锁</strong>。</p><h1 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h1><p>ReentrantReadWriteLock实现了ReadWriteLock接口，该接口定义了两个方法，分别返回读锁和写锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantReadWriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReadWriteLock</span>, java.io.Serializable &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the lock used for reading.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the lock used for reading</span><span class="hljs-comment">     */</span>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the lock used for writing.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the lock used for writing</span><span class="hljs-comment">     */</span>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;&#125;</code></pre></div><h1 id="类成员属性"><a href="#类成员属性" class="headerlink" title="类成员属性"></a>类成员属性</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//读锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;<span class="hljs-comment">//写锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;<span class="hljs-comment">//Sync是AQS的实现类</span><span class="hljs-keyword">final</span> Sync sync;<span class="hljs-comment">//Unsafe实例</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<span class="hljs-comment">//获取Thread.tid的内存偏移值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> TID_OFFSET;<span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; tk = Thread.class;            TID_OFFSET = UNSAFE.objectFieldOffset                (tk.getDeclaredField(<span class="hljs-string">&quot;tid&quot;</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);        &#125;&#125;</code></pre></div><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>默认的构造方法创建非公平策略的<code>ReentrantReadWriteLock</code>，传入<code>true</code>则可以创建公平策略的<code>ReentrantReadWriteLock</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>(<span class="hljs-literal">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates a new &#123;<span class="hljs-doctag">@code</span> ReentrantReadWriteLock&#125; with</span><span class="hljs-comment">     * the given fairness policy.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fair &#123;<span class="hljs-doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;        sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();        readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);        writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);    &#125;</code></pre></div><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p><code>ReentrantReadWriteLock</code>共有五个内部类，其基本结构如下：</p><ul><li>Sync：AQS的实现类<ul><li>FairSync：公平策略</li><li>NofairSync：非公平策略</li></ul></li><li>ReadLock：读锁</li><li>WriteLock：写锁</li></ul><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>该类继承自<code>AQS</code>抽象类，<code>ReentrantReadWriteLock</code>的大部分操作都交给<code>Sync</code>对象进行处理。</p><h3 id="HoldCounter"><a href="#HoldCounter" class="headerlink" title="HoldCounter"></a>HoldCounter</h3><p>该类配合读锁使用，属性定义如下：</p><ul><li>count： 代表某个读线程重入的次数</li><li>tid：获取当前线程的TID属性</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldCounter</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-comment">// Use id, not reference, to avoid garbage retention</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">tid</span> <span class="hljs-operator">=</span> getThreadId(Thread.currentThread());&#125;</code></pre></div><h3 id="ThreadLocalHoldCounter"><a href="#ThreadLocalHoldCounter" class="headerlink" title="ThreadLocalHoldCounter"></a>ThreadLocalHoldCounter</h3><p>该类继承自<code>ThreadLocal</code>，并重写了<code>initialValue()</code>，<code>ThreadLocal</code>可以将线程与对象相关联，<code>get</code>得到的值都是<code>initialValue()</code>生成的<code>HoldCounter</code>对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span>            <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;            <span class="hljs-keyword">public</span> HoldCounter <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HoldCounter</span>();            &#125;&#125;</code></pre></div><h3 id="类的成员属性"><a href="#类的成员属性" class="headerlink" title="类的成员属性"></a>类的成员属性</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;    <span class="hljs-comment">// 版本序列号</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6317671515068378041L</span>;            <span class="hljs-comment">// 高16位为读锁，低16位为写锁</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;    <span class="hljs-comment">// 读锁单位</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);    <span class="hljs-comment">// 读锁最大数量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 写锁最大数量</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 本地线程计数器</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ThreadLocalHoldCounter readHolds;    <span class="hljs-comment">// 缓存的计数器</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HoldCounter cachedHoldCounter;    <span class="hljs-comment">// 第一个读线程</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">firstReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 第一个读线程的计数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> firstReaderHoldCount;&#125;</code></pre></div><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><div class="code-wrapper"><pre><code class="hljs java">Sync() &#123;    <span class="hljs-comment">//本地线程计数器</span>            readHolds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalHoldCounter</span>();    <span class="hljs-comment">//设置AQS的state</span>            setState(getState()); <span class="hljs-comment">// ensures visibility of readHolds</span>&#125;</code></pre></div><h3 id="sharedCount"><a href="#sharedCount" class="headerlink" title="sharedCount"></a>sharedCount</h3><p>该方法将<code>c</code>无符号右移16位，得到的值为读锁的线程数量，因为<code>c</code>的高16位代表读锁，低16位代表写锁数量。</p><p>也可以通过方法命名看出来，读锁是共享模式，写锁是独占模式。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</code></pre></div><h3 id="exclusiveCount"><a href="#exclusiveCount" class="headerlink" title="exclusiveCount"></a>exclusiveCount</h3><p>该方法表示返回占有写锁的线程数量，通过<code>state</code>与<code>(1 &lt;&lt; 16) - 1</code>进行与运算，其等价于<code>state % 2 ^ 16</code>，因为写锁数量由<code>state</code>的低16位表示。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</code></pre></div><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><p>此方法用于释放写锁，通过这个调用链，可以清楚的看出<code>AQS</code>在并发类中的重要性，这也体现出了<code>AQS</code>的设计精髓，通过模板模式，将具体操作延迟到子类去实现。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//WriteLock</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;            sync.release(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//AQS中定义</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)                unparkSuccessor(h);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;    <span class="hljs-comment">//判断当前线程是否是独占线程</span>            <span class="hljs-keyword">if</span> (!isHeldExclusively())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();    <span class="hljs-comment">//nextc为释放资源后的写锁资源数量</span>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;    <span class="hljs-comment">//判断释放后的写锁数量是否为0</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (free)                <span class="hljs-comment">//为0说明当前没有线程独占</span>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);            setState(nextc);            <span class="hljs-keyword">return</span> free;&#125;</code></pre></div><h3 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h3><p><code>ReadLock</code>释放锁的流程，与<code>WriteLock</code>释放类似。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//ReadLock</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;            sync.releaseShared(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;    <span class="hljs-comment">//获取当前线程</span>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-comment">//如果当前线程是第一个读线程</span>            <span class="hljs-keyword">if</span> (firstReader == current) &#123;                <span class="hljs-comment">// assert firstReaderHoldCount &gt; 0;</span>                <span class="hljs-comment">//判断读线程占用资源数是否为1</span>                <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)                    <span class="hljs-comment">//为1则将第一个读线程置为空</span>                    firstReader = <span class="hljs-literal">null</span>;                <span class="hljs-keyword">else</span>                    <span class="hljs-comment">//不然就--</span>                    firstReaderHoldCount--;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//到这段说明：当前线程不是第一个读线程</span>                <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;                <span class="hljs-comment">//如果计数器为空，或者计数器中tid存储的不是当前线程</span>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))                    <span class="hljs-comment">//将计数器设置为当前线程计数器</span>                    rh = readHolds.get();                <span class="hljs-comment">//获取count</span>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> rh.count;                <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;                    <span class="hljs-comment">//count &lt;= 1 则将ThreadLocal中的值删除</span>                    readHolds.remove();                    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)                        <span class="hljs-keyword">throw</span> unmatchedUnlockException();                &#125;                <span class="hljs-comment">//更新计数器</span>                --rh.count;            &#125;    <span class="hljs-comment">//CAS自旋进行更新state</span>            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))                    <span class="hljs-comment">// Releasing the read lock has no effect on readers,</span>                    <span class="hljs-comment">// but it may allow waiting writers to proceed if</span>                    <span class="hljs-comment">// both read and write locks are now free.</span>                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;            &#125;        &#125;</code></pre></div><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>此方法用于写线程获取写锁，基本流程如下：</p><ul><li>首先会获取state，判断是否为0<ul><li>若为0，表示此时没有读锁线程。再判断写线程是否应该被阻塞，而在非公平策略下总是不会被阻塞，在公平策略下会进行判断(判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞)，之后在设置状态state，然后返回true。</li><li>若不为0，则表示此时存在读锁或写锁线程，若写锁线程数量为0或者当前线程不是独占锁线程，则返回false，表示不成功，否则，判断写锁线程的申请资源数量 + 现有的写线程数量是否大于了<code>MAX_COUNT</code>，若是，则抛出<code>Error</code>，否则，设置状态<code>state</code>，返回true，表示成功。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//WriteLock</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;            sync.acquire(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-comment">/*</span><span class="hljs-comment">             * Walkthrough:</span><span class="hljs-comment">             * 1. If read count nonzero or write count nonzero</span><span class="hljs-comment">             *    and owner is a different thread, fail.</span><span class="hljs-comment">             * 2. If count would saturate, fail. (This can only</span><span class="hljs-comment">             *    happen if count is already nonzero.)</span><span class="hljs-comment">             * 3. Otherwise, this thread is eligible for lock if</span><span class="hljs-comment">             *    it is either a reentrant acquire or</span><span class="hljs-comment">             *    queue policy allows it. If so, update state</span><span class="hljs-comment">             *    and set owner.</span><span class="hljs-comment">             */</span>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();    <span class="hljs-comment">//c为state</span>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();    <span class="hljs-comment">//w为写锁的线程数量</span>            <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);    <span class="hljs-comment">//c == 0代表当前没有读锁线程或写锁线程</span>            <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>                <span class="hljs-comment">//写线程数量为0或者当前线程没有占有独占资源</span>                <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">//如果申请的数量 + 现有的写线程 &gt; MAX_COUNT</span>                <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);                <span class="hljs-comment">// Reentrant acquire</span>                setState(c + acquires);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (writerShouldBlock() ||                !compareAndSetState(c, c + acquires))                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//设置独占线程</span>            setExclusiveOwnerThread(current);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;</code></pre></div><h3 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h3><p>此方法被读线程用于获取读锁，基本流程如下：</p><ul><li>首先判断写锁是否为0并且当前线程不占有独占锁，直接返回。</li><li>否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功<ul><li>若当前没有读锁，则设置第一个读线程firstReader和firstReaderHoldCount</li><li>若当前线程线程为第一个读线程，则增加firstReaderHoldCount</li><li>否则，将设置当前线程对应的HoldCounter对象的值。</li></ul></li><li>如果下列三个条件不满足(读线程是否应该被阻塞、小于最大值、比较设置成功)则会执行<code>fullTryAcquireShared</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;            <span class="hljs-comment">/*</span><span class="hljs-comment">             * Walkthrough:</span><span class="hljs-comment">             * 1. If write lock held by another thread, fail.</span><span class="hljs-comment">             * 2. Otherwise, this thread is eligible for</span><span class="hljs-comment">             *    lock wrt state, so ask if it should block</span><span class="hljs-comment">             *    because of queue policy. If not, try</span><span class="hljs-comment">             *    to grant by CASing state and updating count.</span><span class="hljs-comment">             *    Note that step does not check for reentrant</span><span class="hljs-comment">             *    acquires, which is postponed to full version</span><span class="hljs-comment">             *    to avoid having to check hold count in</span><span class="hljs-comment">             *    the more typical non-reentrant case.</span><span class="hljs-comment">             * 3. If step 2 fails either because thread</span><span class="hljs-comment">             *    apparently not eligible or CAS fails or count</span><span class="hljs-comment">             *    saturated, chain to version with full retry loop.</span><span class="hljs-comment">             */</span>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();    <span class="hljs-comment">//如果当前有写线程，并且独占线程不是当前线程</span>            <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;                getExclusiveOwnerThread() != current)                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-comment">//读锁数量</span>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);    <span class="hljs-comment">//如果当前线程需要被阻塞，并且读锁数量小于MAX_COUNT,并且CAS设置state成功</span>            <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;                r &lt; MAX_COUNT &amp;&amp;                compareAndSetState(c, c + SHARED_UNIT)) &#123;                <span class="hljs-comment">//读锁为0</span>                <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">//设置第一个读线程和计数器</span>                    firstReader = current;                    firstReaderHoldCount = <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;                    <span class="hljs-comment">//当前线程为第一个读线程</span>                    <span class="hljs-comment">//计数器加1</span>                    firstReaderHoldCount++;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//设置当前线程对应的HoldCounter对象的值</span>                    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;                    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))                        cachedHoldCounter = rh = readHolds.get();                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)                        readHolds.set(rh);                    rh.count++;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">return</span> fullTryAcquireShared(current);        &#125;</code></pre></div><h2 id="NofairSync"><a href="#NofairSync" class="headerlink" title="NofairSync"></a>NofairSync</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8159625535654395037L</span>;        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// writers can always barge</span>        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">/* As a heuristic to avoid indefinite writer starvation,</span><span class="hljs-comment">             * block if the thread that momentarily appears to be head</span><span class="hljs-comment">             * of queue, if one exists, is a waiting writer.  This is</span><span class="hljs-comment">             * only a probabilistic effect since a new reader will not</span><span class="hljs-comment">             * block if there is a waiting writer behind other enabled</span><span class="hljs-comment">             * readers that have not yet drained from the queue.</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();        &#125;    &#125;</code></pre></div><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2274990926593161451L</span>;        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">writerShouldBlock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> hasQueuedPredecessors();        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readerShouldBlock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> hasQueuedPredecessors();        &#125;    &#125;</code></pre></div><h2 id="ReadLock"><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p><code>ReadLock</code>拥有一个内部变量<code>sync</code>，构造方法用于初始化<code>sync</code>，可以联系<code>ReentrantReadWriteLock</code>的构造方法一起看。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5992448646407690164L</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Constructor for use by subclasses</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> lock the outer lock object</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> NullPointerException if the lock is null</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ReadLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;            sync = lock.sync;        &#125;&#125;</code></pre></div><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>从核心方法<code>lock()</code>和<code>unlock()</code>中可以看出其具体实现都是交给<code>sync</code>进行实现。读操作由于是共享的，所以它使用的是<code>AQS</code>的共享模式实现的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;            sync.acquireShared(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//相应中断的lock</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;            sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//尝试获取lock</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> sync.tryReadLock();&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>                <span class="hljs-keyword">throws</span> InterruptedException &#123;            <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;            sync.releaseShared(<span class="hljs-number">1</span>);&#125;</code></pre></div><h2 id="WriteLock"><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h2><p><code>WriteLock</code>和<code>ReadLock</code>类似，不同的是，写操作是独占的，因此它使用<code>AQS</code>的独占模式实现。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">4992448646407690164L</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;        <span class="hljs-keyword">protected</span> <span class="hljs-title function_">WriteLock</span><span class="hljs-params">(ReentrantReadWriteLock lock)</span> &#123;            sync = lock.sync;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;            sync.acquire(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;            sync.acquireInterruptibly(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">( )</span> &#123;            <span class="hljs-keyword">return</span> sync.tryWriteLock();        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>                <span class="hljs-keyword">throws</span> InterruptedException &#123;            <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;            sync.release(<span class="hljs-number">1</span>);        &#125;</code></pre></div><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://juejin.cn/post/6844903663488483336">https://juejin.cn/post/6844903663488483336</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock源码分析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>相对于<code>synchronized</code>关键字，<code>ReentrantLock</code>具备以下特点：</p><ul><li>可中断</li><li>可设置超时时间</li><li>可设置为公平锁</li><li>支持多个条件变量</li></ul><h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h1><p>可重入锁的实现上，主要关注两点：</p><ul><li><p>可重入线程的再次获取锁的处理</p></li><li><p>可重入锁的释放机制</p></li></ul><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，<code>Lock</code>接口定义了锁的通用方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable</code></pre></div><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p><code>sync</code>代表当前<code>ReentrantLock</code>使用的获取策略。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7373984872572414699L</span>;</code></pre></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>无参构造方法<ul><li>默认是非公平策略</li></ul></li><li>有参构造方法<ul><li>传入<code>true</code>使用公平策略。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates an instance of &#123;<span class="hljs-doctag">@code</span> ReentrantLock&#125;.</span><span class="hljs-comment">     * This is equivalent to using &#123;<span class="hljs-doctag">@code</span> ReentrantLock(false)&#125;.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;        sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates an instance of &#123;<span class="hljs-doctag">@code</span> ReentrantLock&#125; with the</span><span class="hljs-comment">     * given fairness policy.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fair &#123;<span class="hljs-doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;        sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();    &#125;</code></pre></div><h2 id="获取锁的策略"><a href="#获取锁的策略" class="headerlink" title="获取锁的策略"></a>获取锁的策略</h2><p><code>ReentrantLock</code>内部有三个内部类，其中<code>Sync</code>是其它两个类<code>NonfairSync</code>和<code>FairSync</code>的父类，分别代表着非公平策略和公平策略。</p><p>两者之间各有优缺点：</p><ul><li>公平策略：频繁进行上下文切换，造成较大的资源消耗。</li><li>非公平策略：存在线程饥饿问题，但是与公平策略相比，少量的上下文切换保证了更大的吞吐量。</li></ul><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>继承自<code>AbstractQueuedSynchronizer</code>，实现了对<code>state</code>字段的修改操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5179523762034025860L</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Performs &#123;<span class="hljs-doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span><span class="hljs-comment">         * is to allow fast path for nonfair version.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span><span class="hljs-comment">         * subclasses, but both need nonfair try for trylock method.</span><span class="hljs-comment">         */</span>    <span class="hljs-comment">//非公平方式尝试获取锁</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-comment">//获取当前线程</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();            <span class="hljs-comment">//获取AQS的state状态</span>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();            <span class="hljs-comment">//为0表示暂无线程占用锁</span>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//通过CAS设置state</span>                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                    <span class="hljs-comment">//设置成功之后，设置当前线程独占</span>                    setExclusiveOwnerThread(current);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;            <span class="hljs-comment">//如果当前线程拥有锁，则表示进行重入</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;                <span class="hljs-comment">//添加重入次数</span>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);                setState(nextc);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    <span class="hljs-comment">//尝试释放锁资源，全部释放则返回true</span>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;            <span class="hljs-comment">//c是释放后的资源量</span>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;            <span class="hljs-comment">//如果当前线程不是占有锁的线程，抛出异常</span>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();            <span class="hljs-comment">//free是全部释放的标识</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-comment">//如果c = 0，说明全部释放资源，可重入环境</span>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//设置全部释放标识</span>                free = <span class="hljs-literal">true</span>;                <span class="hljs-comment">//置空独占线程</span>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);            &#125;            setState(c);            <span class="hljs-keyword">return</span> free;        &#125;    <span class="hljs-comment">//判断资源是否被当前线程占有</span>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">// While we must in general read state before owner,</span>            <span class="hljs-comment">// we don&#x27;t need to do so to check if current thread is owner</span>            <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();        &#125;    <span class="hljs-comment">//生成一个条件</span>        <span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();        &#125;        <span class="hljs-comment">// Methods relayed from outer class</span><span class="hljs-comment">//返回占用锁的线程</span>        <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getOwner</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : getExclusiveOwnerThread();        &#125;<span class="hljs-comment">//如果锁被线程占有，则返回state</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHoldCount</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> isHeldExclusively() ? getState() : <span class="hljs-number">0</span>;        &#125;    <span class="hljs-comment">//判断锁是否被线程占有</span>    <span class="hljs-comment">//state不等于0则锁被线程占用</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//自定义反序列化逻辑</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span>            <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;            s.defaultReadObject();            setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// reset to unlocked state</span>        &#125;    &#125;</code></pre></div><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p><code>NonfairSync</code>表示是非公平策略获取锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7316153563782823691L</span>;        <span class="hljs-comment">//获得锁</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">//CAS操作设置state为1</span>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))                <span class="hljs-comment">//CAS设置成功，则设置独占进程为当前进程</span>                setExclusiveOwnerThread(Thread.currentThread());            <span class="hljs-keyword">else</span>                <span class="hljs-comment">//锁已经被占用，或者set失败</span>                <span class="hljs-comment">//独占方式进行获取</span>                acquire(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);        &#125;    &#125;</code></pre></div><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><p>采用公平策略获取锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<span class="hljs-comment">//调用acquire方法，以独占方式获取锁</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;            acquire(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//尝试获取公平锁</span>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;            <span class="hljs-comment">//获取当前线程</span>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();            <span class="hljs-comment">//获取AQS的state</span>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();            <span class="hljs-comment">//如果当前没有线程占有锁</span>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//判断AQS Queue是否有线程在等待</span>                <span class="hljs-comment">//如果没有则直接通过CAS获取锁资源</span>                <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                    <span class="hljs-comment">//设置当前线程为独占线程</span>                    setExclusiveOwnerThread(current);                    <span class="hljs-comment">//获取成功</span>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;            <span class="hljs-comment">//如果当前线程已经占有锁，则更新可重入信息</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;                <span class="hljs-comment">//更新可重入信息</span>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;                <span class="hljs-comment">//检查边界</span>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);                setState(nextc);                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;</code></pre></div><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>调用<code>sync.lock()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;        sync.lock();&#125;</code></pre></div><h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h3><p>响应中断的获取锁的方法，调用<code>AQS.acquireInterruptibly()</code>完成。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        sync.acquireInterruptibly(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>            <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">if</span> (Thread.interrupted())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();        <span class="hljs-keyword">if</span> (!tryAcquire(arg))            doAcquireInterruptibly(arg);&#125;</code></pre></div><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3><p>非公平方式尝试获取锁，调用<code>sync.nonfairTryAcquire(1)</code>完成。重载方法提供了超时策略，同时响应中断。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>            <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span>            <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">if</span> (Thread.interrupted())            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();        <span class="hljs-keyword">return</span> tryAcquire(arg) ||            doAcquireNanos(arg, nanosTimeout);&#125;</code></pre></div><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><p>调用<code>sync.release(1)</code>完成<code>unlock()</code>操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;        sync.release(<span class="hljs-number">1</span>);&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ReentrantLock</code>的核心功能主要通过内部类<code>Sync</code>完成。而<code>Sync</code>继承自<code>AQS</code>，通过<code>AQS</code>中的<code>Sync Queue</code>完成对线程排队的功能。<code>ReentrantLock</code>的公平策略和非公平策略通过另外两个内部类<code>FairSync</code>、<code>NonfairSync</code>实现。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员练级攻略》 阅读总结</title>
    <link href="/2020/%E9%9A%8F%E7%AC%94/programmer-study-manual/"/>
    <url>/2020/%E9%9A%8F%E7%AC%94/programmer-study-manual/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​陈皓叔叔的这个专栏之前就有所耳闻并大致过了一遍，如今重新精读本专栏，认真学习，对整体的学习方向进行把握，并且进行总结。</p><p>如何入门？</p><p>学习Python，JavaScript，学习使用操作系统Linux，编程工具VS Code，Web开发等，这些更容易获得编程的成就感。</p><p>如何成为专业的程序员？</p><p>拥有程序员的自我修养。这是反映出程序员的工程师特质和价值观，决定了这条路你到底能走多远。<strong>有修养的程序员才可能成长为真正的工程师和架构师，没有修养的程序员智能沦为码农，这是码农和工程师的关键区分点。</strong></p><ul><li>英文能力</li><li>提问的能力</li><li>写代码的修养<ul><li><a href="https://book.douban.com/subject/4262627/">重构：改善既有代码的设计</a></li><li><a href="https://book.douban.com/subject/4199741/">代码整洁之道</a></li><li><a href="https://book.douban.com/subject/11614538/">程序员的职业素养</a></li><li>Code Review<ul><li>对自我成长非常有帮助</li><li>不做Code Review的公司没有必要呆</li></ul></li><li>Unit Test</li></ul></li><li>安全防范意识<ul><li>代码安全</li><li>防御性编程</li></ul></li><li>软件工程和上线规范<ul><li><a href="https://book.douban.com/subject/4187479/">完美软件：对软件测试的各种幻想</a></li><li><a href="https://book.douban.com/subject/25742200/">Google软件测试之道</a></li></ul></li><li>编程规范</li></ul><p>专业基础包括哪些？</p><ul><li>编程语言：推荐C、C++、Java这三个工业级的编程语言。</li><li>理论学科：数据结构和算法，计算机网络，计算机组成原理，操作系统，编译原理</li></ul><p>从业方向？</p><ul><li>如果你对操作系统、文件系统、数据库、网络等比较感兴趣，那么可以考虑从事底层方面的工作。</li><li>如果对分布式系统架构、微服务、DevOps、Cloud Native 等有热情，那么可以从事架构方面的工作。</li><li>如果是对大数据、机器学习、人工智能等比较关注，那么数据领域可以成为你一展身手的地方。</li><li>如果你对用户体验或者交互等更感兴趣，那么前端工程师也是个不错的选择。</li><li>此外，安全开发、运维开发、嵌入式开发等几大方向中，也为你提供了丰富多彩的发展空间。</li></ul><p>两个观点：</p><ul><li>各种技术方向不是鱼和熊掌，是可以兼得的。</li><li>很多技术都是相通的，关键是要学的深入本质。</li></ul><p>几个问题：</p><ul><li>理论和现实的差距：学院派的知识是成为专家的必经之路，<strong>这就是“工人”和“工程师</strong>”的差别，是“建筑工人”和“建筑架构师”的差别。</li><li>技术太多学不过来&#x2F;技术能力的瓶颈：自己懒惰的借口，<strong>以绝大多数人努力的程度，和为自己不努力找借口的程度为参考，只要你坚持正常的学习就可以超过大多数人了。</strong></li></ul><p>学习建议？</p><ul><li>一定要坚持，要保持长时间学习，甚至终身学习的态度。</li><li>一定要动手，不管例子多么简单，建议至少自己动手敲一遍看看是否理解了里面的细枝末节。</li><li>一定要学会思考，思考为什么会这样，要学会举一反三。</li><li>不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累，会在未来至少十年通用。</li></ul><h2 id="编程入门"><a href="#编程入门" class="headerlink" title="编程入门"></a>编程入门</h2><ul><li>入门语言Python</li><li>入门语言JavaScript</li><li>操作系统LInux</li><li>编程工具VS Code</li><li>Web入门</li></ul><h2 id="正式入门"><a href="#正式入门" class="headerlink" title="正式入门"></a>正式入门</h2><ul><li>编程技能<ul><li><a href="http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/">如何快速提升自己的编程能力</a></li></ul></li><li>编程技巧<ul><li><a href="https://book.douban.com/subject/1477390/">代码大全</a></li></ul></li><li>编程语言<ul><li>Java</li></ul></li><li>操作系统<ul><li><a href="https://book.douban.com/subject/30359954/">鸟哥的Linux私房菜</a></li></ul></li><li>网络协议<ul><li>系统了解HTTP协议</li></ul></li><li>数据库设计<ul><li>基本的设计知识</li><li><a href="https://book.douban.com/subject/3354490/">MySQL必知必会</a></li></ul></li><li>前端<ul><li>Vue</li></ul></li><li>字符编码方面<ul><li><a href="https://en.wikipedia.org/wiki/Character_encoding">Wikipedia</a></li></ul></li></ul><p>为什么转成Java语言？</p><ul><li>Java语言的综合实力最强，是一个工业级的编程语言。</li><li>像 Python 和 JavaScript 这样的动态语言用着是很爽，但是，只有像 C、C++ 和 Java 这样的静态语言才可以让你真正地进阶。</li><li>对于一个合格的程序员，掌握几门语言是非常正常的事情。</li></ul><h3 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h3><ul><li>IDE</li><li>版本管理工具</li><li>前端调试</li><li>数据库设计工具</li></ul><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><a href="https://book.douban.com/subject/34898994/">Java核心技术·卷 I 基础知识</a></li></ul><blockquote><p>这本书本来是 Sun 公司的官方用书，是一本 Java的入门参考书。对于 Java 初学者来说，是一本非常不错的值得时常翻阅的技术手册。书中有较多地方进行 Java 与 C++ 的比较，因为当时 Java 面世的时候，又被叫作 “C++ Killer”。而我在看这本书的时候，发现书中有很多 C++ 的东西，于是又去学习了C++。学习 C++ 的时候，发现有很多 C 的东西不懂，又顺着去学习了 C。然后，C -&gt;C++ -&gt; Java 整条线融汇贯通，这对我未来的技术成长有非常大的帮助。</p></blockquote><ul><li><a href="https://book.douban.com/subject/27047716/">Effective Java</a></li></ul><blockquote><p>这本书是模仿 Scott Meyers 的经典图书《Effective C++》的。Effective 这种书基本上都是各种经验之谈，所以，这是一本非常不错的书，你一定要读。这里需要推荐一下 Google Guava 库 ，这个库不但是 JDK 的升级库，其中有如：集合（collections）、缓存（caching）、原生类型支持（primitives support）、并发库（concurrency libraries）、通用注解（common annotations）、字符串处理（string processing）、I&#x2F;O 等库，其还是Effective Java 这本书中的那些经验的实践代表。</p></blockquote><ul><li><a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a></li></ul><blockquote><p>是一本完美的 Java 并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容。最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。</p></blockquote><ul><li><a href="https://book.douban.com/subject/26740520/">Java性能权威指南</a></li></ul><blockquote><p>通过学习这本书，你可以比较大程度地提升性能测试的效果。其中包括：使用 JDK 中自带的工具收集 Java 应用的性能数据，理解 JIT 编译器的优缺点，调优JVM 垃圾收集器以减少对程序的影响，学习管理堆内存和 JVM 原生内存的方法，了解如何最大程度地优化 Java 线程及同步的性能，等等。看完这本书后，如果你还有余力，想了解更多的底层细节，那么，你有必要去读一下《深入理解 Java 虚拟机》。</p></blockquote><ul><li><a href="https://book.douban.com/subject/2130190/">Java编程思想</a></li></ul><blockquote><p>真是一本透着编程思想的书。上面的书让你从微观角度了解 Java，而这本书则可以让你从一个宏观角度了解 Java。这本书和 Java 核心技术的厚度差不多，但这本书的信息密度比较大。所以，读起来是非常耗大脑的，因为它会让你不断地思考。对于想学好 Java 的程序员来说，这是一本必读的书。</p></blockquote><p>学Java一定要学面向对象的设计模式，两本书：</p><ul><li><a href="https://book.douban.com/subject/2243615/">Head First 设计模式</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul><p>学习设计模式，不能迷失在23个设计模式种，一定要明白两个原则：</p><ul><li><p><strong>Program to an ‘interface’, not an ‘implementation’</strong></p><ul><li>使用者不需要知道数据类型，结构，算法等细节。</li><li>使用者不需要知道实现细节，只需要知道提供的接口。</li><li>利用封装，抽象，动态绑定，多态等符合面向对象的特质和理念。</li></ul></li><li><p><strong>Favor ‘object composition’ over ‘class inheritance’</strong></p><ul><li>继承需要给子类暴露一些父类的设计和实现细节。</li><li>父类实现的改变会造成子类也需要改变。</li><li>我们以为继承主要是为了代码重用，实际上在子类中需要重新实现很多父类的方法。继承更多的应该是为了多态。</li></ul></li><li><p>Java字节码相关</p><ul><li>相关教程和工具</li></ul></li><li><p>JVM相关</p><ul><li>The Java Virtual Machine Specification Java SE 8 Edition</li><li>JSR-133</li><li>垃圾回收机制</li><li>垃圾回收调优</li></ul></li><li></li></ul><p>上面的这些知识融会贯通，已经是高级的Java程序员了。</p><h3 id="C-C-语言"><a href="#C-C-语言" class="headerlink" title="C&#x2F;C++语言"></a>C&#x2F;C++语言</h3><ul><li><a href="https://book.douban.com/subject/1139336/">C程序设计语言</a></li><li><a href="https://book.douban.com/subject/2280547/">C语言程序设计现代方法</a></li><li><a href="https://book.douban.com/subject/2778632/">C缺陷与陷阱</a></li><li><a href="https://book.douban.com/subject/25708312/">C++ Primer</a></li><li><a href="https://book.douban.com/subject/5387403/">Effective C++</a></li><li><a href="https://book.douban.com/subject/5908727/">More Effective C++</a></li><li><a href="https://book.douban.com/subject/10427315/">深度探索C++对象模型</a></li></ul><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ul><li><a href="https://gobyexample.com/">Go by Example</a></li><li><a href="https://book.douban.com/subject/27044219/">Go程序设计语言</a></li><li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li></ul><h2 id="理论学科"><a href="#理论学科" class="headerlink" title="理论学科"></a>理论学科</h2><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><blockquote><p> 无论是做业务还是做底层系统，经常需要使用算法处理各种问题，例如：业务上需要算法比较两个数组中差异的布隆过滤器，或者是在监控系统实时计算过去一分钟的P99统计时的蓄水池算法，或者是数据库的B+树索引，还是Linux内核中的<code>epoll</code>或者<code>TreeMap</code>中的红黑树。还有做任务调度的背包问题等都会用到数据结构和算法。</p></blockquote><ul><li><p>算法书籍：</p><ul><li>《算法》</li><li>《算法图解》</li><li>《算法导论》</li><li>《编程珠玑》</li><li>《数据结构与算法分析》</li></ul><h3 id="系统知识"><a href="#系统知识" class="headerlink" title="系统知识"></a>系统知识</h3></li></ul><p>书籍：</p><ul><li>《深入理解计算机系统》</li><li>《Unix高级环境编程》</li><li>《Unix网络编程》</li><li>《TCP&#x2F;IP详解 卷I协议》</li><li>《Linux C编程一站式学习》</li><li>《TCP&#x2F;IP网络编程》</li><li>《图解TCP&#x2F;IP》</li><li>《Wireshark数据包分析实战》</li></ul><h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><p>一些软件设计的相关原则：</p><ul><li><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t repeat yourself</a></li><li><a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle</a></li><li>Program to an interface, not an implementation：设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。</li><li><a href="https://en.wikipedia.org/wiki/You_Ain%27t_Gonna_Need_It">You aren’t gonna need it</a></li><li><a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a></li><li><a href="https://zh.wikipedia.org/zh-hans/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)">面向对象的SOLID原则</a></li><li><a href="http://en.wikipedia.org/wiki/Hollywood_Principle">Hollywood principle</a></li><li>高内聚低耦合</li><li>CoC（Convention over Configuration）- <strong>惯例优于配置原则</strong></li><li>SoC (Separation of Concerns) - 关注点分离，实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装</li><li>DbC（Design by Contract）：契约式设计</li><li>ADP（Acyclic Dependencies Principle）：无环依赖原则</li></ul><p>一些软件设计的读物：</p><ul><li>领域驱动设计</li><li>UNIX编程技术</li><li>Clean Architecture</li></ul><h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li>基础知识</li><li>网络调优</li><li>网络协议</li></ul><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h3><ul><li>阻塞I&#x2F;O</li><li>非阻塞I&#x2F;O</li><li>I&#x2F;O的多路复用（select、poll）</li><li>信号驱动的I&#x2F;O（SIGIO）</li><li>异步I&#x2F;O（POSIX的aio_functions）</li></ul><h3 id="Lock-Free编程相关"><a href="#Lock-Free编程相关" class="headerlink" title="Lock-Free编程相关"></a>Lock-Free编程相关</h3><p>如果想开发出一个高性能的程序，你就非常有必要学习<code>Lock-Free</code>的编程方式。</p><ul><li>相关的概念</li><li>论文</li><li>博客</li><li>现有的实现，C++&#x2F;Java类库</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>64位系统编程</li><li>提高OpenSSL的执行性能</li><li>压缩</li><li>SSD硬盘性能测试</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>关系型数据库<ul><li>MySQL官方手册</li><li>高性能MySQL</li><li>MySQL技术内幕：InnoDB存储引擎</li><li>数据库的索引设计与优化</li></ul></li><li>非关系型数据库<ul><li>各类论文</li></ul></li></ul><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><ul><li>服务调度<ul><li>涉及服务发现、配置管理、弹性伸缩、故障恢复等。</li></ul></li><li>资源调度<ul><li>涉及对底层资源的调度使用、如计算资源、网络资源和存储资源等。</li></ul></li><li>流量调度<ul><li>涉及路由、负载均衡、流量控制、熔断等。</li></ul></li><li>数据调度<ul><li>涉及数据副本、数据一致性、分布式事务、分库分表等。</li></ul></li><li>容错处理<ul><li>涉及隔离、幂等、重试、业务补偿、异步、降级等。</li></ul></li><li>自动化运维<ul><li>涉及持续集成、持续部署、全栈监控、调用链跟踪等。</li></ul></li></ul><p>几个注意点：</p><ul><li>分布式系统之所以复杂，就是因为它太容易出错了。这意味着，你要把处理错误的代码当成正常功能的代码来处理。</li><li>开发一个健壮的分布式系统的成本是单体系统的几百倍甚至几万倍。这意味着，我们要自己开发一个，需要能力很强的开发人员。</li><li>非常健壮的开源的分布式系统并不多，或者说基本没有。这意味着，如果你要用开源的，那么你需要 hold 得住其源码。</li><li>管理或是协调多个服务或机器是非常难的。这意味着，我们要去读很多很多的分布式系统的论文。</li><li>在分布式环境下，出了问题是很难 debug 的。这意味着，我们需要非常好的监控和跟踪系统，还需要经常做演练和测试。</li><li>在分布式环境下，你需要更科学地分析和统计。这意味着，我们要用 P90 这样的统计指标，而不是平均值，我们还需要做容量计划和评估。</li><li>在分布式环境下，需要应用服务化。这意味着，我们需要一个服务开发框架，比如 SOA或微服务。</li><li>在分布式环境下，故障不可怕，可怕的是影响面过大，时间过长。这意味着，我们需要花时间来开发我们的自动化运维平台。</li></ul><h3 id="分布式架构入门"><a href="#分布式架构入门" class="headerlink" title="分布式架构入门"></a>分布式架构入门</h3><ul><li>分布式理论<ul><li>各种理论算法</li><li>论文</li><li>一致性问题</li></ul></li><li>分布式事务</li><li>Paxos一致性算法</li><li>Raft一致性算法</li><li>Gossip一致性算法</li><li>分布式存储和数据库</li><li>分布式信息系统</li><li>日志和数据</li><li>分布式监控和跟踪</li><li>数据分析</li></ul><h3 id="分布式架构工程设计"><a href="#分布式架构工程设计" class="headerlink" title="分布式架构工程设计"></a>分布式架构工程设计</h3><ul><li>论文</li><li>分布式设计模式<ul><li>可用性</li><li>数据管理</li><li>设计和实现</li><li>消息</li><li>管理和监控</li><li>性能和扩展</li><li>系统弹力</li><li>安全</li></ul></li><li>设计与工程实践<ul><li>分布式系统的故障测试</li><li>弹性伸缩</li><li>一致性哈希</li><li>数据库分布式</li><li>缓存</li><li>消息队列</li><li>日志方面</li><li>性能方面</li><li>搜索方面</li><li>公司的架构实践</li></ul></li></ul><h2 id="容器化和自动化运维"><a href="#容器化和自动化运维" class="headerlink" title="容器化和自动化运维"></a>容器化和自动化运维</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li>基础知识</li><li>实践</li><li>底层技术细节</li></ul><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Kubernetes 是 Google 开源的容器集群管理系统，是 Google 多年大规模容器管理技术<br>Borg 的开源版本，也是 CNCF 最重要的项目之一，主要功能包括：</p><ul><li>基于容器的应用部署、维护和滚动升级；</li><li>负载均衡和服务发现；</li><li>跨机器和跨地区的集群调度；</li><li>自动伸缩；</li><li>无状态服务和有状态服务；</li><li>广泛的 Volume 支持；</li><li>插件机制保证扩展性。</li></ul><p>如何学习？</p><ul><li>Kubernetes handbook</li><li>Kubernetes指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>秒杀系统设计总结</title>
    <link href="/2020/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/seckill-summary/"/>
    <url>/2020/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/seckill-summary/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>  秒杀从规模上可以分为以下两类：</p><ul><li>大秒：类似双十一，商品数量规模大，价格低，流量超大的活动。</li><li>小秒：商家自己配置的一些时段类型的活动，由商家自己指定时间上架。</li></ul><h2 id="秒杀系统面对的问题"><a href="#秒杀系统面对的问题" class="headerlink" title="秒杀系统面对的问题"></a>秒杀系统面对的问题</h2><p>  秒杀系统本质上就是一个满足大并发、高性能和高可用的分布式系统。</p><ul><li>高并发环境下的系统稳定性：如何保证系统在面对巨大的流量情况下，不被打崩？<ul><li>两个问题<ul><li>并发读<ul><li>核心优化理念：减少用户到服务端来读数据。或者让他们读取更少的数据。</li></ul></li><li>并发写<ul><li>核心优化理念：在数据库层面独立出来一个库，做特殊的处理。</li></ul></li></ul></li><li>大流量会产生以下实际待解决问题<ul><li>Redis缓存击穿&#x2F;雪崩&#x2F;穿透等问题</li><li>关系型数据库性能问题，锁竞争对性能的消耗</li></ul></li></ul></li><li>保证数据的最终一致性：库存不能超卖。</li><li>大数据分析功能：分析本次秒杀活动的商业效益。</li><li>需要有一个兜底方案，以防最坏的情况发生。</li></ul><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="架构原则：-“4要1不要”"><a href="#架构原则：-“4要1不要”" class="headerlink" title="架构原则： “4要1不要”"></a>架构原则： “4要1不要”</h2><blockquote><p>架构是一种平衡的艺术，最好的架构一旦脱离了它所适应的场景，一切都将是空谈。</p></blockquote><ul><li><p>数据要尽量少</p><ul><li>用户请求的数据能少就少，包括上传给系统的数据和系统返回给用户的数据。</li></ul></li><li><p>HTTP请求数尽量少</p><ul><li>合并CSS，JS文件</li></ul></li><li><p>路径要尽量短</p><ul><li>用户发出请求到返回数据的过程中，经过的节点要尽量短<ul><li>通常，每经过一个节点，都会产生一个新的Socket连接。</li></ul></li><li>会减少时延</li><li>可以选择将多个相互强依赖的引用部署在一起，将RPC变成JVM内部的方法调用</li></ul></li><li><p>依赖要尽量少</p><ul><li>完成一次用户请求必须依赖的系统或服务要少（指的是强依赖）<ul><li>比如展示秒杀页面，它强依赖商品信息，用户信息，但是优惠券，成交列表等非必要模块是可以在紧急情况下去掉。</li></ul></li><li>对系统模块进行分级，0级，1级，2级等</li></ul></li><li><p>不要有单点</p><ul><li>系统中的单点是系统架构上的一个大忌，单点意味着没有备份，风险不可控。<ul><li>如何避免单点？<ul><li>避免将服务的状态和机器绑定（服务无状态化）<ul><li>把服务的配置动态化（使用配置中心Nacos等）</li><li>存储服务不好实现，因为数据持久化存储在机器的磁盘里面。文件存储可以通过冗余多个备份的方式来解决单点问题。</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="流量过滤"><a href="#流量过滤" class="headerlink" title="流量过滤"></a>流量过滤</h2><p>  本质：逐级过滤掉无效的流量。基本有以下一些解决方案：</p><ul><li>活动开始前前端页面的Button无法点击，防止活动尚未开始时，用户进行点击产生流量。<ul><li>同时后端需要做相关校验。避免用户直接请求秒杀接口。</li><li>秒杀url实现动态化，可以选择进行md5加密随机字符串，然后通过另一个接口校验秒杀接口的合法性</li></ul></li><li>错峰：前端添加验证码或者答题，防止瞬间产生超高的流量，增加题目辨别难度，避免以图像识别等技术进行破解。</li><li>校验：对参与活动的用户进行校验拦截。主要从以下几个方面进行判断<ul><li>用户白名单</li><li>用户终端校验：对用户终端类型进行判断</li><li>IP、MAC、ID校验</li><li>参与次数校验：避免多次参与活动</li><li>用户黑名单：避免羊毛党等</li></ul></li><li>限流：通过接口限流策略判断请求是否放行<ul><li>令牌桶算法</li></ul></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>  前面的流量过滤基本过滤掉大部分流量，但是系统性能还需进行优化，主要有以下的解决方案：</p><ul><li>动静分离</li><li>活动预热：将参加活动的商品独立出来，不和普通的商品库存共享服务，提前将数据缓存到<code>Redis</code>，查询全部走缓存，扣减库存视情况而定。</li><li>选择<code>Nginx</code></li><li>采用微服务架构部署，提高部署量，均摊请求。</li><li>秒杀是典型的读多写少的场景，考虑到单体redis的性能问题，可以考虑：<ul><li><code>Redis</code>集群</li><li>主从同步</li><li>读写分离</li><li>如果使用<code>Redis</code>集群，同时需要考虑保证多节点的数据一致性</li></ul></li><li>异步处理：采用消息队列<ul><li>异步，削峰，解耦</li></ul></li></ul><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>  <strong>“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据</strong>。</p><p>  简而言之，静态数据是能不经过后端请求，直接输出给用户的数据，</p><p>  如何对静态数据做缓存？</p><ul><li>把静态数据缓存到离用户最近的地方。<ul><li>用户浏览器</li><li>CDN<ul><li>失效问题</li><li>命中率问题</li><li>发布更新问题</li></ul></li><li>服务器端Cache</li></ul></li><li>静态化改造就是直接缓存HTTP连接。<ul><li>静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据。Web代理服务器直接根据请求<code>URL</code>，取出对应的HTTP响应头和响应体然后直接返回。</li></ul></li><li>选择缓存性能优秀的工具进行缓存服务，可以在Web服务器层面进行缓存，例如Nginx，Apache。</li></ul><h4 id="如何做动静分离的改造？"><a href="#如何做动静分离的改造？" class="headerlink" title="如何做动静分离的改造？"></a>如何做动静分离的改造？</h4><ul><li>URL唯一化，每个商品由ID来标识。item.xxx.com&#x2F;item.htm?id&#x3D;xxxx 就可以作为唯一的 URL 标识。<ul><li>URL唯一可以根据id作为key，查询之前缓存的HTTP连接。</li></ul></li><li>分离浏览者相关的因素。登录状态可以通过请求获取<ul><li>JWT</li></ul></li><li>分离时间因素。服务端输出的时间也通过请求获取。</li><li>异步化地域因素：详情页面上的地域信息做成异步方式获取。</li><li>去掉Cookie，可以通过Web服务器删除服务器输出的页面中的Cookie。</li></ul><h4 id="动态数据的处理方式"><a href="#动态数据的处理方式" class="headerlink" title="动态数据的处理方式"></a>动态数据的处理方式</h4><ul><li>ESI方案：在Web代理服务器上做动态内容请求，并将请求插入到静态页面中。当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。</li><li>CSI方案：即单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</li></ul><h2 id="解决超卖"><a href="#解决超卖" class="headerlink" title="解决超卖"></a>解决超卖</h2><p>  一般情况下，减库存有以下方式：</p><ul><li>下单减库存：是最简单的方式，也控制的最精准。但是存在恶意锁单等问题。</li><li>付款减库存：大并发的情况下，可能存在买家下单后无法付款的问题。</li><li>预扣库存：买家下单后，库存为其保留一定时间，超时未付款自动释放库存</li></ul><p>  如果扣库存逻辑较为简单，比如没有复杂的SKU库存和总库存这种联动关系的话，可以选择在<code>Redis</code>完成减库存。<code>Redis</code>定时更新到<code>MySQL</code>。</p><p>  复杂秒杀场景选择的方式：</p><ol><li>首先查询<code>Redis</code>缓存库存是否充足</li><li>先扣库存再落订单数据，以防订单生成没有了库存的超卖问题</li><li>扣库存先扣数据库，再扣<code>Redis</code>，并且两个操作需要在同一个事务中，一个执行失败全部回滚。<ul><li>数据库<code>MySQL</code>更新可以采取<strong>乐观锁</strong>方式，添加<code>version</code>字段进行处理，性能较悲观锁高。</li></ul></li></ol><p>  上述方案能一定程度解决问题，但是如果大量请求线程落在同一条库存记录上去<code>update</code>时，会造成<code>InnoDB</code>行锁的竞争问题，而并发度越高等待的线程会越多，TPS（Transaction Per Second）会下降，相应时间上升，数据库的吞吐量会严重受影响。</p><p>  这时，需要做数据库层面的优化。</p><h2 id="质量保障"><a href="#质量保障" class="headerlink" title="质量保障"></a>质量保障</h2><ul><li>熔断限流降级</li><li>监控：QPS监控，容器监控，CPU监控，IO监控等</li><li>提前压测</li></ul><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><ul><li>埋点，检测</li><li>数据大盘，通过数据库数据配合监控系统（首选）</li><li>离线数据分析</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LockSupport源码分析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/LockSupport%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/LockSupport%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Basic thread blocking primitives for creating locks and other synchronization classes.   – Java Doc</p></blockquote><p><code>LockSupport</code>是用来创建锁和其它同步类的基本线程阻塞原语。底层依赖<code>Unsafe</code>实现，我们可以在其它的并发同步工具类的实现中看到该类的使用。<code>LockSupport</code>提供了<code>park()</code>和<code>unpark()</code>方法来分别实现阻塞线程和唤醒线程，每个使用<code>LockSupport</code>的线程都有一个<code>permit</code>，该值默认为0，取值0,1。</p><ul><li><code>unpark()</code>：如果<code>permit</code>当前值为0，将其自增1。</li><li><code>park()</code>：如果当前<code>permit</code>为1，将其自减1并立即返回，如果为0，直接阻塞。</li></ul><p>这两个方法不会有<code>Thread.suspend</code> 和<code>Thread.resume</code>所可能引发的死锁问题，因为<code>permit</code>存在，调用 <code>park </code>的线程和另一个试图将其 <code>unpark </code>的线程之间的竞争将保持活性。</p><p>如果调用线程被中断，那么<code>park</code>将会返回。<code>park</code>方法可能在任何时间<strong>no reason</strong>地返回，因此通常在重新检查返回条件地循环里调用此方法。在某种意义上，<code>park</code>是<strong>busy wait</strong>（忙则等待）的一种优化，减少了自旋对性能的消耗。当时必须与<code>unpark</code>配合使用才会更加高效。</p><p><code>park</code>还提供了支持<code>blocker</code>参数的方法，<code>blocker</code>对象在线程受阻塞时被记录，用于允许监视和诊断工具确定线程被阻塞的原因。提供了<code>getBlocker(Thread t)</code>来访问<code>blocker</code>。</p><p>下面是<code>Java Docs</code>中的示例用法：一个先进先出非重入锁类的基本框架：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FIFOMutex</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Thread&gt; waiters      = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;Thread&gt;();     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;      <span class="hljs-type">boolean</span> <span class="hljs-variable">wasInterrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;      <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();      waiters.add(current);       <span class="hljs-comment">// Block while not first in queue or cannot acquire lock</span>      <span class="hljs-keyword">while</span> (waiters.peek() != current ||             !locked.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;        LockSupport.park(<span class="hljs-built_in">this</span>);        <span class="hljs-keyword">if</span> (Thread.interrupted()) <span class="hljs-comment">// ignore interrupts while waiting</span>          wasInterrupted = <span class="hljs-literal">true</span>;      &#125;      waiters.remove();      <span class="hljs-keyword">if</span> (wasInterrupted)          <span class="hljs-comment">// reassert interrupt status on exit</span>        current.interrupt();    &#125;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;      locked.set(<span class="hljs-literal">false</span>);      LockSupport.unpark(waiters.peek());    &#125;  &#125;&#125;</code></pre></div><hr><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li>UNSAFE：用于进行内存级别操作的工具类。</li><li>parkBlockerOffset：存储<code>Thread.parkBlocker</code>的内存偏移地址，记录线程被谁阻塞的。用于线程监控和分析工具用来定位原因的。可以通过<code>getBlocker</code>获取到阻塞的对象。</li><li>SEED：存储<code>Thread.threadLocalRandomSeed</code>的内存偏移地址</li><li>PROBE：存储<code>Thread.threadLocalRandomProbe</code>的内存偏移地址</li><li>SECONDARY：存储<code>Thread.threadLocalRandomSecondarySeed</code>的内存偏移地址</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> parkBlockerOffset;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SEED;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> PROBE;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SECONDARY;</code></pre></div><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>不允许实例化，只能通过调用静态方法来完成操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">LockSupport</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// Cannot be instantiated.</span></code></pre></div><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>通过反射机制获取<code>Thread</code>类的<code>parkBlocker</code>字段，然后通过<code>UNSAFE.objectFieldOffset</code>获取到<code>parkBlocker</code>在内存的偏移量。</p><blockquote><p>Q：为什么不通过get&#x2F;set方式获取某个字段？</p><p>A：parkBlocker在线程处于阻塞状态下才会被赋值，此时直接调用线程内的方法，线程不会作出回应的。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取unsafe实例</span>            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; tk = Thread.class;            parkBlockerOffset = UNSAFE.objectFieldOffset                (tk.getDeclaredField(<span class="hljs-string">&quot;parkBlocker&quot;</span>));            SEED = UNSAFE.objectFieldOffset                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSeed&quot;</span>));            PROBE = UNSAFE.objectFieldOffset                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomProbe&quot;</span>));            SECONDARY = UNSAFE.objectFieldOffset                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSecondarySeed&quot;</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;    &#125;</code></pre></div><h3 id="setBlocker"><a href="#setBlocker" class="headerlink" title="setBlocker"></a>setBlocker</h3><p>对给定的线程<code>t</code>的<code>parkBlocker</code>赋值。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBlocker</span><span class="hljs-params">(Thread t, Object arg)</span> &#123;        <span class="hljs-comment">// Even though volatile, hotspot doesn&#x27;t need a write barrier here.</span>        UNSAFE.putObject(t, parkBlockerOffset, arg);    &#125;</code></pre></div><h3 id="getBlocker"><a href="#getBlocker" class="headerlink" title="getBlocker"></a>getBlocker</h3><p>返回线程<code>t</code>的<code>parkBlocker</code>对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBlocker</span><span class="hljs-params">(Thread t)</span> &#123;        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();        <span class="hljs-keyword">return</span> UNSAFE.getObjectVolatile(t, parkBlockerOffset);    &#125;</code></pre></div><h3 id="park"><a href="#park" class="headerlink" title="park"></a>park</h3><p>park方法阻塞线程，发生以下情况时，当前线程会继续执行：</p><ul><li>其它线程调用<code>unpark</code>方法唤醒该线程</li><li>其它线程中断当前线程</li><li><strong>no reason</strong>地返回</li></ul><p>该方法有两个重载版本。</p><blockquote><p>Q：为什么调用两次setBlocker方法？</p></blockquote><p>A：调用<code>park</code>方法时，当前线程首先设置好<code>parkBlocker</code>字段，然后调用<code>UNSAFE.park</code>方法，此时，当前线程阻塞，第二个<code>setBlocker</code>无法执行，过了一段时间，该线程的<code>unpark</code>方法被调用，该线程拿到<code>permit</code>后执行，将该线程的<code>blocker</code>字段置空。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();        setBlocker(t, blocker);        UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);        setBlocker(t, <span class="hljs-literal">null</span>);    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span> &#123;        UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);    &#125;</code></pre></div><h3 id="parkNanos"><a href="#parkNanos" class="headerlink" title="parkNanos"></a>parkNanos</h3><p>阻塞当前线程，最长不超过<code>nanos</code>纳秒</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span> &#123;        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>)            UNSAFE.park(<span class="hljs-literal">false</span>, nanos);    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span> &#123;        <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();            setBlocker(t, blocker);            UNSAFE.park(<span class="hljs-literal">false</span>, nanos);            setBlocker(t, <span class="hljs-literal">null</span>);        &#125;    &#125;</code></pre></div><h3 id="parkUntil"><a href="#parkUntil" class="headerlink" title="parkUntil"></a>parkUntil</h3><p>该方法表示在限定的时间内将阻塞。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span> &#123;        UNSAFE.park(<span class="hljs-literal">true</span>, deadline);    &#125;</code></pre></div><h3 id="unpark"><a href="#unpark" class="headerlink" title="unpark"></a>unpark</h3><p>如果给定线程的<code>permit</code>不可用，则将其置为可用，如果该线程阻塞，则将它解除阻塞状态。否则，保证下一次调用<code>park</code>不会受阻塞。如果给定线程尚未启动，则无法保证该操作有任何效果。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;    <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)        UNSAFE.unpark(thread);&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html#park--">Java SE Doc</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java原子类的使用与实现</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/Java%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/Java%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常情况下，在Java中，<code>++i</code>这类自增&#x2F;自减运算符在并发环境中不能保证并发安全。需要通过加锁才能解决并发环境下的原子性问题。Atomic原子类通过CAS方式来解决线程安全问题，CAS是一种无锁算法（乐观锁），乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p><p>Atomic原子类分为以下几类：</p><ul><li>基本类型：AtomicInteger，AtomicLong，AtomicBoolean</li><li>数组类型：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li><li>引用类型：AtomicReference，AtomicStampedRerence，AtomicMarkableReference</li><li>更新字段类：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</li><li>Java8 新增类：DoubleAccumulator，DoubleAdder，LongAccumulator，LongAdder</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="原子基本类型"><a href="#原子基本类型" class="headerlink" title="原子基本类型"></a>原子基本类型</h3><p>使用原子的方式更新基本类型。</p><ul><li>AtomicBoolean: 原子布尔类型。</li><li>AtomicInteger: 原子整型。</li><li>AtomicLong: 原子长整型。</li></ul><p>以下以<code>AtomInteger</code>举例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//以原子方式将给定值与当前值相加，线程安全的i = i + delta</span><span class="hljs-type">int</span> <span class="hljs-title function_">addAndGet</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span>;<span class="hljs-comment">//如果当前值== except，则以原子方式将当前值设置为update，成功返回true</span><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span>;<span class="hljs-comment">//以原子方式将当前值减1，相当于线程安全的i--</span><span class="hljs-type">int</span> <span class="hljs-title function_">decrementAndGet</span><span class="hljs-params">()</span>;<span class="hljs-comment">//以原子方式将当前值加1，相当于线程安全的i++</span><span class="hljs-type">int</span> <span class="hljs-title function_">incrementAndGet</span><span class="hljs-params">()</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<span class="hljs-comment">/**</span><span class="hljs-comment">     * Atomically increments by one the current value.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the updated value</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">incrementAndGet</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Atomically decrements by one the current value.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the updated value</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">decrementAndGet</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, -<span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;    &#125;</code></pre></div><p>从上面代码可以看出，AtomicInteger底层使用<code>volatile</code>关键字和CAS来保证线程安全。其中：</p><ul><li>volatile保证线程的可见性，让每次读取的变量都是最新值</li><li>CAS保证原子性</li></ul><h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>以原子方式更新数组中的某个元素。</p><ul><li>AtomicIntegerArray: 原子更新整型数组里的元素。</li><li>AtomicLongArray: 原子更新长整型数组里的元素。</li><li>AtomicReferenceArray: 原子更新引用类型数组里的元素。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;);        System.out.println(array);        System.out.println(array.getAndAdd(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));        System.out.println(array);    &#125;</code></pre></div><h3 id="原子引用类型"><a href="#原子引用类型" class="headerlink" title="原子引用类型"></a>原子引用类型</h3><ul><li>AtomicReference：原子更新引用类型。</li><li>AtomicStampedReference： 原子更新引用类型,内部使用Pair来存储元素值及其版本号。</li><li>AtomicMarkableReferce：原子更新带有标记位的引用类型，标记是否被改过。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建两个Person对象，它们的id分别是101和102。</span><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">101</span>);<span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">102</span>);<span class="hljs-comment">// 新建AtomicReference对象，初始化它的值为p1对象</span><span class="hljs-type">AtomicReference</span> <span class="hljs-variable">ar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>(p1);<span class="hljs-comment">// 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。</span>ar.compareAndSet(p1, p2);<span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> (Person)ar.get();System.out.println(<span class="hljs-string">&quot;p3 is &quot;</span>+p3);System.out.println(<span class="hljs-string">&quot;p3.equals(p1)=&quot;</span>+p3.equals(p1));<span class="hljs-comment">//output</span>p3 is id:<span class="hljs-number">102</span>p3.equals(p1)=<span class="hljs-literal">false</span></code></pre></div><h3 id="原子字段类"><a href="#原子字段类" class="headerlink" title="原子字段类"></a>原子字段类</h3><ul><li>AtomicIntegerFieldUpdater：原子更新Integer的字段的更新器。 </li><li>AtomicLongFieldUpdater：原子更新Long字段的更新器。 </li><li>AtomicStampedFieldUpdater： 原子更新带有版本号的引用类型。</li><li>AtomicReferenceFieldUpdater： 原子更新引用的更新器。</li></ul><p>这四个类通过反射更新字段的值，使用字段类如下：</p><ol><li>使用静态方法<code>newUpdater()</code>创建一个更新器，并需要设置想要更新的类和属性。</li><li>更新类的字段必须使用public volatile修饰。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;Person&gt; cls;          <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        AtomicIntegerFieldUpdater&lt;Person&gt; mAtoLong = AtomicIntegerFieldUpdater.newUpdater(Person.class, <span class="hljs-string">&quot;id&quot;</span>);        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1000</span>);        mAtoLong.compareAndSet(person, <span class="hljs-number">1000</span>, <span class="hljs-number">1001</span>);        System.out.println(<span class="hljs-string">&quot;id=&quot;</span>+person.getId());     &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;&#125;</code></pre></div><p>使用该类有如下约束：</p><ul><li>字段必须由volatile修饰</li><li>字段的访问修饰符能让调用方访问到。</li><li>只能是实例变量，不能加static</li><li>对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int&#x2F;long类型的字段，不能修改其包装类型(Integer&#x2F;Long)。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。</li></ul><h2 id="CAS理论"><a href="#CAS理论" class="headerlink" title="CAS理论"></a>CAS理论</h2><p>CAS（Compare-And-Swap）：是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值。一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则返回false。CAS的基本思路就是循环进行CAS操作直到成功为止。</p><p>CAS在X86架构下汇编指令是<code>lock cmpxchg</code>。需要和volatile配合使用，保证拿到的变量是最新值。</p><p>虽然乐观锁通常情况下比悲观锁性能更优，但是还存在以下一些问题：</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS自旋需要在操作值得时候检查是否发生变化，但是如果一个值是A，变成B，然后又变成A，CAS检查会发现没有变化。<strong>AtomicStampedReference</strong>来解决ABA问题：这个类的<code>compareAndSet</code>方法作用是首先检查当前引用是否等于预期引用，并且当前<code>stamp</code>是否等于预期<code>stamp</code>，这里的<code>stamp</code>类似于版本号功能。如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h3><p>CAS自旋如果长时间不成功，会给CPU带来较大得执行开销。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>对多个共享变量操作时，CAS无法保证多个操作的原子性，但是可以使用锁来解决。<br>当然可以将多个共享变量合并成一个共享变量来操作，比如<code>i = 2;j = a</code>，合并为<code>ij = 2a</code>，然后CAS操作<code>ij</code>，从Java 1.5开始，JDK提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p><h2 id="Unsafe-CAS解析"><a href="#Unsafe-CAS解析" class="headerlink" title="Unsafe-CAS解析"></a>Unsafe-CAS解析</h2><p>Java中原子类中CAS操作通过调用<code>Unsafe</code>去实现，<code>Unsafe</code>是位于<code>sun.misc</code>下的一个类，提供的功能主要如下：</p><ul><li>数组相关<ul><li>返回数组元素内存大小</li><li>返回数组首元素偏移大小</li></ul></li><li>内存屏障<ul><li>禁止load, store重排序</li></ul></li><li>系统相关<ul><li>返回内存页的大小</li><li>返回系统指针大小</li></ul></li><li>线程调度<ul><li>线程挂起, 恢复</li><li>获取，释放锁</li></ul></li><li>内存操作<ul><li>分配、拷贝、扩充、释放堆外内存</li></ul></li><li>CAS</li><li>Class<ul><li>动态创建类</li><li>获取field的内存地址偏移量</li><li>检测、确保类初始化</li></ul></li><li>对象操作<ul><li>获取对象成员属性的偏移量</li><li>非常规对象实例化</li><li>存储、获取指定偏移地址的变量值。</li></ul></li></ul><p>下文对<code>Unsafe</code>的CAS做简要分析。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndSetInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;        <span class="hljs-type">int</span> var5;        <span class="hljs-keyword">do</span> &#123;            var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);        &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var4));        <span class="hljs-keyword">return</span> var5;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getAndSetLong</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">long</span> var4)</span> &#123;        <span class="hljs-type">long</span> var6;        <span class="hljs-keyword">do</span> &#123;            var6 = <span class="hljs-built_in">this</span>.getLongVolatile(var1, var2);        &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapLong(var1, var2, var6, var4));        <span class="hljs-keyword">return</span> var6;    &#125;</code></pre></div><p><code>Unsafe</code>调用<code>compareAndSwapInt</code>进行CAS操作，使用while操作进行自旋。这是一个<code>native</code>方法，实现位于<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/prims/unsafe.cpp">unsafe.cpp</a>，<code>cmpxchg</code>在不同平台上有不同的实现。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">UNSAFE_ENTRY</span>(jboolean, <span class="hljs-built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  <span class="hljs-built_in">UnsafeWrapper</span>(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);  oop p = JNIHandles::<span class="hljs-built_in">resolve</span>(obj);  jint* addr = (jint *) <span class="hljs-built_in">index_oop_from_field_offset_long</span>(p, offset);  <span class="hljs-keyword">return</span> (jint)(Atomic::<span class="hljs-built_in">cmpxchg</span>(x, addr, e)) == e;UNSAFE_END</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字剖析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>The Java programming language allows threads to access shared variables (§17.1).As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.The Java programming language provides a second mechanism, volatile fields,that is more convenient than locking for some purposes.A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable (§17.4).</p></blockquote><p>上述定义摘自《The Java Language Specification Java SE 8 Edition》，从语言规范中给出的定义可以总结出：</p><ul><li>变量被<code>volatile</code>修饰后，JMM能确保所有的线程看到的这个变量的值是一致的。（可见性）</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="防止重排序"><a href="#防止重排序" class="headerlink" title="防止重排序"></a>防止重排序</h3><p>在单例模式中，并发环境通常使用<code>Double Check Lock</code>来解决问题，案例如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == singleton) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == singleton) &#123;                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singleton;    &#125;&#125;</code></pre></div><p>上述案例在<code>singleton = new Singleton();</code>这句代码，可以分解为三个步骤：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给引用</li></ol><p>但是，由于编译器或者处理器为了提高程序性能，会对指令进行重排序，会将上述三个步骤按以下步骤执行：</p><ol><li>分配内存空间</li><li>将内存空间的地址赋值给引用</li><li>初始化对象</li></ol><p>如果按照这个流程，多线程环境下。如果线程A通过单例模式获取实例，此时获取的对象并未完成初始化，线程B访问该实例，会存在空指针异常。</p><p>通过对<code>singleton</code>字段添加<code>volatile</code>关键字可以解决这个问题。</p><h3 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h3><p>可见性问题主要指一个线程修改了共享变量值，另一个线程看不到修改过的值，该问题主要原因是JMM要求每一个线程都拥有自己的工作内存（相当于高速缓存）。<code>volatile</code>关键字可以使得线程禁用该高速缓存。案例如下：变量b作为条件变量，b为<code>true</code>则进入死循环，在线程执行<code>start()</code>后，将b改为false并不能结束死循环，因为线程1一直从高速缓存中读取该值。通过添加<code>volatile</code>可以解决这个问题。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo03</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;start&quot;</span>);        <span class="hljs-keyword">while</span> (b) &#123;        &#125;        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">VolatileDemo03</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileDemo03</span>();        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                t.m();            &#125;        &#125;).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        t.b = <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><h3 id="无法保证原子性"><a href="#无法保证原子性" class="headerlink" title="无法保证原子性"></a>无法保证原子性</h3><h4 id="i-问题"><a href="#i-问题" class="headerlink" title="i++问题"></a>i++问题</h4><p><code>i++</code>在指令层面主要分为三步：</p><ul><li>load i</li><li>increment</li><li>store i</li></ul><p>volatile无法保证三个操作具有原子性。</p><p>假设线程1将i的值<code>load</code>，存入工作内存中，再放到寄存器A中，然后执行<code>increment</code>自增1，此时线程2执行同样的操作，然后<code>store</code>回写主内存，此时线程1的工作内存的i缓存失效，重新从主内存中读取该值，读到11，接着线程1执行<code>store</code>将寄存器A的值11回写主内存，这样就出现了线程安全问题。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo04</span> &#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addI</span><span class="hljs-params">()</span> &#123;        i++;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-keyword">final</span> <span class="hljs-type">VolatileDemo04</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileDemo04</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">10</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    test.addI();                &#125;            &#125;);            thread.start();        &#125;        Thread.sleep(<span class="hljs-number">10000</span>);        System.out.println(test.i);    &#125;&#125;</code></pre></div><h4 id="long-double变量"><a href="#long-double变量" class="headerlink" title="long,double变量"></a>long,double变量</h4><p>32位JVM将<code>long</code>和<code>double</code>变量的操作分为高32位和低32位两部分，普通的long&#x2F;double的r&#x2F;w操作可能不是原子性的，使用volatile可以保证单次r&#x2F;w操作是原子性的。</p><blockquote><p>For the purposes of the Java programming language memory model, a single write to a non-volatile <code>long</code> or <code>double</code> value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.</p><p>Writes and reads of volatile <code>long</code> and <code>double</code> values are always atomic.</p><p>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</p><p>Some implementations may find it convenient to divide a single write action on a 64-bit <code>long</code> or <code>double</code> value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to <code>long</code> and <code>double</code> values atomically or in two parts.</p><p>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as <code>volatile</code> or synchronize their programs correctly to avoid possible complications.</p></blockquote><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>volatile的可见性是基于内存屏障（Memory Barrier）实现的。</strong></p><ul><li><p>内存屏障：一组CPU指令，用于实现对内存操作的顺序限制。</p><ul><li>对volatile变量写指令后添加写屏障</li><li>对volatile变量读指令前添加读屏障</li></ul></li></ul><p>前置知识：</p><ul><li>缓存行（Cache Line）：CPU Cache的最小单位，通常大小为64字节（取决于CPU），缓存行可能会导致伪共享问题。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        stop = <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><p>通过添加VM options打印程序汇编代码：</p><div class="code-wrapper"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UnlockDiagnosticVMOptions</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+LogCompilation</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintAssembly</span> -<span class="hljs-title class_">Xcomp</span> -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:CompileCommand=dontinline</span>,*<span class="hljs-title class_">VolatileDemo05</span>.main -<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:CompileCommand=compileonly</span>,*<span class="hljs-title class_">VolatileDemo05</span>.main</code></pre></div><p>如果提示以下内容，需要将<code>hedis-amd64.dll</code>放在<code>jre/bin/server</code>目录下。</p><div class="code-wrapper"><pre><code class="hljs pgsql">Java HotSpot(TM) <span class="hljs-number">64</span>-<span class="hljs-type">Bit</span> <span class="hljs-keyword">Server</span> VM <span class="hljs-built_in">warning</span>: PrintAssembly <span class="hljs-keyword">is</span> enabled; turning <span class="hljs-keyword">on</span> DebugNonSafepoints <span class="hljs-keyword">to</span> gain additional output</code></pre></div><p>volatile变量操作部分汇编代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">0x0000000003941c9b</span>: movabs $<span class="hljs-number">0x76baa20b0</span>,%rsi  ;   &#123;oop(a <span class="hljs-string">&#x27;java/lang/Class&#x27;</span> = <span class="hljs-string">&#x27;wang/l1n/concurrent/volatiledemo/VolatileDemo05&#x27;</span>)&#125;<span class="hljs-number">0x0000000003941ca5</span>: mov    $<span class="hljs-number">0x1</span>,%edi<span class="hljs-number">0x0000000003941caa</span>: mov    %dil,<span class="hljs-number">0x68</span>(%rsi)<span class="hljs-number">0x0000000003941cae</span>: lock addl $<span class="hljs-number">0x0</span>,(%rsp)     ;*putstatic stop</code></pre></div><p>可以看到在<code>mov %dil,0x68(%rsi)</code>写操作之后有<code>lock addl $0x0,(%rsp)</code>，lock前缀指令在处理器发生了两件事：</p><ol><li>将当前处理器缓存行的数据回写到系统内存。</li><li>写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ol><p>为了提高处理速度，CPU不直接与内存进行通信，而是先将数据缓存到Cache（L1、L2）中，回写内存的时机由系统决定。</p><p>那么如果对volatile变量进行写操作，则不会经过Cache，而是直接将缓存行回写到主内存。</p><p>数据写回内存是一个并发操作，如果另一个CPU也要写回内存，就会出现问题，所以需要锁定。cache是486机器才引入的技术，所以在486以后P6处理器以前，是锁总线；在P6以后，如果访问的内存区域已经缓存在处理器内部，则不会声言Lock#信号，而是锁缓存+缓存一致性协议（<strong>cache coherency mechanism</strong>）来保证指令的原子性。此操作称为<strong>缓存锁定</strong>。</p><p>IA-32处理器和Intel 64处理器使用<strong>缓存一致性协议（MESI）</strong>维护内部缓存和其他处理器缓存的一致性。</p><p>MESI的核心思想：CPU写数据时，如果发现变量是共享变量（其它CPU也存在该变量的副本），会通知其它CPU将该变量的缓存行设置为无效状态，因此其它CPU读该变量时，会从内存重新读取。</p><blockquote><p>Beginning with the P6 family processors, when the LOCK prefix is prefixed to an instruction and the memory area being accessed is cached internally in the processor, the LOCK# signal is generally not asserted. Instead, only the processor’s cache is locked. Here, the processor’s cache coherency mechanism ensures that the operation is carried out atomically with regards to memory. </p></blockquote><p>volatile和MESI的区别：</p><ul><li>缓存一致性：硬件层面的问题，指的是多核CPU中的多个Cache缓存的一致性问题，MESI解决的是这个问题。</li><li>内存一致性：多线程程序中访问内存中变量的一致性，volatile解决这个问题。</li></ul><p>通俗来说，<strong>没有一点关系</strong>。</p><hr><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="volatile的happens-before规则"><a href="#volatile的happens-before规则" class="headerlink" title="volatile的happens-before规则"></a>volatile的happens-before规则</h4><p><code>happens-before</code>规则中有一条关于volatile变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p><h4 id="volatile禁止重排序"><a href="#volatile禁止重排序" class="headerlink" title="volatile禁止重排序"></a>volatile禁止重排序</h4><p>JMM使用内存屏障来解决，下表是JMM针对编译器制定的重排序规则表：</p><table><thead><tr><th align="center">能否重排序</th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">第一个操作</td><td align="center">普通读&#x2F;写</td><td align="center">volatile读</td><td align="center">volatile写</td></tr><tr><td align="center">普通读&#x2F;写</td><td align="center"></td><td align="center"></td><td align="center">NO</td></tr><tr><td align="center">volatile读</td><td align="center">NO</td><td align="center">NO</td><td align="center">NO</td></tr><tr><td align="center">volatile写</td><td align="center"></td><td align="center">NO</td><td align="center">NO</td></tr></tbody></table><p>为了能实现该表中制定的顺序，编译器再生成字节码文件时，会插入内存屏障来禁止重排序。</p><hr><table><thead><tr><th align="center">内存屏障指令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">StoreStore</td><td align="center">禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td align="center">StoreLoad</td><td align="center">防止上面的 volatile 写与下面可能有的 volatile 读&#x2F;写重排序。</td></tr><tr><td align="center">LoadLoad</td><td align="center">禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td align="center">LoadStore</td><td align="center">禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java并发编程的艺术》</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized关键字剖析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在使用<code>Synchronized</code>关键字需要把握以下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待。</li><li>每一个实例都有自己的一个锁资源，存放于对象头中（2bit表示锁信息）</li></ul><h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><ul><li>同步代码块锁（可以指定锁定对象）</li><li>方法锁（默认锁定对象为this（当前实例对象））</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;   <span class="hljs-keyword">synchronized</span> (obj)&#123;   System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;   System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;</code></pre></div><h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><p><code>synchronized</code>修饰静态方法或指定锁对象为Class对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//do something</span>&#125;<span class="hljs-keyword">synchronized</span>(ObjectDemo.class)&#123;    &#125;</code></pre></div><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>在操作系统进程管理中，对进程并发问题主要提供了两种解决方法：信号量和管程。在Java 1.5之前，提供的唯一并发原语就是管程，Java 1.5之后提供的JUC包也是以管程技术为基础的。</p><h3 id="管程定义"><a href="#管程定义" class="headerlink" title="管程定义"></a>管程定义</h3><blockquote><p>一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。</p></blockquote><p>通俗而言：管程（Monitor）是管理共享变量以及对共享变量的操作过程，让他们支持并发。在OS领域一般称为管程，Java中可以称为<strong>监视器</strong>（monitor）。</p><h3 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h3><p>MESA模型是当今广泛使用的MESA模型，Java管程的实现参考的也是MESA模型。并对其进行了精简。Java内置的管程只有一个条件变量。</p><p>如下图所示：管程X将共享变量queue、入队操作于出队操作封装起来。如果线程A和线程B访问共享变量queue，只能通过调用管程提供的<code>enq()</code>和<code>deq()</code>来实现。两个方法保证互斥性，，只允许一个线程进入管程并操作。该模型能实现并发编程中的互斥问题。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/concurrent/sync/MESA.jpg" alt="管程"></p><p>下图为MESA管程模型示意图，框中即是封装的管程，所有线程通过入口等待队列进入管程。管程还引入了条件变量的概念，<strong>每一个条件变量都对应一个等待队列</strong>。管程的同步主要通过<code>Condition</code>（条件变量）实现。<code>Condition</code>可以执行<code>wait()</code>和<code>signal()</code>。</p><p>假设线程T1执行出队操作，同时有个前提条件：队列不为空，这是条件变量。如果T1进入管程发现队列为空，则会在条件变量的等待队列进行等待。调用<code>wait()</code>实现。此刻允许其它线程进入管程。</p><p>此时线程T2执行入队操作，入队成功后，队列不空条件对于T1已经满足，T2调用<code>notify()</code>来通知T1。通知他条件已满足。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/concurrent/sync/MESA1.jpg" alt="MESA管程模型"></p><h3 id="两个操作"><a href="#两个操作" class="headerlink" title="两个操作"></a>两个操作</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>MESA模型提供了一个特有的编程范式，通过循环检查条件调用<code>wait()</code>。管程模型中：条件满足后，如何通知相关线程。管程要求同一时刻只能有一个线程能执行，那么上述问题中T1，T2谁执行呢？</p><p>在MESA中，T2通过<code>notify()</code>通知完后，继续执行，T1从条件变量的等待队列进入入口等待队列中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(条件不满足) &#123;wait();&#125;</code></pre></div><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p>尽量使用<code>notifyAll()</code>，如果满足以下三个条件则可以使用<code>notify()</code>：</p><ul><li>所有等待线程拥有相同的等待条件</li><li>所有等待线程被唤醒后，执行相同的操作</li><li>只需要唤醒一个线程</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="JVM字节码层面"><a href="#JVM字节码层面" class="headerlink" title="JVM字节码层面"></a>JVM字节码层面</h3><p>从JVM层面来看，主要通过两个字节码指令实现，<code>monitorenter</code>与<code>monitorexit</code>。这两个字节码需要指定一个对象引用作为参数。这个对象引用就是monitor object。它就是synchronized传入的对象实例，该对象充当着维护了mutex以及顶层父类<code>Object</code>提供的<code>wait/notify</code>机制。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">wang</span>.l1n.volatile1.Demo02 &#123;  <span class="hljs-keyword">public</span> wang.l1n.volatile1.Demo02();    Code:       <span class="hljs-number">0</span>: aload_0       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;    Code:       <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field object:Ljava/lang/Object;</span>       <span class="hljs-number">3</span>: dup       <span class="hljs-number">4</span>: astore_1       <span class="hljs-number">5</span>: monitorenter       <span class="hljs-number">6</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>       <span class="hljs-number">9</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String hello world</span>      <span class="hljs-number">11</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>      <span class="hljs-number">14</span>: aload_1      <span class="hljs-number">15</span>: monitorexit      <span class="hljs-number">16</span>: <span class="hljs-keyword">goto</span>          <span class="hljs-number">24</span>      <span class="hljs-number">19</span>: astore_2      <span class="hljs-number">20</span>: aload_1      <span class="hljs-number">21</span>: monitorexit      <span class="hljs-number">22</span>: aload_2      <span class="hljs-number">23</span>: athrow      <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span>    Exception table:       from    to  target type           <span class="hljs-number">6</span>    <span class="hljs-number">16</span>    <span class="hljs-number">19</span>   any          <span class="hljs-number">19</span>    <span class="hljs-number">22</span>    <span class="hljs-number">19</span>   any  <span class="hljs-keyword">static</span> &#123;&#125;;    Code:       <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// class java/lang/Object</span>       <span class="hljs-number">3</span>: dup       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>       <span class="hljs-number">7</span>: putstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field object:Ljava/lang/Object;</span>      <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>&#125;</code></pre></div><h3 id="JVM实现层面"><a href="#JVM实现层面" class="headerlink" title="JVM实现层面"></a>JVM实现层面</h3><p>每个Java对象都关联一个Monitor对象，如果使用<code>synchronized</code>给对象上锁，该对象的<code>MarkWord</code>中就被设置指向Monitor对象的指针。</p><p>Java对象在堆内存中存储，其中<code>Mark Word</code>中<code>2bit</code>存储了锁标识，Java的顶层父类<code>Object</code>定义了<code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>方法，这些方法的具体实现，依赖于<code>ObjectMonitor</code>模式，这是JVM内部基于C++实现的一套机制，基本原理如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/concurrent/sync/object%20monitor.png" alt="ObjectMonitor"></p><ul><li>Entry Set：从未获得过Monitor得线程，排队竞争Monitor</li><li>owner：同一时刻，只有一个线程持有Monitor</li><li>Wait Set：曾经持有Monitor的线程，通过<code>Object.wait()</code>主动进入wait set</li></ul><p>当一个线程需要获取Object锁时，会判断当前owner是否被持有，未持有则此线程会成为锁的owner，否则进入<code>wait Set</code>中进行等待。</p><p>该线程可以通过调用wait方法将锁释放，进入<code>wait Set</code>中进行等待，其他线程此刻可以获得锁，从而使得之前不成立的条件变量（Condition）成立，这样之前阻塞的线程就可以重新进入<code>Entry Set</code>取竞争锁。</p><ul><li>持有Monitor的线程t1检到条件变量c不符合，则执行<code>wait()</code>，使自己：<ul><li>主动释放Monitor资源</li><li>进入Wait Set，挂起自己</li></ul></li><li>线程t2发现t1符合条件变量c之后，执行<code>notify()</code>，使得：<ul><li>s继续正常执行，直到执行完毕释放Monitor或者主动<code>wait()</code></li><li>s释放Monitor后，Wait Set中的t1重新竞争获取Monitor</li></ul></li></ul><p>HotSpot VM通过<a href="https://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/objectMonitor.hpp">ObjectMonitor</a>实现该机制，该类包含以下关键字段：</p><ul><li>_EntryList：对应 entry set</li><li>_WaitSet：对应 wait set</li><li>_owner：指向持有 Monitor 线程的指针</li><li>_recursions：重入次数，获得同一个Monitor 加1，释放同一个Monitor减1，为0，说明释放了Monitor。</li><li>_count：近似等于 _EntryList + _WaitSet</li></ul><h3 id="互斥锁存储结构"><a href="#互斥锁存储结构" class="headerlink" title="互斥锁存储结构"></a>互斥锁存储结构</h3><p><code>MarkWord</code>结构如下：</p><div class="code-wrapper"><pre><code class="hljs gherkin">|<span class="hljs-string">--------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>||<span class="hljs-string"> Mark Word (64 bits) </span>|<span class="hljs-string"> State </span>||<span class="hljs-string">--------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>||<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Normal </span>||<span class="hljs-string">--------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>||<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Biased </span>||<span class="hljs-string">--------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>||<span class="hljs-string"> ptr_to_lock_record:62 </span>|<span class="hljs-string"> 00 </span>|<span class="hljs-string"> Lightweight Locked </span>||<span class="hljs-string">--------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>||<span class="hljs-string"> ptr_to_heavyweight_monitor:62 </span>|<span class="hljs-string"> 10 </span>|<span class="hljs-string"> Heavyweight Locked </span>||<span class="hljs-string">--------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>||<span class="hljs-string"> </span>|<span class="hljs-string"> 11 </span>|<span class="hljs-string"> Marked for GC </span>||<span class="hljs-string">--------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|</code></pre></div><h2 id="JVM中锁的优化"><a href="#JVM中锁的优化" class="headerlink" title="JVM中锁的优化"></a>JVM中锁的优化</h2><p>在JDK 1.6之前，synchronized的实现会调用<code>Object</code>的enter和exit，这种锁被称为重量级锁，需要从用户态切换到内核态执行，十分消耗性能，在JDK1.6之后，对锁的实现引入了大量的优化，比如锁粗化（Lock Coarsening），锁消除（Lock Elimination），轻量级锁（Lightweight Locking），偏向锁（Biased Locking），适应性自旋（Adaptive Spinning）等优化技术来减少锁的性能开销。</p><p>JDK 1.6中的Synchronized同步锁，一共有四种状态：无锁，偏向锁，轻量级锁，重量级锁，数据存储在<code>Mark Word</code>中。</p><p>它会随着竞争情况逐渐升级，但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁没有对资源进行锁定，所有线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点是修改操作在循环内进行，线程会不断尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。CAS原理就是无锁的实现。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问（<strong>重入锁机制</strong>），那么该线程就会自动获得锁，降低获得锁的代价。</p><p>当一个线程通过同步代码块获得锁的时候，会在<code>Mark Word</code>中存储锁偏向的线程ID。在线程进入或退出同步代码块时不再通过CAS操作来加锁解锁，而是检查<code>Mark Word</code>中是否存储着指向当前线程的偏向锁。</p><p>偏向锁只有遇到其他线程竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动释放偏向锁。</p><p>偏向锁在JDK 6以后是默认启用的，可以通过<code>-XX:UseBiasedLocking=false</code>关闭，关闭之后，程序默认进入轻量级锁状态。</p><p>撤销偏向锁的时机：</p><ul><li><p>调用对象的hashCode</p></li><li><p>其他线程使用对象锁</p></li><li><p>调用wait&#x2F;notify</p></li><li><p><strong>批量重偏向</strong>：对象被多个线程访问，但是未造成竞争，当对象偏向某线程后，<strong>在规定时间内，若另一个线程也尝试获取资源，偏向锁升级为轻量级锁，并且这个次数达到阈值20次时，这个对象就不会升级为轻量级锁，而直接改变偏向线程。</strong></p></li><li><p><strong>批量重撤销</strong>：当上述次数达到阈值40次，JVM认为这个对象继续使用偏向锁会影响性能，取消偏向锁机制。</p></li></ul><p>偏向锁的几个参数：</p><div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-punctuation">-</span>XX<span class="hljs-punctuation">:</span>BiasedLockingBulkRebiasThreshold <span class="hljs-punctuation">=</span> <span class="hljs-number">20</span>   <span class="hljs-comment">// 默认偏向锁批量重偏向阈值</span><span class="hljs-punctuation">-</span>XX<span class="hljs-punctuation">:</span>BiasedLockingBulkRevokeThreshold <span class="hljs-punctuation">=</span> <span class="hljs-number">40</span>   <span class="hljs-comment">// 默认偏向锁批量撤销阈值</span><span class="hljs-punctuation">-</span>XX<span class="hljs-punctuation">:</span>BiasedLockingDecayTime<span class="hljs-comment">//重偏向的阈值事件</span><span class="hljs-punctuation">-</span>XX<span class="hljs-punctuation">:</span><span class="hljs-punctuation">+</span>UseBiasedLocking <span class="hljs-comment">// 使用偏向锁，jdk6之后默认开启</span><span class="hljs-punctuation">-</span>XX<span class="hljs-punctuation">:</span>BiasedLockingStartupDelay <span class="hljs-punctuation">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 延迟偏向时间, 默认不为0，jvm启动多少ms以后开启偏向锁机制（此处设为0，不延迟）</span></code></pre></div><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>使用场景：多线程访问时间错开（没有竞争），使用轻量级锁。</p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程通过自旋的方式尝试获取锁，不会阻塞。从而提高性能。</p><p>轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来地线程开销。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>若当前只有一个等待线程，则该线程通过自旋进行等待，但是当自旋超过一定次数，或是一个线程在持有锁，一个在自旋，又有第三个线程访问时，轻量级锁升级为重量级锁。</p><table><thead><tr><th align="center">锁</th><th align="center">优点</th><th align="center">缺点</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">偏向锁</td><td align="center">加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td align="center">适用于只有一个线程访问同步快的场景</td></tr><tr><td align="center">轻量级锁</td><td align="center">竞争的线程不会阻塞，提高了响应速度</td><td align="center">如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td><td align="center">追求响应时间，同步快执行速度非常快</td></tr><tr><td align="center">重量级锁</td><td align="center">线程竞争不使用自旋，不会消耗CPU</td><td align="center">线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td align="center">追求吞吐量，同步快执行速度较长</td></tr></tbody></table><h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><p>​在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而实采用循环的方式去获取锁，这样做的好处是减少线程上下文切换的消耗。</p><p>但是自旋锁本身是有缺点的，它不能代替阻塞，自旋虽然避免了上下文切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待的效果很好，但是如果锁占用时间国产，自旋只会白白浪费处理器资源。所以自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，通过**-XX:PreBlockSpin**修改）没有成功获得锁，就挂起线程，停止自旋。</p><p>自旋锁的实现原理是CAS算法。自旋锁在JDK 1.4.2引入，使用**-XX:UseSpinning**开启，JDK 6开始默认开启，并且引入了自适应的自旋锁。</p><p>自适应意味着自旋的时间不再固定，而实由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么JVM会认为这次自选也是很有可能再次成功，进而它将自旋等待持续更长的时间。如果某个锁自旋很少成功获得，那么就会直接省略掉自旋过程，直接阻塞线程。</p><p>在自旋锁中，有三种常见的锁形式：TicketLock、CLHlock、MCSlock</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>​锁销除指的是虚拟机即时编译器在运行时，对一些代码上要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁销除的主要判定依据是来源于逃逸分析的数据支持。（JVM会判断一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那么JVM把它们当成线程独有的数据。）</p><p>例如下述代码，在JDK1.5之后，Javac编译器会对该段代转换成<code>StringBuilder</code>对象的<code>append</code>操作进行字符串连接。<code>StringBuilder</code>非线程安全，但是JVM判断该段代码不会逃逸，所以会进行锁销除操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">demo</span><span class="hljs-params">(String s1, String s2)</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> s1 + s2;    <span class="hljs-keyword">return</span> s;&#125;</code></pre></div><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>当连续的一系列操作会对一个对象反复加锁解锁，会消耗大量CPU资源，JVM会检测到这种情况，并将加锁粗化到整个方法。例如下述代码。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">demo</span><span class="hljs-params">(String s1, String s2)</span> &#123;    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();    sb.append(s1);    sb.append(s2);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre></div><h3 id="Synchronized与Lock"><a href="#Synchronized与Lock" class="headerlink" title="Synchronized与Lock"></a>Synchronized与Lock</h3><p>Lock是JUC的顶层接口，用户能通过其实现互斥同步功能。Lock在实现上并未使用到synchronized，而是利用了volatile的可见性。</p><p>Lock与synchronized相比，提供了更加方便的API。ReentrantLock是Lock的最常用的实现类，提供了以下功能：</p><ul><li>等待可中断：持有锁的线程长时间不释放锁，等待的线程可以选择放弃等待。</li><li>公平锁：根据申请锁的顺序依次获取锁，会使得性能下降。synchronized为非公平锁，ReentrantLock默认为非公平锁，但是可以指定为公平锁。</li><li>锁可以绑定多个Condition。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8特性</title>
    <link href="/2020/Java%E5%9F%BA%E7%A1%80/java8-note/"/>
    <url>/2020/Java%E5%9F%BA%E7%A1%80/java8-note/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="函数式编程简介"><a href="#函数式编程简介" class="headerlink" title="函数式编程简介"></a>函数式编程简介</h3><blockquote><p>函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。（摘自Wikipedia）</p></blockquote><p>面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。</p><p>核心思想: 使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</p><h3 id="Lambda语法格式"><a href="#Lambda语法格式" class="headerlink" title="Lambda语法格式"></a>Lambda语法格式</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//无参数，无返回值</span>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> ()-&gt; System.out.println(<span class="hljs-string">&quot;Hello world&quot;</span>);      runnable.run();      <span class="hljs-comment">//有一个参数，无返回值</span>      Consumer&lt;String&gt; consumer = (e) -&gt; System.out.println(e);      consumer.accept(<span class="hljs-string">&quot;Hello world&quot;</span>);      <span class="hljs-comment">//两个参数，多条语句</span>      Comparator&lt;Integer&gt; comparator = (a, b) -&gt; &#123;          System.out.println(<span class="hljs-string">&quot;Hello world&quot;</span>);          <span class="hljs-keyword">return</span> Integer.compare(a, b);      &#125;;      <span class="hljs-comment">//lambda中只有一条语句，可简写</span>      Comparator&lt;Integer&gt; comparator1 = (a, b) -&gt; Integer.compare(a, b);      <span class="hljs-comment">//省略参数类型</span>      Comparator&lt;Integer&gt; comparator2 = (Integer a, Integer b) -&gt; Integer.compare(a, b);      Comparator&lt;Integer&gt; comparator3 = (a, b) -&gt; Integer.compare(a, b);</code></pre></div><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>接口中只有一个抽象方法的接口（不包括默认方法），称为函数式接口。使用<code>@FunctionInterface</code>注解修饰，用来检查是否满足条件。</p><table><thead><tr><th align="center">函数式接口</th><th align="center">参数类型</th><th align="center">返回类型</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">Cunsumer<T></td><td align="center">T</td><td align="center">void</td><td align="center">对类型为T的对象操作<code>void accept(T t)</code></td></tr><tr><td align="center">Supplier<T></td><td align="center">无</td><td align="center">T</td><td align="center">返回类型为T的对象<code>T get()</code></td></tr><tr><td align="center">Function&lt;T, R&gt;</td><td align="center">T</td><td align="center">R</td><td align="center">对类型T的对象操作，返回R类型对象<code>R apply(T t)</code></td></tr><tr><td align="center">Predicate<T></td><td align="center">T</td><td align="center">boolean</td><td align="center">确定类型T的对象，是否满足<code>boolean test(T t)</code></td></tr></tbody></table><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。</p></blockquote><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h4><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">filter(Predicate p)</td><td align="center">接收Lambda，从流中排除某些元素</td></tr><tr><td align="center">distinct()</td><td align="center">筛选，通过<code>hashCode()</code>和<code>equals</code>去除重复元素</td></tr><tr><td align="center">limit(long maxSize)</td><td align="center">使得集合元素不超过给定数量</td></tr><tr><td align="center">skip(long n)</td><td align="center">跳过元素，返回一个去掉了前n个元素的流，不足n个，则返回空流</td></tr></tbody></table><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">sorted()</td><td align="center">产生一个新流，其中按照自然顺序排序</td></tr><tr><td align="center">sorted(Comparator&lt;? super T&gt; comparator)</td><td align="center">按照comparator排序</td></tr></tbody></table><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">map(Function mapper)</td><td align="center">接收函数，该函数应用到每个元素，并将其映射为一个新的元素</td></tr><tr><td align="center">mapToDouble(ToDoubleFunction mapper);</td><td align="center">接收函数，该函数应用到每个元素，并将其映射为一个新的DoubleStream</td></tr><tr><td align="center">mapToLong(ToLongFunction mapper)</td><td align="center">接收函数，该函数应用到每个元素，并将其映射为一个新的LongStream</td></tr><tr><td align="center">mapToInt(ToIntFunction mapper)</td><td align="center">接收函数，该函数应用到每个元素，并将其映射为一个新的IntStream</td></tr><tr><td align="center">flatMap(Function f)</td><td align="center">接收函数，该函数应用到每个元素，并将流中的每个值换成另一个流，然后将所有流连成一个流</td></tr></tbody></table><h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">allMatch(Predicate p)</td><td align="center">检查是否匹配所有元素</td></tr><tr><td align="center">anyMatch(Predicate p)</td><td align="center">检查是否至少匹配一个元素</td></tr><tr><td align="center">noneMatch(Predicate p)</td><td align="center">检查是否没有匹配所有元素</td></tr><tr><td align="center">findFirst()</td><td align="center">返回第一个元素</td></tr><tr><td align="center">findAny()</td><td align="center">返回当前流中任意元素</td></tr><tr><td align="center">count()</td><td align="center">返回流中元素总数</td></tr><tr><td align="center">max(Comparator comparator)</td><td align="center">返回流中最大值</td></tr><tr><td align="center">min(Comparator comparator)</td><td align="center">返回流中最小值</td></tr></tbody></table><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">collect(Collector c)</td><td align="center">将流转换为其他形式，接收一个Collector接口的实现</td></tr></tbody></table><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        employeeList.stream()                .filter((x)-&gt; x.getAge() &gt; <span class="hljs-number">20</span>)                .forEach(System.out::println);        System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);        employeeList.stream()                .distinct()                .forEach(System.out::println);        List&lt;String&gt; stringList = Arrays.asList(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-string">&quot;eee&quot;</span>);        stringList.stream()                .map(String::toUpperCase)                .forEach(System.out::println);        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);        employeeList.stream()                .map(Employee::getName)                .forEach(System.out::println);    &#125;</code></pre></div><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>并行流将一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。在<code>Stream API</code>中可以声明性地通过<code>parallel()</code> 与<code>sequential()</code>在并行流与顺序流之间进行切换。</p><p><code>Stream</code>中的并行流底层使用<code>Fork/Join</code>框架。</p><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>A container object which may or may not contain a non-null value.If a value is present, isPresent() will return true and get() will return the value.</p></blockquote><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="of"><a href="#of" class="headerlink" title="of"></a>of</h4><blockquote><p>为非null的值创建一个Optional。</p></blockquote><p>传入null，则会抛出<code>NullPointerException </code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T value)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Optional</span>&lt;&gt;(value);&#125;</code></pre></div><h4 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h4><blockquote><p>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">ofNullable</span><span class="hljs-params">(T value)</span> &#123;        <span class="hljs-keyword">return</span> value == <span class="hljs-literal">null</span> ? empty() : of(value);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;        <span class="hljs-keyword">return</span> t;&#125;</code></pre></div><h4 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h4><blockquote><p>如果值存在返回true，否则返回false。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPresent</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span>;&#125;</code></pre></div><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><blockquote><p>如果Optional有值则将其返回，否则抛出NoSuchElementException。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(<span class="hljs-string">&quot;No value present&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> value;&#125;</code></pre></div><h4 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h4><blockquote><p>如果Optional实例有值则为其调用consumer，否则不做处理</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; consumer)</span> &#123;        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)            consumer.accept(value);&#125;</code></pre></div><h4 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h4><blockquote><p>如果有值则将其返回，否则返回指定的其它值。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">orElse</span><span class="hljs-params">(T other)</span> &#123;        <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> ? value : other;&#125;</code></pre></div><h4 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h4><blockquote><p>orElseGet方法可以接受Supplier接口的实现用来生成默认值。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">orElseGet</span><span class="hljs-params">(Supplier&lt;? extends T&gt; other)</span> &#123;        <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> ? value : other.get();&#125;</code></pre></div><h4 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h4><blockquote><p>如果有值则将其返回，否则抛出supplier接口创建的异常。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;X <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; T <span class="hljs-title function_">orElseThrow</span><span class="hljs-params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="hljs-keyword">throws</span> X &#123;        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> value;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> exceptionSupplier.get();        &#125;&#125;</code></pre></div><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><blockquote><p>为空则返回空Optional，不为空返回mapper.apply后的数据</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;        Objects.requireNonNull(mapper);        <span class="hljs-keyword">if</span> (!isPresent())            <span class="hljs-keyword">return</span> empty();        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Optional.ofNullable(mapper.apply(value));        &#125;&#125;</code></pre></div><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><blockquote><p>与map类似，返回值不用Optional封装</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title function_">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;        Objects.requireNonNull(mapper);        <span class="hljs-keyword">if</span> (!isPresent())            <span class="hljs-keyword">return</span> empty();        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> Objects.requireNonNull(mapper.apply(value));        &#125;&#125;</code></pre></div><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><blockquote><p>如果有值并且满足断言条件则返回封装该值的Optional，否则返回空Optional。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; predicate)</span> &#123;        Objects.requireNonNull(predicate);        <span class="hljs-keyword">if</span> (!isPresent())            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-built_in">this</span> : empty();&#125;</code></pre></div><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><blockquote><p>接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;       System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);    &#125;&#125;</code></pre></div><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：</p><ul><li>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</li><li>接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法(不管方法是否是默认方法)，那么必须覆盖该方法来解决冲突。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();        System.out.println(a.print());      <span class="hljs-comment">//B</span>&#125;</code></pre></div><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>接口中允许存在静态方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="时间API"><a href="#时间API" class="headerlink" title="时间API"></a>时间API</h2><p>Demo：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();        <span class="hljs-comment">// 今天加一天</span>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">tomorrow</span> <span class="hljs-operator">=</span> today.plus(<span class="hljs-number">1</span>, ChronoUnit.DAYS);        <span class="hljs-comment">// 明天减两天</span>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">yesterday</span> <span class="hljs-operator">=</span> tomorrow.minusDays(<span class="hljs-number">2</span>);        <span class="hljs-comment">// 2014 年七月的第四天</span>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">independenceDay</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2014</span>, Month.JULY, <span class="hljs-number">4</span>);        <span class="hljs-type">DayOfWeek</span> <span class="hljs-variable">dayOfWeek</span> <span class="hljs-operator">=</span> independenceDay.getDayOfWeek();        System.out.println(dayOfWeek);        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">germanFormatter</span> <span class="hljs-operator">=</span>                DateTimeFormatter                        .ofLocalizedDate(FormatStyle.MEDIUM)                        .withLocale(Locale.GERMAN);        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">xmas</span> <span class="hljs-operator">=</span> LocalDate.parse(<span class="hljs-string">&quot;24.12.2014&quot;</span>, germanFormatter);        System.out.println(xmas);        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">sylvester</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2014</span>, Month.DECEMBER, <span class="hljs-number">31</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>);        <span class="hljs-type">DayOfWeek</span> <span class="hljs-variable">dayOfWeek1</span> <span class="hljs-operator">=</span> sylvester.getDayOfWeek();        System.out.println(dayOfWeek1);        <span class="hljs-type">Month</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> sylvester.getMonth();        System.out.println(month);    <span class="hljs-comment">// 获取改时间是该天中的第几分钟</span>        <span class="hljs-type">long</span> <span class="hljs-variable">minuteOfDay</span> <span class="hljs-operator">=</span> sylvester.getLong(ChronoField.MINUTE_OF_DAY);        System.out.println(minuteOfDay);        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span>                DateTimeFormatter                        .ofPattern(<span class="hljs-string">&quot;MMM dd, yyyy - HH:mm&quot;</span>);        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">parsed</span> <span class="hljs-operator">=</span> LocalDateTime.parse(<span class="hljs-string">&quot;Nov 03, 2014 - 07:13&quot;</span>, formatter);        <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> formatter.format(parsed);        System.out.println(string);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Integer小细节</title>
    <link href="/2020/Java%E5%9F%BA%E7%A1%80/java-type/"/>
    <url>/2020/Java%E5%9F%BA%E7%A1%80/java-type/</url>
    
    <content type="html"><![CDATA[<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><h3 id="IntegerCache"><a href="#IntegerCache" class="headerlink" title="IntegerCache"></a>IntegerCache</h3><p>在Java中，创建的对象会存储在堆内存，·IntegerCache·主要用来做缓存，减少内存的重复消耗。但是<code>IntegerCache</code>缓存的数据范围在-128到127之间。可以通过 <code>-XX:AutoBoxCacheMax=high</code> 来指定这个缓冲池的大小，JVM通过<code> java.lang.IntegerCache.high</code> 系统属性来存储该值，<code>IntegerCache</code>初始化的时候就会读取该系统属性来决定大小。以下为源码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];        <span class="hljs-keyword">static</span> &#123;            <span class="hljs-comment">// high value may be configured by property</span>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;            <span class="hljs-comment">//读取JVM参数值</span>            <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);            <span class="hljs-comment">//初始化high</span>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);                    i = Math.max(i, <span class="hljs-number">127</span>);                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span>                &#125;            &#125;            high = h;            <span class="hljs-comment">//127 - (-128) + 1为数组容量</span>            cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];            <span class="hljs-comment">//初始化Cache数组</span>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)                cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;    &#125;</code></pre></div><h3 id="Integer-valueOf"><a href="#Integer-valueOf" class="headerlink" title="Integer.valueOf()"></a>Integer.valueOf()</h3><p>首先看一下关于该方法的实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;    <span class="hljs-comment">//判断传入的变量是否处于IntegerCache之内，是的话直接返回缓存中的数据</span>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);    &#125;<span class="hljs-keyword">public</span> <span class="hljs-title function_">Integer</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;        <span class="hljs-built_in">this</span>.value = value;&#125;</code></pre></div><p>因此以下代码便十分容易理解：</p><ul><li>构造方法是创建一个新对象，必然不是同一个地址</li><li><code>valueOf</code>在<code>-128 ~ 127</code>区间之内返回<code>IntegerCache</code>中的对应数组的元素。而超过该范围通过构造方法进行创建。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<span class="hljs-comment">// false</span>System.out.println(x == y);    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<span class="hljs-comment">// true</span>System.out.println(a == b);<span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">129</span>);<span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">129</span>);<span class="hljs-comment">//false</span>System.out.println(c == d);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TreeMap源码分析</title>
    <link href="/2020/Java%E9%9B%86%E5%90%88/java-treemap/"/>
    <url>/2020/Java%E9%9B%86%E5%90%88/java-treemap/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>TreeMap</code>底层通过红黑树实现，在查询性能上能达到<code>O(logn)</code>，由于使用红黑树结构进行存储，所以<code>TreeMap</code>的元素都是有序的。同时，这也是一个非线程安全的<code>Map</code>，无法在并发环境下使用。</p><p><code>TreeMap</code>继承自<code>AbstractMap</code>，该类Map接口的抽象实现。实现了 <code>NavigableMap</code>、<code>Cloneable</code>和 <code>Serializable</code>接口。其中<code>NavigableMap</code>继承自<code>SortedMap</code>，这保证了<code>TreeMap</code>的有序性。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMap</span>&lt;K,V&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</code></pre></div><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>TreeMap</code>采用红黑树进行构建，红黑树是一种自平衡二叉查找树。插入、删除、查找的时间复杂度为<code>O(logn)</code>。与另一个自平衡二叉查找树<code>AVL Tree</code>相比，红黑树以减少旋转操作牺牲部分平衡性，但是其整体性能优于<code>AVL Tree</code>。</p><p>有关红黑树的定义如下（摘自wikipedia）：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/treemap/rbtree-construction.png" alt="红黑树结构示意图（摘自Wikipedia）"></p><p><code>TreeMap</code>中树节点的定义如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;        K key;        V value;        Entry&lt;K,V&gt; left;        Entry&lt;K,V&gt; right;        Entry&lt;K,V&gt; parent;        <span class="hljs-type">boolean</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> BLACK;                Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;            <span class="hljs-built_in">this</span>.key = key;            <span class="hljs-built_in">this</span>.value = value;            <span class="hljs-built_in">this</span>.parent = parent;        &#125;                <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> key;        &#125;                <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> value;        &#125;            <span class="hljs-keyword">public</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span> &#123;            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;            <span class="hljs-built_in">this</span>.value = value;            <span class="hljs-keyword">return</span> oldValue;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            <span class="hljs-keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">keyHash</span> <span class="hljs-operator">=</span> (key==<span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : key.hashCode());            <span class="hljs-type">int</span> <span class="hljs-variable">valueHash</span> <span class="hljs-operator">=</span> (value==<span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : value.hashCode());            <span class="hljs-keyword">return</span> keyHash ^ valueHash;        &#125;        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value;        &#125;    &#125;</code></pre></div><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//TreeMap中用来确定顺序的comparator</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; comparator;<span class="hljs-comment">//树的根节点</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt; root;   <span class="hljs-comment">//树的大小</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//结构变化计数器</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">modCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//EntrySet</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> EntrySet entrySet;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> KeySet&lt;K&gt; navigableKeySet;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;K,V&gt; descendingMap;<span class="hljs-comment">//SubMapIterator中fence == null时，key的值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">UNBOUNDED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//RB Tree的颜色变量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">RED</span>   <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">BLACK</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;</code></pre></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>共有四个构造方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">()</span> &#123;        comparator = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">//传入comparator</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; comparator)</span> &#123;        <span class="hljs-built_in">this</span>.comparator = comparator;    &#125;    <span class="hljs-comment">//传入map</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;        comparator = <span class="hljs-literal">null</span>;        putAll(m);    &#125;   <span class="hljs-comment">//传入有序map</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;        comparator = m.comparator();        <span class="hljs-keyword">try</span> &#123;            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);        &#125; <span class="hljs-keyword">catch</span> (java.io.IOException cannotHappen) &#123;        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;        &#125;    &#125;</code></pre></div><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/treemap/rbtree-rotateLeft.png" alt="左旋操作"></p><p>上图中的5失衡，需要对该节点进行左旋进行修复。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/** From CLR */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotateLeft</span><span class="hljs-params">(Entry&lt;K,V&gt; p)</span> &#123;        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//r为右子树节点</span>            Entry&lt;K,V&gt; r = p.right;           <span class="hljs-comment">//p的右子树换成它子的左孩子节点</span>            p.right = r.left;            <span class="hljs-comment">//如果p的右孩子节点不为空</span>            <span class="hljs-keyword">if</span> (r.left != <span class="hljs-literal">null</span>)                <span class="hljs-comment">//将该节点的父节指向p</span>                r.left.parent = p;            <span class="hljs-comment">//r的父节点指向p的父结点</span>            r.parent = p.parent;            <span class="hljs-comment">//判断旋转的p节点是否为树的根节点</span>            <span class="hljs-keyword">if</span> (p.parent == <span class="hljs-literal">null</span>)                <span class="hljs-comment">//如果是，将根节点设置为r</span>                root = r;            <span class="hljs-comment">//如果失衡节点p是父节点的左孩子节点</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.parent.left == p)                <span class="hljs-comment">//将父节点的左孩子节点设置为r</span>                p.parent.left = r;            <span class="hljs-keyword">else</span>                <span class="hljs-comment">//失衡节点是父节点的右孩子节点</span>                p.parent.right = r;            <span class="hljs-comment">//将r节点的左子树设置为失衡节点p</span>            r.left = p;            p.parent = r;        &#125;    &#125;</code></pre></div><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/java/treemap/rbtree-rorateRight.jpg" alt="右旋操作"></p><p>上图中的10失衡，需要对该节点进行右旋进行修复。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(Entry&lt;K,V&gt; p)</span> &#123;    <span class="hljs-comment">//失衡节点传入不为空</span>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;           <span class="hljs-comment">//l为失衡节点的左子树</span>            Entry&lt;K,V&gt; l = p.left;            <span class="hljs-comment">//将失衡节点的左孩子节点指向它左子树的左孩子节点</span>            p.left = l.right;            <span class="hljs-comment">//l的右子树不为空，将右子树的父指针指向p</span>            <span class="hljs-keyword">if</span> (l.right != <span class="hljs-literal">null</span>) l.right.parent = p;            <span class="hljs-comment">//l升级为原来p节点的地位</span>            l.parent = p.parent;            <span class="hljs-comment">//如果原来的p节点为根节点，将l设置为根节点</span>            <span class="hljs-keyword">if</span> (p.parent == <span class="hljs-literal">null</span>)                root = l;            <span class="hljs-comment">//如果p是父节点的右孩子，则将其父节点的右孩子设置为l</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.parent.right == p)                p.parent.right = l;            <span class="hljs-keyword">else</span> p.parent.left = l;            <span class="hljs-comment">//设置l的右节点为p，右旋完成</span>            l.right = p;            p.parent = l;        &#125;    &#125;</code></pre></div><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get</code>通过调用<code>getEntry</code>获取对应的<code>entry</code>。返回的是<code>entry.value</code>。查找逻辑较为简单，是<code>BST</code>经典查询代码。代码注释如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;        Entry&lt;K,V&gt; p = getEntry(key);        <span class="hljs-keyword">return</span> (p==<span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : p.value);&#125;<span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">getEntry</span><span class="hljs-params">(Object key)</span> &#123;        <span class="hljs-comment">// Offload comparator-based version for sake of performance</span>        <span class="hljs-keyword">if</span> (comparator != <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> getEntryUsingComparator(key);    <span class="hljs-comment">//不允许key为空</span>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            Comparable&lt;? <span class="hljs-built_in">super</span> K&gt; k = (Comparable&lt;? <span class="hljs-built_in">super</span> K&gt;) key;        Entry&lt;K,V&gt; p = root;    <span class="hljs-comment">//从根节点开始找</span>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;                        <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> k.compareTo(p.key);            <span class="hljs-comment">//比key大，往左子树找</span>            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)                p = p.left;            <span class="hljs-comment">//比key小，往右子树找</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)                p = p.right;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> p;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p><code>put</code>方法首先检查是否已经存在该<code>key</code>，如果有则覆盖，没有则构造新节点进行插入。插入后调用<code>fixAfterInsertion</code>进行红黑树的修复。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;        Entry&lt;K,V&gt; t = root;    <span class="hljs-comment">//根节点为空</span>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;            compare(key, key); <span class="hljs-comment">// type (and possibly null) check</span>            root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(key, value, <span class="hljs-literal">null</span>);            size = <span class="hljs-number">1</span>;            modCount++;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-type">int</span> cmp;        Entry&lt;K,V&gt; parent;        <span class="hljs-comment">// split comparator and comparable paths</span>        Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; cpr = comparator;    <span class="hljs-comment">//comparator不为空</span>        <span class="hljs-keyword">if</span> (cpr != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//遍历找到与该key相等的节点，覆盖旧值</span>            <span class="hljs-keyword">do</span> &#123;                parent = t;                cmp = cpr.compare(key, t.key);                <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)                    t = t.left;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)                    t = t.right;                <span class="hljs-keyword">else</span>                    <span class="hljs-keyword">return</span> t.setValue(value);            &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>);        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//comparator为空</span>            <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>                Comparable&lt;? <span class="hljs-built_in">super</span> K&gt; k = (Comparable&lt;? <span class="hljs-built_in">super</span> K&gt;) key;            <span class="hljs-keyword">do</span> &#123;                parent = t;                cmp = k.compareTo(t.key);                <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)                    t = t.left;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)                    t = t.right;                <span class="hljs-keyword">else</span>                    <span class="hljs-keyword">return</span> t.setValue(value);            &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>);        &#125;    <span class="hljs-comment">//没有相同的key，构造新Entry进行插入</span>        Entry&lt;K,V&gt; e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(key, value, parent);        <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)            parent.left = e;        <span class="hljs-keyword">else</span>            parent.right = e;    <span class="hljs-comment">//插入后修复</span>        fixAfterInsertion(e);        size++;        modCount++;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;</code></pre></div><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove</code>方法首先调用<code>getEntry</code>获取需要删除的entry，调用<code>deleteEntry</code>进行删除。红黑树的删除逻辑与二叉查找树相类似，可以分为两种情况：</p><ol><li>待删除节点P的左右子树都为空，则直接删除</li><li>待删除节点P的左右子树非空，用P的后继节点代替P</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;        Entry&lt;K,V&gt; p = getEntry(key);        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> p.value;        deleteEntry(p);        <span class="hljs-keyword">return</span> oldValue;    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteEntry</span><span class="hljs-params">(Entry&lt;K,V&gt; p)</span> &#123;        modCount++;        size--;        <span class="hljs-comment">//上述的第二种情况，找到P的后继节点代替它</span>        <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span> &amp;&amp; p.right != <span class="hljs-literal">null</span>) &#123;            Entry&lt;K,V&gt; s = successor(p);            p.key = s.key;            p.value = s.value;            p = s;        &#125; <span class="hljs-comment">// p has 2 children</span>        <span class="hljs-comment">// Start fixup at replacement node, if it exists.</span>        Entry&lt;K,V&gt; replacement为 = (p.left != <span class="hljs-literal">null</span> ? p.left : p.right);<span class="hljs-comment">//replacement用来代替删除节点</span>        <span class="hljs-keyword">if</span> (replacement != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// Link replacement to parent</span>            replacement.parent = p.parent;            <span class="hljs-comment">//p没有父节点</span>            <span class="hljs-keyword">if</span> (p.parent == <span class="hljs-literal">null</span>)                <span class="hljs-comment">//说明它是根节点，直接将replacement设置为根节点。</span>                root = replacement;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == p.parent.left)                p.parent.left  = replacement;            <span class="hljs-keyword">else</span>                p.parent.right = replacement;            <span class="hljs-comment">// Null out links so they are OK to use by fixAfterDeletion.</span>            p.left = p.right = p.parent = <span class="hljs-literal">null</span>;            <span class="hljs-comment">// 进行删除后修复</span>            <span class="hljs-keyword">if</span> (p.color == BLACK)                fixAfterDeletion(replacement);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.parent == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// return if we are the only node.</span>            root = <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//  No children. Use self as phantom replacement and unlink.</span>            <span class="hljs-keyword">if</span> (p.color == BLACK)                fixAfterDeletion(p);            <span class="hljs-keyword">if</span> (p.parent != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">if</span> (p == p.parent.left)                    p.parent.left = <span class="hljs-literal">null</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == p.parent.right)                    p.parent.right = <span class="hljs-literal">null</span>;                p.parent = <span class="hljs-literal">null</span>;            &#125;        &#125;    &#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了<code>TreeMap</code>的数据结构上的实现，并介绍了红黑树的基本概念，并对增删改查的接口做了简要介绍，但是并未深入探究修复的接口（<code>fixAfterDeletion</code>和<code>fixAfterInsertion</code>）。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2020/Java%E9%9B%86%E5%90%88/java-hashmap/"/>
    <url>/2020/Java%E9%9B%86%E5%90%88/java-hashmap/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​Java中对于Map数据结构，提供了<code>java.util.Map</code>接口，该接口下主要有四个常见的实现类，分别是：</p><ul><li><code>HashMap</code>：根据<code>key.hashCode</code>计算存储位置，能在$O(1)$完成查询，但是遍历顺序是不确定的，<code>HashMap</code>最多存储一个键为null，允许多条entry的值为null。<code>HashMap</code>非线程安全。</li><li><code>HashTable</code>：线程安全的Map，常用方法全部通过<code>synchronized</code>保证线程安全，可以使用<code>ConcurrentHashMap</code>达到目的，此类不建议使用。</li><li><code>LinkedHashMap</code>：继承自<code>HashMap</code>，内部通过双向链表将所有entry连接起来，保证了迭代顺序和插入顺序相同。</li><li><code>TreeMap</code>：实现了SortedMap接口，能够将保存的记录按照键排序。内部通过红黑树进行存储。</li></ul><p><code>HashMap</code>在<code>JDK 7</code>中采用了数组+链表的数据结构，在<code>JDK 8</code>后，底层数据结构转变为：数组+链表+红黑树，也就是当出现Hash冲突时，当链表长度大于阈值(或者红黑树的边界值，默认为8)并且当前数组的长度大于64，链表会转为红黑树存储节点提高搜索效率。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</code></pre></div><p><code>HashMap</code> 继承了 <code>AbstractMap</code> ，该类提供了Map接口的抽象实现，并提供了一些方法的基本实现。实现了 <code>Map</code>、<code>Cloneable</code>和 <code>Serializable</code>接口。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>loadFactor：该变量控制table数组存放数据的疏密程度，越趋向1时，数组中存放的数据越多越密。链表的长度会增加，因此会导致查找效率变低。该值越小，则数组中存放的数据越少，越稀疏，则会导致空间利用率下降。默认值0.75是较好的默认值，可以最大程度减少rehash的次数，避免过多的性能消耗。</li><li>threshold：当前 <code>HashMap</code>所能容纳键值对数量的最大值，超过这个值，则需扩容。<strong>threshold &#x3D; capacity * loadFactor</strong><ul><li>默认容量为16，默认负载因子为0.75，当size达到16 * 0.75 &#x3D; 12时，需要进行扩容(resize)，<strong>即默认扩容阈值为12。</strong></li><li>扩容倍数为：2倍</li></ul></li><li>DEFAULT_INITIAL_CAPACITY：默认初始容量为16</li><li>table：存储Node的数组，链表状态下的节点。<ul><li>length大小必须为2的n次方，减少hash冲突的现象。</li></ul></li><li>entrySet：存储entry的set集合</li><li>size：实际存储的键值对数量</li><li>modCount：对map结构操作的次数。</li><li>TREEIFY_THRESHOLD：转为红黑树的链表节点阈值（条件之一）。</li><li>MIN_TREEIFY_CAPACITY：树化的数组长度阈值（条件之一）。</li><li>UNTREEIFY_THRESHOLD：树退化成链表的阈值。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//存储元素的数组，大小为2的幂次</span><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="hljs-comment">//存放具体元素的集合</span>   <span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<span class="hljs-comment">//已经存放了的数组大小</span>   <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">//结构修改的计数器</span>   <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<span class="hljs-comment">//临界值，实际大小超过该值，则进行扩容</span>   <span class="hljs-type">int</span> threshold;<span class="hljs-comment">//负载因子</span>   <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<span class="hljs-comment">//默认初始容量：16</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">//最大容量</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;   <span class="hljs-comment">//默认的负载因子</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;   <span class="hljs-comment">//链表节点数大于该阈值，转为红黑树存储</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;   <span class="hljs-comment">//红黑树节点数小于该值，转为链表存储</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<span class="hljs-comment">//树化时，检查table数组长度是否大于该值，小于则扩容</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;</code></pre></div><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>链表状态下的节点，继承自<code>Map.Entry&lt;K,V&gt;</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K,V&gt; next;    <span class="hljs-comment">//构造方法</span>    Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;        <span class="hljs-built_in">this</span>.hash = hash;        <span class="hljs-built_in">this</span>.key = key;        <span class="hljs-built_in">this</span>.value = value;        <span class="hljs-built_in">this</span>.next = next;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>        &#123; <span class="hljs-keyword">return</span> key; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>      &#123; <span class="hljs-keyword">return</span> value; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;    <span class="hljs-comment">//Node的HashCode返回键值的HashCode异或值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);    &#125;<span class="hljs-comment">//设置新值，返回旧值</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V newValue)</span> &#123;        <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;        value = newValue;        <span class="hljs-keyword">return</span> oldValue;    &#125;<span class="hljs-comment">//equals</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-comment">//返回key的HashCode值</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;    <span class="hljs-type">int</span> h;    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;<span class="hljs-comment">//如果对象x的类是C，如果C实现了Comparable&lt;C&gt;接口，那么返回C，否则返回null</span><span class="hljs-keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Comparable) &#123;        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;        <span class="hljs-keyword">if</span> ((c = x.getClass()) == String.class) <span class="hljs-comment">// bypass checks</span>            <span class="hljs-keyword">return</span> c;        <span class="hljs-keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ts.length; ++i) &#123;                <span class="hljs-keyword">if</span> (((t = ts[i]) <span class="hljs-keyword">instanceof</span> ParameterizedType) &amp;&amp;                    ((p = (ParameterizedType)t).getRawType() ==                     Comparable.class) &amp;&amp;                    (as = p.getActualTypeArguments()) != <span class="hljs-literal">null</span> &amp;&amp;                    as.length == <span class="hljs-number">1</span> &amp;&amp; as[<span class="hljs-number">0</span>] == c) <span class="hljs-comment">// type arg is c</span>                    <span class="hljs-keyword">return</span> c;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><p>红黑树状态下的节点，继承自<code>LinkedHashMap.Entry&lt;K,V&gt;</code>，而该类继承自<code>HashMap.Node&lt;K,V&gt;</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;        <span class="hljs-comment">//父结点</span>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span>    <span class="hljs-comment">//左孩子节点</span>        TreeNode&lt;K,V&gt; left;    <span class="hljs-comment">//右孩子节点</span>        TreeNode&lt;K,V&gt; right;        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span>    <span class="hljs-comment">//颜色</span>        <span class="hljs-type">boolean</span> red;        TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;            <span class="hljs-built_in">super</span>(hash, key, val, next);        &#125;</code></pre></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>核心的构造方法是第一个，通过调用<code>tableSizeFor</code>为<code>threshold</code>（扩容临界值）赋值。</p><blockquote><p>Returns a power of two size for the given target capacity.</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;       <span class="hljs-comment">//边界检测</span>       <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +                                           initialCapacity);       <span class="hljs-comment">//边界检测</span>       <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)           initialCapacity = MAXIMUM_CAPACITY;       <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +                                              loadFactor);       <span class="hljs-built_in">this</span>.loadFactor = loadFactor;       <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);   &#125;<span class="hljs-comment">//调用前一个构造方法</span>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;       <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);   &#125;  <span class="hljs-comment">//未传参数时,负载因子设置为默认值</span>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;       <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;   &#125;   <span class="hljs-comment">//传递Map的时候，调用putMapEntries进行批量添加</span>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;       <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;       putMapEntries(m, <span class="hljs-literal">false</span>);   &#125;</code></pre></div><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h3><p>该方法在初始化时，对<code>threshold</code>赋值，通过位运算找到大于或等于cap的最小的2的幂次方。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="hash（计算hash值）"><a href="#hash（计算hash值）" class="headerlink" title="hash（计算hash值）"></a>hash（计算hash值）</h3><p>该方法在插入时，计算元素的hash值时调用。<code>hash</code>值为传入key的<code>hashCode</code>与其右移16位的异或值。这被称为<strong>扰动函数</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;        <span class="hljs-type">int</span> h;        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;</code></pre></div><p><code>hashCode</code>方法，是key的类自带的hash方法，返回一个int的Hash值，理论上，这个值应当均匀得分布在int的范围内，但是<code>HashMap</code>初始化大小为16，如果让hash映射到16个桶中，通过取模实现十分简单。但是直接取模会造成较多的哈希碰撞。扰动函数的作用是：增加了随机性，减少了hash碰撞的几率。</p><p>那么如何通过hash值，获取对应的数组下标呢？在<code>putVal</code>中，获取下标的方法如下：<code>(n - 1) &amp; hash</code>，n是数组大小，上文中<code>threshold</code>为2<sup>n</sup>，那么<code>(n - 1)</code><sub>2</sub> &#x3D; 00….111111，那么通过<code>&amp;</code>运算，会保留下hash的低位。为何用<code>&amp;</code>替代取模运算，主要是位运算的效率高于取模运算。这也证明了为何<code>threshold</code>必须要是2的幂次方，通过控制该值，从而达到提高hash映射效率的目的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)</code></pre></div><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>主要逻辑：</p><ol><li>根据hash找到指定位置的节点</li><li>判断第一个节点的key是否符合要求，符合要求直接返回第一个节点，否则继续查找。</li><li>如果是红黑树结构，通过调用<code>getTreeNode(hash, key)</code>查找红黑树节点并返回。</li><li>如果是链表结构，遍历节点查询并返回</li><li>如果没有找到，返回null</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;    Node&lt;K,V&gt; e;    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;&#125;<span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//第一个节点就命中</span>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-keyword">return</span> first;        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//判断是否为红黑树节点</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-comment">//如果是链表，就遍历链表找到相应的数据</span>            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>主要逻辑：</p><ol><li>若桶数组table为空或length&#x3D;&#x3D;0，则通过<code>resize()</code>进行扩容。</li><li>根据key的hash得到数组索引，查找要插入的键值对是否已经存在，存在的话，用新值替换旧值。</li><li>如果不存在，将键值对插入链表或者红黑树中，并根据长度判断是否将链表转换成红黑树。</li><li>判断键值对数量是否大于阈值，大于的话进行扩容操作。</li></ol><p>需要注意的是，<code>treeifyBin</code>方法在进行树化前，进行了检查。如果小于<code>MIN_TREEIFY_CAPACITY</code>，则进行扩容，不进行树化。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;        <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);    &#125;<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            <span class="hljs-comment">//如果未初始化，进行数组初始化，赋予初始容量</span>            n = (tab = resize()).length;    <span class="hljs-comment">//通过hash找到下标，如果该位置为空</span>    <span class="hljs-comment">//若下标处有节点存储，使用p存储</span>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)            <span class="hljs-comment">//直接将数据存储进去</span>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//发生hash碰撞</span>            Node&lt;K,V&gt; e; K k;            <span class="hljs-comment">//如果插入的key和当前key相同，直接覆盖</span>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                e = p;            <span class="hljs-comment">//如果当前节点类型是红黑树节点，使用红黑树进行插入</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//链表的情况</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;                    <span class="hljs-comment">//将新节点放到链表的末尾</span>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);                        <span class="hljs-comment">//如果链表长度达到红黑树化的阈值，将链表转化成红黑树</span>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>)                            treeifyBin(tab, hash);                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-comment">//如果该key已经存在于链表中，覆盖</span>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))                        <span class="hljs-keyword">break</span>;                    p = e;                &#125;            &#125;            <span class="hljs-comment">//e不为空说明值已经插入成功</span>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;                <span class="hljs-comment">//onlyIfAbsent控制是否替换原来的value</span>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)                    e.value = value;                afterNodeAccess(e);                <span class="hljs-keyword">return</span> oldValue;            &#125;        &#125;        ++modCount;    <span class="hljs-comment">//扩容检测</span>        <span class="hljs-keyword">if</span> (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;<span class="hljs-comment">//链表转为红黑树的方法</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;        <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;    <span class="hljs-comment">//树化的第二个条件</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)            <span class="hljs-comment">//如果小于树化条件，使用resize</span>            resize();        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;            TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">do</span> &#123;                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);                <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)                    hd = p;                <span class="hljs-keyword">else</span> &#123;                    p.prev = tl;                    tl.next = p;                &#125;                tl = p;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);            <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)                hd.treeify(tab);        &#125;    &#125;</code></pre></div><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>主要逻辑：</p><ol><li>判断第一个节点是否是需删除节点，如果是，将节点存储下来。</li><li>如果节点是红黑树节点，通过调用<code>getTreeNode</code>找到需删除节点，存储下来。</li><li>如果是链表，遍历获取到需删除节点。</li><li>删除节点，并进行修复工作</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;    Node&lt;K,V&gt; e;    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) == <span class="hljs-literal">null</span> ?        <span class="hljs-literal">null</span> : e.value;&#125;<span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value,</span><span class="hljs-params">                           <span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span> &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, index;    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;        Node&lt;K,V&gt; node = <span class="hljs-literal">null</span>, e; K k; V v;        <span class="hljs-comment">//如果键与第一个节点相等，则该节点是需删除节点</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))            node = p;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//如果是红黑树节点，调用红黑树的查找方法找到需删除节点</span>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-comment">//遍历链表，找到需删除节点</span>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                        ((k = e.key) == key ||                         (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;                        node = e;                        <span class="hljs-keyword">break</span>;                    &#125;                    p = e;                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);            &#125;        &#125;        <span class="hljs-comment">//删除节点，并修复链表或红黑树</span>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||                             (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))) &#123;            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-built_in">this</span>, tab, movable);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)                tab[index] = node.next;            <span class="hljs-keyword">else</span>                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            <span class="hljs-keyword">return</span> node;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre></div><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p><code>HashMap</code>的table数组长度为2的幂，阈值大小 &#x3D; <code>capacity * load factor</code>（默认阈值为12），<code>Node</code>数量超过阈值，进行扩容，<strong>扩容倍数为2倍。</strong></p><p>主要逻辑：</p><ol><li>计算新的桶数组容量<code>newCap</code>和新阈值<code>newThr</code>。<code>newCap</code>为原来的两倍，<code>newThr</code>为原来的两倍。</li><li>根据<code>newCap</code>创建新的桶数组，初始化新的桶数组。</li><li>将键值对节点重新映射到新的桶数组中，如果是红黑树节点，则需要拆分红黑树，如果是普通节点，则节点按照顺序进行分组。</li></ol><p>需要注意的是：<code>resize</code>十分消耗性能，日常开发需要尽量避免。方法中变量含义如下：</p><ul><li>oldTab：引用扩容前的哈希表</li><li>oldCap：表示扩容前的table数组的长度</li><li>newCap：扩容之后table数组大小</li><li>newThr：扩容之后下次触发扩容的阈值</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-comment">//如果table长度大于0，说明已经被初始化</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果table的容量超过最大容量，不进行扩容</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">//将容量变为原来的两倍，阈值变为原来的两倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">//newCap = threshold</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)        newCap = oldThr;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//阈值为默认容量与默认负载因子乘积</span>        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    <span class="hljs-comment">//新阈值为0时，按照默认公式重新算newThr</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);    &#125;    <span class="hljs-comment">//赋值</span>    threshold = newThr;    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>    <span class="hljs-comment">//创建新的桶数组</span>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];    table = newTab;    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-comment">//如果旧的桶数组不为空，就遍历桶数组，并将键值对映射到新的桶数组</span>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    <span class="hljs-comment">//如果是红黑树节点，进行拆分</span>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 链表节点情况</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        <span class="hljs-comment">//遍历链表并进行按序分组</span>                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-comment">//将分组后的链表映射到新的桶数组中</span>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre></div><h2 id="红黑树退化"><a href="#红黑树退化" class="headerlink" title="红黑树退化"></a>红黑树退化</h2><p>在<code>TreeNode.split</code>方法和中，有一段代码对是否需要进行退化进行了判断。如果树节点个数小于<code>6</code>，则会退化为链表，至于该阈值与树化阈值<code>（UNTREEIFY_THRESHOLD 与 TREEIFY_THRESHOLD）</code>不等的原因，主要为了避免桶数组中的某个节点在该值附近震荡，从而导致频繁的树化和链表化。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (loHead != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)                    tab[index] = loHead.untreeify(map);                <span class="hljs-keyword">else</span> &#123;                    tab[index] = loHead;                    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-literal">null</span>) <span class="hljs-comment">// (else is already treeified)</span>                        loHead.treeify(tab);                &#125;            &#125;            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)                    tab[index + bit] = hiHead.untreeify(map);                <span class="hljs-keyword">else</span> &#123;                    tab[index + bit] = hiHead;                    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-literal">null</span>)                        hiHead.treeify(tab);                &#125;            &#125;</code></pre></div><p>此外，在<code>TreeNode.removeTreeNode</code>中，删除红黑树节点之前，如果满足以下条件，也会进行链表化再进行删除：</p><ul><li>树的左子树为空</li><li>树的右子树为空</li><li>树的左孙子节点为空</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.right == <span class="hljs-literal">null</span> ||                (rl = root.left) == <span class="hljs-literal">null</span> || rl.left == <span class="hljs-literal">null</span>) &#123;                tab[index] = first.untreeify(map);  <span class="hljs-comment">// too small</span>                <span class="hljs-keyword">return</span>;&#125;</code></pre></div><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>HashMap多线程操作存在以下问题：</p><ul><li>多线程下扩容形成死循环：JDK1.7中使用头插法插入元素，扩容时可能导致形成环形链表，JDK1.8采用尾插法，不会出现此问题。</li><li>多线程put操作导致元素的丢失：多线程put时，发生hash碰撞，会导致key被覆盖，从而导致元素丢失。</li><li>put和get并发，导致get为null：线程1执行put，因元素个数超出扩容阈值而导致resize，线程2执行get时，会得到null。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对 JDK 8 中的 <code>HashMap</code> 的源代码进行了简要分析，主要为增删改查接口的内部实现机制以及扩容原理。</p><p>HashMap内部基于数组实现的，数组每个元素称为一个桶(bucket)，当存储的键值对数量超过阈值时，还会进行扩容操作，HashMap中的键值对会重新Hash到新位置。当桶中节点数超过阈值，则会进行树化，如果删除导致低于阈值，则会进行链表化。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList源码分析</title>
    <link href="/2020/Java%E9%9B%86%E5%90%88/java-linkedlist/"/>
    <url>/2020/Java%E9%9B%86%E5%90%88/java-linkedlist/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>LinkedList</code>底层采用双向链表结构实现，所以在存储元素功能上，并不需要扩容机制，但是需要额外的空间存储指针，头插和尾插的时间复杂度为<code>O(1)</code>，指定位置插入的时间复杂度为<code>O(n)</code>，<code>LinkedList</code>是非线程安全的集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</code></pre></div><p><code>LinkedList</code>继承了<code>AbstractSequentialList</code>。该类提供了一套基于顺序访问的接口。</p><p>实现了<code>List</code>接口和<code>Deque</code>接口，使得<code>LinkedList</code>同时具备了<code>List</code>和双端队列的特性。</p><p><code>LinkedList</code>实现了<code>Serializable</code>接口，表明<code>ArrayList</code>支持序列化。</p><p><code>LinkedList</code>实现了<code>Cloneable</code>接口，能被克隆。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Node节点包括数据，前驱节点和后继节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;            <span class="hljs-built_in">this</span>.item = element;            <span class="hljs-built_in">this</span>.next = next;            <span class="hljs-built_in">this</span>.prev = prev;        &#125;    &#125;</code></pre></div><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>分别是链表长度，头节点，尾节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-keyword">transient</span> Node&lt;E&gt; last;</code></pre></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法有两种，注释如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//空构造方法</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;   &#125;   <span class="hljs-comment">//传入集合，调用addAll进行添加</span>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;       <span class="hljs-built_in">this</span>();       addAll(c);   &#125;</code></pre></div><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="linkFirst"><a href="#linkFirst" class="headerlink" title="linkFirst"></a>linkFirst</h3><p>将元素添加到头部。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;    <span class="hljs-comment">//新节点的前驱节点为null，后继节点为原来的头节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f);        first = newNode;    <span class="hljs-comment">//如果头节点为空</span>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)            <span class="hljs-comment">//新插入的既是头节点，也是尾节点。</span>            last = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//将原来头节点的前驱指针指向新节点</span>            f.prev = newNode;        size++;        modCount++;    &#125;</code></pre></div><h3 id="linkLast"><a href="#linkLast" class="headerlink" title="linkLast"></a>linkLast</h3><p>将元素添加到尾部。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;    <span class="hljs-comment">//新节点的后继节点为null，前驱节点为原来的尾节点</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);        last = newNode;    <span class="hljs-comment">//如果尾节点为空,直接将新节点设置为头节点</span>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)            first = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//否则将原来的尾节点后继指向新节点</span>            l.next = newNode;        size++;        modCount++;    &#125;</code></pre></div><h3 id="linkBefore"><a href="#linkBefore" class="headerlink" title="linkBefore"></a>linkBefore</h3><p>在一个非空节点前插入元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;        <span class="hljs-comment">// assert succ != null;</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;    <span class="hljs-comment">//插入节点的前驱为succ的前驱，后继节点为succ</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);    <span class="hljs-comment">//设置succ的前驱指针</span>        succ.prev = newNode;    <span class="hljs-comment">//如果succ的前驱节点为空</span>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)            <span class="hljs-comment">//新插入的节点为头节点</span>            first = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//否则succ的前驱节点的后继指针指向新节点</span>            pred.next = newNode;        size++;        modCount++;    &#125;</code></pre></div><h3 id="unlinkFirst"><a href="#unlinkFirst" class="headerlink" title="unlinkFirst"></a>unlinkFirst</h3><p>移除头节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> &#123;        <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> f.item;    <span class="hljs-comment">//获取头节点的下一个元素</span>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;    <span class="hljs-comment">//方便GC</span>        f.item = <span class="hljs-literal">null</span>;        f.next = <span class="hljs-literal">null</span>;    <span class="hljs-comment">//first指针指向next节点</span>        first = next;    <span class="hljs-comment">//如果链表只有一个节点</span>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)            <span class="hljs-comment">//删除后为空，将尾指针置空</span>            last = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//否则将next的前置置为空</span>            next.prev = <span class="hljs-literal">null</span>;    <span class="hljs-comment">//设置size和modCount</span>        size--;        modCount++;        <span class="hljs-keyword">return</span> element;    &#125;</code></pre></div><h3 id="unlinkLast"><a href="#unlinkLast" class="headerlink" title="unlinkLast"></a>unlinkLast</h3><p>移除尾节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> &#123;        <span class="hljs-comment">// assert l == last &amp;&amp; l != null;</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> l.item;        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;    <span class="hljs-comment">//方便GC</span>        l.item = <span class="hljs-literal">null</span>;        l.prev = <span class="hljs-literal">null</span>;    <span class="hljs-comment">//last指针指向原来尾节点的前一个</span>        last = prev;    <span class="hljs-comment">//如果前一个为空</span>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>)            <span class="hljs-comment">//说明现在没有节点，头节点置空</span>            first = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//否则将尾节点的next置为空</span>            prev.next = <span class="hljs-literal">null</span>;        size--;        modCount++;        <span class="hljs-keyword">return</span> element;    &#125;</code></pre></div><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>移除一个非空节点。</p><div class="code-wrapper"><pre><code class="hljs java">E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;        <span class="hljs-comment">// assert x != null;</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="hljs-comment">//如果x是头节点，将头指针指向x的next</span>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;            first = next;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//不是的话，将x的前驱指针指向它的后继节点</span>            <span class="hljs-comment">//并将x的前去指针置空</span>            prev.next = next;            x.prev = <span class="hljs-literal">null</span>;        &#125;<span class="hljs-comment">//如果后继节点为空，说明删除的节点是尾节点</span>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//last指向前一个</span>            last = prev;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//处理next的前驱指针</span>            next.prev = prev;            x.next = <span class="hljs-literal">null</span>;        &#125;        x.item = <span class="hljs-literal">null</span>;        size--;        modCount++;        <span class="hljs-keyword">return</span> element;    &#125;</code></pre></div><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>根据下标返回节点。</p><div class="code-wrapper"><pre><code class="hljs java">Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-comment">//如果下标小于size/2，从头节点开始遍历</span>        <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;            Node&lt;E&gt; x = first;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)                x = x.next;            <span class="hljs-keyword">return</span> x;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//从尾部开始遍历</span>            Node&lt;E&gt; x = last;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)                x = x.prev;            <span class="hljs-keyword">return</span> x;        &#125;    &#125;</code></pre></div><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>返回元素第一次出现的下标。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//o为null时，从头结点开始找到第一个null节点</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">return</span> index;                index++;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//否则从头开始找与o匹配的</span>            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;                <span class="hljs-keyword">if</span> (o.equals(x.item))                    <span class="hljs-keyword">return</span> index;                index++;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre></div><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><p>找到最后一个匹配的下标。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> size;    <span class="hljs-comment">//从尾部开始找</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;                index--;                <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">return</span> index;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;                index--;                <span class="hljs-keyword">if</span> (o.equals(x.item))                    <span class="hljs-keyword">return</span> index;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre></div><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>add方法调用<code>linkLast</code>，将元素添加到链表。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;        linkLast(e);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);        last = newNode;        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)            first = newNode;        <span class="hljs-keyword">else</span>            l.next = newNode;        size++;        modCount++;    &#125;</code></pre></div><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><p>将传入的集合从指定下标开始插入。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;    <span class="hljs-comment">//检查index</span>        checkPositionIndex(index);<span class="hljs-comment">//存到数组中</span>        Object[] a = c.toArray();        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;    <span class="hljs-comment">//检验是否为空数组</span>        <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        Node&lt;E&gt; pred, succ;    <span class="hljs-comment">//如果插入位置为尾部</span>        <span class="hljs-keyword">if</span> (index == size) &#123;            <span class="hljs-comment">//succ指向空 pred指向尾节点</span>            succ = <span class="hljs-literal">null</span>;            pred = last;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//不为空则通过node方法找到指定下标的节点</span>            succ = node(index);            pred = succ.prev;        &#125;<span class="hljs-comment">//遍历插入数据</span>        <span class="hljs-keyword">for</span> (Object o : a) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) o;            Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, <span class="hljs-literal">null</span>);            <span class="hljs-comment">//如果插入位置在链表头部</span>            <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)                <span class="hljs-comment">//头指针设置新节点</span>                first = newNode;            <span class="hljs-keyword">else</span>                pred.next = newNode;            pred = newNode;        &#125;<span class="hljs-comment">//如果从尾部开始插入</span>        <span class="hljs-keyword">if</span> (succ == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//重置尾节点</span>            last = pred;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//否则将插入的链表与原来的链表连接起来</span>            pred.next = succ;            succ.prev = pred;        &#125;        size += numNew;        modCount++;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;</code></pre></div><h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>peek方法返回链表的头节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-keyword">return</span> (f == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : f.item;    &#125;</code></pre></div><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll方法返回头节点，并将头节点删除。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;        <span class="hljs-keyword">return</span> (f == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : unlinkFirst(f);    &#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>LinkedList</code>通过实现<code>List </code>接口与<code>Deque</code>接口，底层数据结构采用了双向链表，同时具备了<code>List</code>，<code>Queue</code>和<code>Stack</code>的特性，本文对其该集合的基本的API实现做了简要分析。关于迭代器并未阐述，其机制与<code>ArrayList</code>类似，通过<code>fail-fast</code>检测在迭代时结构是否发生改变。</p><p>与<code>ArrayList</code>相比，<code>LinkedList</code>的查找性能差于<code>ArrayList</code>，但是其插入和删除性能优于<code>ArrayList</code>，在日常开发中，可以根据业务场景选择合适的集合。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="/2020/Java%E9%9B%86%E5%90%88/java-arraylist/"/>
    <url>/2020/Java%E9%9B%86%E5%90%88/java-arraylist/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ArrayList</code>是<code>List</code>接口的实现类，其底层通过数组实现。当空间不够会通过内部的扩容机制进行扩容。时间复杂度与数组类似，<code>ArrayList</code>是非线程安全的集合，在并发环境下使用会产生错误。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre></div><p><code>ArrayList</code>继承了<code>AbstractList</code>，实现了<code>List</code>接口，提供了添加、删除、修改、遍历等功能</p><p><code>ArrayList</code>实现了<code>RandomAccess</code>接口，实现该接口表明<code>ArrayList</code>支持快速随机访问。</p><p><code>ArrayList</code>实现了<code>Serializable</code>接口，表明<code>ArrayList</code>支持序列化。</p><p><code>ArrayList</code>实现了<code>Cloneable</code>接口，能被克隆。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//默认初始化大小</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">//传入initialCapacity为0时，elementData指向该变量</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">//不传initialCapacity时，elementData指向该变量</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">//存放数据的数组</span>   <span class="hljs-keyword">transient</span> Object[] elementData;   <span class="hljs-comment">//list大小</span>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;</code></pre></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>ArrayList</code>共有三个构造方法。注释如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//传递了长度的构造方法</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;    <span class="hljs-comment">//边界检查</span>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+                                               initialCapacity);        &#125;    &#125;    <span class="hljs-comment">//无参构造</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    &#125;    <span class="hljs-comment">//传递集合</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;        <span class="hljs-comment">//获取初始值数组</span>        elementData = c.toArray();        <span class="hljs-comment">//如果传入的为非空集合</span>        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// c.toArray可能返回的不是Object[]类型</span>            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//传递空集合，将elementData指向空数组</span>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;        &#125;    &#125;</code></pre></div><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取对应下标的元素，时间复杂度<code>O(1)</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        rangeCheck(index);        <span class="hljs-keyword">return</span> elementData(index);&#125;E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-keyword">return</span> (E) elementData[index];&#125;</code></pre></div><h3 id="rangeCheck"><a href="#rangeCheck" class="headerlink" title="rangeCheck"></a>rangeCheck</h3><p>检查传入下标是否合法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-keyword">if</span> (index &gt;= size)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));&#125;</code></pre></div><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>设置对应下标的元素，返回原来的元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;        rangeCheck(index);        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);        elementData[index] = element;        <span class="hljs-keyword">return</span> oldValue;    &#125;</code></pre></div><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>add有两种方式，一种是尾插，一种是指定位置插入。</p><p>插入中，首先需要检查容量是否足够，不够会进行扩容，扩容机制会在后续介绍。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;    <span class="hljs-comment">//判断是否需要扩容</span>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>        elementData[size++] = e;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;        rangeCheckForAdd(index);        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    <span class="hljs-comment">//从index开始到末尾，逐个向后移动1位，相当于index处空出一个位置。</span>        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,                         size - index);        elementData[index] = element;        size++;    &#125;</code></pre></div><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>remove有两种删除方式：一种是根据下标删除，一种是根据对象删除。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        rangeCheck(index);        modCount++;        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<span class="hljs-comment">//找到index后一位</span>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            <span class="hljs-comment">//将numMoved开始到结尾向前移动一位</span>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                             numMoved);    <span class="hljs-comment">//置空，让其被GC</span>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>        <span class="hljs-keyword">return</span> oldValue;&#125;<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;    <span class="hljs-comment">//检查</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)                <span class="hljs-comment">//判断空元素</span>                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-comment">//fastRemove不检查边界值，不返回删除元素值</span>                    fastRemove(index);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)                <span class="hljs-comment">//调用equals检查对象是否符合要求</span>                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;                    fastRemove(index);                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><h3 id="fastRemove"><a href="#fastRemove" class="headerlink" title="fastRemove"></a>fastRemove</h3><p>不检查边界值，并且不返回删除元素的方式进行删除指定下标的数据。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        modCount++;        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                             numMoved);        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>&#125;</code></pre></div><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>清空列表。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;        modCount++;        <span class="hljs-comment">// 将每个元素置空，方便GC回收</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)            elementData[i] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//长度置为0</span>        size = <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><p>将集合添加进列表中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;    <span class="hljs-comment">//将集合转为Object数组</span>        Object[] a = c.toArray();        <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;    <span class="hljs-comment">//确保容量足够</span>        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>    <span class="hljs-comment">//将数组copy到elementData中</span>        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);    <span class="hljs-comment">//更新长度</span>        size += numNew;        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;    &#125;</code></pre></div><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>返回元素在列表中第一个匹配的下标。不存在返回-1。<code>lastIndexOf</code>同理，找到最后匹配的下标。实现原理为<code>for</code>从前往后扫描。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;    <span class="hljs-comment">//如果传入元素为空</span>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//找到列表中第一个为空的下标，返回</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)                    <span class="hljs-keyword">return</span> i;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//equals找到第一个匹配对象，并返回</span>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))                    <span class="hljs-keyword">return</span> i;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre></div><h3 id="removeRange"><a href="#removeRange" class="headerlink" title="removeRange"></a>removeRange</h3><p>删除指定区间的元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;        modCount++;    <span class="hljs-comment">//将指定区间的元素覆盖掉</span>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - toIndex;        System.arraycopy(elementData, toIndex, elementData, fromIndex,                         numMoved);        <span class="hljs-comment">//将指定区间的元素置空，方便GC</span>        <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> size - (toIndex-fromIndex);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> newSize; i &lt; size; i++) &#123;            elementData[i] = <span class="hljs-literal">null</span>;        &#125;        size = newSize;    &#125;</code></pre></div><h3 id="retainAll"><a href="#retainAll" class="headerlink" title="retainAll"></a>retainAll</h3><p>retainAll返回该集合与传入集合的交集，并且将非交集元素删除。通过调用<code>batchRemove</code>进行元素删除。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;        Objects.requireNonNull(c);        <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">true</span>);    &#125;<span class="hljs-comment">//删除非交集元素</span><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">batchRemove</span><span class="hljs-params">(Collection&lt;?&gt; c, <span class="hljs-type">boolean</span> complement)</span> &#123;    <span class="hljs-comment">//获取到当前List的数组</span>        <span class="hljs-keyword">final</span> Object[] elementData = <span class="hljs-built_in">this</span>.elementData;        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>;        <span class="hljs-type">boolean</span> <span class="hljs-variable">modified</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//for找出相同的，并将相同的逐个放在elementData</span>            <span class="hljs-keyword">for</span> (; r &lt; size; r++)                <span class="hljs-keyword">if</span> (c.contains(elementData[r]) == complement)                    elementData[w++] = elementData[r];        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//如果 c.contains()抛出异常</span>            <span class="hljs-keyword">if</span> (r != size) &#123;                <span class="hljs-comment">//复制剩余的元素</span>                System.arraycopy(elementData, r,                                 elementData, w,                                 size - r);                <span class="hljs-comment">//w为当前List的length</span>                w += size - r;            &#125;            <span class="hljs-comment">//如果交集长度与原来长度不匹配</span>            <span class="hljs-keyword">if</span> (w != size) &#123;                <span class="hljs-comment">// 删除多余的元素</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> w; i &lt; size; i++)                    elementData[i] = <span class="hljs-literal">null</span>;                modCount += size - w;                size = w;                modified = <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> modified;    &#125;</code></pre></div><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize"></a>trimToSize</h3><p>手动缩容，将list的elementData没使用的空间删除。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123;        modCount++;        <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;            elementData = (size == <span class="hljs-number">0</span>)              ? EMPTY_ELEMENTDATA              : Arrays.copyOf(elementData, size);        &#125;    &#125;</code></pre></div><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p><code>ensureCapacityInternal</code>提供内部调用，<code>ensureCapacity</code>可提供外部调用。</p><ul><li>扩容时机：<code>size + 1 - elementData.length &gt; 0</code>，即list实际大小超出elementData长度时，进行扩容</li><li>扩容倍数：原容量的1.5倍（向下取整）</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;        modCount++;        <span class="hljs-comment">// 边界检查</span>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)            grow(minCapacity);    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);        &#125;        <span class="hljs-keyword">return</span> minCapacity;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)            <span class="hljs-comment">// any size if not default element table</span>            ? <span class="hljs-number">0</span>            <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span>            <span class="hljs-comment">// supposed to be at default size.</span>            : DEFAULT_CAPACITY;        <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;            ensureExplicitCapacity(minCapacity);        &#125;    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;        <span class="hljs-comment">// 原容量</span>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;    <span class="hljs-comment">//新容量为原容量的1.5倍</span>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">//判断新容量是否大于需要的最小容量</span>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)            newCapacity = minCapacity;    <span class="hljs-comment">//比最大容量还大</span>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)            newCapacity = hugeCapacity(minCapacity);        <span class="hljs-comment">//copy</span>        elementData = Arrays.copyOf(elementData, newCapacity);    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();    <span class="hljs-comment">//若minCapacity &gt; MAX_ARRAY_SIZE,将Integer.MAX_VALUE作为新数组大小</span>    <span class="hljs-comment">//否则MAX_ARRAY_SIZE作为新数组大小</span>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;    &#125;</code></pre></div><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><p>在对List的结构进行修改时，都会进行<code>modCount++</code>，该变量记录集合的修改次数。其中包括：</p><ul><li>trimToSize</li><li>ensureExplicitCapacity</li><li>remove</li><li>clear</li><li>removeIf</li><li>replaceAll</li><li>sort</li></ul><p>在使用迭代器遍历集合的时候同时修改结构时，<code>modCount</code>值会改变，而迭代器中<code>checkForComodification</code>方法是在迭代中检查集合是否发生修改。其原理是比较创建迭代器的时候的<code>modCount</code>与当前modCount是否相同。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (modCount != expectedModCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();        &#125;</code></pre></div><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><code>next</code>方法会调用<code>checkForComodification</code>方法来判断<code>List</code>迭代过程中是否发生结构上的修改，原理已在上文阐述。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * An optimized version of AbstractList.Itr</span><span class="hljs-comment">     */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;        <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span>        <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span>        <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;        Itr() &#123;&#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> cursor != size;        &#125;        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="hljs-comment">//通过i = cursor自增，逐个获取元素</span>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">//判断List是否在迭代器创建后发生过修改</span>            checkForComodification();            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;            <span class="hljs-keyword">if</span> (i &gt;= size)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();            Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();            cursor = i + <span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];        &#125;       ......<span class="hljs-meta">@Override</span>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; consumer)</span> &#123;            Objects.requireNonNull(consumer);            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> ArrayList.<span class="hljs-built_in">this</span>.size;            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;            <span class="hljs-keyword">if</span> (i &gt;= size) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">final</span> Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;            <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();            &#125;            <span class="hljs-keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;                consumer.accept((E) elementData[i++]);            &#125;            <span class="hljs-comment">// update once at end of iteration to reduce heap write traffic</span>            cursor = i;            lastRet = i - <span class="hljs-number">1</span>;            checkForComodification();        &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (modCount != expectedModCount)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();        &#125;    &#125;</code></pre></div><h4 id="遍历时删除"><a href="#遍历时删除" class="headerlink" title="遍历时删除"></a>遍历时删除</h4><p>如果在遍历时删除，foreach在编译成字节码时会转成迭代器遍历的方式。运行时会在上述<code>checkForComodification</code>方法中抛出<code>ConcurrentModificationException</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        list.add(<span class="hljs-number">2</span>);        list.add(<span class="hljs-number">1</span>);        list.add(<span class="hljs-number">3</span>);        list.add(<span class="hljs-number">1</span>);        System.out.println(list);        <span class="hljs-keyword">for</span> (Integer item : list) &#123;            <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-number">1</span>))&#123;                list.remove(item);            &#125;        &#125;        System.out.println(list);&#125;</code></pre></div><p>上述机制称为<code>fail-fast</code>机制，这种机制在Java集合类中十分常见，简而言之就是操作前先考虑异常情况，如果发生异常，立即停止操作。</p><p>根据阿里的Java规范，正确的方式如下：</p><blockquote><p>【强制】不要在 foreach 循环里进行元素的 remove&#x2F;add 操作。remove 元素请使用 Iterator<br>方式，如果并发操作，需要对 Iterator 对象加锁。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java">Iterator&lt;Integer&gt; it = list.iterator();        <span class="hljs-keyword">while</span> (it.hasNext())        &#123;            <span class="hljs-type">Integer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();            <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-number">1</span>))            &#123;                it.remove();            &#125;        &#125;        System.out.println(list);</code></pre></div><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><code>ArrayList</code>的<code>elementData </code>添加了<code>transient</code>关键字，所以在序列化的时候<code>elementData </code>并不是序列化的一部分。而<code>ArrayList</code>通过内部更为细致的方法进行了序列化控制。内部序列化方法只保存非空元素，从而达到节约空间的目的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span>       <span class="hljs-keyword">throws</span> java.io.IOException&#123;       <span class="hljs-comment">// Write out element count, and any hidden stuff</span>       <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;       s.defaultWriteObject();       <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span>       s.writeInt(size);       <span class="hljs-comment">// Write out all elements in the proper order.</span>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;           s.writeObject(elementData[i]);       &#125;       <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();       &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span><span class="hljs-comment">    * deserialize it).</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span>       <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;       elementData = EMPTY_ELEMENTDATA;       <span class="hljs-comment">// Read in size, and any hidden stuff</span>       s.defaultReadObject();       <span class="hljs-comment">// Read in capacity</span>       s.readInt(); <span class="hljs-comment">// ignored</span>       <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;           <span class="hljs-comment">// be like clone(), allocate array based upon size not capacity</span>           <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> calculateCapacity(elementData, size);           SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);           ensureCapacityInternal(size);           Object[] a = elementData;           <span class="hljs-comment">// Read in all elements in the proper order.</span>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;               a[i] = s.readObject();           &#125;       &#125;   &#125;</code></pre></div><h2 id="子列表"><a href="#子列表" class="headerlink" title="子列表"></a>子列表</h2><p><code>subList</code>返回<code>List</code>指定区间的数据，可以看到<code>subList</code>中的操作会影响到父列表。</p><p>其次需要注意的是，<code>subList</code>的返回结果不可强转成<code>ArrayList</code>，否则会抛出<code>ClassCastException</code>，因为<code>subList</code>返回的是<code>ArrayList</code>的内部类<code>SubList</code>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;E&gt; <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;            subListRangeCheck(fromIndex, toIndex, size);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubList</span>(<span class="hljs-built_in">this</span>, offset, fromIndex, toIndex);        &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RandomAccess</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractList&lt;E&gt; parent;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parentOffset;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> offset;        <span class="hljs-type">int</span> size;        SubList(AbstractList&lt;E&gt; parent,                <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex) &#123;            <span class="hljs-built_in">this</span>.parent = parent;            <span class="hljs-built_in">this</span>.parentOffset = fromIndex;            <span class="hljs-built_in">this</span>.offset = offset + fromIndex;            <span class="hljs-built_in">this</span>.size = toIndex - fromIndex;            <span class="hljs-built_in">this</span>.modCount = ArrayList.<span class="hljs-built_in">this</span>.modCount;        &#125;        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E e)</span> &#123;            rangeCheck(index);            checkForComodification();            <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> ArrayList.<span class="hljs-built_in">this</span>.elementData(offset + index);            ArrayList.<span class="hljs-built_in">this</span>.elementData[offset + index] = e;            <span class="hljs-keyword">return</span> oldValue;        &#125;        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;            rangeCheck(index);            checkForComodification();            <span class="hljs-keyword">return</span> ArrayList.<span class="hljs-built_in">this</span>.elementData(offset + index);        &#125;    &#125;</code></pre></div><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a>Arrays.asList</h2><p>该方法通常用于将一个数组转换成一个List集合，但是需要注意不能使用其修改集合的相关方法，add&#x2F;remove&#x2F;clear会抛出<code>UnsupportedOperationException</code>，因为该方法返回的<code>ArrayList</code>是<code>Arrays</code>的一个内部类。其内部没有实现集合的修改方法。</p><p>其次传递的数组必须是对象数组，而不能是基本类型，如果传入基本类型数组，该方法得到的就是数组对象本身，而不是元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span>    <span class="hljs-meta">@SuppressWarnings(&quot;varargs&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">asList</span><span class="hljs-params">(T... a)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(a);    &#125;</code></pre></div><p>演示：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);        list.add(<span class="hljs-string">&quot;yes&quot;</span>);        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;        List&lt;<span class="hljs-type">int</span>[]&gt; list1 = Arrays.asList(arr);        System.out.println(list1.get(<span class="hljs-number">2</span>));    &#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对<code>ArrayList</code>的成员变量，构造方法，API，扩容机制与其它细节做了简单介绍。并对日常开发中会使用到的一些细节做了简要描述，可以减少在日常开发过程中犯错误的几率。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存更新策略总结</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h2><p>具体逻辑如下：</p><ul><li>写策略：更DB数据，再删除cache数据</li><li>读策略：<ul><li>cache hit：直接返回命中数据。</li><li>cache miss：从数据库中读取，然后将数据写入cache，并返回。</li></ul></li></ul><p>适用场景：</p><ul><li>适合读多写少的场景，不适合写多的场景。</li></ul><h2 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read&#x2F;Write Through"></a>Read&#x2F;Write Through</h2><p>具体逻辑如下：</p><ul><li>Read Through：写入时先查询cache是否hit，hit直接返回，miss则有cache组件负责去DB查，并写入cache，再返回。</li><li>Write Through：更新先查询cache是否hit，hit则更新缓存中数据，然后有cache组件更新到DB，完成后通知更新完成。若miss则直接更新数据库</li></ul><h2 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h2><p>具体逻辑如下：</p><ul><li>只更新缓存，立即返回，持久层更新采用异步更新方式。</li></ul><p>广泛用于OS，比如CPU Cache、文件系统Cache，数据非强一致性，存在丢数据的问题。</p><p>适用场景：写多场景</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存优化</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><blockquote><p>info memory</p></blockquote><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">used_memory</span>:<span class="hljs-number">701520</span>                      redis分配器分配的内存量，也就是实际存储数据的内润使用总量<span class="hljs-attribute">used_memory_human</span>:<span class="hljs-number">685</span>.<span class="hljs-number">08</span>K               以可读格式返回redis使用的内存总量<span class="hljs-attribute">used_memory_rss</span>:<span class="hljs-number">664584</span>                  从操作系统角度，redis进程占用的总物理内存<span class="hljs-attribute">used_memory_rss_human</span>:<span class="hljs-number">649</span>.<span class="hljs-number">01</span>K          <span class="hljs-attribute">used_memory_peak</span>:<span class="hljs-number">778480</span>                  内存分配器分配的最大内存，代表`used_memory`的历史峰值<span class="hljs-attribute">used_memory_peak_human</span>:<span class="hljs-number">760</span>.<span class="hljs-number">23</span>K          以可读的格式显示内存的消耗峰值<span class="hljs-attribute">total_system_memory</span>:<span class="hljs-number">0</span><span class="hljs-attribute">total_system_memory_human</span>:<span class="hljs-number">0</span>B<span class="hljs-attribute">used_memory_lua</span>:<span class="hljs-number">37888</span>                   Lua引擎消耗的内存<span class="hljs-attribute">used_memory_lua_human</span>:<span class="hljs-number">37</span>.<span class="hljs-number">00</span>K<span class="hljs-attribute">maxmemory</span>:<span class="hljs-number">0</span><span class="hljs-attribute">maxmemory_human</span>:<span class="hljs-number">0</span>B<span class="hljs-attribute">maxmemory_policy</span>:noeviction<span class="hljs-attribute">mem_fragmentation_ratio</span>:<span class="hljs-number">0</span>.<span class="hljs-number">95</span>            内存碎片率，used_memory_rss/used_memory<span class="hljs-attribute">mem_allocator</span>:jemalloc-<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">0</span>            redis使用的内存分配器</code></pre></div><h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p>Redis中使用的内存可分为如下几类：</p><ul><li>自身内存：自身维护的数据字典等元数据，占用较少</li><li>对象内存：存储的所有entry对象</li><li>缓存：客户端缓冲区+AOF缓冲区等</li><li>Lua内存：用于加载Lua脚本</li><li>子进程内存：一般是持久化时fork出来的子进程占用的内存</li><li>运行内存：运行时消耗的内存</li><li>内存碎片：Redis使用jemalloc来分配内存，按照固定大小划分，当删除数据后，释放的内存不会立即返回给OS，Redis无法有效利用，因此形成碎片。</li></ul><h2 id="内存优化方案"><a href="#内存优化方案" class="headerlink" title="内存优化方案"></a>内存优化方案</h2><h3 id="对象内存"><a href="#对象内存" class="headerlink" title="对象内存"></a>对象内存</h3><p>Redis中对象大多有两种存储方案，尽量将大小控制在较为节省的存储阈值之内。</p><h3 id="客户端缓冲区"><a href="#客户端缓冲区" class="headerlink" title="客户端缓冲区"></a>客户端缓冲区</h3><p>客户端缓冲区占用内存较大的原因如下：</p><ul><li>client访问大key，导致client输出缓存异常增长。</li><li>client使用monitor命令，它会将所有访问redis的命令持续放到输出缓冲区，导致输出缓冲区异常增长。</li><li>clinet使用pipeline封装了大量命令</li><li>从节点复制慢，导致主节点输出缓冲区积压。</li></ul><p>优化方案:</p><ul><li>大key需要进行拆分</li><li>尽量避免使用monitor等指令</li><li>使用pipeline设置最大阈值</li><li>主从复制区设置阈值</li></ul><h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><ul><li>手动执行memory purge命令</li><li>通过配置参数进行控制</li></ul><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">activedefrag</span> yes：启用自动碎片清理开关<span class="hljs-attribute">active</span>-defrag-ignore-bytes <span class="hljs-number">100</span>mb：内存碎片空间达到多少才开启碎片整理<span class="hljs-attribute">active</span>-defrag-threshold-lower <span class="hljs-number">10</span>：碎片率达到百分之多少才开启碎片整理<span class="hljs-attribute">active</span>-defrag-threshold-upper <span class="hljs-number">100</span>：内存碎片率超过多少，则尽最大努力整理（占用最大资源去做碎片整理）<span class="hljs-attribute">active</span>-defrag-cycle-min <span class="hljs-number">25</span>：内存自动整理占用资源最小百分比<span class="hljs-attribute">active</span>-defrag-cycle-max <span class="hljs-number">75</span>：内存自动整理占用资源最大百分比</code></pre></div><h3 id="子进程优化"><a href="#子进程优化" class="headerlink" title="子进程优化"></a>子进程优化</h3><p>Linux中的fork使用了copy on write机制，fork之后与父进程共享内存空间，只有发生写操作修改内存数据时，才会真正分配内存空间。</p><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><h3 id="键值生命周期"><a href="#键值生命周期" class="headerlink" title="键值生命周期"></a>键值生命周期</h3><ul><li>周期数据需要设置过期时间，<code>object idle time</code>可以找垃圾key-value</li><li>过期时间不宜集中，会导致缓存穿透和雪崩等问题</li></ul><h3 id="命令使用技巧"><a href="#命令使用技巧" class="headerlink" title="命令使用技巧"></a>命令使用技巧</h3><ul><li>O(n)以上命令关注n的数量<ul><li>hgetall,lrange,smembers,zrange,sinter等</li></ul></li><li>禁用命令<ul><li>禁止线上使用keys,flushall,flushdb，通过redis的rename机制禁用掉命令，或者使用scan的方式渐进式处理</li></ul></li><li>合理使用select<ul><li>redis的多数据库较弱，使用数字进行区分</li><li>很多客户端支持较差</li><li>同时多业务用多数据库实际上还是单线程处理，会有干扰</li></ul></li><li>redis的事务功能较弱，不建议过多使用<ul><li>不支持回滚</li></ul></li><li>redis集群版本在使用Lua上有特殊要求<ul><li>所有的key，必须爱一个slot上，否则返回error</li></ul></li><li>必要情况下使用monitor命令时，注意不要长时间使用</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群机制分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h2><p>Redis集群实现数据同步，保证服务高可用。</p><ul><li><p>一主多从</p></li><li><p>数据流向是单向的，master-&gt;slave</p></li></ul><p>开启指令：</p><div class="code-wrapper"><pre><code class="hljs stata">slaveof 192.168.1.10 6379<span class="hljs-comment">//当前服务节点称为指定IP的从节点</span>slaveof <span class="hljs-keyword">no</span> <span class="hljs-keyword">one</span>                  <span class="hljs-comment">//取消从属关系</span></code></pre></div><p>配置文件：</p><div class="code-wrapper"><pre><code class="hljs arduino">slaveof ip portslave-read-only yes             <span class="hljs-comment">//从节点只读</span></code></pre></div><p>全量复制的开销：</p><ul><li>bgsave的时间</li><li>RDB文件网络传输时间</li><li>从节点清空数据时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Redis复制分为同步和命令传播两个操作：</p><ul><li>同步：将从服务器的数据库状态更新为主库状态</li><li>命令传播：同步完后，主库状态又发生变化，此时使用命令传播完成状态同步。</li></ul><p>Redis使用<code>PSYNC</code>可以同时解决全量复制和部分复制两种情况。</p><p>需要维护的变量包括 ：</p><ul><li>runID：每个Redis实例启动生成的随机ID</li><li>offset：复制进度</li></ul><p>执行<code>slaveof</code>时，slave节点会将master的地址保存在：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span>    <span class="hljs-type">char</span> *masterhost;    <span class="hljs-type">int</span> masterport;&#125;</code></pre></div><p>slave节点会将该命令封装成通信协议并发给master，完成socket建立，并发送PING检查socket是否正常。</p><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p>命令传播的阶段，slave默认每秒一次的频率，向master发送心跳：</p><div class="code-wrapper"><pre><code class="hljs xml">REPLCONF ACK <span class="hljs-tag">&lt;<span class="hljs-name">replication_offset</span>&gt;</span>replication_offset为slave当前的复制偏移量</code></pre></div><p>心跳主要有三个作用：</p><ul><li>检测主从之间连接状态：节点保活机制</li><li>辅助实现min-slaves：防止master在不安全的情况下执行写命令。<ul><li><code>min-slaves-to-write</code></li><li><code>min-slaves-max-log</code></li></ul></li><li>检测命令丢失：如果因为网络原因产生命令丢失，master发现slave的offset小于自己当前offset，则认为产生命令丢失，并按照slave的offset传递数据。</li></ul><h2 id="sentinel机制"><a href="#sentinel机制" class="headerlink" title="sentinel机制"></a>sentinel机制</h2><p>主从复制存在的问题</p><ul><li>手动故障转移：master发生宕机，需要手动切换</li><li>写能力和存储能力受限</li></ul><p>Sentinel（机制）是Redis官方推荐的高可用性(HA)解决方案，由一个或多个sentinel组成的sentinel system，可以监视主从集群的状态，当master发生宕机，自动将master下面的某个slave升级为新的master。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><div class="code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/redis-sentinel /</span>path<span class="hljs-regexp">/to/</span>sentinel.conf</code></pre></div><p>启动流程会执行以下步骤：</p><ul><li>初始化server：sentinel本质上是一个运行在特殊模式的Redis服务器。</li><li>代码：sentinel使用<code>sentinel.c/REDIS_SENTINEL_PORT</code>作为默认端口，使用<code>sentinel.c/sentinelcmds</code>作为命令表</li><li>初始化sentinel状态：<code>sentinel.c/sentinelState</code>结构</li><li>根据配置文件，初始化sentinel监视的主服务器列表：上面的结构使用<code>dict</code>保存master信息，key为master的名称，value为master对应的<code>sentinel.c/sentinelRedisInstance</code>，每个被监视的Redis服务器实例都被使用该结构存储。master的IP端口信息使用<code>struct sentinelAddr</code>进行存储。该数据sentinel初始化时从<code>sentinel.conf</code>完成加载。</li><li>创建连向master的socket连接：sentinel节点对master创建两个异步连接：<ul><li>命令连接：专门向master发送命令，并接收回复</li><li>订阅连接：订阅master的<code>__sentinel__:hello</code>频道，用于sentinel发现其他sentinel节点</li></ul></li></ul><h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><p>每10s每个sentinel会对master发送<code>info</code>命令，sentinel主要获取两方面信息：</p><ul><li>master信息：run ID、role</li><li>master对应的slave信息，包括IP端口、状态，偏移量等</li></ul><p>当获取到对应slave节点信息后，sentinel会创建到slave的两个连接，创建完命令连接后， 每10s对slave发送<code>info</code>命令，sentinel会获取以下信息：</p><ul><li>slave：run ID、role、master_port、master_host、主从之间的连接状态</li></ul><p>sentinel默认每2s向所有节点的<code>__sentinel__:hello</code>发送消息，主要是sentinel本身信息和master的信息。并且sentinel会通过订阅连接不断接收主从节点发来的消息，这里面是sentinel信息，如果与当前sentinel不同，说明是其他sentinel，那么当前sentinel会更新sentinel字典信息，并创建连向新sentinel的命令连接。</p><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><p>sentinel每1s向所有实例发送PING，包括主从、其他sentinel，并通过实例是否返回PONG判断是否在线。配置文件中的<code>down-after-milliseconds</code>内，未收到回复，sentinel就会将该实例标记为主观下线状态。但是多个sentinel的主线下线阈值不同，可能存在某节点在sentinelA是离线，在sentinelB是在线。</p><h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><p>多个sentinel实例对同一台服务器做出SDOWN判断，并且通过<code>sentinel is-master-down-by-addr ip</code>命令互相交流之后，得出服务器下线的判断。客观下线是足够的sentinel都将服务器标记为主观下线之后，服务器才会标记为客观下线。</p><h3 id="sentinel选举"><a href="#sentinel选举" class="headerlink" title="sentinel选举"></a>sentinel选举</h3><p>当某个master被判断为客观下线后，各个sentinel会进行协商，选举出一个主sentinel，并由主sentinel完成故障转移等操作。选举算法是Raft，<strong>选举规则</strong>如下：</p><ul><li>所有sentinel拥有相同资格参与选举、每次完成选举后，epoch都会自增一次</li><li>当A向B发送<code>sentinel is-master-down-by-addr ip</code>时，A要求B将其设置为主sentinel。最先向B发送的将会成为B的局部主sentinel。</li><li>B接收到A的命令，回复信息中分别由局部主sentinel的run ID和<code>leader_epoch</code>。</li><li>A接收到回复，B的局部主sentinel是否为自己，如果A称为半数以上的局部主sentinel，则会成为全局主sentinel。</li><li>规定时间内未完成选举，则会再进行。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>选举出主sentinel后，主sentinel会将已下线的master进行故障转移，步骤如下：</p><ul><li>已下线的master从属的slave列表中挑选一个，并将其转换为master。挑选其中状态良好、数据完整的slave。</li><li>让其他slave改为复制新的master的数据。向其他slave发送<code>SLAVEOF</code>。</li></ul><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><p>Redis集群是Redis提供的分布式数据库方案，通过sharding完成数据共享，并通过复制、故障转移来提供高可用特性。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>一个集群由多个Node构成，刚运行时都是独立的Node，需要通过<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>指令来构成集群。<code>CLUSTER NODE</code>可以查询集群信息。Node通过以下配置参数判断是否以集群模式启动：</p><div class="code-wrapper"><pre><code class="hljs bash">cluster-enabled <span class="hljs-built_in">yes</span></code></pre></div><p>Node使用以下struct来定义：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 节点状态</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNode</span> &#123;</span>    <span class="hljs-comment">// 创建节点的时间</span>    <span class="hljs-type">mstime_t</span> ctime; <span class="hljs-comment">/* Node object creation time. */</span>    <span class="hljs-comment">// 节点的名字，由 40 个十六进制字符组成</span>    <span class="hljs-comment">// 例如 68eef66df23420a5862208ef5b1a7005b806f2ff</span>    <span class="hljs-type">char</span> name[REDIS_CLUSTER_NAMELEN]; <span class="hljs-comment">/* Node name, hex string, sha1-size */</span>    <span class="hljs-comment">// 节点标识</span>    <span class="hljs-comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span>    <span class="hljs-comment">// 以及节点目前所处的状态（比如在线或者下线）。</span>    <span class="hljs-type">int</span> flags;      <span class="hljs-comment">/* REDIS_NODE_... */</span>    <span class="hljs-comment">// 节点当前的配置纪元，用于实现故障转移</span>    <span class="hljs-type">uint64_t</span> configEpoch; <span class="hljs-comment">/* Last configEpoch observed for this node */</span>        <span class="hljs-comment">// 该节点负责处理的槽数量</span>    <span class="hljs-type">int</span> numslots;   <span class="hljs-comment">/* Number of slots handled by this node */</span>    <span class="hljs-comment">// 如果本节点是主节点，那么用这个属性记录从节点的数量</span>    <span class="hljs-type">int</span> numslaves;  <span class="hljs-comment">/* Number of slave nodes, if this is a master */</span>    <span class="hljs-comment">// 指针数组，指向各个从节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNode</span> **<span class="hljs-title">slaves</span>;</span> <span class="hljs-comment">/* pointers to slave nodes */</span>    <span class="hljs-comment">// 如果这是一个从节点，那么指向主节点</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNode</span> *<span class="hljs-title">slaveof</span>;</span> <span class="hljs-comment">/* pointer to the master node */</span>    <span class="hljs-comment">// 最后一次发送 PING 命令的时间</span>    <span class="hljs-type">mstime_t</span> ping_sent;      <span class="hljs-comment">/* Unix time we sent latest ping */</span>    <span class="hljs-comment">// 最后一次接收 PONG 回复的时间戳</span>    <span class="hljs-type">mstime_t</span> pong_received;  <span class="hljs-comment">/* Unix time we received the pong */</span>    <span class="hljs-comment">// 最后一次被设置为 FAIL 状态的时间</span>    <span class="hljs-type">mstime_t</span> fail_time;      <span class="hljs-comment">/* Unix time when FAIL flag was set */</span>    <span class="hljs-comment">// 最后一次给某个从节点投票的时间</span>    <span class="hljs-type">mstime_t</span> voted_time;     <span class="hljs-comment">/* Last time we voted for a slave of this master */</span>    <span class="hljs-comment">// 最后一次从这个节点接收到复制偏移量的时间</span>    <span class="hljs-type">mstime_t</span> repl_offset_time;  <span class="hljs-comment">/* Unix time we received offset for this node */</span>    <span class="hljs-comment">// 这个节点的复制偏移量</span>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> repl_offset;      <span class="hljs-comment">/* Last known repl offset for this node. */</span>    <span class="hljs-comment">// 节点的 IP 地址</span>    <span class="hljs-type">char</span> ip[REDIS_IP_STR_LEN];  <span class="hljs-comment">/* Latest known IP address of this node */</span>    <span class="hljs-comment">// 节点的端口号</span>    <span class="hljs-type">int</span> port;                   <span class="hljs-comment">/* Latest known port of this node */</span>    <span class="hljs-comment">// 保存连接节点所需的有关信息</span>    clusterLink *link;          <span class="hljs-comment">/* TCP/IP link with this node */</span>    <span class="hljs-comment">// 一个链表，记录了所有其他节点对该节点的下线报告</span>    <span class="hljs-built_in">list</span> *fail_reports;         <span class="hljs-comment">/* List of nodes signaling this as failing */</span>&#125;;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterLink</span> &#123;</span>    <span class="hljs-comment">// 连接的创建时间</span>    <span class="hljs-type">mstime_t</span> ctime;             <span class="hljs-comment">/* Link creation time */</span>    <span class="hljs-comment">// TCP 套接字描述符</span>    <span class="hljs-type">int</span> fd;                     <span class="hljs-comment">/* TCP socket file descriptor */</span>    <span class="hljs-comment">// 输出缓冲区，保存着等待发送给其他节点的消息（message）。</span>    sds sndbuf;                 <span class="hljs-comment">/* Packet send buffer */</span>    <span class="hljs-comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span>    sds rcvbuf;                 <span class="hljs-comment">/* Packet reception buffer */</span>    <span class="hljs-comment">// 与这个连接相关联的节点，如果没有的话就为 NULL</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clusterNode</span> *<span class="hljs-title">node</span>;</span>   <span class="hljs-comment">/* Node related to this link if any, or NULL */</span>&#125; clusterLink;</code></pre></div><h3 id="分片方式"><a href="#分片方式" class="headerlink" title="分片方式"></a>分片方式</h3><p>集群通过<strong>分片</strong>的方式保存数据，当请求进入，计算key的hash值，并对16383进行取余，得到指定slot位置 。整个数据库被分为16384个slot，这些slot会被平均分配给各个节点。slot被定义在<code>clusterNode</code>中，整个slot数组长度为2048 bytes，以<code>bitmap</code>形式进行存储。处理slot的node的映射信息存储在<code>clusterState</code>中。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 槽数量</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_CLUSTER_SLOTS 16384</span><span class="hljs-comment">// 由这个节点负责处理的槽</span><span class="hljs-comment">// 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长</span><span class="hljs-comment">// 每个字节的每个位记录了一个槽的保存状态</span><span class="hljs-comment">// 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理</span><span class="hljs-comment">// 比如 slots[0] 的第一个位保存了槽 0 的保存情况</span><span class="hljs-comment">// slots[0] 的第二个位保存了槽 1 的保存情况，以此类推</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> slots[REDIS_CLUSTER_SLOTS/<span class="hljs-number">8</span>];<span class="hljs-comment">// 该节点负责处理的槽数量</span><span class="hljs-type">int</span> numslots;<span class="hljs-comment">// 存储处理各个槽的节点</span><span class="hljs-comment">// 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理</span>clusterNode *slots[REDIS_CLUSTER_SLOTS];</code></pre></div><p>至于为什么需要存储slot-&gt;node的映射，是为了解决<strong>想知道slot[i]由哪个node存储</strong>，使用该映射能在$O(1)$内查询到，否则需要遍历<code>clusterState.nodes</code>字典中的所有<code>clusterNode</code>结构，检查这些结构的slots数组，直到找到负责处理slot{i]的节点为止。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 将slot分配给指定节点</span><span class="hljs-attribute">CLUSTER</span> ADDSLOTS ＜slot＞<span class="hljs-meta"> [slot ...]</span></code></pre></div><h3 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h3><p>假设客户端向集群发送key相关指令，处理流程如下：</p><ol><li>接受命令的Node计算出key属于哪个slot，并判断当前slot是否属于自己，是则执行<ul><li>通过<code>CRC16(key) &amp; 16383</code>计算key的所属slot</li></ul></li><li>否则给客户端返回MOVED错误（附带处理该slot的Node信息），客户端重新给正确Node发送请求。<ul><li><code>MOVED ＜slot＞ ＜ip＞:＜port＞</code></li></ul></li></ol><h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>Cluster底层通信协议为Gossip协议，集群中每个节点定期向其他节点发送PING，以此交换各个节点状态。</p><h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>集群中节点定期向其他节点发送PING，检测对方是否在线，如果未收到PONG，则会将其标记为<code>probable fail</code>，如果集群中半数以上认为某节点疑似下线。则会向其他节点广播某节点<code>fail</code>的情况。</p><p>当某个slave发现自己正在复制的master进入fail状态，则会进行故障转移：</p><ul><li>选取master中一个slave，并执行<code>SLAVEOF no one</code>，成为新的master</li><li>新的master会撤销所有已下线的master的指派slot，并将这些都指派给自己</li><li>新的master广播一条PONG消息，通知其他节点其已成为master</li></ul><h3 id="集群选主"><a href="#集群选主" class="headerlink" title="集群选主"></a>集群选主</h3><p>Redis Cluster的选举算法基于Raft实现。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis数据保存在内存中，为了防止进程异常退出而导致数据丢失，可以考虑将数据保存到磁盘上。</p><p>Redis提供的两种持久化方案：</p><ul><li>RDB：直接将数据库状态写到文件，既可以手动执行，也可以配置为定期执行。</li><li>AOF：将写命令append到AOF文件中。</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>两种方案：</p><ul><li>save：直接执行</li><li>bgsave：fork一个子进程执行</li></ul><p><code>rdbSave</code>是save的具体实现函数，bgsave与其区别是通过fork子进程完成备份，并在完成后给父进程发送信号。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rdbSave</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename)</span> &#123;    dictIterator *di = <span class="hljs-literal">NULL</span>;    dictEntry *de;    <span class="hljs-type">char</span> tmpfile[<span class="hljs-number">256</span>];    <span class="hljs-type">char</span> magic[<span class="hljs-number">10</span>];    <span class="hljs-type">int</span> j;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> now = mstime();    FILE *fp;    rio rdb;    <span class="hljs-type">uint64_t</span> cksum;    <span class="hljs-comment">// 创建临时文件</span>    <span class="hljs-built_in">snprintf</span>(tmpfile,<span class="hljs-number">256</span>,<span class="hljs-string">&quot;temp-%d.rdb&quot;</span>, (<span class="hljs-type">int</span>) getpid());    fp = fopen(tmpfile,<span class="hljs-string">&quot;w&quot;</span>);    <span class="hljs-keyword">if</span> (!fp) &#123;        redisLog(REDIS_WARNING, <span class="hljs-string">&quot;Failed opening .rdb for saving: %s&quot;</span>,            strerror(errno));        <span class="hljs-keyword">return</span> REDIS_ERR;    &#125;    <span class="hljs-comment">// 初始化 I/O</span>    rioInitWithFile(&amp;rdb,fp);    <span class="hljs-comment">// 设置校验和函数</span>    <span class="hljs-keyword">if</span> (server.rdb_checksum)        rdb.update_cksum = rioGenericUpdateChecksum;    <span class="hljs-comment">// 写入 RDB 版本号</span>    <span class="hljs-built_in">snprintf</span>(magic,<span class="hljs-keyword">sizeof</span>(magic),<span class="hljs-string">&quot;REDIS%04d&quot;</span>,REDIS_RDB_VERSION);    <span class="hljs-keyword">if</span> (rdbWriteRaw(&amp;rdb,magic,<span class="hljs-number">9</span>) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;    <span class="hljs-comment">// 遍历所有数据库</span>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; server.dbnum; j++) &#123;        <span class="hljs-comment">// 指向数据库</span>        redisDb *db = server.db+j;        <span class="hljs-comment">// 指向数据库键空间</span>        dict *d = db-&gt;dict;        <span class="hljs-comment">// 跳过空数据库</span>        <span class="hljs-keyword">if</span> (dictSize(d) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 创建键空间迭代器</span>        di = dictGetSafeIterator(d);        <span class="hljs-keyword">if</span> (!di) &#123;            fclose(fp);            <span class="hljs-keyword">return</span> REDIS_ERR;        &#125;        <span class="hljs-comment">/* Write the SELECT DB opcode </span><span class="hljs-comment">         *</span><span class="hljs-comment">         * 写入 DB 选择器</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_SELECTDB) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;        <span class="hljs-keyword">if</span> (rdbSaveLen(&amp;rdb,j) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;        <span class="hljs-comment">/* Iterate this DB writing every entry </span><span class="hljs-comment">         *</span><span class="hljs-comment">         * 遍历数据库，并写入每个键值对的数据</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;            sds keystr = dictGetKey(de);            robj key, *o = dictGetVal(de);            <span class="hljs-type">long</span> <span class="hljs-type">long</span> expire;                        <span class="hljs-comment">// 根据 keystr ，在栈中创建一个 key 对象</span>            initStaticStringObject(key,keystr);            <span class="hljs-comment">// 获取键的过期时间</span>            expire = getExpire(db,&amp;key);            <span class="hljs-comment">// 保存键值对数据</span>            <span class="hljs-keyword">if</span> (rdbSaveKeyValuePair(&amp;rdb,&amp;key,o,expire,now) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;        &#125;        dictReleaseIterator(di);    &#125;    di = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* So that we don&#x27;t release it again on error. */</span>    <span class="hljs-comment">/* EOF opcode </span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 写入 EOF 代码</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_EOF) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;    <span class="hljs-comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span><span class="hljs-comment">     * loading code skips the check in this case. </span><span class="hljs-comment">     *</span><span class="hljs-comment">     * CRC64 校验和。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 如果校验和功能已关闭，那么 rdb.cksum 将为 0 ，</span><span class="hljs-comment">     * 在这种情况下， RDB 载入时会跳过校验和检查。</span><span class="hljs-comment">     */</span>    cksum = rdb.cksum;    memrev64ifbe(&amp;cksum);    rioWrite(&amp;rdb,&amp;cksum,<span class="hljs-number">8</span>);    <span class="hljs-comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span>    <span class="hljs-comment">// 冲洗缓存，确保数据已写入磁盘</span>    <span class="hljs-keyword">if</span> (fflush(fp) == EOF) <span class="hljs-keyword">goto</span> werr;    <span class="hljs-keyword">if</span> (fsync(fileno(fp)) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> werr;    <span class="hljs-keyword">if</span> (fclose(fp) == EOF) <span class="hljs-keyword">goto</span> werr;    <span class="hljs-comment">/* Use RENAME to make sure the DB file is changed atomically only</span><span class="hljs-comment">     * if the generate DB file is ok. </span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span> (rename(tmpfile,filename) == <span class="hljs-number">-1</span>) &#123;        redisLog(REDIS_WARNING,<span class="hljs-string">&quot;Error moving temp DB file on the final destination: %s&quot;</span>, strerror(errno));        unlink(tmpfile);        <span class="hljs-keyword">return</span> REDIS_ERR;    &#125;    <span class="hljs-comment">// 写入完成，打印日志</span>    redisLog(REDIS_NOTICE,<span class="hljs-string">&quot;DB saved on disk&quot;</span>);    <span class="hljs-comment">// 清零数据库脏状态</span>    server.dirty = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录最后一次完成 SAVE 的时间</span>    server.lastsave = time(<span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// 记录最后一次执行 SAVE 的状态</span>    server.lastbgsave_status = REDIS_OK;    <span class="hljs-keyword">return</span> REDIS_OK;werr:    <span class="hljs-comment">// 关闭文件</span>    fclose(fp);    <span class="hljs-comment">// 删除文件</span>    unlink(tmpfile);    redisLog(REDIS_WARNING,<span class="hljs-string">&quot;Write error saving DB on disk: %s&quot;</span>, strerror(errno));    <span class="hljs-keyword">if</span> (di) dictReleaseIterator(di);    <span class="hljs-keyword">return</span> REDIS_ERR;&#125;</code></pre></div><h3 id="RDB载入还原"><a href="#RDB载入还原" class="headerlink" title="RDB载入还原"></a>RDB载入还原</h3><p>Redis对RDB文件的载入还原步骤如下：</p><ul><li>判断是否开启AOF持久化功能，若开启载入AOF文件</li><li>否则载入RDB文件</li></ul><p>之所以优先载入AOF文件，是因为：<strong>AOF更新频率比RDB更高</strong></p><h3 id="定期执行"><a href="#定期执行" class="headerlink" title="定期执行"></a>定期执行</h3><p>Redis允许通过设置服务器配置项使server每隔一段时间自动执行一次BGSAVE命令。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> &lt;seconds&gt; &lt;changes&gt;<span class="hljs-meta"> [&lt;seconds&gt; &lt;changes&gt; ...]</span><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>//<span class="hljs-number">900</span>s之内，进行了至少<span class="hljs-number">1</span>次修改操作<span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">5</span>//<span class="hljs-number">300</span>s之内，进行了至少<span class="hljs-number">10</span>次修改操作<span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">2</span>//<span class="hljs-number">60</span>s之内，进行了至少<span class="hljs-number">2</span>次修改操作</code></pre></div><p>以上的配置项保存在<code>struct redisServer&gt;saveparams</code>字段中，这是一个数组，<code>saveparam</code>的结构如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 服务器的保存条件（BGSAVE 自动执行的条件）</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">saveparam</span> &#123;</span>    <span class="hljs-comment">// 多少秒之内</span>    <span class="hljs-type">time_t</span> seconds;    <span class="hljs-comment">// 发生多少次修改</span>    <span class="hljs-type">int</span> changes;&#125;;</code></pre></div><p>同时server状态还维持了两个相关的变量：</p><ul><li>dirty：修改计数器，记录距离上次执行save指令，服务器对数据库状态进行了多少次修改。</li><li>lastsave：UNIX时间戳，记录上次成功执行SAVE的时间。</li></ul><p>Redis中的定时任务函数<code>serverCron</code>其中由于一项工作就是遍历<code>saveparams</code>选项的条件是否满足，满足的话则执行。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>按照顺序结构如下：</p><ul><li>REDIS：5 bytes，为REDIS五个字符，快速检查载入的文件是否为RDB文件</li><li>db_version：4 bytes，字符串表示的整数，记录RDB文件的版本号</li><li>databases：包含多个数据库以及对应数据<ul><li>每个非空数据库都可以保存SELECTDB、db_number、key_value_pairs。</li></ul></li><li>EOF：1 byte，标志着正文内容的结束</li><li>check_sum：8 bytes的无符号整数，是对前四个部分计算得出的，载入文件时会对比check_sum，以此检查文件是否出错。</li></ul><div class="code-wrapper"><pre><code class="hljs c">root@pc:/opt/redis<span class="hljs-meta"># od -c dump.rdb </span><span class="hljs-number">0000000</span>   R   E   D   I   S   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span> <span class="hljs-number">372</span>  \t   r   e   d   i   s<span class="hljs-number">0000020</span>   -   v   e   r  \v   <span class="hljs-number">2</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>   .   <span class="hljs-number">2</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span>   .   <span class="hljs-number">2</span>   <span class="hljs-number">5</span>   <span class="hljs-number">5</span><span class="hljs-number">0000040</span> <span class="hljs-number">372</span>  \n   r   e   d   i   s   -   b   i   t   s <span class="hljs-number">300</span>   @ <span class="hljs-number">372</span> <span class="hljs-number">005</span><span class="hljs-number">0000060</span>   c   t   i   m   e <span class="hljs-number">302</span> <span class="hljs-number">314</span> <span class="hljs-number">213</span> <span class="hljs-number">354</span>   b <span class="hljs-number">372</span>  \b   u   s   e   d<span class="hljs-number">0000100</span>   -   m   e   m <span class="hljs-number">302</span>   @ <span class="hljs-number">032</span> <span class="hljs-number">020</span>  \<span class="hljs-number">0</span> <span class="hljs-number">372</span>  \b   a   o   f   -   b<span class="hljs-number">0000120</span>   a   s   e <span class="hljs-number">300</span>  \<span class="hljs-number">0</span> <span class="hljs-number">376</span>  \<span class="hljs-number">0</span> <span class="hljs-number">373</span> <span class="hljs-number">001</span>  \<span class="hljs-number">0</span>  \<span class="hljs-number">0</span> <span class="hljs-number">005</span>   h   e   l   l<span class="hljs-number">0000140</span>   o <span class="hljs-number">005</span>   v   a   l   u   e <span class="hljs-number">377</span>   + <span class="hljs-number">361</span>   .   <span class="hljs-string">&#x27; 337 354  \n   0</span><span class="hljs-string">0000160</span></code></pre></div><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF是Redis的另一种持久化方案，这是通过保存写命令来记录数据库的状态，恢复时从前到后执行一次即可恢复数据。所有的命令都是以Redis的命令请求协议的格式来保存的。</p><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># 是否开启AOF，默认关闭（no）</span><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><span class="hljs-comment"># 指定 AOF 文件名</span>appendfilename appendonly.aof<span class="hljs-comment"># Redis支持三种不同的刷盘模式：</span><span class="hljs-comment"># appendfsync always #每次发生数据变化立即写入到磁盘中</span><span class="hljs-comment"># appendfsync no  #sync由OS控制</span>appendfsync everysec <span class="hljs-comment">#每秒钟写入磁盘一次</span><span class="hljs-comment">#设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no</span><span class="hljs-literal">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite <span class="hljs-literal">no</span> <span class="hljs-comment">#当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span>auto-aof-rewrite-percentage <span class="hljs-number">100</span><span class="hljs-comment">#当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span>auto-aof-rewrite-min-size 64mb</code></pre></div><h3 id="AOF实现"><a href="#AOF实现" class="headerlink" title="AOF实现"></a>AOF实现</h3><p>AOF的实现可以分为以下三个步骤：</p><ul><li>append：每次写命令执行完成后，会以协议格式将命令追加到<code>struct redisServer-&gt;aof_buf</code>中</li><li>write和sync：<code>serverCron</code>中会判断<code>appendfsync</code>的值来选择<code>flushAppendOnlyFile</code>的具体策略。<ul><li>always：将<code>aof_buf</code>中的所有内容write并sync到AOF文件</li><li>everysec：将<code>aof_buf</code>中的所有内容write到AOF文件，如果上次sync时间距离现在超过一秒钟，会fork一个进程再次对AOF文件进行sync。</li><li>no：将<code>aof_buf</code>中的所有内容同步写入到AOF文件，sync动作由OS决定。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 根据 AOF 政策，</span>   <span class="hljs-comment">// 考虑是否需要将 AOF 缓冲区中的内容写入到 AOF 文件中</span>   <span class="hljs-comment">/* AOF postponed flush: Try at every cron cycle if the slow fsync</span><span class="hljs-comment">    * completed. */</span>   <span class="hljs-keyword">if</span> (server.aof_flush_postponed_start) flushAppendOnlyFile(<span class="hljs-number">0</span>);   <span class="hljs-comment">/* AOF write errors: in this case we have a buffer to flush as well and</span><span class="hljs-comment">    * clear the AOF error in case of success to make the DB writable again,</span><span class="hljs-comment">    * however to try every second is enough in case of &#x27;hz&#x27; is set to</span><span class="hljs-comment">    * an higher frequency. */</span>   run_with_period(<span class="hljs-number">1000</span>) &#123;       <span class="hljs-keyword">if</span> (server.aof_last_write_status == REDIS_ERR)           flushAppendOnlyFile(<span class="hljs-number">0</span>);   &#125;</code></pre></div><h3 id="AOF载入还原"><a href="#AOF载入还原" class="headerlink" title="AOF载入还原"></a>AOF载入还原</h3><p>Redis对AOF文件的载入还原步骤如下：</p><ul><li>创建一个不带网络连接的fake client。</li><li>从AOF文件中分析并读取一条写命令，使用fake client执行，直至所有写命令全部执行完成。</li></ul><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>为了解决AOF文件大小膨胀的问题，Redis提供了AOF重写功能：Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件。新文件不会包含冗余命令，类似于Bitcask模型的merge操作，会对冗余指令进行合并，重写由<strong>子进程</strong>执行，并不会阻塞主线程。</p><p>为了防止重写期间，服务器继续处理写命令请求而导致数据不一致的问题，设置了一个重写缓冲区，server端接收到命令后，会将写命令同时发送给AOF缓冲区和重写缓冲区。</p><p>子进程完成AOF重写后，会给父进程发送一个信号，父进程的信号处理函数执行如下逻辑：</p><ol><li>将重写缓冲区中所有内容写入新的AOF文件中，保证数据一致性。</li><li>对新的AOF文件改名，原子地覆盖原文件。</li></ol><h2 id="RDB和AOF的对比"><a href="#RDB和AOF的对比" class="headerlink" title="RDB和AOF的对比"></a>RDB和AOF的对比</h2><ul><li>启动优先级：RDB低，AOF高</li><li>体积：RDB小，AOF大</li><li>恢复速度：RDB快</li><li>数据安全性：RDB丢数据，AOF根据策略决定</li><li>轻重：RDB较重</li></ul><p>Redis4.0提出了<strong>混合使用</strong>AOF和RDB的方法，RDB以一定频率执行，两次RDB执行期间，使用AOF记录两次之间的所有命令操作，第二次只需要将AOF中修改的数据进行更新即可。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL体系结构和存储引擎</title>
    <link href="/2020/MySQL/mysql-structure-and-engine/"/>
    <url>/2020/MySQL/mysql-structure-and-engine/</url>
    
    <content type="html"><![CDATA[<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>MySQL体系结构如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="MySQL体系结构"></p><p>分别由Client Connectors层、MySQL Server层以及存储引擎层组成。</p><ul><li>Client Connectors层：负责处理客户端的连接请求，与客户端创建连接。</li><li>MySQL Server层：<ul><li>Connection Pool：负责处理和存储数据库与客户端创建的连接，一个线程负责管理一个连接，包括了用户认证模块，就是用户登录身份的认证和鉴权以及安全管理</li><li>Service &amp; utilities：管理服务&amp;工具集，包括备份恢复、安全管理、集群管理、工具</li><li>SQL interface：负责接受客户端发送的各种语句</li><li>Parser：对SQL语句进行语法解析生成解析树</li><li>Optimizer：查询优化器会根据解析树生成执行计划，并选择合适的索引，然后按照执行计划执行SQL并与各个存储引擎交互</li><li>Caches：包括各个存储引擎的缓存部分，例如InnoDB的Buffer Pool</li></ul></li><li>存储引擎层：包括InnoDB，MyISAM以及支持归档的Archive和内存的Memory</li><li>存储引擎底部是物理存储层，包括二进制日志，数据文件，错误日志，慢查询日志，全日志，redo&#x2F;undo日志</li></ul><p>一条SQL语句的执行过程可以参照如下图示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/SQL%20process.png"></p><ol><li>与MySQL建立连接。</li><li>查询缓存，如果开启了Query。 Cache并且查询缓存中存在该查询语句，则直接将结果返回到客户端，没有开启或缓存未命中则由解析器进行语法语义解析，并生成解析树。</li><li>预处理器生成新的解析树。</li><li>查询优化器进行优化。</li><li>查询执行引擎执行SQL，通过API接口查询物理存储层的数据，并返回结果。</li></ol><p>其中，查询缓存于MySQL 8.0中移除，具体原因：查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上的所有的查询缓存都会被清空。</p><p>MySQL官方博客关于该技术移除的解释<a href="https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/">https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/</a></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="MySQL存储引擎"></p><p>在 MySQL 5.6 版本之前，默认的存储引擎都是 MyISAM，但 5.6 版本以后默认的存储引擎就是 InnoDB。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/InnoDB%E7%BB%93%E6%9E%84.png" alt="InnoDB结构"></p><p>InnoDB上半部分是实例层，位于内存中，下半部分是物理层，位于文件系统中。<br>其中实例层分为线程和内存，InnoDB中重要的线程有Master Thread（主线程），其优先级最高，主要负责调度其他线程，其内部有几个循环：主循环，后台循环，刷新循环，暂停循环，Master Thread 会根据其内部运行的相关状态在各循环间进行切换。</p><p>大部分操作在主循环中完成，其包含1s和10s两种操作：</p><ul><li>1s操作<ul><li>日志缓冲刷新到磁盘（即使事务未提交，也被执行）</li><li>最多可以刷100个新脏页到磁盘</li><li>执行并改变缓冲的操作</li><li>若当前没有用户活动，可以切换到后台循环</li></ul></li><li>10s操作<ul><li>最多可以刷新100个脏页到磁盘</li><li>合并至多5个被改变的缓冲</li><li>日志缓冲刷新到磁盘</li><li>删除无用的Undo页</li><li>刷新100个或10个脏页到磁盘，产生一个检查点</li><li>buf_dump_thread 负责将 buffer pool 中的内容 dump 到物理文件中，以便再次启动 MySQL 时，可以快速加热数据。</li><li>page_cleaner_thread 负责将 buffer pool 中的脏页刷新到磁盘，在 5.6 版本之前没有这个线程，刷新操作都是由主线程完成的，所以在刷新脏页时会非常影响 MySQL 的处理能力，在5.7 版本之后可以通过参数设置开启多个 page_cleaner_thread。</li><li>purge_thread 负责将不再使用的 Undo 日志进行回收。</li><li>read_thread 处理用户的读请求，并负责将数据页从磁盘上读取出来，可以通过参数设置线程数量。</li><li>write_thread 负责将数据页从缓冲区写入磁盘，也可以通过参数设置线程数量，page_cleaner 线程发起刷脏页操作后 write_thread 就开始工作了。</li><li>redo_log_thread 负责把日志缓冲中的内容刷新到 Redo log 文件中。</li><li>insert_buffer_thread 负责把 Insert Buffer 中的内容刷新到磁盘。实例层的内存部分主要包含 InnoDB Buffer Pool，这里包含 InnoDB 最重要的缓存内容。数据和索引页、undo 页、insert buffer 页、自适应 Hash 索引页、数据字典页和锁信息等。additional memory pool 后续已不再使用。Redo buffer 里存储数据修改所产生的 Redo log。double write buffer 是 double write 所需的 buffer，主要解决由于宕机引起的物理写入操作中断，数据页不完整的问题。</li></ul></li></ul><p>物理层在逻辑上分为系统表空间、用户表空间和Redo日志。</p><ul><li>系统表空间有ibdata文件和一些Undo，ibdata文件有insert buffer段、double write段、回滚段、索引段、数据字典段和Undo信息段。</li><li>用户表空间之以<code>.ibd</code>后缀结尾的文件，文件中包含 insert buffer 的 bitmap 页、叶子页（这里存储真正的用户数据）、非叶子页。InnoDB 表是索引组织表，采用 B+ 树组织存储，数据都存储在叶子节点中，分支节点（即非叶子页）存储索引分支查找的数据值。</li><li>Redo日志包括多个Redo文件，这些文件循环使用。当达到一定存储阈值会触发checkpoint刷脏页操作，同时也会在MySQL实例异常宕机后重启，InnoDB表数据自动还原回复过程中使用。</li></ul><p>InnoDB内存结构：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/InnoDB%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="内存结构"></p><ul><li>用户读取或者写入的最新数据都存储在 Buffer Pool 中，如果 Buffer Pool 中没有找到则会读取物理文件进行查找，之后存储到 Buffer Pool 中并返回给 MySQL Server。Buffer Pool 采用LRU 机制。</li><li>Redo log 是一个循环复用的文件集，负责记录InnoDB中所有对 Buffer Pool的物理修改日志</li></ul><p> InnoDB和MyIASM的区别</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/InnoDB%20VS%20MyIASM.png"></p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/InnoDB.png"></p><p>其次，InnoDB性能优于MyIASM，CPU核数与InnoDB读写能力呈线性关系。</p><p>InnoDB 核心要点：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/InnoDB%E8%A6%81%E7%82%B9.png"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis对象机制分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis中提供的数据结构都使用了下面的redisObject进行包装，通过包装可以提供不同场景下使用不同的数据结构的实现。Redis的对象机制还使用了<strong>引用计数</strong>方式的内存回收机制。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span>    <span class="hljs-comment">// 类型</span>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;    <span class="hljs-comment">// 编码</span>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-comment">// 对象最后一次被访问的时间</span>    <span class="hljs-type">unsigned</span> lru:REDIS_LRU_BITS; <span class="hljs-comment">/* lru time (relative to server.lruclock) */</span>    <span class="hljs-comment">// 引用计数</span>    <span class="hljs-type">int</span> refcount;    <span class="hljs-comment">// 指向实际值的指针</span>    <span class="hljs-type">void</span> *ptr;&#125; robj;</code></pre></div><p>type值可选：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_STRING 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_LIST 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_SET 2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ZSET 3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_HASH 4</span></code></pre></div><p>encoding可选：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="hljs-comment">/* Raw representation */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_INT 1     <span class="hljs-comment">/* Encoded as integer */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_HT 2      <span class="hljs-comment">/* Encoded as hash table */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="hljs-comment">/* Encoded as zipmap */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="hljs-comment">/* Encoded as regular linked list */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="hljs-comment">/* Encoded as ziplist */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="hljs-comment">/* Encoded as intset */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="hljs-comment">/* Encoded as skiplist */</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="hljs-comment">/* Embedded sds string encoding */</span></span></code></pre></div><h2 id="结构的编码方案"><a href="#结构的编码方案" class="headerlink" title="结构的编码方案"></a>结构的编码方案</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>编码策略如下：</p><ul><li>若保存的为整数值，并且可以用long表示，使用int进行编码</li><li>若保存的为字符串值，并且长度大于32字节，使用SDS存储，编码格式为raw</li><li>若保存的为字符串值，并且长度小于32字节，使用embstr进行编码</li></ul><p>embstr是对短字符串的优化编码，使用redisObject和sdshdr来表示字符串对象，embstr只调用一次内存分配函数来分配两个struct，raw编码使用两次内存分配函数分别完成分配。同理内存释放也如此。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>编码策略如下：</p><ul><li>列表对象字符串对象长度小于64字节，并且保存元素数量小于512，使用ziplist进行编码，否则使用linkedlist编码</li><li>上述两个阈值通过<code>list-max-ziplist-value</code>和<code>list-max-ziplist-entries</code>控制</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>编码策略如下：</p><ul><li>保存的所有键值长度都小于64字节，并且键值对数量小于512个，满足这两个条件使用ziplist编码，否则使用hashtable编码</li><li>阈值由<code>hash-max-ziplist-value</code>和<code>hash-max-ziplist-entries</code>控制</li><li>ziplist编码时，键值节点紧挨在一起，先添加的靠近表头</li><li>hashtable编码时，键值对使用dictEntry存储，键使用<code>StringObject</code>，值使用<code>StringObject</code></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>编码策略如下：</p><ul><li>集合对象保存的所有元素都是整数时，并且元素个数不超过512个，使用intset进行存储，否则使用hashtable存储</li><li>阈值通过<code>set-max-intset-entries</code>进行控制</li><li>intset编码时，集合存储在整数集合中</li><li>hashtable编码时，每个键都是<code>StringObject</code>，值为NULL</li></ul><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>编码策略如下：</p><ul><li>有序集合保存的元素数量小于128个，保存的所有成员长度都小于64字节，同时满足使用ziplist编码，否则使用skiplist编码，并使用hashtable进行辅助存储。</li><li>上述阈值使用<code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>来控制</li><li>ziplist中有序集合元素按score从大到小排序。</li><li>skiplist按照score从大到小保存了所有集合元素，支持范围查询等操作<ul><li>同时使用hashtable存储成员到score的映射（键为元素，值为score），通过hashtable可以在$O(1)$时间查到元素的score</li><li>skiplist和hashtable给你通过指针共享元素和score，因此不会浪费额外的内存。</li></ul></li></ul><p><strong>为什么同时使用跳表 + 哈希表 来实现有序集合？</strong></p><ul><li>若只用hashtable实现，尽管可以在$O(1)$时间内找到元素对应的score，但是无法满足范围查找，例如ZRANGE等命令，hashtable完成排序至少需要$O(N * logN)$的时间以及$O(N)$的空间。</li><li>若只用skiplist实现，根据元素查找score的操作升到$O(logN)$的时间复杂度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis过期删除策略与内存淘汰机制</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><p>过期删除策略主要有以下三种：</p><ul><li>定时删除：设置过期时间的同时，创建一个定时器，当到达过期时间后，执行删除操作。<ul><li>优点：对内存友好，不会长时间占用内存</li><li>缺点：对CPU不友好，当过期entry过多会占用大量CPU时间，并且创建定时器存在性能消耗。</li></ul></li><li>惰性删除：每次查询到该entry时，检查是否过期，若过期就删除，否则返回。<ul><li>优点：对CPU友好</li><li>缺点：无用数据占用大量内存空间，依赖于客户端请求对过期数据进行删除。有内存泄漏的风险。</li></ul></li><li>定期删除：每隔一段时间对数据库进行检查，删除其中的过期entry。<ul><li>综合考虑上述策略的优缺点，可以合理设置执行时长和频率。</li></ul></li></ul><p>Redis中主要配合使用<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略，在内存和CPU性能中取得平衡。<br>使用过期字典存储所有key的过期时间。key是一个指针，指向key对象，value是一个long long类型的整数，保存key的过期时间。</p><p>实现：</p><ul><li>惰性删除：<code>db.c/expireIfNeeded</code>在读写之前对key进行检查.</li><li>定期删除：<code>redis.c/activeExpireCycle</code>实现，每当Redis的<code>serverCron</code>执行时，都会主动清除过期数据。<ul><li><code>activeExpireCycle</code>的工作流程如下：<ul><li>每次取出一定数量的随机key进行检查，并删除其中的过期数据</li><li>全局变量<code>current_db</code>存储当前的检查进度（db编号），并且下次<code>activeExpireCycle</code>执行会接着上次进度进行处理。全部检查完毕后该变量置为0。</li></ul></li></ul></li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>当Redis的运行内存已经超过设置的最大内存时，会使用内存淘汰策略删除符合相关条件的key。<br>最大内存通过设置<code>maxmemory &lt;bytes&gt;</code>即可。默认为0，表示没有内存大小的限制。</p><p>Redis的内存淘汰策略如下：</p><ul><li><p>不淘汰</p><ul><li>noeviction：不淘汰任何数据、直接返回错误。</li></ul></li><li><p>对设置了过期时间的数据进行淘汰</p><ul><li>volatile-random： 随意淘汰设置了过期时间的任意entry。</li><li>volatile-ttl：优先淘汰更早过期的entry。</li><li>volatile-lru：淘汰所有设置了过期时间的entry中最近最久未使用的entry。</li><li>volatile-lfu：淘汰所有设置了过期时间的entry中最少使用的entry。</li></ul></li><li><p>对全部数据进行淘汰</p><ul><li>allkeys-random：随即淘汰任意entry。</li><li>allkeys-lru：使用LRU策略淘汰任意entry。</li><li>allkeys-lfu：使用LFU策略淘汰任意entry。</li></ul></li></ul><p>修改redis.conf中的<code>maxmemory-policy &lt;策略&gt;</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础知识总结</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h3><ul><li>速度快（内存，10w QPS, C , 单线程）</li><li>持久化（将内存数据异步更新到磁盘,RDB&amp;AOF）</li><li>多种数据结构（string list set zset hash BitMaps HyperLogLog GEO）</li><li>支持多语言</li><li>功能丰富（发布订阅 事务 Lua脚本 pipeline）</li><li>简单（23000 lines of code 不依赖外部库 单线程模型）</li><li>主从复制</li></ul><p>单线程为什么这么快？</p><ol><li>纯内存</li><li>非阻塞IO，使用多路复用机制，提升连接并发度。</li><li>避免多线程切换和竞态消耗</li></ol><h3 id="Redis典型应用场景"><a href="#Redis典型应用场景" class="headerlink" title="Redis典型应用场景"></a>Redis典型应用场景</h3><ul><li>缓存系统（缓存）</li><li>计数器（微博转发和评论）</li><li>消息队列系统</li><li>排行榜</li><li>社交网络</li><li>实时系统（垃圾邮件–布隆过滤器）</li></ul><h3 id="Redis可执行文件说明"><a href="#Redis可执行文件说明" class="headerlink" title="Redis可执行文件说明"></a>Redis可执行文件说明</h3><div class="code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">redis</span>-server      ---&gt;</span>    Redis服务器<span class="hljs-function"><span class="hljs-title">redis</span>-cli         ---&gt;</span>    Redis客户端<span class="hljs-function"><span class="hljs-title">redis</span>-benchmark   ---&gt;</span>    Redis性能测试<span class="hljs-function"><span class="hljs-title">redis</span>-check-aof   ---&gt;</span>    AOF文件修复<span class="hljs-function"><span class="hljs-title">redis</span>-check-dump  ---&gt;</span>    RDB文件检查<span class="hljs-function"><span class="hljs-title">redis</span>-sentinel    ---&gt;</span>    Sentinel服务器</code></pre></div><h3 id="Redis-通用API"><a href="#Redis-通用API" class="headerlink" title="Redis 通用API"></a>Redis 通用API</h3><div class="code-wrapper"><pre><code class="hljs scss">keys                ---&gt;    遍历所有key，热备从节点         <span class="hljs-built_in">O</span>(n)dbsize              ---&gt;    计算key的总数                   <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)exist key           ---&gt;    检查key是否存在，返回<span class="hljs-number">0</span>或<span class="hljs-number">1</span>       <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-selector-tag">del</span> key             ---&gt;    删除指定的key                   <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)expire key seconds  ---&gt;    key在seconds秒后过期            <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)         ttl key             ---&gt;    查看key的剩余过期时间           <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) persist key         ---&gt;    去掉key的过期时间               <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) type key            ---&gt;    查看当前key的类型               <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre></div><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>String应用场景：字符串缓存、计数器、分布式锁</p><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs xquery">get<span class="hljs-built_in"> key</span>del<span class="hljs-built_in"> key</span>incr                            整型自增decr                            整型自减incrby<span class="hljs-built_in"> key</span> k                   <span class="hljs-built_in"> key</span>自增k，如<span class="hljs-built_in">果key</span>不存在，自增后get<span class="hljs-built_in">(key</span>) = kdecr<span class="hljs-built_in"> key</span> k                     <span class="hljs-built_in"> key</span>自减k，如<span class="hljs-built_in">果key</span>不存在，自减后get<span class="hljs-built_in">(key</span>) = kset<span class="hljs-built_in"> key</span> <span class="hljs-keyword">value</span>                   无论是否存在setnx<span class="hljs-built_in"> key</span> <span class="hljs-keyword">value</span>                <span class="hljs-built_in"> key</span>不存在才能设置set<span class="hljs-built_in"> key</span> <span class="hljs-keyword">value</span> xx               <span class="hljs-built_in"> key</span>存在，才设置mget key1 key2                  批量获取mset key1 value1 key2 value2    批量设置getset<span class="hljs-built_in"> key</span> newvalue             set<span class="hljs-built_in"> key</span> newvalue并返回旧的<span class="hljs-keyword">value</span>append<span class="hljs-built_in"> key</span> <span class="hljs-keyword">value</span>                将<span class="hljs-keyword">value</span>追加到旧的<span class="hljs-keyword">value</span>中strlen<span class="hljs-built_in"> key</span>                      返回字符串长度incrbyfloat<span class="hljs-built_in"> key</span> <span class="hljs-number">3.5</span>             增<span class="hljs-built_in">加key</span>对应的值<span class="hljs-number">3.5</span>getrange<span class="hljs-built_in"> key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>          获取字符串指定下标所有的值setrange<span class="hljs-built_in"> key</span> index <span class="hljs-keyword">value</span>        设置指定下标所有对应的值</code></pre></div><p>Hash应用场景：存储键值对数据</p><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs lsl">hget <span class="hljs-type">key</span> field                  获取hash <span class="hljs-type">key</span>对应的field的valuehset <span class="hljs-type">key</span> field value            设置hash <span class="hljs-type">key</span>对应field的valuehdel <span class="hljs-type">key</span> field                  删除hexists <span class="hljs-type">key</span> field               判断hash <span class="hljs-type">key</span>是否有field                        hlen <span class="hljs-type">key</span>                        获取hash <span class="hljs-type">key</span> field长度hmget <span class="hljs-type">key</span> field1 field2         批量获取hmset key1 field1 value1        批量设置hgetall <span class="hljs-type">key</span>                     返回hash <span class="hljs-type">key</span>对应的所有的field和valuehvals <span class="hljs-type">key</span>                       返回hash <span class="hljs-type">key</span>对应所有的field的valuehkeys <span class="hljs-type">key</span>                       返回hash <span class="hljs-type">key</span>对应的所有fieldhsetnx <span class="hljs-type">key</span> field value          设置hash <span class="hljs-type">key</span>对应的field的valuehincrby <span class="hljs-type">key</span> field intCounter    hash <span class="hljs-type">key</span> 对应的field的value自增intCounterhincrbyfloat</code></pre></div><p>List特点：可重复的、可左右弹出压入的</p><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs tcl">rpush key value1 value2                     从列表右端进行插入lpush<span class="hljs-keyword">linsert</span> key before|<span class="hljs-keyword">after</span> value newValue     在<span class="hljs-keyword">list</span>指定的前后newValuelpop key                                    左边弹出一个元素rpop key                                    右边弹出一个元素lrem key count value                        根据count值，删除所有value相等的项，count&gt;<span class="hljs-number">0</span> 从左往右删除。count&lt;<span class="hljs-number">0</span>从右往左，count=<span class="hljs-number">0</span>删除所有value相等的值ltrim key start end                         按照索引范围修剪列表<span class="hljs-keyword">lrange</span> key start end                        获取列表指定所有范围的item<span class="hljs-keyword">lindex</span> key index                            获取列表指定索引的itemllen key                                    获取列表长度<span class="hljs-keyword">lset</span> key index newValue                     设置指定索引为newValueblpop key timeout                           lpop阻塞版本 timeout是阻塞超时时间brpop                                       rpop阻塞版本</code></pre></div><p>Set特点：无序、不重复</p><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs q">sadd <span class="hljs-built_in">key</span> element            向集合<span class="hljs-built_in">key</span>中添加elementsrem <span class="hljs-built_in">key</span> element            将集合中的element移出scard <span class="hljs-built_in">key</span>                   计算集合大小sismember <span class="hljs-built_in">key</span> element       判断是否在集合中srandmember <span class="hljs-built_in">key</span> <span class="hljs-built_in">count</span>       从集合中随机挑出<span class="hljs-built_in">count</span>个元素smembers <span class="hljs-built_in">key</span>                获取集合所有元素spop <span class="hljs-built_in">key</span>                    随机弹出一个元素sdiff key1 key2             差集sinter key1 key2            交集sunion key1 key2            并集</code></pre></div><p>zset特点：有序、无重复元素</p><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">zadd key score <span class="hljs-keyword">element</span>              添加score和<span class="hljs-keyword">element</span>  O(logN)zrem key <span class="hljs-keyword">element</span>                    删除元素            O(<span class="hljs-number">1</span>)zscore key <span class="hljs-keyword">element</span>                  返回元素的分数zincrby key increScore <span class="hljs-keyword">element</span>      增加或者减少元素的分数zcard key                           返回元素的总个数zrankzrange key <span class="hljs-built_in">start</span> <span class="hljs-function"><span class="hljs-keyword">end</span>                返回索引内的元素</span>zrangebyscore key minScore maxScore 返回指定分数范围内的升序元素zcount key minScore maxScore        返回有序集合内指定范围内的个数zremrangebyrank key <span class="hljs-built_in">start</span> <span class="hljs-function"><span class="hljs-keyword">end</span>       删除指定排名内的升序元素</span>zremrangebyscore key <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span>        删除指定分数范围内的升序元素zrevrank                            zrevrangezrevrangebyscorezinterstorezunionstore</code></pre></div><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>位图：字符以二进制格式存储在内存中</p><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs xquery">setbit<span class="hljs-built_in"> key</span> offset <span class="hljs-keyword">value</span>                 给位图指定索引设置值getbit<span class="hljs-built_in"> key</span> offsetbitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]                获取位值为<span class="hljs-number">1</span>的个数bitop op destkey<span class="hljs-built_in"> key</span>                    做多个bitmap的<span class="hljs-keyword">and</span> <span class="hljs-keyword">or</span><span class="hljs-built_in"> not</span> xor操作并将结果保存到destKey中bitpos<span class="hljs-built_in"> key</span> targetBit [<span class="hljs-keyword">start</span>] [<span class="hljs-keyword">end</span>]      计算位图指定范围第一个偏移量对应的值等于targetBit的位置</code></pre></div><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>特点如下：</p><ul><li>基于HyperLogLog算法：极小空间完成独立数量统计</li><li>本质还是string</li></ul><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs gauss">pfadd <span class="hljs-built_in">key</span> element                       添加元素pfcount <span class="hljs-built_in">key</span>                             计算独立总数pfmerge destKey sourcekey [sourcekey]   合并多个hyperloglog</code></pre></div><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>GEO：存储经纬度，计算两地距离，范围计算</p><p>常用API：</p><div class="code-wrapper"><pre><code class="hljs maxima">geoadd <span class="hljs-built_in">key</span> longitude latitude <span class="hljs-built_in">member</span>                   增加地理位置信息geoadd cities:locations <span class="hljs-number">116.28</span> <span class="hljs-number">39.55</span> beijinggeopos <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>                                       获取地理位置信息geodist <span class="hljs-built_in">key</span> member1 member2 [unit]                      获取两地位置的距离，unit：m,km,mi,ftgeoradius</code></pre></div><ul><li>since 3.2 +</li><li>type geoKey &#x3D; zset</li><li>没有删除API：zrem key member</li></ul><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令的相关信息记录下来，以便后期的问题排查和调优。</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">默认配置参数slowlog-<span class="hljs-built_in">max</span>-<span class="hljs-built_in">len</span> = <span class="hljs-number">128</span>                  <span class="hljs-comment"># 最多能保存的慢查询日志条数，若超过采用FIFO方案将最旧的慢查询日志先删除。</span>slowlog-<span class="hljs-built_in">log</span>-slower-than = <span class="hljs-number">10000</span>        <span class="hljs-comment"># 慢查询的预设阀值（单位：微秒）</span>如果slowlog-<span class="hljs-built_in">log</span>-slower-than的值是<span class="hljs-number">0</span>，则会记录所有命令。如果slowlog-<span class="hljs-built_in">log</span>-slower-than的值小于<span class="hljs-number">0</span>，则任何命令都不会记录日志。慢查询命令slowlog <span class="hljs-built_in">get</span> [n]         获取慢查询队列slowlog <span class="hljs-built_in">len</span>             获取慢查询队列长度slowlog reset           清空慢查询队列</code></pre></div><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>客户端将多个请求打包，同时发给服务端。比较是否非实时需求，统一打包一次发送，减少网络传输的开销和时延问题。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务将一种或多种请求打包，然后一次性按顺序 执行多个命令的机制，事务执行过程中，服务器不会中断事务去执行其他请求。事务以<code>MULTI</code>命令开始，接着将多个命令放入事务中，由<code>EXEC</code>将这个事务提交给服务器。</p><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>主要有以下角色：</p><ul><li>发布者（publisher）</li><li>订阅者（subscriber）</li><li>频道（channel）</li></ul><p>常用API</p><div class="code-wrapper"><pre><code class="hljs css">publish channel messagesubscribe channelunsubscribe channelpsubscribe <span class="hljs-selector-attr">[pattern]</span>    订阅模式punsubscribe <span class="hljs-selector-attr">[pattern]</span>  退出指定的模式pubsub channels         列出至少有一个订阅者的频道pubsub numsub <span class="hljs-selector-attr">[channel]</span> 列出指定频道的订阅者数量pubsub numpat           列出被订阅者的数量</code></pre></div><h2 id="缓存的使用和设计"><a href="#缓存的使用和设计" class="headerlink" title="缓存的使用和设计"></a>缓存的使用和设计</h2><h3 id="缓存的收益和成本"><a href="#缓存的收益和成本" class="headerlink" title="缓存的收益和成本"></a>缓存的收益和成本</h3><p>收益：</p><ul><li>加速读写</li><li>降低后端负载</li></ul><p>成本：</p><ul><li>数据不一致：缓存层和数据层由时间窗口不一致，和更新策略有关</li><li>代码维护成本：多了一层缓存逻辑</li><li>运维成本</li></ul><p>使用场景：</p><ol><li>降低后端负载<ul><li>对高消耗的SQL：join结果集、分组统计结果缓存</li></ul></li><li>加速请求响应<ul><li>利用Redis优化IO响应时间</li></ul></li><li>大量写合并为批量写<ul><li>计数器先Redis累加再批量写DB</li></ul></li></ol><h3 id="缓存的更新策略"><a href="#缓存的更新策略" class="headerlink" title="缓存的更新策略"></a>缓存的更新策略</h3><ol><li>LRU&#x2F;LFU&#x2F;FIFO算法剔除，例如<code>maxmemory=policy</code></li><li>超时剔除，例如<code>expire</code></li><li>主动更新：开发控制生命周期</li></ol><h3 id="缓存的粒度控制"><a href="#缓存的粒度控制" class="headerlink" title="缓存的粒度控制"></a>缓存的粒度控制</h3><ul><li>通用性：全量属性更好</li><li>占用空间：部分属性更好</li><li>代码维护：表面上全量属性更好</li></ul><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>cache和数据库中都没有的数据，但是用户不断发起请求。流量大的时候，DB可能宕机。</p><p>原因：</p><ol><li>业务代码自身问题</li><li>恶意攻击，爬虫</li></ol><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li>增加Filter，增加参数合法校验</li><li>使用布隆过滤器，过滤Redis请求</li><li>缓存空对象</li></ol><div class="code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-title function_">getPassThrought</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>) &#123;    <span class="hljs-built_in">String</span> cacheValue = cache.<span class="hljs-property">get</span>(<span class="hljs-built_in">key</span>);    <span class="hljs-keyword">if</span>(StringUtils.<span class="hljs-property">isBlank</span>(cacheValue))&#123;        <span class="hljs-built_in">String</span> storageValue = storage.<span class="hljs-property">get</span>(<span class="hljs-built_in">key</span>);        cache.<span class="hljs-property">set</span>(<span class="hljs-built_in">key</span>,storageValue);        <span class="hljs-comment">//如果存储数据为空，设置一个过期时间</span>        <span class="hljs-keyword">if</span>(StringUtils.<span class="hljs-property">isBlank</span>(storageValue))&#123;            cache.<span class="hljs-property">expire</span>(<span class="hljs-built_in">key</span>,<span class="hljs-number">60</span> * <span class="hljs-number">5</span>);        &#125;        <span class="hljs-keyword">return</span> storageValue;    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> cacheValue;    &#125;&#125;</code></pre></div><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>cache中没有数据，但是数据库中有数据，某个热点Key突然失效，导致大量请求都打在DB中。</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>根据实际场景，考虑热点数据是否可以设置为永不过期。</li><li>接口限流、服务熔断、降级来保护服务。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>某时刻大量Key同时失效，流量直接打到DB，导致DB流量瞬间加大，造成级联故障。</p><h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li>保证缓存高可用性<ul><li>个别节点，个别机器</li><li>Redis Cluster，Redis sentinel</li></ul></li><li>key的失效时间设置为随机值，避免使用相同的过期时间。</li><li>依赖隔离组件为后端限流，考虑增加熔断机制。</li><li>压力测试提前发现问题。</li></ol><h3 id="缓存无底洞问题"><a href="#缓存无底洞问题" class="headerlink" title="缓存无底洞问题"></a>缓存无底洞问题</h3><p>2010年，FaceBook有3000个Memcache节点，发现问题：加机器没有性能提升，反而下降</p><p>问题关键点：</p><ul><li>更多的节点 !&#x3D; 更高的性能</li><li>批量接口需求（mget,mset）</li><li>数据增长和水平扩展需求</li></ul><h4 id="优化IO的几种方法"><a href="#优化IO的几种方法" class="headerlink" title="优化IO的几种方法"></a>优化IO的几种方法</h4><ol><li>命令本身优化，例如慢查询<code>keys</code>,<code>hgetall bigkey</code></li><li>减少网络通信次数</li><li>减少接入成本：例如客户端长连接&#x2F;连接池,NIO等</li></ol><h4 id="四种批量优化的方法"><a href="#四种批量优化的方法" class="headerlink" title="四种批量优化的方法"></a>四种批量优化的方法</h4><ol><li>串行mget</li><li>串行IO</li><li>并行IO</li><li>hash_tag</li></ol><h2 id="Redis安全"><a href="#Redis安全" class="headerlink" title="Redis安全"></a>Redis安全</h2><ol><li>设置密码<ul><li>服务端配置：requirepass和masterauth</li><li>客服端连接：auth命令和-a参数</li></ul></li><li>伪装危险命令</li></ol><ul><li>服务端配置：rename-command为空或者随机字符</li><li>客户端连接：不可用或者使用指定随机字符</li></ul><ol start="3"><li>bind：服务端配置：bind限制的是网卡，并不是客户端IP</li></ol><ul><li>bind不支持config set</li><li>bind 127.0.0.1要谨慎</li></ul><ol start="4"><li>防火墙</li><li>定期备份</li><li>不使用默认端口</li><li>使用非root用户启动</li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构-Stream源码分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-stream/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-stream/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis在5.0.0版本中引进了消息队列的功能，该功能由Stream实现，本文主要介绍Stream的相关实现。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>Stream的实现依赖于Rax树与<code>listpack</code>结构，每个消息流都包含一个Rax树，以消息ID为key，listpack为value存储在Rax树中。其基本结构如下：</p><ul><li>rax：rax存储生产者生产的具体消息，每个消息有唯一ID为键</li><li>length：代表当前stream中消息个数。</li><li>last_id：为当前stream中最后插入的消息ID，stream为空时，该值为0。</li><li>cgroups：存储了当前stream相关的消费组，以消费组组名为键，streamCG为值存储在rax中。<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stream</span> &#123;</span>    rax *rax;               <span class="hljs-comment">/* The radix tree holding the stream. */</span>    <span class="hljs-type">uint64_t</span> length;        <span class="hljs-comment">/* Number of elements inside this stream. */</span>    streamID last_id;       <span class="hljs-comment">/* Zero if there are yet no items. */</span>    rax *cgroups;           <span class="hljs-comment">/* Consumer groups dictionary: name -&gt; streamCG */</span>&#125; stream;</code></pre></div></li></ul><p>一个Stream的基本结构如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/redis/stream/structure.PNG" alt="Stream结构"></p><p>每一个listpack都有一个master entry，该结构存储了该listpack待插入消息的所有field。</p><h3 id="streamID"><a href="#streamID" class="headerlink" title="streamID"></a>streamID</h3><p>消息ID的基本结构如下：</p><ul><li>ms：消息创建时的时间</li><li>seq：序号<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">streamID</span> &#123;</span>    <span class="hljs-type">uint64_t</span> ms;        <span class="hljs-comment">/* Unix time in milliseconds. */</span>    <span class="hljs-type">uint64_t</span> seq;       <span class="hljs-comment">/* Sequence number. */</span>&#125; streamID;</code></pre></div></li></ul><h3 id="streamCG"><a href="#streamCG" class="headerlink" title="streamCG"></a>streamCG</h3><p>每个stream会有多个消费组，每个消费组通过组名称进行唯一标识，同时关联一个streamCG结构。该结构如下：</p><ul><li>last_id：该消费组已经确认的最后一个消息ID</li><li>pel：为该消费组尚未确认的消息，消息ID为键，streamNACK为值，存储在rax树中</li><li>consumers：消费组中的所有消费者，消费者名称为键，streamConsumer为值。<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">streamCG</span> &#123;</span>    streamID last_id;    rax *pel;    rax *consumers;&#125; streamCG;</code></pre></div></li></ul><h3 id="streamConsumer"><a href="#streamConsumer" class="headerlink" title="streamConsumer"></a>streamConsumer</h3><p>消费者结构如下：</p><ul><li>seen_time：为该消费者最后一次活跃的时间</li><li>name：消费者名称，为sds结构</li><li>pel：为该消费者尚未确认的消息，消息ID为键，streamNACK为值，存储在rax树中<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">streamConsumer</span> &#123;</span>    <span class="hljs-type">mstime_t</span> seen_time;    sds name;    rax *pel;&#125; streamConsumer;</code></pre></div></li></ul><h3 id="streamNACK"><a href="#streamNACK" class="headerlink" title="streamNACK"></a>streamNACK</h3><p>该结构为未确认消息，streamNACK维护了消费组或消费者尚未确认的消息，消费组中的pel的元素与消费者的pel元素是共享的。该结构如下：</p><ul><li>delivery_time：为该消息最后发送给消费方的时间</li><li>delivery_count：该消息已发送的次数</li><li>consumer：当前归属的消费者<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">streamNACK</span> &#123;</span>    <span class="hljs-type">mstime_t</span> delivery_time;    <span class="hljs-type">uint64_t</span> delivery_count;    streamConsumer *consumer;&#125; streamNACK;</code></pre></div></li></ul><h3 id="streamIterator"><a href="#streamIterator" class="headerlink" title="streamIterator"></a>streamIterator</h3><p>该结构主要提供遍历功能，基本结构如下：</p><ul><li>stream：当前迭代器正在遍历的消息流</li><li>master_id：为listpack中第一个插入的消息ID（master entry）</li><li>master_fields_count：第一个entry的field个数</li><li>master_fields_start：master entry的field首地址</li><li>master_fields_ptr：记录field的位置</li><li>entry_flags：当前遍历的消息的标志位</li><li>rev：迭代器方向</li><li>start_key,end_key：遍历范围</li><li>ri：rax迭代器，用于遍历rax树中的所有key</li><li>lp：当前的listpack指针</li><li>lp_ele：当前正在遍历的listpack中的元素</li><li>lp_flags：指向翻墙消息的flag域</li><li>field_buf,value_buf：从listpack读取数据的缓存<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">streamIterator</span> &#123;</span>    stream *stream;         <span class="hljs-comment">/* The stream we are iterating. */</span>    streamID master_id;     <span class="hljs-comment">/* ID of the master entry at listpack head. */</span>    <span class="hljs-type">uint64_t</span> master_fields_count;       <span class="hljs-comment">/* Master entries # of fields. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *master_fields_start; <span class="hljs-comment">/* Master entries start in listpack. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *master_fields_ptr;   <span class="hljs-comment">/* Master field to emit next. */</span>    <span class="hljs-type">int</span> entry_flags;                    <span class="hljs-comment">/* Flags of entry we are emitting. */</span>    <span class="hljs-type">int</span> rev;                <span class="hljs-comment">/* True if iterating end to start (reverse). */</span>    <span class="hljs-type">uint64_t</span> start_key[<span class="hljs-number">2</span>];  <span class="hljs-comment">/* Start key as 128 bit big endian. */</span>    <span class="hljs-type">uint64_t</span> end_key[<span class="hljs-number">2</span>];    <span class="hljs-comment">/* End key as 128 bit big endian. */</span>    raxIterator ri;         <span class="hljs-comment">/* Rax iterator. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *lp;      <span class="hljs-comment">/* Current listpack. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *lp_ele;  <span class="hljs-comment">/* Current listpack cursor. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *lp_flags; <span class="hljs-comment">/* Current entry flags pointer. */</span>    <span class="hljs-comment">/* Buffers used to hold the string of lpGet() when the element is</span><span class="hljs-comment">     * integer encoded, so that there is no string representation of the</span><span class="hljs-comment">     * element inside the listpack itself. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> field_buf[LP_INTBUF_SIZE];    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> value_buf[LP_INTBUF_SIZE];&#125; streamIterator;</code></pre></div></li></ul><h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p>listpack是一个字符串列表的序列化格式，该结构可用于存储字符串或整型。其主要结构如下图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/redis/stream/listpack.PNG" alt="listpack基本结构"><br>listpack主要由四部分构成，分别是：</p><ul><li>Total Bytes为整个listpack的空间大小</li><li>Num Elem：listpack的Entry个数，占用两个字节，但是Entry个数大于等于65535时，该值为65535，所以这种情况下获取元素个数，需要遍历整个listpack</li><li>Entry：为每个具体的元素</li><li>End：为listpack的结束标志，占用一个字节，内容为0xFF</li></ul><p>Entry由三部分构成，基本如下：</p><ul><li>Encode：元素的编码方式，占用一个字节</li><li>content：内容</li><li>backlen：记录entry的长度（不包括该字段本身）</li></ul><p>其中编码方式取值如下图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/redis/stream/encode.PNG" alt="编码取值"></p><p>Stream的消息内容存储在listpack中，消息存储格式是每个字段都是一个entry，而不是键整个消息作为字符串存储的，每个listpack会存储多个消息，具体存储个数由<code>stream-node-max-bytes</code>（listpack节点最大占用字节数，默认4096）和<code>stream-node-max-entries</code>（最大存储元素个数，默认100）决定.</p><p>每个listpack在创建时，会将第一个插入的entry构建成master entry，其基本结构如下所示：</p><div class="code-wrapper"><pre><code class="hljs coq">count   |   <span class="hljs-type">deleted</span>  |  <span class="hljs-type">num</span>-fields  |   <span class="hljs-type">field</span><span class="hljs-number">-1</span> |   <span class="hljs-type">field</span><span class="hljs-number">-2</span> |   <span class="hljs-type">0</span></code></pre></div><p>其中：</p><ul><li>count：为当前listpack中所有未删除的消息个数</li><li>deleted：当前listpack中所有已经删除的消息个数</li><li>num-fields：field个数</li><li>field-N：field域</li><li>0为标识位，再从后向前遍历listpack时使用</li></ul><p>存储一个消息时，如果该消息的field域与master entry完全相同，则不需要再次存储field域</p><h2 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h2><p>Redis对于Rax的解释为<code>A radix tree implement</code>，基数树的一种实现。Rax中不仅可以存储字符串，也可以为该字符串设置值形成kv结构。其基本结构如下：</p><ul><li>head：指向头节点</li><li>numele：元素个数（key）</li><li>numnodes：节点个数<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rax</span> &#123;</span>    raxNode *head;    <span class="hljs-type">uint64_t</span> numele;    <span class="hljs-type">uint64_t</span> numnodes;&#125; rax;</code></pre></div></li></ul><h2 id="raxNode"><a href="#raxNode" class="headerlink" title="raxNode"></a>raxNode</h2><p>raxNode代表Rax树中的一个节点，其基本结构如下所示：</p><ul><li>iskey：表明当前节点是否包含一个key，占用1bit</li><li>isnull：表明当前key对应的value是否为空，占用1bit</li><li>iscompr：表明当前节点是否为压缩节点，占用1bit</li><li>size：压缩节点压缩的字符串长度或者非压缩节点的子节点个数，占用29bit</li><li>data：包含填充字段，同时存储了当前节点包含的字符串以及子节点的指针，key对应的value指针。<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raxNode</span> &#123;</span>    <span class="hljs-type">uint32_t</span> iskey:<span class="hljs-number">1</span>;    <span class="hljs-type">uint32_t</span> isnull:<span class="hljs-number">1</span>;    <span class="hljs-type">uint32_t</span> iscompr:<span class="hljs-number">1</span>;    <span class="hljs-type">uint32_t</span> size:<span class="hljs-number">29</span>;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[];&#125; raxNode;</code></pre></div></li></ul><p>其中raxNode分为压缩节点域非压缩节点。主要区别在于非压缩节点的每个字符都有子节点，如果字符个数小于2，都是非压缩节点。</p><h2 id="raxStack"><a href="#raxStack" class="headerlink" title="raxStack"></a>raxStack</h2><p>raxStack结构用于存储从根节点到当前节点的路径，基本结构如下：</p><ul><li>stack：用于记录路径，该指针可能指向static_items或者堆内存</li><li>items,maxitems：代表stack指向的空间的已用空间以及最大空间</li><li>static_items：一个数组，每个元素都是指针，存储路径</li><li>oom：代表当前栈是否出现过内存溢出<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raxStack</span> &#123;</span>    <span class="hljs-type">void</span> **<span class="hljs-built_in">stack</span>;    <span class="hljs-type">size_t</span> items, maxitems;    <span class="hljs-type">void</span> *static_items[RAX_STACK_STATIC_ITEMS];    <span class="hljs-type">int</span> oom;&#125; raxStack;</code></pre></div></li></ul><h2 id="raxIterator"><a href="#raxIterator" class="headerlink" title="raxIterator"></a>raxIterator</h2><p>raxIterator用于遍历Rax树中的所有key，基本结构如下：</p><ul><li>flags：代表当前迭代器标志位,取值如下：<ul><li>RAX_ITER_JUST_SEEKED：当前迭代器指向的元素是刚刚搜索过的，当需要从迭代器中获取元素时，直接返回当前元素并清空标志位。</li><li>RAX_ITER_EOF：代表当前迭代器已经遍历到最后一个节点</li><li>RAX_ITER_SAFE：代表当前迭代器为安全迭代器，可以进行写操作</li></ul></li><li>rt：当前迭代器对应的rax</li><li>key：存储了当前迭代器遍历到的key，该指针指向key_static_string或者堆内存</li><li>data：value值</li><li>key_len,key_max：key指向的空间的已用空间以及最大空间</li><li>key_static_string：key的默认存储空间，key过大时，会使用堆内存</li><li>node：当前key所在的raxNode</li><li>stack：记录了从根节点到当前节点的路径，用于raxNode线上遍历</li><li>node_cb：为节点的回调函数，默认为空<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raxIterator</span> &#123;</span>    <span class="hljs-type">int</span> flags;    rax *rt;                <span class="hljs-comment">/* Radix tree we are iterating. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *key;     <span class="hljs-comment">/* The current string. */</span>    <span class="hljs-type">void</span> *data;             <span class="hljs-comment">/* Data associated to this key. */</span>    <span class="hljs-type">size_t</span> key_len;         <span class="hljs-comment">/* Current key length. */</span>    <span class="hljs-type">size_t</span> key_max;         <span class="hljs-comment">/* Max key len the current key buffer can hold. */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key_static_string[RAX_ITER_STATIC_LEN];    raxNode *node;          <span class="hljs-comment">/* Current node. Only for unsafe iteration. */</span>    raxStack <span class="hljs-built_in">stack</span>;         <span class="hljs-comment">/* Stack used for unsafe iteration. */</span>    raxNodeCallback node_cb; <span class="hljs-comment">/* Optional node callback. Normally set to NULL. */</span>&#125; raxIterator;</code></pre></div></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上文主要对Redis Stream的基本结构与其底层数据结构做了简要分析，了解了消息由listpack结构存储，以消息ID为key，listpack为value存储在Rax树中。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>源码分析</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构-Quicklist源码分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-quicklist/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-quicklist/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>quicklist是Redis 3.2中引入的数据结构，其本质是一个双向链表，链表的节点类型是ziplist，当ziplist节点过多，quicklist会退化成双向链表，以提高效率。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a>quicklistNode</h2><p>该结构为节点类型。</p><ul><li>prev：指向前驱节点</li><li>next：指向后继节点</li><li>zl：指向对应的压缩列表</li><li>sz：压缩列表的大小</li><li>encoding：采用的编码方式，1为原生，2代表使用LZF进行压缩</li><li>container：为节点指向的容器类型，1代表none，2代表ziplist存储数据</li><li>recompress：代表这个节点是否是压缩节点，如果是，则使用压缩节点前先进行解压缩，使用后重新压缩</li><li>attempted_compress：测试时使用<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;             <span class="hljs-comment">/* ziplist size in bytes */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;     <span class="hljs-comment">/* count of items in ziplist */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> encoding : <span class="hljs-number">2</span>;   <span class="hljs-comment">/* RAW==1 or LZF==2 */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> container : <span class="hljs-number">2</span>;  <span class="hljs-comment">/* NONE==1 or ZIPLIST==2 */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* was this node previous compressed? */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> attempted_compress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* node can&#x27;t compress; too small */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">/* more bits to steal for future usage */</span>&#125; quicklistNode;</code></pre></div></li></ul><h2 id="quicklistLZF"><a href="#quicklistLZF" class="headerlink" title="quicklistLZF"></a>quicklistLZF</h2><p>如果使用LZF算法进行压缩，节点指向的结构为quicklistLZF，其中sz表示compressed数组所占用字节大小。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistLZF</span> &#123;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <span class="hljs-comment">/* LZF size in bytes*/</span>    <span class="hljs-type">char</span> compressed[];&#125; quicklistLZF;</code></pre></div><h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><ul><li>head：指向头节点</li><li>tail：指向尾节点</li><li>count：quicklist中压缩列表的entry总数</li><li>len：节点个数</li><li>fill：每个节点的ziplist长度，可以通过参数<code>list-max-ziplist-size</code>配置节点所占内存大小</li><li>compress：该值表示两端各有compress个节点不压缩<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span>    quicklistNode *head;    quicklistNode *tail;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;        <span class="hljs-comment">/* total count of all entries in all ziplists */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;          <span class="hljs-comment">/* number of quicklistNodes */</span>    <span class="hljs-type">int</span> fill : <span class="hljs-number">16</span>;              <span class="hljs-comment">/* fill factor for individual nodes */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compress : <span class="hljs-number">16</span>; <span class="hljs-comment">/* depth of end nodes not to compress;0=off */</span>&#125; quicklist;</code></pre></div></li></ul><h2 id="quicklistEntry"><a href="#quicklistEntry" class="headerlink" title="quicklistEntry"></a>quicklistEntry</h2><ul><li>quicklist：指向当前元素所在的quicklist</li><li>node：指向当前元素所在的节点</li><li>zi：当前元素所在的ziplist</li><li>value：当前节点的字符串内容</li><li>longval：当前节点的整型值</li><li>sz：节点的大小</li><li>offset：该节点相对于整个ziplist的偏移量，即相当于第几个entry<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistEntry</span> &#123;</span>    <span class="hljs-type">const</span> quicklist *quicklist;    quicklistNode *node;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zi;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *value;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> longval;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;    <span class="hljs-type">int</span> offset;&#125; quicklistEntry;</code></pre></div></li></ul><h2 id="quicklistIter"><a href="#quicklistIter" class="headerlink" title="quicklistIter"></a>quicklistIter</h2><p>用于quicklist遍历的迭代器。</p><ul><li>quicklist：指向对应的quicklist</li><li>current：指向元素所在的节点</li><li>zi：指向元素所在的ziplist</li><li>offset：表示节点在ziplist中的偏移量</li><li>direction：表示迭代器的方向<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistIter</span> &#123;</span>    <span class="hljs-type">const</span> quicklist *quicklist;    quicklistNode *current;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zi;    <span class="hljs-type">long</span> offset; <span class="hljs-comment">/* offset in current ziplist */</span>    <span class="hljs-type">int</span> direction;&#125; quicklistIter;</code></pre></div></li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="quicklistPushHead"><a href="#quicklistPushHead" class="headerlink" title="quicklistPushHead"></a>quicklistPushHead</h2><p>该接口在头部插入元素。传入参数分别是待插入的quicklist，插入的数据value，大小sz。返回指为0代表没有新建head节点，1代表新建了head节点<br>基本逻辑如下：</p><ul><li>查看quicklist的head节点是否允许插入，可以就利用ziplist的接口进行插入。</li><li>否则新建head节点进行插入。<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">quicklistPushHead</span><span class="hljs-params">(quicklist *quicklist, <span class="hljs-type">void</span> *value, <span class="hljs-type">size_t</span> sz)</span> &#123;    quicklistNode *orig_head = quicklist-&gt;head;    <span class="hljs-comment">//检查头节点是否允许插入</span>    <span class="hljs-keyword">if</span> (likely(            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;            <span class="hljs-comment">//使用头节点中的ziplist接口进行插入</span>        quicklist-&gt;head-&gt;zl =            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);        quicklistNodeUpdateSz(quicklist-&gt;head);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//创建新节点进行插入</span>        quicklistNode *node = quicklistCreateNode();        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);        quicklistNodeUpdateSz(node);        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);    &#125;    <span class="hljs-comment">//更新对应数据</span>    quicklist-&gt;count++;    quicklist-&gt;head-&gt;count++;    <span class="hljs-keyword">return</span> (orig_head != quicklist-&gt;head);&#125;</code></pre></div></li></ul><h2 id="quicklistReplaceAtIndex"><a href="#quicklistReplaceAtIndex" class="headerlink" title="quicklistReplaceAtIndex"></a>quicklistReplaceAtIndex</h2><p>更改元素需要传入index，基本逻辑是：</p><ul><li>删除原有元素</li><li>插入新元素<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">quicklistReplaceAtIndex</span><span class="hljs-params">(quicklist *quicklist, <span class="hljs-type">long</span> index, <span class="hljs-type">void</span> *data,</span><span class="hljs-params">                            <span class="hljs-type">int</span> sz)</span> &#123;    quicklistEntry entry;    <span class="hljs-comment">//检查index位置的元素是否存在</span>    <span class="hljs-keyword">if</span> (likely(quicklistIndex(quicklist, index, &amp;entry))) &#123;        <span class="hljs-comment">//删除</span>        entry.node-&gt;zl = ziplistDelete(entry.node-&gt;zl, &amp;entry.zi);        <span class="hljs-comment">//添加</span>        entry.node-&gt;zl = ziplistInsert(entry.node-&gt;zl, entry.zi, data, sz);        <span class="hljs-comment">//更新sz字段</span>        quicklistNodeUpdateSz(entry.node);        quicklistCompress(quicklist, entry.node);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div></li></ul><h2 id="quicklistIndex"><a href="#quicklistIndex" class="headerlink" title="quicklistIndex"></a>quicklistIndex</h2><p>该方法主要通过元素的下标查找对应元素，找到index对应数据所在的节点，再调用ziplist的<code>ziplistGet</code>得到Index对应的数据。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//idx为需要查找的下标, 结果写入entry，返回0代表没找到，1代表找到</span><span class="hljs-type">int</span> <span class="hljs-title function_">quicklistIndex</span><span class="hljs-params">(<span class="hljs-type">const</span> quicklist *quicklist, <span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> idx,</span><span class="hljs-params">                   quicklistEntry *entry)</span> &#123;    quicklistNode *n;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> accum = <span class="hljs-number">0</span>;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> index;    <span class="hljs-comment">//idx为负值，表示从尾部向头部的偏移量</span>    <span class="hljs-type">int</span> forward = idx &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">/* &lt; 0 -&gt; reverse, 0+ -&gt; forward */</span>    <span class="hljs-comment">//初始化entry</span>    initEntry(entry);    entry-&gt;quicklist = quicklist;    <span class="hljs-keyword">if</span> (!forward) &#123;        <span class="hljs-comment">//idx小于0，将idx设置为(-idx) - 1，从尾部查找</span>        index = (-idx) - <span class="hljs-number">1</span>;        n = quicklist-&gt;tail;    &#125; <span class="hljs-keyword">else</span> &#123;        index = idx;        n = quicklist-&gt;head;    &#125;    <span class="hljs-keyword">if</span> (index &gt;= quicklist-&gt;count)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//遍历Node节点，找到对应的index元素</span>    <span class="hljs-keyword">while</span> (likely(n)) &#123;        <span class="hljs-keyword">if</span> ((accum + n-&gt;count) &gt; index) &#123;            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            D(<span class="hljs-string">&quot;Skipping over (%p) %u at accum %lld&quot;</span>, (<span class="hljs-type">void</span> *)n, n-&gt;count,              accum);            accum += n-&gt;count;            n = forward ? n-&gt;next : n-&gt;prev;        &#125;    &#125;    <span class="hljs-keyword">if</span> (!n)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    D(<span class="hljs-string">&quot;Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu&quot;</span>, (<span class="hljs-type">void</span> *)n,      accum, index, index - accum, (-index) - <span class="hljs-number">1</span> + accum);    <span class="hljs-comment">//计算index所在的ziplist的偏移量</span>    entry-&gt;node = n;    <span class="hljs-keyword">if</span> (forward) &#123;        <span class="hljs-comment">/* forward = normal head-to-tail offset. */</span>        entry-&gt;offset = index - accum;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">/* reverse = need negative offset for tail-to-head, so undo</span><span class="hljs-comment">         * the result of the original if (index &lt; 0) above. */</span>        entry-&gt;offset = (-index) - <span class="hljs-number">1</span> + accum;    &#125;    quicklistDecompressNodeForUse(entry-&gt;node);    entry-&gt;zi = ziplistIndex(entry-&gt;node-&gt;zl, entry-&gt;offset);    <span class="hljs-comment">//利用ziplistGet获取元素</span>    ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);    <span class="hljs-comment">/* The caller will use our result, so we don&#x27;t re-compress here.</span><span class="hljs-comment">     * The caller can recompress or delete the node as needed. */</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了Quicklist的基本数据结构，并对该结构的基本增删改查接口做了简要分析。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>源码分析</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构-Intset源码分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-intset/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-intset/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Intset是一个有序的，存储Integer类型数据的结构，当元素为64位有符号整数范围之内时，它是Redis数据结构中有序集合ZSET的底层实现，但是当元素个数超过一定数量时（默认为512），会转为hashtable进行存储，由配置项<code>set-max-intset-entries 512</code>决定。如果向有序集合中添加非整型变量，底层实现也会装欢为hashtable。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>intset结构如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT32： (sizeof(int32_t))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span>    <span class="hljs-type">uint32_t</span> encoding;    <span class="hljs-type">uint32_t</span> length;    <span class="hljs-type">int8_t</span> contents[];&#125; intset;</code></pre></div><p>各字段含义：</p><ul><li>encoding：编码类型，决定每个元素占用几个字节<ul><li>INTSET_ENC_INT16：当元素大小位于<code>INT16_MIN</code>和<code>INT16_MAX</code>之间使用，每个元素占用两个字节。</li><li>INTSET_ENC_INT32：元素大小位于<code>INT16_MAX</code>和<code>INT32_MAX</code>之间或<code>INT32_MIN</code>到<code>INT16_MIN</code>之间，该编码方式占用四个字节。</li><li>INTSET_ENC_INT64：元素大小位于<code>INT32_MAX</code>到<code>INT64_MAX</code>或<code>INT64_MIN</code>到<code>INT32_MIN</code>之间，该编码方式每个元素占用八个字节。</li></ul></li><li>length：元素个数</li><li>contents：存储具体元素的数组，从小到大排序，并且不包含任何重复项</li></ul><p>当添加的新元素比集合里面所有元素类型都长时，集合需要整体进行upgrade，然后完成添加。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="intsetFind"><a href="#intsetFind" class="headerlink" title="intsetFind"></a>intsetFind</h2><p>查找算法主要通过二分查找实现。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Determine whether a value belongs to this set */</span><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">intsetFind</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value)</span> &#123;    <span class="hljs-comment">//判断编码方式</span>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);    <span class="hljs-comment">//编码方式如果当前intset的编码方式，直接返回0</span>    <span class="hljs-comment">//否则调用intsetSearch函数进行查找</span>    <span class="hljs-keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="hljs-literal">NULL</span>);&#125;<span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">intsetSearch</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint32_t</span> *pos)</span> &#123;    <span class="hljs-type">int</span> min = <span class="hljs-number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="hljs-number">-1</span>, mid = <span class="hljs-number">-1</span>;    <span class="hljs-type">int64_t</span> cur = <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* The value can never be found when the set is empty */</span>    <span class="hljs-comment">//intset如果为空，直接返回0</span>    <span class="hljs-keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        当前元素如果大于当前有序集合最大值或者小于最小值，直接返回<span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;            <span class="hljs-keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; _intsetGet(is,<span class="hljs-number">0</span>)) &#123;            <span class="hljs-keyword">if</span> (pos) *pos = <span class="hljs-number">0</span>;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">//由于集合有序，采用二分查找</span>    <span class="hljs-keyword">while</span>(max &gt;= min) &#123;        mid = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)min + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)max) &gt;&gt; <span class="hljs-number">1</span>;        cur = _intsetGet(is,mid);        <span class="hljs-keyword">if</span> (value &gt; cur) &#123;            min = mid+<span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; cur) &#123;            max = mid<span class="hljs-number">-1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (value == cur) &#123;        <span class="hljs-keyword">if</span> (pos) *pos = mid;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (pos) *pos = min;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><h2 id="intsetAdd"><a href="#intsetAdd" class="headerlink" title="intsetAdd"></a>intsetAdd</h2><p>主要逻辑如下：</p><ul><li>判断插入的值的编码格式，小于当前intset编码格式直接插入，大于则调用<code>intsetUpgradeAndAdd</code>函数进行升级</li><li>上述条件小于时，调用<code>intsetSearch</code>进行查找，如果插入的值已经存在，直接返回。</li><li>不存在则进行扩容操作，<code>intsetResize</code>将intset的长度加一。</li><li>如果插入的位置位于原来元素之间，使用<code>intsetMoveTail</code>进行元素移动，空出一个位置进行插入。</li><li>调用<code>_intsetSet</code>保存元素</li></ul><div class="code-wrapper"><pre><code class="hljs C">intset *<span class="hljs-title function_">intsetAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">uint8_t</span> *success)</span> &#123;    <span class="hljs-comment">//获取添加元素的编码值</span>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);    <span class="hljs-type">uint32_t</span> pos;    <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;        <span class="hljs-comment">//如果该元素编码大于当前intset编码。进行升级</span>        <span class="hljs-keyword">return</span> intsetUpgradeAndAdd(is,value);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//否则先进行查重，如果已经存在该元素，直接返回（保证有序集合的唯一性）</span>        <span class="hljs-keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;            <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">0</span>;            <span class="hljs-keyword">return</span> is;        &#125;        <span class="hljs-comment">//扩容</span>        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);        <span class="hljs-comment">//如果插入元素位置合法，将该位置往后挪</span>        <span class="hljs-keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">//保存元素</span>    _intsetSet(is,pos,value);    <span class="hljs-comment">//修改inset的长度，将其加1</span>    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> is;&#125;<span class="hljs-type">static</span> intset *<span class="hljs-title function_">intsetUpgradeAndAdd</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value)</span> &#123;    <span class="hljs-type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);    <span class="hljs-type">uint8_t</span> newenc = _intsetValueEncoding(value);    <span class="hljs-type">int</span> length = intrev32ifbe(is-&gt;length);    <span class="hljs-type">int</span> prepend = value &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;    <span class="hljs-comment">/* First set new encoding and resize */</span>    is-&gt;encoding = intrev32ifbe(newenc);    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);    <span class="hljs-comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span><span class="hljs-comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span><span class="hljs-comment">     * space at either the beginning or the end of the intset. */</span>    <span class="hljs-keyword">while</span>(length--)        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));    <span class="hljs-comment">/* Set the value at the beginning or the end. */</span>    <span class="hljs-keyword">if</span> (prepend)        _intsetSet(is,<span class="hljs-number">0</span>,value);    <span class="hljs-keyword">else</span>        _intsetSet(is,intrev32ifbe(is-&gt;length),value);    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> is;&#125;</code></pre></div><h2 id="intsetRemove"><a href="#intsetRemove" class="headerlink" title="intsetRemove"></a>intsetRemove</h2><p>主要逻辑如下：</p><ul><li>判断新插入值的编码是否小于等于当前intset编码。</li><li>该值是否在intset中存在，如果存在，将intset的值从pos + 1的位置移动到pos位置。</li><li>更新长度字段。</li></ul><div class="code-wrapper"><pre><code class="hljs C">intset *<span class="hljs-title function_">intsetRemove</span><span class="hljs-params">(intset *is, <span class="hljs-type">int64_t</span> value, <span class="hljs-type">int</span> *success)</span> &#123;    <span class="hljs-comment">//获取待删除元素的编码</span>    <span class="hljs-type">uint8_t</span> valenc = _intsetValueEncoding(value);    <span class="hljs-type">uint32_t</span> pos;    <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">0</span>;    <span class="hljs-comment">//如果编码小于等于当前intset编码并且查找到该元素，则进行删除操作</span>    <span class="hljs-keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;        <span class="hljs-comment">//获取intset长度</span>        <span class="hljs-type">uint32_t</span> len = intrev32ifbe(is-&gt;length);        <span class="hljs-comment">/* We know we can delete */</span>        <span class="hljs-keyword">if</span> (success) *success = <span class="hljs-number">1</span>;        <span class="hljs-comment">//调用intsetMoveTail对待删除元素进行覆盖</span>        <span class="hljs-keyword">if</span> (pos &lt; (len<span class="hljs-number">-1</span>)) intsetMoveTail(is,pos+<span class="hljs-number">1</span>,pos);        is = intsetResize(is,len<span class="hljs-number">-1</span>);        is-&gt;length = intrev32ifbe(len<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">return</span> is;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要对Redis中集合的底层数据结构intset结构及其基本操作函数做了简要分析，该结构主要使用场景为集合元素全为整型且元素数量不多（默认小于512）。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>源码分析</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构-Dict源码分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-dict/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-dict/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>字典是一种用来存储键值对的数据结构。Redis本身就是KV型数据库，整个数据库就是用字典进行存储的，对Redis的增删改查操作，实际上就是对字典中的数据进行增删改查操作。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul><li>table：指针数组，用于存储键值对，指向的是<code>dictEntry</code>结构体，每个<code>dictEntry</code>存有键值对</li><li>size：table数组的大小</li><li>sizemask：掩码，用来计算键的索引值。值恒为size -1</li><li>used：table数组已存键值对个数</li></ul><p>Hash表的数组容量初始值为4，扩容倍数为当前一倍，所以sizemask大小为<code>3,7,11,31</code>，二进制表示为<code>111111...</code>，在计算索引值时，首先计算hash值，通过<code>hash = dict-&gt; type-&gt;hashFunction(k0)</code>得到对应hash。再通过<code>idx = hash &amp; d-&gt;dt[table].sizemask</code>计算entry存储的索引位置，位运算速度快于取余运算，Redis使用链地址法来解决<strong>hash冲突</strong>问题。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span>    dictEntry **table;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;&#125; dictht;</code></pre></div><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>hashtable一般需要将负载因子维护在一个合理的范围，使得其达到最大的操作效率，当键值对数量太多或太少时，都需要对hashtable进行相应的扩展或缩容。rehash动作是分批次、渐进式完成的，这是为了避免rehash对server性能造成影响。</p><p>Redis进行rehash的执行步骤如下：</p><ol><li>为<code>ht[1]</code>分配空间，空间大小取决于<code>ht[0]</code>包含的键值对数量。</li><li>将所有保存在<code>ht[0]</code>的键值对rehash到<code>ht[1]</code>上，即重新计算对应hash和index，并存储在<code>ht[1]</code></li><li>释放<code>ht[0]</code>空间，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新建一个空白hashtable，为下一次rehash服务。</li></ol><p>在渐进式rehash过程中，查询等操作同时使用两个hashtable。</p><h3 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h3><p>键值对节点，存放键值对数据。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span>    <span class="hljs-comment">//键</span>    <span class="hljs-type">void</span> *key;    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-comment">//存储值</span>        <span class="hljs-type">void</span> *val;        <span class="hljs-type">uint64_t</span> u64;        <span class="hljs-comment">//存储过期时间</span>        <span class="hljs-type">int64_t</span> s64;        <span class="hljs-type">double</span> d;    &#125; v;<span class="hljs-comment">//值，联合体</span>    <span class="hljs-comment">//next指针，Hash冲突时的单链表法</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span>&#125; dictEntry;</code></pre></div><h3 id="dictType"><a href="#dictType" class="headerlink" title="dictType"></a>dictType</h3><p>存放的是对字典操作的函数指针</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictType</span> &#123;</span>    <span class="hljs-comment">//Hash函数，默认使用MurmurHash2算法来计算hash值</span>    <span class="hljs-type">uint64_t</span> (*hashFunction)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);    <span class="hljs-comment">//键对应的复制函数</span>    <span class="hljs-type">void</span> *(*keyDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key);    <span class="hljs-comment">//值对应的复制函数</span>    <span class="hljs-type">void</span> *(*valDup)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *obj);    <span class="hljs-comment">//键的比对函数</span>    <span class="hljs-type">int</span> (*keyCompare)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key2);    <span class="hljs-comment">//键的销毁函数</span>    <span class="hljs-type">void</span> (*keyDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *key);    <span class="hljs-comment">//值得销毁函数</span>    <span class="hljs-type">void</span> (*valDestructor)(<span class="hljs-type">void</span> *privdata, <span class="hljs-type">void</span> *obj);&#125; dictType;</code></pre></div><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><ul><li>type：字典操作函数指针，指向一个dictType结构的指针</li><li>privdata：私有数据，配合tyoe指针指向的函数一起使用</li><li>ht：大小为2的数组，默认使用ht[0]，当字典扩容缩容时进行rehash时，才会用到ht[1]</li><li>rehashidx：标记该字典是否在进行rehash，没进行为-1，用来记录rehash到了哪个元素，值为下标值</li><li>iterators：用来记录当前运行的安全迭代器数，当有安全迭代器，会暂停rehash</li></ul><p>基本结构图如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/redis/dict/dict.png" alt="字典结构图"></p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><span class="hljs-comment">//存放字典的操作函数</span>    dictType *type;    <span class="hljs-comment">//依赖的数据</span>    <span class="hljs-type">void</span> *privdata;    <span class="hljs-comment">//Hash表</span>    dictht ht[<span class="hljs-number">2</span>];    <span class="hljs-comment">//rehash标识，默认为-1，代表没有进行rehash操作</span>    <span class="hljs-type">long</span> rehashidx;     <span class="hljs-comment">//当前运行的迭代器数</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators;&#125; dict;</code></pre></div><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="dictCreate"><a href="#dictCreate" class="headerlink" title="dictCreate"></a>dictCreate</h2><p>redis-server启动时，会初始化一个空字典用于存储整个数据库的键值对，初始化的主要逻辑如下：</p><ul><li>申请空间</li><li>调用<code>_dictInit</code>完成初始化<div class="code-wrapper"><pre><code class="hljs C">dict *<span class="hljs-title function_">dictCreate</span><span class="hljs-params">(dictType *type,</span><span class="hljs-params">        <span class="hljs-type">void</span> *privDataPtr)</span>&#123;    dict *d = zmalloc(<span class="hljs-keyword">sizeof</span>(*d));    _dictInit(d,type,privDataPtr);    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-type">int</span> _dictInit(dict *d, dictType *type,        <span class="hljs-type">void</span> *privDataPtr)&#123;    _dictReset(&amp;d-&gt;ht[<span class="hljs-number">0</span>]);    _dictReset(&amp;d-&gt;ht[<span class="hljs-number">1</span>]);    d-&gt;type = type;    d-&gt;privdata = privDataPtr;    d-&gt;rehashidx = <span class="hljs-number">-1</span>;    d-&gt;iterators = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> DICT_OK;&#125;</code></pre></div></li></ul><h2 id="dictAdd"><a href="#dictAdd" class="headerlink" title="dictAdd"></a>dictAdd</h2><p>添加键值对，主要逻辑如下：</p><ul><li>调用<code>dictAddRaw</code>，添加键</li><li>给返回的新节点设置值（更新val字段）<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">dictAdd</span><span class="hljs-params">(dict *d, <span class="hljs-type">void</span> *key, <span class="hljs-type">void</span> *val)</span>&#123;    <span class="hljs-comment">//添加键，字典中键已存在则返回NULL，否则添加新节点，并返回</span>    dictEntry *entry = dictAddRaw(d,key,<span class="hljs-literal">NULL</span>);    <span class="hljs-comment">//键存在则添加错误</span>    <span class="hljs-keyword">if</span> (!entry) <span class="hljs-keyword">return</span> DICT_ERR;    <span class="hljs-comment">//设置值</span>    dictSetVal(d, entry, val);    <span class="hljs-keyword">return</span> DICT_OK;&#125;<span class="hljs-comment">//d为入参字典，key为键，existing为Hash表节点地址</span>dictEntry *<span class="hljs-title function_">dictAddRaw</span><span class="hljs-params">(dict *d, <span class="hljs-type">void</span> *key, dictEntry **existing)</span>&#123;    <span class="hljs-type">long</span> index;    dictEntry *entry;    dictht *ht;    <span class="hljs-comment">//字典是否在进行rehash操作</span>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);    <span class="hljs-comment">//查找键，找到直接返回-1，并把老节点存放在existing里，否则返回新节点索引值</span>    <span class="hljs-keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;，    <span class="hljs-comment">//检测容量</span>    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="hljs-number">1</span>] : &amp;d-&gt;ht[<span class="hljs-number">0</span>];    <span class="hljs-comment">//申请新节点内存空间，插入哈希表</span>    entry = zmalloc(<span class="hljs-keyword">sizeof</span>(*entry));    entry-&gt;next = ht-&gt;table[index];    ht-&gt;table[index] = entry;    ht-&gt;used++;    <span class="hljs-comment">//存储键信息</span>    dictSetKey(d, entry, key);    <span class="hljs-keyword">return</span> entry;&#125;</code></pre></div></li></ul><h2 id="dictExpand"><a href="#dictExpand" class="headerlink" title="dictExpand"></a>dictExpand</h2><p>扩容操作主要逻辑：</p><ul><li>计算扩容大小（是size的下一个2的幂）</li><li>将新申请的地址存放于ht[1]，并把<code>rehashidx</code>标为1，表示需要进行rehash</li></ul><p>扩容完成后ht[1]中为全新的Hash表，扩容之后，添加操作的键值对全部存放于全新的Hash表中，修改删除查找等操作需要在ht[0]和ht[1]中进行检查。此外还需要将ht[0]中的键值对rehash到ht[1]中。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">dictExpand</span><span class="hljs-params">(dict *d, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span>&#123;    <span class="hljs-comment">//如果已存在空间大于传入size，则无效</span>    <span class="hljs-keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="hljs-number">0</span>].used &gt; size)        <span class="hljs-keyword">return</span> DICT_ERR;    dictht n; <span class="hljs-comment">/* the new hash table */</span>    <span class="hljs-comment">//扩容值为2的幂</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> realsize = _dictNextPower(size);    <span class="hljs-comment">//相同则不扩容</span>    <span class="hljs-keyword">if</span> (realsize == d-&gt;ht[<span class="hljs-number">0</span>].size) <span class="hljs-keyword">return</span> DICT_ERR;    <span class="hljs-comment">//将新的hash表内部变量初始化，并申请对应的内存空间</span>    n.size = realsize;    n.sizemask = realsize<span class="hljs-number">-1</span>;    n.table = zcalloc(realsize*<span class="hljs-keyword">sizeof</span>(dictEntry*));    n.used = <span class="hljs-number">0</span>;    <span class="hljs-comment">//如果当前是空表，就直接存放在ht[0]</span>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].table == <span class="hljs-literal">NULL</span>) &#123;        d-&gt;ht[<span class="hljs-number">0</span>] = n;        <span class="hljs-keyword">return</span> DICT_OK;    &#125;    扩容后的新内存放入ht[<span class="hljs-number">1</span>]    d-&gt;ht[<span class="hljs-number">1</span>] = n;    <span class="hljs-comment">//表示需要进行rehash</span>    d-&gt;rehashidx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> DICT_OK;&#125;</code></pre></div><h2 id="dictResize"><a href="#dictResize" class="headerlink" title="dictResize"></a>dictResize</h2><p>缩容操作主要通过<code>dictExpand(d, minimal)</code>实现。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DICT_HT_INITIAL_SIZE     4</span><span class="hljs-type">int</span> <span class="hljs-title function_">dictResize</span><span class="hljs-params">(dict *d)</span>&#123;    <span class="hljs-type">int</span> minimal;    <span class="hljs-comment">//判断是否在rehash</span>    <span class="hljs-keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="hljs-keyword">return</span> DICT_ERR;    <span class="hljs-comment">//minimal为ht[0]的已使用量</span>    minimal = d-&gt;ht[<span class="hljs-number">0</span>].used;    <span class="hljs-comment">//如果键值对数量 &lt; 4，将缩容至4</span>    <span class="hljs-keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)        minimal = DICT_HT_INITIAL_SIZE;        <span class="hljs-comment">//调用dictExpand进行缩容</span>    <span class="hljs-keyword">return</span> dictExpand(d, minimal);&#125;</code></pre></div><h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><p>Rehash在缩容和扩容时都会触发。执行插入、删除、查找、修改操作前，会判断当前字典是否在rehash，如果在，调用<code>dictRehashStep</code>进行rehash（只对一个节点rehash）。如果服务处于空闲时，也会进行rehash操作（<code>incrementally</code>批量，一次100个节点）</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">dictRehash</span><span class="hljs-params">(dict *d, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> empty_visits = n*<span class="hljs-number">10</span>; <span class="hljs-comment">/* Max number of empty buckets to visit. */</span>    <span class="hljs-comment">//如果已经rehash结束，直接返回</span>    <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="hljs-number">0</span>].used != <span class="hljs-number">0</span>) &#123;        dictEntry *de, *nextde;        <span class="hljs-comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span><span class="hljs-comment">         * elements because ht[0].used != 0 */</span>        assert(d-&gt;ht[<span class="hljs-number">0</span>].size &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)d-&gt;rehashidx);        <span class="hljs-comment">//找到hash表中不为空的位置</span>        <span class="hljs-keyword">while</span>(d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] == <span class="hljs-literal">NULL</span>) &#123;            d-&gt;rehashidx++;            <span class="hljs-keyword">if</span> (--empty_visits == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//de为rehash标识，存放正在进行rehash节点的索引值</span>        de = d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx];        <span class="hljs-comment">/* Move all the keys in this bucket from the old to the new hash HT */</span>        <span class="hljs-keyword">while</span>(de) &#123;            <span class="hljs-type">uint64_t</span> h;            nextde = de-&gt;next;            <span class="hljs-comment">//h</span>            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="hljs-number">1</span>].sizemask;            <span class="hljs-comment">//插入</span>            de-&gt;next = d-&gt;ht[<span class="hljs-number">1</span>].table[h];            d-&gt;ht[<span class="hljs-number">1</span>].table[h] = de;            <span class="hljs-comment">//更新数据</span>            d-&gt;ht[<span class="hljs-number">0</span>].used--;            d-&gt;ht[<span class="hljs-number">1</span>].used++;            de = nextde;        &#125;        <span class="hljs-comment">//置空</span>        d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] = <span class="hljs-literal">NULL</span>;        d-&gt;rehashidx++;    &#125;    <span class="hljs-comment">//检查是否已经rehash过了</span>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used == <span class="hljs-number">0</span>) &#123;        zfree(d-&gt;ht[<span class="hljs-number">0</span>].table);        d-&gt;ht[<span class="hljs-number">0</span>] = d-&gt;ht[<span class="hljs-number">1</span>];        _dictReset(&amp;d-&gt;ht[<span class="hljs-number">1</span>]);        d-&gt;rehashidx = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/* More to rehash... */</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="dictFind"><a href="#dictFind" class="headerlink" title="dictFind"></a>dictFind</h2><p>查找键的逻辑较为简单，遍历ht[0]和ht[1]。</p><div class="code-wrapper"><pre><code class="hljs C">dictEntry *<span class="hljs-title function_">dictFind</span><span class="hljs-params">(dict *d, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span>&#123;    dictEntry *he;    <span class="hljs-type">uint64_t</span> h, idx, table;    <span class="hljs-comment">//字典为空，直接返回</span>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used + d-&gt;ht[<span class="hljs-number">1</span>].used == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* dict is empty */</span>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);    <span class="hljs-comment">//获取键的hash值</span>    h = dictHashKey(d, key);    <span class="hljs-comment">//遍历查找hash表,ht[0]和ht[1]</span>    <span class="hljs-keyword">for</span> (table = <span class="hljs-number">0</span>; table &lt;= <span class="hljs-number">1</span>; table++) &#123;        idx = h &amp; d-&gt;ht[table].sizemask;        he = d-&gt;ht[table].table[idx];        <span class="hljs-comment">//遍历单链表</span>        <span class="hljs-keyword">while</span>(he) &#123;            <span class="hljs-keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))                <span class="hljs-keyword">return</span> he;            he = he-&gt;next;        &#125;        <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><h2 id="dictDelete"><a href="#dictDelete" class="headerlink" title="dictDelete"></a>dictDelete</h2><p>删除的主要逻辑如下：</p><ul><li>查找该键是否存在于该字典中</li><li>存在则将节点从单链表中删除</li><li>释放节点内存空间，used减一<div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">dictDelete</span><span class="hljs-params">(dict *ht, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span> &#123;    <span class="hljs-keyword">return</span> dictGenericDelete(ht,key,<span class="hljs-number">0</span>) ? DICT_OK : DICT_ERR;&#125;<span class="hljs-type">static</span> dictEntry *<span class="hljs-title function_">dictGenericDelete</span><span class="hljs-params">(dict *d, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">int</span> nofree)</span> &#123;    <span class="hljs-type">uint64_t</span> h, idx;    dictEntry *he, *prevHe;    <span class="hljs-type">int</span> table;    <span class="hljs-comment">//如果字典为空直接返回</span>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used == <span class="hljs-number">0</span> &amp;&amp; d-&gt;ht[<span class="hljs-number">1</span>].used == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//。如果正在rehash，则调用_dictRehashStep进行rehash一次</span>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);    <span class="hljs-comment">//获取需要删除节点的键Hash值</span>    h = dictHashKey(d, key);    <span class="hljs-comment">//从ht[0]和ht[1]中查找</span>    <span class="hljs-keyword">for</span> (table = <span class="hljs-number">0</span>; table &lt;= <span class="hljs-number">1</span>; table++) &#123;        idx = h &amp; d-&gt;ht[table].sizemask;        he = d-&gt;ht[table].table[idx];        prevHe = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//遍历单链表查找</span>        <span class="hljs-keyword">while</span>(he) &#123;            <span class="hljs-keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;                <span class="hljs-comment">//删除节点</span>                <span class="hljs-keyword">if</span> (prevHe)                    prevHe-&gt;next = he-&gt;next;                <span class="hljs-keyword">else</span>                    d-&gt;ht[table].table[idx] = he-&gt;next;                <span class="hljs-keyword">if</span> (!nofree) &#123;                    <span class="hljs-comment">//释放节点内存空间</span>                    dictFreeKey(d, he);                    dictFreeVal(d, he);                    zfree(he);                &#125;                <span class="hljs-comment">//used自减一</span>                d-&gt;ht[table].used--;                <span class="hljs-keyword">return</span> he;            &#125;            prevHe = he;            he = he-&gt;next;        &#125;        <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* not found */</span>&#125;</code></pre></div></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要对Redis中的字典基本结构做了简要分析，对字典的创建，键值对添加&#x2F;删除&#x2F;查找等操作与字典的缩容扩容机制做了简要分析，键值对修改操作主要通过<code>db.c</code>中的<code>dbOverwrite</code>函数调用<code>dictSetVal</code>实现。</p><p>字典是通过两个hashtable来实现的，一个用于日常存储，一个用于渐进式rehash，字典被应用于提供的<strong>hash结构</strong>和服务端的<strong>数据库存储</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>源码分析</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构-ZipList源码分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-ziplist/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-ziplist/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>压缩列表（ziplist）的本质是一个字节数组，主要是Redis为了节省内存而设计的数据结构。在Redis的list和hash都使用了ziplist，<strong>当list或hash的元素个数比较少，并且元素都是短字符串或小整数值时</strong>，使用ziplist作为其底层数据结构。</p><p>压缩列表的基本结构基本如下所示：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">zlbytes</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">zltail</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">zllen</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span> ... <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">zlend</span>&gt;</span></code></pre></div><ul><li>uint32_t zlbytes：压缩列表的字节长度，占4个字节</li><li>uint32_t zltail：压缩列表尾元素相对于起始地址的偏移量，占4个字节，方便从列表尾部进行操作</li><li>uint16_t zllen：元素个数，占2个字节，元素个数无法超过2^16-1，只能通过遍历整个列表才能获取到个数</li><li>uint8_t zlend：列表的结尾元素，占1个字节，值为255（0xff）</li><li>entry：列表的元素，可以是字节数组或者整数<ul><li>prevlen：表示前一个元素的字节长度，1~5个字节表示，当前一个元素长度小于254字节，用1个字节表示，大于或等于254字节时，用5个字节表示，该情况下，第一个字节为<code>0xFE</code>，剩余4个字节表示真正长度</li><li>encoding：表示当前元素的编码，编码表示当前存储的是字节数组还是整数</li><li>entry：存储数据内容</li></ul></li></ul><p>encoding选项：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_INT_8B 0xfe</span></code></pre></div><p>下面是一个包含两个元素的ziplist，存储的数据为字符串“2”和“5”。它由15个字节组成</p><div class="code-wrapper"><pre><code class="hljs gherkin">[0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]      |<span class="hljs-string">             </span>|<span class="hljs-string">          </span>|<span class="hljs-string">       </span>|<span class="hljs-string">       </span>|<span class="hljs-string">     </span>|   zlbytes        zltail    entries   <span class="hljs-string">&quot;2&quot;</span>     <span class="hljs-string">&quot;5&quot;</span>   end</code></pre></div><p>Redis通过宏定义来对以上部分进行快速定位，zl为压缩列表首地址指针。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></code></pre></div><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>压缩列表在获取元素长度、获取元素内容都需要经过解码运算，解码后的数据结果存储在zlentry结构中。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zlentry</span> &#123;</span>    <span class="hljs-comment">//上述的prevlen的长度</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlensize;    <span class="hljs-comment">//上述的prevlen的内容</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlen;    <span class="hljs-comment">//encoding字段的长度</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lensize;    <span class="hljs-comment">//元素数据的长度</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;    <span class="hljs-comment">//当前元素的首部长度，prevrawlensize + lensize</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> headersize;    <span class="hljs-comment">//数据类型</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encoding;    <span class="hljs-comment">//指向元素的首地址的指针</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p;           &#125; zlentry;</code></pre></div><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="ziplistNew"><a href="#ziplistNew" class="headerlink" title="ziplistNew"></a>ziplistNew</h2><p>创建压缩列表，返回值为压缩列表的首地址。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">ziplistNew</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;    <span class="hljs-comment">//计算分配的字节数</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;    <span class="hljs-comment">//申请内存空间</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl = zmalloc(bytes);    <span class="hljs-comment">//初始化</span>    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);    ZIPLIST_LENGTH(zl) = <span class="hljs-number">0</span>;    <span class="hljs-comment">//设置结尾标识符0xff</span>    zl[bytes<span class="hljs-number">-1</span>] = ZIP_END;    <span class="hljs-keyword">return</span> zl;&#125;</code></pre></div><h2 id="ziplistInsert"><a href="#ziplistInsert" class="headerlink" title="ziplistInsert"></a>ziplistInsert</h2><p>该接口在指定的位置p，插入的数据的地址指针为s，长度为slen。新插入的数据占据p原来的位置，p之后的数据项向后移动。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">ziplistInsert</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> slen)</span> &#123;    <span class="hljs-keyword">return</span> __ziplistInsert(zl,p,s,slen);&#125;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *__ziplistInsert(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> slen) &#123;    <span class="hljs-type">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;    <span class="hljs-comment">//初始化变量</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevlensize, prevlen = <span class="hljs-number">0</span>;    <span class="hljs-type">size_t</span> offset;    <span class="hljs-type">int</span> nextdiff = <span class="hljs-number">0</span>;    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encoding = <span class="hljs-number">0</span>;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> value = <span class="hljs-number">123456789</span>;    zlentry tail;    <span class="hljs-comment">//如果p不是尾元素</span>    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] != ZIP_END) &#123;        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);        <span class="hljs-keyword">if</span> (ptail[<span class="hljs-number">0</span>] != ZIP_END) &#123;            prevlen = zipRawEntryLength(ptail);        &#125;    &#125;    <span class="hljs-comment">//尝试将数据内容解析为整数</span>    <span class="hljs-keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;        <span class="hljs-comment">//按整数类型编码进行存储</span>        reqlen = zipIntSize(encoding);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//按字节数组类型编码进行存储</span>        reqlen = slen;    &#125;    <span class="hljs-comment">/* We need space for both the length of the previous entry and</span><span class="hljs-comment">     * the length of the payload. */</span>    reqlen += zipStorePrevEntryLength(<span class="hljs-literal">NULL</span>,prevlen);    reqlen += zipStoreEntryEncoding(<span class="hljs-literal">NULL</span>,encoding,slen);    <span class="hljs-comment">//不是从尾部进行插入时，需要确保下一个entry可以存储当前entry的长度</span>    <span class="hljs-type">int</span> forcelarge = <span class="hljs-number">0</span>;    nextdiff = (p[<span class="hljs-number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (nextdiff == <span class="hljs-number">-4</span> &amp;&amp; reqlen &lt; <span class="hljs-number">4</span>) &#123;        nextdiff = <span class="hljs-number">0</span>;        forcelarge = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//存储偏移量</span>    offset = p-zl;    <span class="hljs-comment">//调用realloc重新分配空间</span>    zl = ziplistResize(zl,curlen+reqlen+nextdiff);    <span class="hljs-comment">//重新偏移到插入位置p</span>    p = zl+offset;    <span class="hljs-comment">//数据复制</span>    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] != ZIP_END) &#123;        <span class="hljs-comment">//因为zlend恒为0xff，所以减一</span>        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="hljs-number">-1</span>+nextdiff);        <span class="hljs-comment">//更新entryX + 1元素的prevlen数据</span>        <span class="hljs-keyword">if</span> (forcelarge)        <span class="hljs-comment">//该entry的prevlen仍然用5个字节存储时</span>            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);        <span class="hljs-keyword">else</span>            zipStorePrevEntryLength(p+reqlen,reqlen);        <span class="hljs-comment">//更新zltail</span>        ZIPLIST_TAIL_OFFSET(zl) =            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);        <span class="hljs-comment">//</span>        zipEntry(p+reqlen, &amp;tail);        <span class="hljs-keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;            ZIPLIST_TAIL_OFFSET(zl) =                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;               ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);    &#125;        <span class="hljs-keyword">if</span> (nextdiff != <span class="hljs-number">0</span>) &#123;        offset = p-zl;        zl = __ziplistCascadeUpdate(zl,p+reqlen);        p = zl+offset;    &#125;    <span class="hljs-comment">//写entry</span>    p += zipStorePrevEntryLength(p,prevlen);    p += zipStoreEntryEncoding(p,encoding,slen);    <span class="hljs-keyword">if</span> (ZIP_IS_STR(encoding)) &#123;        <span class="hljs-built_in">memcpy</span>(p,s,slen);    &#125; <span class="hljs-keyword">else</span> &#123;        zipSaveInteger(p,value,encoding);    &#125;    <span class="hljs-comment">//更新zllen</span>    ZIPLIST_INCR_LENGTH(zl,<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> zl;&#125;</code></pre></div><h2 id="ziplistDelete"><a href="#ziplistDelete" class="headerlink" title="ziplistDelete"></a>ziplistDelete</h2><p>zl指向压缩列表首地址，*p指向需要删除的entry的首地址，返回值为压缩列表首地址。<code>__ziplistDelete</code>可以同时删除多个连续元素，输入参数p指向的是首个待删除元素的地址，num表示待删除的元素个数。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">ziplistDelete</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **p)</span> &#123;    <span class="hljs-type">size_t</span> offset = *p-zl;    zl = __ziplistDelete(zl,*p,<span class="hljs-number">1</span>);        *p = zl+offset;    <span class="hljs-keyword">return</span> zl;&#125;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *__ziplistDelete(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num) &#123;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i, totlen, deleted = <span class="hljs-number">0</span>;    <span class="hljs-type">size_t</span> offset;    <span class="hljs-type">int</span> nextdiff = <span class="hljs-number">0</span>;    zlentry first, tail;    <span class="hljs-comment">//解码第一个待删除的元素</span>    zipEntry(p, &amp;first);    <span class="hljs-comment">//遍历所有待删除的元素，同时指针p向后偏移</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; p[<span class="hljs-number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;        p += zipRawEntryLength(p);        deleted++;    &#125;    <span class="hljs-comment">//该变量为待删除元素总长度</span>    totlen = p-first.p; <span class="hljs-comment">/* Bytes taken by the element(s) to delete. */</span>    <span class="hljs-keyword">if</span> (totlen &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>] != ZIP_END) &#123;            <span class="hljs-comment">//计算元素entryN长度的变化量</span>            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);            <span class="hljs-comment">//更新元素entryN的prevlen数据</span>            p -= nextdiff;            zipStorePrevEntryLength(p,first.prevrawlen);            <span class="hljs-comment">//更新zltail</span>            ZIPLIST_TAIL_OFFSET(zl) =                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);            zipEntry(p, &amp;tail);            <span class="hljs-keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;                ZIPLIST_TAIL_OFFSET(zl) =                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);            &#125;            <span class="hljs-comment">//数据复制</span>            memmove(first.p,p,                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class="hljs-number">-1</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">/* The entire tail was deleted. No need to move memory. */</span>            ZIPLIST_TAIL_OFFSET(zl) =                intrev32ifbe((first.p-zl)-first.prevrawlen);        &#125;        <span class="hljs-comment">//重新分配空间，与添加逻辑相似</span>        offset = first.p-zl;        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);        ZIPLIST_INCR_LENGTH(zl,-deleted);        p = zl+offset;        <span class="hljs-keyword">if</span> (nextdiff != <span class="hljs-number">0</span>)            zl = __ziplistCascadeUpdate(zl,p);    &#125;    <span class="hljs-keyword">return</span> zl;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要对压缩列表的基本概念与在Redis中的具体实现做了简要分析，同时对压缩列表在Redis中的添加删除接口做了简要的源代码分析。使用压缩列表能有效地节省内存，在Redis的Hash结构中，当field比较少时，采用压缩列表进行存储，当达到对应阈值，转为dict进行存储，与JDK1.8中的HashMap存储策略有异曲同工之妙。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>源码分析</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构-SkipList源码分析</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-zskiplist/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/redis-zskiplist/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>跳表(SkipList)通过对有序链表添加多级索引，从而实现类似于二分查找效果的有序链表，它的插入&#x2F;删除&#x2F;搜索的平均时间复杂度为<code>O(log n)</code>，该数据结构可以用来代替平衡树以提高效率。其基本结构如 下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/redis/skiplist/skiplist.png" alt="跳表基本结构"></p><p>如果此时查找51的节点，步骤基本如下：</p><ol><li>从第二层开始查找，1比51小，向后比较</li><li>21比51小，21后面为NULL，下降到第一层的21先后比较</li><li>第一层中21的next节点为41，41比51小，41的next节点61比51大，下降到第0层比较</li><li>41的next节点为51，查找完成。</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>zskiplistNode：</p><ul><li>ele：存储SDS类型的数据</li><li>score：排序用的分值</li><li>backward：后退指针，指向当前节点最底层的前驱节点，第一个指向NULL</li><li>level：数组，它的长度在生成时随机生成一个1 ~ 64的值，值越大出现概率越低<ul><li>forward：指向本层的下一个节点，尾节点指向NULL</li><li>span：指向的节点与本节点之间的元素个数</li></ul></li></ul><p>zskiplist：</p><ul><li>header：指向跳表的头节点</li><li>tail：指向跳表的尾节点</li><li>length：跳表的长度</li><li>level：跳表的高度</li></ul><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* ZSETs use a specialized version of Skiplists */</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span>    sds ele;    <span class="hljs-type">double</span> score;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;    &#125; level[];&#125; zskiplistNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;    <span class="hljs-type">int</span> level;&#125; zskiplist;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span>    dict *dict;    zskiplist *zsl;&#125; zset;</code></pre></div><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="zslCreate"><a href="#zslCreate" class="headerlink" title="zslCreate"></a>zslCreate</h2><h3 id="zslCreateNode"><a href="#zslCreateNode" class="headerlink" title="zslCreateNode"></a>zslCreateNode</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Create a skiplist node with the specified number of levels.</span><span class="hljs-comment"> * The SDS string &#x27;ele&#x27; is referenced by the node after the call. */</span>zskiplistNode *<span class="hljs-title function_">zslCreateNode</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">double</span> score, sds ele)</span> &#123;    <span class="hljs-comment">//申请内存空间</span>    zskiplistNode *zn =        zmalloc(<span class="hljs-keyword">sizeof</span>(*zn)+level*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> zskiplistLevel));    <span class="hljs-comment">//初始化</span>    zn-&gt;score = score;    zn-&gt;ele = ele;    <span class="hljs-keyword">return</span> zn;&#125;</code></pre></div><h3 id="zslCreate-1"><a href="#zslCreate-1" class="headerlink" title="zslCreate"></a>zslCreate</h3><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Create a new skiplist. */</span>zskiplist *<span class="hljs-title function_">zslCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;    <span class="hljs-type">int</span> j;    <span class="hljs-comment">//指向跳表的指针</span>    zskiplist *zsl;<span class="hljs-comment">//申请内存空间</span>    zsl = zmalloc(<span class="hljs-keyword">sizeof</span>(*zsl));    <span class="hljs-comment">//设置默认值</span>    zsl-&gt;level = <span class="hljs-number">1</span>;    zsl-&gt;length = <span class="hljs-number">0</span>;    <span class="hljs-comment">//创建头节点</span>    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);    <span class="hljs-comment">//将头节点的level数组的forward设置为NULL，span设置为0</span>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;        zsl-&gt;header-&gt;level[j].forward = <span class="hljs-literal">NULL</span>;        zsl-&gt;header-&gt;level[j].span = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//设置头尾节点</span>    zsl-&gt;header-&gt;backward = <span class="hljs-literal">NULL</span>;    zsl-&gt;tail = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> zsl;&#125;</code></pre></div><h2 id="zslRandomLevel"><a href="#zslRandomLevel" class="headerlink" title="zslRandomLevel"></a>zslRandomLevel</h2><p>level最小值为1，最大值为64，该方法随机生成1 ~ 64的值。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZSKIPLIST_MAXLEVEL 64</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZSKIPLIST_P 0.25</span><span class="hljs-type">int</span> <span class="hljs-title function_">zslRandomLevel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;    <span class="hljs-type">int</span> level = <span class="hljs-number">1</span>;    <span class="hljs-comment">//生成随机值，取低16位为x，当x &lt; 0.25 * 0xFFFF时，level自增1</span>    <span class="hljs-keyword">while</span> ((random()&amp;<span class="hljs-number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="hljs-number">0xFFFF</span>))        level += <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;&#125;</code></pre></div><h2 id="zslInsert"><a href="#zslInsert" class="headerlink" title="zslInsert"></a>zslInsert</h2><p>插入逻辑主要如下：</p><ul><li>查找要插入的位置</li><li>调整跳表高度</li><li>插入节点</li><li>调整backward</li></ul><div class="code-wrapper"><pre><code class="hljs C">zskiplistNode *<span class="hljs-title function_">zslInsert</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele)</span> &#123;    <span class="hljs-comment">//保存每一层需要更新的节点</span>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;    <span class="hljs-comment">//保存从header到update[i]节点的步长</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rank[ZSKIPLIST_MAXLEVEL];    <span class="hljs-type">int</span> i, level;    serverAssert(!isnan(score));    <span class="hljs-comment">//查找要插入的位置</span>    x = zsl-&gt;header;    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">/* store rank that is crossed to reach the insert position */</span>        rank[i] = i == (zsl-&gt;level<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : rank[i+<span class="hljs-number">1</span>];        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;                (x-&gt;level[i].forward-&gt;score &lt; score ||                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>)))        &#123;            rank[i] += x-&gt;level[i].span;            x = x-&gt;level[i].forward;        &#125;        update[i] = x;    &#125;    <span class="hljs-comment">//获取随机层数</span>    level = zslRandomLevel();    <span class="hljs-comment">//如果插入的层数大于最高层，设置rank和update数组</span>    <span class="hljs-keyword">if</span> (level &gt; zsl-&gt;level) &#123;        <span class="hljs-keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;            rank[i] = <span class="hljs-number">0</span>;            update[i] = zsl-&gt;header;            update[i]-&gt;level[i].span = zsl-&gt;length;        &#125;        zsl-&gt;level = level;    &#125;    <span class="hljs-comment">//创建节点</span>    x = zslCreateNode(level,score,ele);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;        <span class="hljs-comment">//更新指向</span>        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;        update[i]-&gt;level[i].forward = x;        <span class="hljs-comment">//更新span</span>        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="hljs-number">0</span>] - rank[i]);        update[i]-&gt;level[i].span = (rank[<span class="hljs-number">0</span>] - rank[i]) + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/* increment span for untouched levels */</span>    <span class="hljs-keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;        update[i]-&gt;level[i].span++;    &#125;<span class="hljs-comment">//调整backward指针</span>    x-&gt;backward = (update[<span class="hljs-number">0</span>] == zsl-&gt;header) ? <span class="hljs-literal">NULL</span> : update[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward)        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x;    <span class="hljs-keyword">else</span>        zsl-&gt;tail = x;    zsl-&gt;length++;    <span class="hljs-keyword">return</span> x;&#125;</code></pre></div><h2 id="zslDelete"><a href="#zslDelete" class="headerlink" title="zslDelete"></a>zslDelete</h2><p>删除逻辑主要如下：</p><ul><li>查找需要删除的节点</li><li>设置span和forward</li></ul><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">// 删除指定的节点，节点是否删除取决于 node是否为 NULL，如果为 NULL的话就删除，否则将值存到 *node中</span><span class="hljs-type">int</span> <span class="hljs-title function_">zslDelete</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele, zskiplistNode **node)</span> &#123;    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;    <span class="hljs-type">int</span> i;    x = zsl-&gt;header;    <span class="hljs-comment">// 定位到每一层需要删除的位置</span>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;                (x-&gt;level[i].forward-&gt;score &lt; score ||                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>)))        &#123;            x = x-&gt;level[i].forward;        &#125;        update[i] = x;    &#125;       <span class="hljs-comment">// 在第一层(也就是完整的链表)中找到要删除的节点位置</span>    x = x-&gt;level[<span class="hljs-number">0</span>].forward;    <span class="hljs-comment">// 完全相同才进行删除</span>    <span class="hljs-keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="hljs-number">0</span>) &#123;        zslDeleteNode(zsl, x, update);        <span class="hljs-keyword">if</span> (!node)            zslFreeNode(x);        <span class="hljs-keyword">else</span>            *node = x;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 遍历结束也没找到</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 删除节点</span><span class="hljs-type">void</span> <span class="hljs-title function_">zslDeleteNode</span><span class="hljs-params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> &#123;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zsl-&gt;level; i++) &#123;        <span class="hljs-comment">// 更新 span和前驱指针</span>        <span class="hljs-keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="hljs-number">1</span>;            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 不相等说明这些节点都在要删除的节点之前，跨度 span应该减 1</span>            update[i]-&gt;level[i].span -= <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward) &#123;        <span class="hljs-comment">// 更新前驱指针，相当于更新双向链表的 prev指向</span>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x-&gt;backward;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 说明要删除的节点是最后一个节点，更新尾节点</span>        zsl-&gt;tail = x-&gt;backward;    &#125;    <span class="hljs-comment">// 对于最上面都是空的层，应该排除，从第一个有数据的层开始算作有效</span>    <span class="hljs-keyword">while</span>(zsl-&gt;level &gt; <span class="hljs-number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="hljs-number">-1</span>].forward == <span class="hljs-literal">NULL</span>)        zsl-&gt;level--;    zsl-&gt;length--;&#125;</code></pre></div><h2 id="zslFree"><a href="#zslFree" class="headerlink" title="zslFree"></a>zslFree</h2><p>删除跳表逻辑：</p><ul><li>释放头节点</li><li>从头节点的第0层开始，通过forward向后遍历，逐个释放节点的内存空间</li><li>最后释放跳表指针空间</li></ul><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Free a whole skiplist. */</span><span class="hljs-type">void</span> <span class="hljs-title function_">zslFree</span><span class="hljs-params">(zskiplist *zsl)</span> &#123;    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="hljs-number">0</span>].forward, *next;    zfree(zsl-&gt;header);    <span class="hljs-keyword">while</span>(node) &#123;        next = node-&gt;level[<span class="hljs-number">0</span>].forward;        zslFreeNode(node);        node = next;    &#125;    zfree(zsl);&#125;<span class="hljs-comment">//释放节点，首先释放SDS的空间，再释放节点空间</span><span class="hljs-type">void</span> <span class="hljs-title function_">zslFreeNode</span><span class="hljs-params">(zskiplistNode *node)</span> &#123;    sdsfree(node-&gt;ele);    zfree(node);&#125;</code></pre></div><h2 id="zslUpdateScore"><a href="#zslUpdateScore" class="headerlink" title="zslUpdateScore"></a>zslUpdateScore</h2><p>更新节点的排序分数基本逻辑如下：</p><ul><li>找到对应需要更新的节点</li></ul><div class="code-wrapper"><pre><code class="hljs C">zskiplistNode *<span class="hljs-title function_">zslUpdateScore</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> curscore, sds ele, <span class="hljs-type">double</span> newscore)</span> &#123;    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;    <span class="hljs-type">int</span> i;    <span class="hljs-comment">//找到对应需要更新的节点</span>    x = zsl-&gt;header;    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;                (x-&gt;level[i].forward-&gt;score &lt; curscore ||                    (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>)))        &#123;            x = x-&gt;level[i].forward;        &#125;        update[i] = x;    &#125;    <span class="hljs-comment">/* Jump to our element: note that this function assumes that the</span><span class="hljs-comment">     * element with the matching score exists. */</span>    x = x-&gt;level[<span class="hljs-number">0</span>].forward;    serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="hljs-number">0</span>);<span class="hljs-comment">//直接更新    </span>    <span class="hljs-keyword">if</span> ((x-&gt;backward == <span class="hljs-literal">NULL</span> || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;        (x-&gt;level[<span class="hljs-number">0</span>].forward == <span class="hljs-literal">NULL</span> || x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;score &gt; newscore))    &#123;        x-&gt;score = newscore;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-comment">//无法重用旧节点时，删除后重新添加</span>    zslDeleteNode(zsl, x, update);    zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);    <span class="hljs-comment">/* We reused the old node x-&gt;ele SDS string, free the node now</span><span class="hljs-comment">     * since zslInsert created a new one. */</span>    x-&gt;ele = <span class="hljs-literal">NULL</span>;    zslFreeNode(x);    <span class="hljs-keyword">return</span> newnode;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要对跳表的概念和基本查询思路做了简要分析，对Redis中的跳表的数据结构和基本增删改查接口做了简要的源代码分析。在Redis中的有序集合<code>zset</code>就是通过<code>skiplist</code>和<code>dict</code>组合实现的。另外一处运用则是集群节点中用作内部的数据结构。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>源码分析</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis底层数据结构-SDS</title>
    <link href="/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-SDS/"/>
    <url>/2020/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-SDS/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>简单动态字符串(Simple Dynamic Strings)是Redis的基本数据结构之一，主要用于存储字符串和整型数据。SDS兼容C语言标准字符串处理函数，同时保证了二进制安全。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="原始版本"><a href="#原始版本" class="headerlink" title="原始版本"></a>原始版本</h2><p>在Redis 3.2之前，SDS基本结构如下：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">//buf中已使用字节数</span>    <span class="hljs-type">int</span> len;    <span class="hljs-comment">//buf中剩余字节数</span>    <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;    <span class="hljs-comment">//数据</span>    <span class="hljs-type">char</span> buf[];&#125;</code></pre></div><p>该结构有如下几个优点：</p><ul><li>有单独的变量存储字符串长度，由于有长度，不会依赖于<code>\0</code>终止符，保证二进制安全。</li><li>杜绝了缓冲区溢出问题。</li><li>获取字符串长度为O(1)</li><li>字符串存储在buf数组中，兼容C处理字符串的函数。</li><li>减少修改字符串时带来的内存分配次数。<ul><li>SDS的空间是预先分配的</li><li>惰性空间释放：当SDS保存的字符串缩短后，并不会立即将内存空间free</li></ul></li></ul><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>Redis 3.2之后，采用如下结构进行存储。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span>    <span class="hljs-type">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="hljs-type">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="hljs-type">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="hljs-type">char</span> buf[];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="hljs-type">char</span> buf[];&#125;;</code></pre></div><p>sdshdr5中采用位来存储相关信息，其中flags占1字节，其中低3位用来表示type，高5位表示长度，所以长度区间为（0 ~ 31），所以长度大于31的字符串需要采用sdshdr8及以上存储。sdshdr8中flags低3位存储类型，剩余5位闲置。以下是字符串类型的宏定义：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDS_TYPE_5  0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDS_TYPE_8  1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDS_TYPE_16 2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDS_TYPE_32 3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDS_TYPE_64 4</span></code></pre></div><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>GCC支持用<code>__attribute__</code>为变量、类型、函数、标签指定特殊属性。这些不是编程语言标准里的内容，而属于编译器对语言的扩展。在声明SDS结构时，采用了<code>__attribute__ ((__packed__))</code>，它告诉编译器结构体使用1字节对齐。使用<code>packed</code>属性可以节省内存，同时统一多个结构的指针访问。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="sdsnewlen"><a href="#sdsnewlen" class="headerlink" title="sdsnewlen"></a>sdsnewlen</h2><div class="code-wrapper"><pre><code class="hljs C">sds <span class="hljs-title function_">sdsnewlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *init, <span class="hljs-type">size_t</span> initlen)</span> &#123;    <span class="hljs-type">void</span> *sh;    sds s;    <span class="hljs-comment">//根据字符串长度获取对应的类型</span>    <span class="hljs-type">char</span> type = sdsReqType(initlen);    <span class="hljs-comment">/* Empty strings are usually created in order to append. Use type 8</span><span class="hljs-comment">     * since type 5 is not good at this. */</span>     <span class="hljs-comment">//将SDS_TYPE_5转成SDS_TYPE_5</span>    <span class="hljs-keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="hljs-number">0</span>) type = SDS_TYPE_8;    <span class="hljs-comment">//计算对应结构体头部所需字节数</span>    <span class="hljs-type">int</span> hdrlen = sdsHdrSize(type);    <span class="hljs-comment">//指向flags的指针</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *fp; <span class="hljs-comment">/* flags pointer. */</span>    <span class="hljs-comment">//分配内存空间</span>    sh = s_malloc(hdrlen+initlen+<span class="hljs-number">1</span>);    <span class="hljs-comment">//判断是否为&quot;SDS_NOINIT&quot;</span>    <span class="hljs-keyword">if</span> (init==SDS_NOINIT)        init = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!init)        <span class="hljs-comment">//初始化结构体空间数据</span>        <span class="hljs-built_in">memset</span>(sh, <span class="hljs-number">0</span>, hdrlen+initlen+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (sh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//s是指向buf的指针</span>    s = (<span class="hljs-type">char</span>*)sh+hdrlen;    <span class="hljs-comment">//指向flags</span>    fp = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s)<span class="hljs-number">-1</span>;    <span class="hljs-comment">//针对不同结构体类型进行初始化操作</span>    <span class="hljs-keyword">switch</span>(type) &#123;        <span class="hljs-keyword">case</span> SDS_TYPE_5: &#123;            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">case</span> SDS_TYPE_8: &#123;            SDS_HDR_VAR(<span class="hljs-number">8</span>,s);            sh-&gt;len = initlen;            sh-&gt;alloc = initlen;            *fp = type;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">case</span> SDS_TYPE_16: &#123;            SDS_HDR_VAR(<span class="hljs-number">16</span>,s);            sh-&gt;len = initlen;            sh-&gt;alloc = initlen;            *fp = type;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">case</span> SDS_TYPE_32: &#123;            SDS_HDR_VAR(<span class="hljs-number">32</span>,s);            sh-&gt;len = initlen;            sh-&gt;alloc = initlen;            *fp = type;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">case</span> SDS_TYPE_64: &#123;            SDS_HDR_VAR(<span class="hljs-number">64</span>,s);            sh-&gt;len = initlen;            sh-&gt;alloc = initlen;            *fp = type;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">//如果两个参数不为0，将字符串数据复制到buf数组</span>    <span class="hljs-keyword">if</span> (initlen &amp;&amp; init)        <span class="hljs-built_in">memcpy</span>(s, init, initlen);    s[initlen] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-keyword">return</span> s;&#125;</code></pre></div><h2 id="sdsfree"><a href="#sdsfree" class="headerlink" title="sdsfree"></a>sdsfree</h2><p>通过定位SDS的头部，调用<code>s_free</code>释放内存。为了减少申请内存的开销，SDS可以提供<code>sdsclear</code>进行重置达到清空的目的。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">/* Free an sds string. No operation is performed if &#x27;s&#x27; is NULL. */</span><span class="hljs-type">void</span> <span class="hljs-title function_">sdsfree</span><span class="hljs-params">(sds s)</span> &#123;    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;    s_free((<span class="hljs-type">char</span>*)s-sdsHdrSize(s[<span class="hljs-number">-1</span>]));</code></pre></div><h2 id="sdsclear"><a href="#sdsclear" class="headerlink" title="sdsclear"></a>sdsclear</h2><p>该方法将字符串长度设置为0，同时将数组第一个元素置为终止符。</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">sdsclear</span><span class="hljs-params">(sds s)</span> &#123;    sdssetlen(s, <span class="hljs-number">0</span>);    s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;&#125;</code></pre></div><h2 id="sdscatsds"><a href="#sdscatsds" class="headerlink" title="sdscatsds"></a>sdscatsds</h2><p>通过调用<code>sdscatlen</code>实现拼接逻辑。</p><div class="code-wrapper"><pre><code class="hljs C">sds <span class="hljs-title function_">sdscatsds</span><span class="hljs-params">(sds s, <span class="hljs-type">const</span> sds t)</span> &#123;    <span class="hljs-keyword">return</span> sdscatlen(s, t, sdslen(t));&#125;sds <span class="hljs-title function_">sdscatlen</span><span class="hljs-params">(sds s, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *t, <span class="hljs-type">size_t</span> len)</span> &#123;    <span class="hljs-type">size_t</span> curlen = sdslen(s);    <span class="hljs-comment">//对buf进行扩容，会进行扩容检测</span>    s = sdsMakeRoomFor(s,len);    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//调用memcpy实现拼接</span>    <span class="hljs-built_in">memcpy</span>(s+curlen, t, len);    <span class="hljs-comment">//更新长度</span>    sdssetlen(s, curlen+len);    <span class="hljs-comment">//设置终止符</span>    s[curlen+len] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-keyword">return</span> s;&#125;</code></pre></div><h2 id="sdsMakeRoomFor"><a href="#sdsMakeRoomFor" class="headerlink" title="sdsMakeRoomFor"></a>sdsMakeRoomFor</h2><p>SDS扩容操作：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDS_MAX_PREALLOC (1024*1024)</span>sds <span class="hljs-title function_">sdsMakeRoomFor</span><span class="hljs-params">(sds s, <span class="hljs-type">size_t</span> addlen)</span> &#123;    <span class="hljs-type">void</span> *sh, *newsh;    <span class="hljs-comment">//剩余有效空间</span>    <span class="hljs-type">size_t</span> avail = sdsavail(s);    <span class="hljs-type">size_t</span> len, newlen;    <span class="hljs-type">char</span> type, oldtype = s[<span class="hljs-number">-1</span>] &amp; SDS_TYPE_MASK;    <span class="hljs-type">int</span> hdrlen;    <span class="hljs-comment">//判断有效空间是否大于需要增加的空间大小</span>    <span class="hljs-keyword">if</span> (avail &gt;= addlen) <span class="hljs-keyword">return</span> s;    <span class="hljs-comment">//sds已使用长度</span>    len = sdslen(s);    sh = (<span class="hljs-type">char</span>*)s-sdsHdrSize(oldtype);    <span class="hljs-comment">//新长度</span>    newlen = (len+addlen);    <span class="hljs-comment">//define SDS_MAX_PREALLOC (1024*1024)</span>    <span class="hljs-comment">//如果新长度 &lt; 1MB，扩大两倍</span>    <span class="hljs-keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)        newlen *= <span class="hljs-number">2</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-comment">//否则扩大1MB</span>        newlen += SDS_MAX_PREALLOC;    <span class="hljs-comment">//根据新长度获取对应type</span>    type = sdsReqType(newlen);    <span class="hljs-comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span><span class="hljs-comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span><span class="hljs-comment">     * at every appending operation. */</span>    <span class="hljs-keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;    <span class="hljs-comment">//</span>    hdrlen = sdsHdrSize(type);    <span class="hljs-keyword">if</span> (oldtype==type) &#123;        <span class="hljs-comment">//无需更改type，通过s_realloc扩大buf数组即可</span>        newsh = s_realloc(sh, hdrlen+newlen+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        s = (<span class="hljs-type">char</span>*)newsh+hdrlen;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">/* Since the header size changes, need to move the string forward,</span><span class="hljs-comment">         * and can&#x27;t use realloc */</span>         <span class="hljs-comment">//按新的数组长度申请内存</span>        newsh = s_malloc(hdrlen+newlen+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//将buf移动到新位置</span>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span>*)newsh+hdrlen, s, len+<span class="hljs-number">1</span>);        <span class="hljs-comment">//释放原来的指针</span>        s_free(sh);        <span class="hljs-comment">//s是指向buf起始位置的指针</span>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen;        <span class="hljs-comment">//赋值flags</span>        s[<span class="hljs-number">-1</span>] = type;        <span class="hljs-comment">//设置新的字符串长度</span>        sdssetlen(s, len);    &#125;    <span class="hljs-comment">//设置新的数组长度</span>    sdssetalloc(s, newlen);    <span class="hljs-keyword">return</span> s;&#125;</code></pre></div><h2 id="sdsRemoveFreeSpace"><a href="#sdsRemoveFreeSpace" class="headerlink" title="sdsRemoveFreeSpace"></a>sdsRemoveFreeSpace</h2><p>缩容操作：</p><div class="code-wrapper"><pre><code class="hljs C">sds <span class="hljs-title function_">sdsRemoveFreeSpace</span><span class="hljs-params">(sds s)</span> &#123;    <span class="hljs-type">void</span> *sh, *newsh;    <span class="hljs-type">char</span> type, oldtype = s[<span class="hljs-number">-1</span>] &amp; SDS_TYPE_MASK;    <span class="hljs-type">int</span> hdrlen, oldhdrlen = sdsHdrSize(oldtype);    <span class="hljs-comment">//字符串长度</span>    <span class="hljs-type">size_t</span> len = sdslen(s);    <span class="hljs-comment">//剩余有效长度</span>    <span class="hljs-type">size_t</span> avail = sdsavail(s);    sh = (<span class="hljs-type">char</span>*)s-oldhdrlen;    如果不需要缩容直接返回    <span class="hljs-keyword">if</span> (avail == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;    <span class="hljs-comment">//根据长度获取类型</span>    type = sdsReqType(len);    <span class="hljs-comment">//获取头部长度</span>    hdrlen = sdsHdrSize(type);    <span class="hljs-comment">/* If the type is the same, or at least a large enough type is still</span><span class="hljs-comment">     * required, we just realloc(), letting the allocator to do the copy</span><span class="hljs-comment">     * only if really needed. Otherwise if the change is huge, we manually</span><span class="hljs-comment">     * reallocate the string to use the different header type. */</span>     <span class="hljs-comment">//如果原始类型和更新类型相似，或者type &gt; SDS_TYPE_8</span>    <span class="hljs-keyword">if</span> (oldtype==type || type &gt; SDS_TYPE_8) &#123;    <span class="hljs-comment">//重分配</span>        newsh = s_realloc(sh, oldhdrlen+len+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        s = (<span class="hljs-type">char</span>*)newsh+oldhdrlen;    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//申请内存空间</span>        newsh = s_malloc(hdrlen+len+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//复制</span>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span>*)newsh+hdrlen, s, len+<span class="hljs-number">1</span>);        <span class="hljs-comment">//释放指针</span>        s_free(sh);        s = (<span class="hljs-type">char</span>*)newsh+hdrlen;        <span class="hljs-comment">//设置类型</span>        s[<span class="hljs-number">-1</span>] = type;        sdssetlen(s, len);    &#125;    sdssetalloc(s, len);    <span class="hljs-keyword">return</span> s;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要对Redis中的简单动态字符串的数据结构与基本API实现做了简要分析，基本了解了SDS如何保证二进制安全与SDS的缩容扩容策略的实现。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>源码分析</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之行为型模式（四）</title>
    <link href="/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern-behavior/"/>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern-behavior/</url>
    
    <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>模板方法模式涉及两个角色：</p><ul><li>抽象模板角色（Abstract Template）：该角色定义多个抽象操作，以便让子类实现。</li><li>具体模板角色（Concrete Template）：该角色实现抽象模板中的抽象方法</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span>&#123;        <span class="hljs-built_in">this</span>.operation();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//业务</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">AbstractClass</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteClass</span>();        ac.templateMethod();    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>封装不变的部分，扩展可变部分。不变的部分封装到父类去实现，可变的通过继承进行扩展。</li><li>提取公共代码，便于维护，将公共部分的代码抽取出来放在父类中，维护时只需要修改父类中的代码。</li><li>行为由父类控制，子类实现。</li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><blockquote><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p></blockquote><p>该模式有四个角色：</p><ul><li>命令角色：该角色声明抽象接口</li><li>具体命令角色：定义一个接收者和行为之间的弱耦合，实现命令方法，并调用接收者的相应操作。</li><li>调用者：负责调用命令对象执行请求。</li><li>接收者：该角色负责具体实施和执行一个请求。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">private</span> Receiver receiver;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteCommand</span><span class="hljs-params">(Receiver receiver)</span> &#123;        <span class="hljs-built_in">this</span>.receiver = receiver;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.receiver.action();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;执行动作&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;    <span class="hljs-keyword">private</span> Command command;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;        <span class="hljs-built_in">this</span>.command = command;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.command.execute();    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>类间解耦</li><li>可扩展性</li></ul><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><blockquote><p>使多个对象都有机会处理请求，从而避免了请求的发送者和请求者之间耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p></blockquote><p>该模式有两个角色：</p><ul><li>抽象处理者角色：该角色对请求进行抽象，并定义一个方法以设定和返回对下一个处理者的引用。</li><li>具体处理者角色：该角色接到请求后，可以将请求处理掉，或者将请求传给下一个处理者。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;    <span class="hljs-keyword">private</span> Handler successor;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> Handler <span class="hljs-title function_">getSuccessor</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> successor;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;        <span class="hljs-built_in">this</span>.successor = successor;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (getSuccessor() != <span class="hljs-literal">null</span>)&#123;            System.out.println(<span class="hljs-string">&quot;请求传递给：&quot;</span>+ getSuccessor());            getSuccessor().handleRequest();        &#125;<span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;请求处理&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>将请求和处理分开</li><li>提高系统的灵活性</li></ul><p>缺点：</p><ul><li>链过长将降低程序的性能</li><li>不易调试</li></ul><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p></blockquote><p>该模式涉及三个角色：</p><ul><li>环境角色：屏蔽高层模块对策略、算法的直接访问</li><li>抽象策略角色：对策略、算法进行抽象</li><li>具体策略角色：实现抽象策略中的具体操作</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strategyInterface</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">strategyInterface</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//具体逻辑</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;    <span class="hljs-keyword">private</span> Strategy strategy;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(Strategy strategy)</span> &#123;        <span class="hljs-built_in">this</span>.strategy = strategy;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextInterface</span><span class="hljs-params">()</span>&#123;        <span class="hljs-built_in">this</span>.strategy.strategyInterface();    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>提供了管理算法族的方法</li><li>可以替换继承关系的办法</li><li>可以避免使用多重条转移语句</li></ul><p>缺点：</p><ul><li>客户端必须直到所有的策略类</li><li>策略模式会造成很多策略类</li></ul><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><blockquote><p>提供一种方法访问容器对象中各个元素，而又不暴露该对象的内部细节。</p></blockquote><p>该模式有四个角色：</p><ul><li>抽象迭代器角色：定义迭代接口</li><li>具体迭代器角色：负责实现迭代接口</li><li>抽象聚集角色：提供创建迭代器角色的接口</li><li>具体聚集角色：实现抽象聚集接口</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;    <span class="hljs-keyword">private</span> ConcreteAggregate aggregate;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate aggregate)</span> &#123;        <span class="hljs-built_in">this</span>.aggregate = aggregate;        <span class="hljs-built_in">this</span>.index = <span class="hljs-number">0</span>;        <span class="hljs-built_in">this</span>.size = aggregate.size();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (hasNext()) &#123;            <span class="hljs-keyword">return</span> aggregate.getElement(index++);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> index &lt; size;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object obj)</span>;    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">Vector</span> <span class="hljs-variable">vector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object obj)</span> &#123;        <span class="hljs-built_in">this</span>.vector.add(obj);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> vector.size();    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-keyword">if</span> (index &lt; vector.size())&#123;            <span class="hljs-keyword">return</span> vector.get(index);        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>简化访问容器元素的操作，具备一个同意的遍历接口</li><li>封装了遍历算法</li></ul><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><blockquote><p>用一个中介对象封装一系列对象的交互，中介者使各对象不需要显式地相互作用，从而使其耦合松散，而且可以独立地改变它们之间地交互。</p></blockquote><p>该模式主要有四个角色：</p><ul><li>抽象中介者角色：定义出对象到中介者的接口</li><li>具体中介者角色：实现抽象中介者</li><li>抽象对象角色：定义出中介者到对象的接口</li><li>具体对象角色：实现抽象对象</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> &#123;    <span class="hljs-keyword">private</span> Mediator mediator;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator mediator)</span> &#123;        <span class="hljs-built_in">this</span>.mediator = mediator;    &#125;    <span class="hljs-keyword">public</span> Mediator <span class="hljs-title function_">getMediator</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> mediator;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMediator</span><span class="hljs-params">(Mediator mediator)</span> &#123;        <span class="hljs-built_in">this</span>.mediator = mediator;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">()</span>&#123;        mediator.colleagueChanged();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague</span><span class="hljs-params">(Mediator mediator)</span> &#123;        <span class="hljs-built_in">super</span>(mediator);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;action&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">colleagueChanged</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;    <span class="hljs-keyword">private</span> ConcreteColleague concreteColleague;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createConcreteMediator</span><span class="hljs-params">()</span>&#123;        concreteColleague = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteColleague</span>(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">colleagueChanged</span><span class="hljs-params">()</span> &#123;        concreteColleague.action();    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>减少类间的依赖，将一对多的依赖变成一对一的依赖。</li><li>避免同事对象之间过度耦合</li><li>中介者模式将对象地行为和协作抽象化</li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖它的对象会得到通知并被自动更新。</p></blockquote><p>该模式主要有四个角色：</p><ul><li>抽象主题角色：被观察者，可以添加删除观察者角色</li><li>抽象观察者角色：为观察者定义接口</li><li>具体主题角色：将有关状态存入具体观察者对象，在内部状态改变时，通知观察者。</li><li>具体观察者角色：实现抽象接口。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加观察者</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除观察者</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通知观察者</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObserver</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">private</span> Vector&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;        observers.add(observer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span> &#123;        observers.remove(observer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObserver</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (Observer observer : observers)&#123;            observer.update();        &#125;    &#125;    <span class="hljs-keyword">public</span> Enumeration&lt;Observer&gt; <span class="hljs-title function_">observers</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> observers.elements();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">()</span>&#123;        <span class="hljs-built_in">this</span>.notifyObserver();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;receive notice&quot;</span>);    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>两者之间是抽象耦合</li><li>支持向所有的观察者发出通知</li></ul><p>缺点：</p><ul><li>如果对观察者的通知是通过另外的线程进行异步投递，需要保证投递的顺序性。</li></ul><h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可以将该对象恢复到原先保存的状态。</p></blockquote><p>通俗的说，备忘录模式就是将一个对象进行备份的方法。</p><p>该模式有三个角色：</p><ul><li>发起人角色：记录当前时刻的内部状态，负责定义哪种属于备份范围的状态，负责创建和恢复数据</li><li>备忘录角色：该角色存储发起人的内部状态</li><li>负责人角色：对备忘录角色进行管理、保存和提供备忘录。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> state;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;        <span class="hljs-built_in">this</span>.state = state;    &#125;    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">createMemento</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-built_in">this</span>.state);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreMemento</span><span class="hljs-params">(Memento memento)</span>&#123;        <span class="hljs-built_in">this</span>.setState(memento.getState());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;    <span class="hljs-keyword">private</span> String state;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Memento</span><span class="hljs-params">(String state)</span> &#123;        <span class="hljs-built_in">this</span>.state = state;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> state;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;        <span class="hljs-built_in">this</span>.state = state;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> &#123;    <span class="hljs-keyword">private</span> Memento memento;    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> memento;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemento</span><span class="hljs-params">(Memento memento)</span> &#123;        <span class="hljs-built_in">this</span>.memento = memento;    &#125;&#125;</code></pre></div><h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><blockquote><p>封装一些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作。</p></blockquote><p>该模式涉及五个角色：</p><ul><li>抽象访问者角色：该角色声明一个或多个访问操作，定义访问者可以访问哪些元素</li><li>具体访问者：实现抽象访问者的接口</li><li>抽象元素角色：声明一个接受操作，接受一个访问者对象</li><li>具体元素角色：实现抽象元素中的接受接口</li><li>结构对象：提供遍历操作</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>&#123;        System.out.println(<span class="hljs-string">&quot;访问元素&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElement concreteElement)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElement concreteElement)</span> &#123;        concreteElement.operation();    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>增加新的操作很容易，只需新增新的访问者类</li><li>访问者模式将有关的行为集中到访问者对象中</li></ul><p>缺点：</p><ul><li>增加新的元素困难，每增加一个都意味着要在抽象访问者类中新增操作</li><li>破坏封装</li><li>违背依赖倒置原则</li></ul><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><blockquote><p>当一个对象内在状态改变时允许改变行为，这个对象看起来像改变了其类型。</p></blockquote><p>核心是封装，状态的变更引起行为的变动，外部看好像该对象对应的类发生改变。</p><p>该模式有三个角色：</p><ul><li>抽象状态角色：该角色用以封装环境对象的一个状态所对应的行为。</li><li>具体状态角色：该角色实现抽象行为。</li><li>环境角色：定义客户端需要的接口，并负责具体状态的切换</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">private</span> Context context;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(Context context)</span> &#123;        <span class="hljs-built_in">this</span>.context = context;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;逻辑处理&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">State</span> <span class="hljs-variable">STATE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteState</span>();    <span class="hljs-keyword">private</span> State currentState;    <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getCurrentState</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> currentState;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentState</span><span class="hljs-params">(State currentState)</span> &#123;        <span class="hljs-built_in">this</span>.currentState = currentState;        currentState.setContext(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle1</span><span class="hljs-params">()</span>&#123;        <span class="hljs-built_in">this</span>.setCurrentState(STATE);        <span class="hljs-built_in">this</span>.currentState.handle();    &#125;&#125;</code></pre></div><p>优点：</p><ul><li>结构清晰</li><li>遵循设计原则</li><li>封装性好</li></ul><h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><blockquote><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p></blockquote><p>该模式有五个角色：</p><ul><li>抽象表达式（Abstract Expression）角色：该角色声明一个所有的具体表达式角色都需要实现的抽象接口，该接口主要是一个解释操作interpret()方法。</li><li>终结符表达式（Terminal Expression）角色：该角色实现了抽象表达式角色所要求的接口，文法中的每一个终结符都有一个具体终结表达式与之对应。</li><li>非终结符表达式（Nonterminal Expression）角色：该角色是一个具体角色，文法中的每一条规则都对应一个非终结符表达式类。</li><li>环境（Context）角色：该角色提供解释器之外的一些全局信息。</li><li>客户端（Client）角色：该角色创建一个抽象语法树，调用解释操作。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExpression</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context ctx)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonterminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context ctx)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">interpreter</span><span class="hljs-params">(Context ctx)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();        <span class="hljs-comment">//todo</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之结构型模式（三）</title>
    <link href="/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern-structure/"/>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern-structure/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote><p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能在一起工作的两个类可以协同工作，别名为包装器（Wrapper）。</p></blockquote><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p>注意：</p><ul><li>类适配器需要继承src类，这要求dst必须是接口，有一定的局限性</li><li>src类的方法在Adapter中会被暴露出来</li><li>Adapter需要重写src的方法</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/5/19 11:40</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>： 被适配的类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Voltage220V</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output220V</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">int</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-number">220</span>;        System.out.println(<span class="hljs-string">&quot;电压：&quot;</span>+ src + <span class="hljs-string">&quot;伏&quot;</span>);        <span class="hljs-keyword">return</span> src;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 适配接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IVoltage5V</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/5/19 11:42</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>： 适配器类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoltageAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Voltage220V</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoltage5V</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> output220V();        <span class="hljs-keyword">return</span> src / <span class="hljs-number">44</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/5/19 11:44</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>： 手机类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charging</span><span class="hljs-params">(IVoltage5V iVoltage5V)</span>&#123;        <span class="hljs-keyword">if</span> (iVoltage5V.output5V() == <span class="hljs-number">5</span>)&#123;            System.out.println(<span class="hljs-string">&quot;电压为：5V，可以充电&quot;</span>);        &#125;<span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;电压不正常，无法充电&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><ul><li>基本思路和类适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题，即：持有src类，实现dst接口，完成src-&gt;dst的适配。</li><li>根据合成复用原则，在系统中使用关联关系替代继承关系。<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/5/19 11:42</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>： 适配器类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoltageAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoltage5V</span> &#123;    <span class="hljs-keyword">private</span> Voltage220V voltage220V;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VoltageAdapter</span><span class="hljs-params">(Voltage220V voltage220V)</span> &#123;        <span class="hljs-built_in">this</span>.voltage220V = voltage220V;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">output5V</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != voltage220V)&#123;            <span class="hljs-type">int</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> voltage220V.output220V();            System.out.println(<span class="hljs-string">&quot;适配完成&quot;</span>);            <span class="hljs-keyword">return</span> src / <span class="hljs-number">44</span>;        &#125;        System.out.println(<span class="hljs-string">&quot;适配失败&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Spring MVC - HandlerAdapter</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HandlerAdapter</span> &#123;    <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(Object var1)</span>;    <span class="hljs-meta">@Nullable</span>    ModelAndView <span class="hljs-title function_">handle</span><span class="hljs-params">(HttpServletRequest var1, HttpServletResponse var2, Object var3)</span> <span class="hljs-keyword">throws</span> Exception;    <span class="hljs-type">long</span> <span class="hljs-title function_">getLastModified</span><span class="hljs-params">(HttpServletRequest var1, Object var2)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;            processedRequest = checkMultipart(request);            multipartRequestParsed = (processedRequest != request);            <span class="hljs-comment">// Determine handler for the current request.</span>            mappedHandler = getHandler(processedRequest);            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;                noHandlerFound(processedRequest, response);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">// Determine handler adapter for the current request.</span>            <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());            <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span>            <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();            <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GET&quot;</span>.equals(method);            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;                <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">// Actually invoke the handler.</span>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;                <span class="hljs-keyword">return</span>;            &#125;            applyDefaultViewName(processedRequest, mv);            mappedHandler.applyPostHandle(processedRequest, response, mv);        &#125;</code></pre></div><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><blockquote><p>桥接是用于把抽象与实现解耦，使得两者可以独立变化。</p></blockquote><p>该模式主要解决在多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/5/20 12:48</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>： 桥接 接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DrawAPI</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedCircle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Drawing Circle[ color: red, radius: &quot;</span>                + radius + <span class="hljs-string">&quot;, x: &quot;</span> + x + <span class="hljs-string">&quot;, &quot;</span> + y + <span class="hljs-string">&quot;]&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreenCircle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DrawAPI</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> radius, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Drawing Circle[ color: green, radius: &quot;</span>                + radius + <span class="hljs-string">&quot;, x: &quot;</span> + x + <span class="hljs-string">&quot;, &quot;</span> + y + <span class="hljs-string">&quot;]&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">protected</span> DrawAPI drawAPI;    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Shape</span><span class="hljs-params">(DrawAPI drawAPI)</span>&#123;        <span class="hljs-built_in">this</span>.drawAPI = drawAPI;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y, radius;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius, DrawAPI drawAPI)</span> &#123;        <span class="hljs-built_in">super</span>(drawAPI);        <span class="hljs-built_in">this</span>.x = x;        <span class="hljs-built_in">this</span>.y = y;        <span class="hljs-built_in">this</span>.radius = radius;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;        drawAPI.drawCircle(radius, x, y);    &#125;&#125;</code></pre></div><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>抽象和实现分离</li><li>对客户透明，客户端不用关心细节的实现</li></ul><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><blockquote><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p></blockquote><p>主要有以下四个角色：</p><ul><li>Component：用于规范需要装饰的对象</li><li>Concrete Component：实现Component角色，定义一个需要装饰的原始类</li><li>Decorator：持有一个构建对象的实例，并定义一个与Component接口一致的接口</li><li>Concrete Decorator：负责对构建对象进行装饰</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//业务</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> &#123;    <span class="hljs-keyword">private</span> Component component;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component component)</span> &#123;        <span class="hljs-built_in">this</span>.component = component;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>&#123;        component.operation();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Component component)</span> &#123;        <span class="hljs-built_in">super</span>(component);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;        <span class="hljs-comment">//自己的方法</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.method();        <span class="hljs-built_in">super</span>.operation();    &#125;&#125;</code></pre></div><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>装饰类和被装饰类可以独立发展。</li><li>装饰模式是继承的一个替代方案。</li><li>多层装饰较为复杂。</li></ul><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><blockquote><p>将对象组合成树形结构以表示部分一整体的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;   <span class="hljs-keyword">private</span> String name;   <span class="hljs-keyword">private</span> String dept;   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> salary;   <span class="hljs-keyword">private</span> List&lt;Employee&gt; subordinates;    <span class="hljs-comment">//构造函数</span>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name,String dept, <span class="hljs-type">int</span> sal)</span> &#123;      <span class="hljs-built_in">this</span>.name = name;      <span class="hljs-built_in">this</span>.dept = dept;      <span class="hljs-built_in">this</span>.salary = sal;      subordinates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Employee&gt;();   &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Employee e)</span> &#123;      subordinates.add(e);   &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Employee e)</span> &#123;      subordinates.remove(e);   &#125;    <span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">getSubordinates</span><span class="hljs-params">()</span>&#123;     <span class="hljs-keyword">return</span> subordinates;   &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;      <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;Employee :[ Name : &quot;</span>+ name       +<span class="hljs-string">&quot;, dept : &quot;</span>+ dept + <span class="hljs-string">&quot;, salary :&quot;</span>      + salary+<span class="hljs-string">&quot; ]&quot;</span>);   &#125;   &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String dept;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> salary;    <span class="hljs-keyword">private</span> List&lt;Employee&gt; subordinates;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, String dept, <span class="hljs-type">int</span> sal)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.dept = dept;        <span class="hljs-built_in">this</span>.salary = sal;        subordinates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Employee&gt;();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Employee e)</span> &#123;        subordinates.add(e);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Employee e)</span> &#123;        subordinates.remove(e);    &#125;    <span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">getSubordinates</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> subordinates;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;Employee :[ Name : &quot;</span> + name                + <span class="hljs-string">&quot;, dept : &quot;</span> + dept + <span class="hljs-string">&quot;, salary :&quot;</span>                + salary + <span class="hljs-string">&quot; ]&quot;</span>);    &#125;&#125;</code></pre></div><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><blockquote><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易使用。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;   <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;      System.out.println(<span class="hljs-string">&quot;Rectangle::draw()&quot;</span>);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;      System.out.println(<span class="hljs-string">&quot;Square::draw()&quot;</span>);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;      System.out.println(<span class="hljs-string">&quot;Circle::draw()&quot;</span>);   &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeMaker</span> &#123;   <span class="hljs-keyword">private</span> Shape circle;   <span class="hljs-keyword">private</span> Shape rectangle;   <span class="hljs-keyword">private</span> Shape square;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShapeMaker</span><span class="hljs-params">()</span> &#123;      circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();      rectangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();      square = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();   &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">()</span>&#123;      circle.draw();   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRectangle</span><span class="hljs-params">()</span>&#123;      rectangle.draw();   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSquare</span><span class="hljs-params">()</span>&#123;      square.draw();   &#125;&#125;</code></pre></div><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><blockquote><p>运用共享技术来有効地支持大量细粒度对象的复用。</p></blockquote><ul><li>常见于系统底层开发，能够解决重复对象的内存浪费问题。</li><li>经典应用场景：池技术（String常量池、数据库连接池、缓冲池）</li></ul><p>享元模式能做到共享的关键是区分内部状态和外部状态。</p><ul><li>内部状态是存储在享元对象内部的，可以共享的信息，不会随环境而变化。</li><li>外部状态是随环境而改变且不可以共享的状态。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(String extrinsicState)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyWeight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-comment">//内部状态</span>    <span class="hljs-keyword">private</span> String intrinsicState;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteFlyWeight</span><span class="hljs-params">(String intrinsicState)</span> &#123;        <span class="hljs-built_in">this</span>.intrinsicState = intrinsicState;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(String extrinsicState)</span> &#123;        System.out.println(<span class="hljs-string">&quot;内部状态：&quot;</span> + intrinsicState);        System.out.println(<span class="hljs-string">&quot;外部状态：&quot;</span> + extrinsicState);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Flyweight&gt; pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-title function_">FlyweightFactory</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String intrinsicState)</span>&#123;        <span class="hljs-type">Flyweight</span> <span class="hljs-variable">flyweight</span> <span class="hljs-operator">=</span> pool.get(intrinsicState);        <span class="hljs-keyword">if</span>(flyweight == <span class="hljs-literal">null</span>)&#123;            flyweight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyWeight</span>(intrinsicState);            pool.put(intrinsicState, flyweight);        &#125;        <span class="hljs-keyword">return</span> flyweight;    &#125;&#125;</code></pre></div><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>为其他对象提供一种代理以控制这个对象的访问。</p></blockquote><p>该模式主要有三个角色：</p><ul><li>Subject（抽象主题角色）：该角色是真实主题和迪阿尼主题共同接口，以便在任何可以使用真实主题的地方都可以使用代理主题。</li><li>Proxy Subject（代理主题角色）：也叫做代理类，该角色负责控制对真实主题的引用，负责在需要的时候创建或删除真实主题对象，并且在真实主题角色处理完毕钱后做预处理工作。</li><li>Real Project（真实主题角色）：该角色被称为被代理角色，是业务逻辑的具体执行者。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//业务代码</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">private</span> Subject subject;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxySubject</span><span class="hljs-params">(Subject subject)</span> &#123;        <span class="hljs-built_in">this</span>.subject = subject;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;        <span class="hljs-built_in">this</span>.beforeRequest();        subject.request();        <span class="hljs-built_in">this</span>.afterRequest();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeRequest</span><span class="hljs-params">()</span>&#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterRequest</span><span class="hljs-params">()</span>&#123;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之创建型模式（二）</title>
    <link href="/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern-creational/"/>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-pattern-creational/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p><p>比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><h3 id="静态常量方法"><a href="#静态常量方法" class="headerlink" title="静态常量方法"></a>静态常量方法</h3><p>demo：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化，外部不能new</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><ul><li>优点<ul><li>写法简单，在类装载的时候就完成实例化，避免了线程安全问题。</li></ul></li><li>缺点<ul><li>没有达到<code>lazy loading</code>的效果，如果一直没有使用，就会造成内存浪费。</li></ul></li></ul><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>demo：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化，外部不能new</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE ;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>demo：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化，外部不能new</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE ;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>)&#123;            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><ul><li>优点<ul><li>起到了<code>lazy loading</code>的效果，当时只能在单线程下使用</li></ul></li><li>缺点<ul><li>多线程下会出现线程安全问题。</li></ul></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>加上<code>synchronized</code>关键字。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化，外部不能new</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE ;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>)&#123;            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><ul><li>缺点<ul><li>效率低</li></ul></li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>demo：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化，外部不能new</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonInstance</span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> SingletonInstance.INSTANCE;    &#125;&#125;</code></pre></div><ul><li>优点<ul><li>避免线程不安全，利用静态内部类特点实现延迟加载，效率高。</li></ul></li></ul><h2 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h2><ul><li>单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象频繁的创建，销毁时。</li><li>由于单例模式只生成一个实例，所以减少了系统的性能开销。</li><li>单例模式可以避免对资源的多重占用，例如写文件操作，避免对同一个资源文件同时操作。</li><li>单例模式可以在系统设置全局的访问点，优化和资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li></ul><h2 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h2><ul><li>单例模式一般没有接口，扩展困难</li><li>单例模式对测试是不利的，没有接口不能使用mock的方式虚拟一个对象</li><li>单例模式与单一职责原则有冲突，一个类只实现一个逻辑</li></ul><h2 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h2><ul><li>要求生成唯一序列号的环境</li><li>在整个项目需要一个共享访问点或共享数据，例如一个Web页面上的计数器，使用单例模式保持计数器的值，并确保是线程安全的。</li><li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源</li><li>需要定义大量的静态变量和静态方法的环境</li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂模式-静态工厂模式"><a href="#简单工厂模式-静态工厂模式" class="headerlink" title="简单工厂模式(静态工厂模式)"></a>简单工厂模式(静态工厂模式)</h2><p>简单工厂模式是有一个工厂对象决定创建出哪一种产品类的实例。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//业务逻辑</span>    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/5/15 17:25</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>： 简单工厂模式</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;    <span class="hljs-keyword">public</span>  &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span>&gt; T <span class="hljs-title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; c)</span> &#123;        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            product = (Product) Class.forName(c.getName()).newInstance();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> (T) product;    &#125;&#125;</code></pre></div><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p></blockquote><p>在工厂方法模式中，抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义，Creator为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现共产ConcreteCreator完成的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span>&gt; T <span class="hljs-title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; c)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Creator</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span>&gt; T <span class="hljs-title function_">createProduct</span><span class="hljs-params">(Class&lt;T&gt; c)</span> &#123;        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            product = (Product) Class.forName(c.getName()).newInstance();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> (T) product;    &#125;&#125;</code></pre></div><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p></blockquote><ul><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductA</span> &#123;        <span class="hljs-comment">//每个产品共有的方法</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shareMethod</span><span class="hljs-params">()</span> &#123;            &#125;    <span class="hljs-comment">//每个产品相同方法，不同实现</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProductA</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;产品A1的实现方法&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCreator</span> &#123;        <span class="hljs-comment">//创建A产品</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCreator</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>();    &#125;&#125;</code></pre></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>java.util.Calendar</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title function_">createCalendar</span><span class="hljs-params">(TimeZone zone,</span><span class="hljs-params">                                           Locale aLocale)</span>    &#123;        <span class="hljs-type">CalendarProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span>            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)                                 .getCalendarProvider();        <span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">return</span> provider.getInstance(zone, aLocale);            &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException iae) &#123;                <span class="hljs-comment">// fall back to the default instantiation</span>            &#125;        &#125;        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (aLocale.hasExtensions()) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">caltype</span> <span class="hljs-operator">=</span> aLocale.getUnicodeLocaleType(<span class="hljs-string">&quot;ca&quot;</span>);            <span class="hljs-keyword">if</span> (caltype != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">switch</span> (caltype) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;buddhist&quot;</span>:                cal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuddhistCalendar</span>(zone, aLocale);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;japanese&quot;</span>:                    cal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JapaneseImperialCalendar</span>(zone, aLocale);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gregory&quot;</span>:                    cal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>(zone, aLocale);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (cal == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// If no known calendar type is explicitly specified,</span>            <span class="hljs-comment">// perform the traditional way to create a Calendar:</span>            <span class="hljs-comment">// create a BuddhistCalendar for th_TH locale,</span>            <span class="hljs-comment">// a JapaneseImperialCalendar for ja_JP_JP locale, or</span>            <span class="hljs-comment">// a GregorianCalendar for any other locales.</span>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The language, country and variant strings are interned.</span>            <span class="hljs-keyword">if</span> (aLocale.getLanguage() == <span class="hljs-string">&quot;th&quot;</span> &amp;&amp; aLocale.getCountry() == <span class="hljs-string">&quot;TH&quot;</span>) &#123;                cal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuddhistCalendar</span>(zone, aLocale);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aLocale.getVariant() == <span class="hljs-string">&quot;JP&quot;</span> &amp;&amp; aLocale.getLanguage() == <span class="hljs-string">&quot;ja&quot;</span>                       &amp;&amp; aLocale.getCountry() == <span class="hljs-string">&quot;JP&quot;</span>) &#123;                cal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JapaneseImperialCalendar</span>(zone, aLocale);            &#125; <span class="hljs-keyword">else</span> &#123;                cal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>(zone, aLocale);            &#125;        &#125;        <span class="hljs-keyword">return</span> cal;    &#125;</code></pre></div><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>使用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</p><ul><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时提高效率。</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态。</li><li>需要注意深拷贝和浅拷贝。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;    <span class="hljs-keyword">private</span> String color;        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            sheep = (Sheep) <span class="hljs-built_in">super</span>.clone();        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            System.out.println(e.getMessage());        &#125;        <span class="hljs-keyword">return</span> sheep;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sheep</span>(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;white&quot;</span>);        <span class="hljs-type">Sheep</span> <span class="hljs-variable">sheep1</span> <span class="hljs-operator">=</span> (Sheep) sheep.clone();    &#125;&#125;</code></pre></div><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>Spring—AbstractBeanFactory</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span> &#123;beforePrototypeCreation(beanName);prototypeInstance = createBean(beanName, mbd, args);&#125;<span class="hljs-keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125;</code></pre></div><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>可以将复杂对象的构造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同表现的对象。</p><p>四个角色：</p><ul><li>Product：具体的产品对象</li><li>Builder：创建一个Product的各个部件的接口</li><li>ConcreteBuilder：实现接口，构建和装配各个部件</li><li>Director：构建一个使用Builder接口的对象，主要用于创建一个复杂的对象，主要两个作用：<ul><li>隔离了客户与对象的生产过程</li><li>负责控制产品对象的生产过程</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span> &#123;    <span class="hljs-keyword">private</span> String baise;    <span class="hljs-keyword">private</span> String wall;    <span class="hljs-keyword">private</span> String roofed;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseBuilder</span> &#123;    <span class="hljs-keyword">protected</span> <span class="hljs-type">House</span> <span class="hljs-variable">house</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">House</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildBasic</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildWall</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roofed</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">public</span> House <span class="hljs-title function_">buildHouse</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> house;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonHouse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HouseBuilder</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildBasic</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;地基&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildWall</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;砌墙&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roofed</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;封顶&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HouseDirector</span> &#123;    <span class="hljs-type">HouseBuilder</span> <span class="hljs-variable">houseBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HouseDirector</span><span class="hljs-params">(HouseBuilder houseBuilder)</span>&#123;        <span class="hljs-built_in">this</span>.houseBuilder = houseBuilder;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHouseBuilder</span><span class="hljs-params">(HouseBuilder houseBuilder)</span> &#123;        <span class="hljs-built_in">this</span>.houseBuilder = houseBuilder;    &#125;    <span class="hljs-comment">//如何处理建房子的过程，交给指挥者</span>    <span class="hljs-keyword">public</span> House <span class="hljs-title function_">constructHouse</span><span class="hljs-params">()</span>&#123;        houseBuilder.buildBasic();        houseBuilder.buildWall();        houseBuilder.roofed();        <span class="hljs-keyword">return</span> houseBuilder.buildHouse();    &#125;&#125;</code></pre></div><h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><p>StringBuilder：</p><div class="code-wrapper"><pre><code class="hljs dos">Appendable接口定义了多个<span class="hljs-built_in">append</span>方法（抽象方法）是抽象建造者。AbstractStringBuilder实现了Appendable接口方法，该类已经是建造者，只是不能实例化StringBuilder既充当了指挥者角色，同时充当了具体的建造者。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之设计原则（一）</title>
    <link href="/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-principle/"/>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design-principle/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><blockquote><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心，这样，你就能不必一次又一次地使用该方案而不必重复劳动。</p></blockquote><h2 id="深入理解面向对象"><a href="#深入理解面向对象" class="headerlink" title="深入理解面向对象"></a>深入理解面向对象</h2><p>向下：三大面向对象机制</p><ul><li>封装：隐藏内部实现</li><li>继承：复用现有代码</li><li>多态：改写对象行为</li></ul><p>现上：深刻把握面向对象机制带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”</p><h2 id="软件设计复杂的根本原因"><a href="#软件设计复杂的根本原因" class="headerlink" title="软件设计复杂的根本原因"></a>软件设计复杂的根本原因</h2><p><strong>变化</strong>：</p><ul><li>客户需求的变化</li><li>技术平台的变化</li><li>开发团队的变化</li><li>市场环境的变化</li></ul><h2 id="如何解决复杂性？"><a href="#如何解决复杂性？" class="headerlink" title="如何解决复杂性？"></a>如何解决复杂性？</h2><p>分解</p><ul><li>人们面对复杂性有一个常见的作法：分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。</li></ul><p>抽象</p><ul><li>更高层次来讲，人们处理复杂性有一个通用的计数，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。</li></ul><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><blockquote><p>一个接口仅负责一个职责，一个类只能由一个原因引起变化。</p></blockquote><p>优点：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义</li><li>可读性提高 </li><li>可维护性提高</li><li>变更引起的风险降低，变更时必不可少的，如果接口的单一职责做好，一个接口的修改只对相对应的实现类有影响。</li></ul><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><blockquote><p>所有引用基类的地方必须能透明的使用其子类的对象。</p></blockquote><p>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常。</p><ul><li>子类必须完全实现父类的方法</li><li>子类可以有自己的方法和属性</li><li>覆盖或实现父类的方法时输入参数可以被放大</li><li>覆写或实现父类的方法时输出结果可以被缩小</li></ul><h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><blockquote><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul></blockquote><p>在Java语言中的表现：</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的</li><li>接口或抽象类不依赖于实现类</li><li>实现类依赖接口或抽象类</li></ul><p>对象的依赖关系有三种方式来传递：</p><ul><li>构造函数传递依赖对象</li><li>Setter方法传递依赖对象</li><li>接口声明依赖对象</li></ul><p>如何实践？</p><ul><li>每个类尽量都有接口或抽象类，或者抽象类与接口两者都具备</li><li>变量的表面类型尽量是接口或者抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则使用：接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共内部构造部分的实现，实现类准确的实现业务逻辑，统统实在适当的时候对父类进行细化。</li></ul><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><blockquote><ul><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ul></blockquote><p>接口分为两种：</p><ul><li>实例接口：在Java中声明一个类，然后用new关键字产生一个实例，它就是对一个类型的事物的描述，这是一种接口</li><li>类接口：interface关键字定义的接口</li></ul><p>接口隔离原则对接口进行规范约束，包含以下四个含义：</p><ul><li>接口要尽量小</li><li>接口要高内聚，减少对外的交互（尽量少公布public方法）</li><li>定制服务（只提供访问者需要的方法）</li><li>接口设计是有限度的（粒度越小，系统越灵活，结构越复杂，开发难度增加，可维护性降低）</li></ul><p>如何实践？</p><ul><li>一个接口只服务于一个子模块或业务逻辑</li><li>通过业务逻辑压缩接口中的public方法</li><li>已经被污染的方法，尽量去修改，若变更风险较大，则采用适配器模式进行处理</li><li>了解环境，深入理解业务逻辑，结合实际。</li></ul><h2 id="迪米特法则（LoD）"><a href="#迪米特法则（LoD）" class="headerlink" title="迪米特法则（LoD）"></a>迪米特法则（LoD）</h2><blockquote><p>一个对象应该对其他对象有最少的了解。</p></blockquote><p>类和类关系越密切，耦合度越大。</p><p>也称为最少知识原则（LKP），通俗的讲：一个对象应该对自己需要耦合或者调用的类知道的最少，你的内部如何复杂和我都没有关系，我就知道你提供这么多public方法，我就调用这么多，其他我一概不关心。</p><p>迪米特法则对类的低耦合提出了明确的要求，其包含以下四层含义：</p><ul><li>只和朋友交流（朋友类：出现在成员变量，方法输入输出参数的类）。</li><li>朋友之间有距离的。</li><li>是自己的就是自己的（一个方法放在本类种，既不增加类间关系，也对本类不产生负面影响，那就放在本类之中）。</li><li>谨慎使用Serializable。</li></ul><p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合之后，类的复用率才可以提高，要求的结果就是产生了大量中转或跳转类，导致系统复杂性提高，同时也为维护带来了难度。</p><h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><blockquote><p>一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。</p></blockquote><ul><li>对扩展开放（提供方），对修改关闭（使用方）</li><li>用抽象构建框架，用实现扩展细节</li><li>一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</li><li>遵循的所有原则，以及设计模式的目的就是遵循开闭原则。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入MySQL索引细节</title>
    <link href="/2020/MySQL/MySQL%E7%B4%A2%E5%BC%95%E7%BB%86%E8%8A%82/"/>
    <url>/2020/MySQL/MySQL%E7%B4%A2%E5%BC%95%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h2 id="索引基本概念"><a href="#索引基本概念" class="headerlink" title="索引基本概念"></a>索引基本概念</h2><p>维基百科对索引的定义：数据库索引是一种数据结构，它以额外的写入和存储空间为代价来提高数据库表上数据索引操作的速度。</p><p>MySQL官方对索引的定义是用于快速查找记录的一种数据结构。</p><p>索引是一个以空间换时间的经典案例。</p><ul><li>索引是物理数据页，数据页大小决定了一个页可以存储多少个索引行，以及需要多少页来存储指定大小的索引。</li><li>索引可以加快检索速度，也可以降低索引列插入、删除、更新的速度，索引维护需要代价。</li></ul><p>有两种基本的索引类型：</p><ul><li>顺序索引：基于值的顺序排序</li><li>散列索引：基于将值平均分布到若干bucket中，一个值所属的bucket是由一个散列函数决定。</li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B Tree"></a>B Tree</h3><p>查询的时间主要依赖于磁盘I&#x2F;O的次数，每次节点访问需要进行一次磁盘IO操作。<br>B Tree取代平衡二叉树主要是降低了树的高度，减少了磁盘IO的次数。其基本结构如下：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/index/B%20Tree.jpg" alt="B Tree"></p><p>B Tree别称平衡的多路搜索树，每个节点最多包括M个子节点，M称为B树的阶。</p><p>M阶的B树（M &gt; 2）有以下的特性：</p><ul><li>根节点的儿子数的范围是 [2,M]。</li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。</li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。</li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li><li>所有叶子节点位于同一层。</li></ul><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+ Tree"></a>B+ Tree</h3><p>B+ Tree与B Tree的差异主要有以下几点：</p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点既保存索引，也保存数据记录。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol><p>其基本结构如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/index/B%2BTree.jpg" alt="B+Tree"></p><p>B+ Tree与B Tree的根本的差异在于<strong>B+ Tree的中间节点不直接存储数据</strong>。</p><ol><li>B+ Tree更矮胖，IO次数更少，同样的磁盘页大小， B+ Tree可以存储更多的节点关键字。</li><li>B+ Tree查询效率更稳定，每次只有访问到叶子节点才能获取到对应的数据。</li><li>范围查询的效率高于B Tree，因为所有的关键字都出现在B+ Tree的叶子节点中，并通过有序链表进行连接。</li></ol><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>与B+ Tree的区别：</p><ul><li>Hash索引不能进行范围查询，不支持ORDER BY排序。因为Hash索引指向的数据是无序的。</li><li>Hash索引不支持联合索引的最左前缀原则，因为Hash索引计算Hash的时候是将索引键合并后再一起计算。</li><li>等值查询效率高，无法进行模糊查询。</li></ul><p>MySQL中Memory引擎支持Hash索引，InnoDB本身不支持Hash索引，但是提供了自适应Hash索引（Adaptive Hash Index）：当某个数据经常被访问，当满足一定条件时，就会把数据页地址放到Hash表中，下次查询时，则直接找到页面的地址。</p><h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><p>MySQL中，索引在存储引擎层实现，所以不同的存储引擎层支持的索引类型可以不同，InnoDB和MyISAM的索引都是使用B+ Tree实现的。B+ Tree结构如下图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/index/B%2B%20tree.png" alt="B+ Tree"></p><p>上图中页面号为20的页面是根页面，根页面存储了&lt;key + pageno&gt;，pageno存储指向叶子节点的页面号。叶子节点存放的数据由索引类型决定。聚簇索引的节点存放的是列数据，二级索引存放的是主键信息。</p><p>的是&lt;key + data&gt;，真正存放哪些数据还是取决于B+ Tree是还是辅助索引。</p><p>B+ Tree索引的特点：</p><ul><li>根页面位置不动：</li><li>非叶子节点中目录项记录的唯一性</li><li>一个页面最少存储两条记录</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>在 MySQL InnoDB 中索引通常可以分为两大类(<strong>物理实现方式</strong>)：主键索引（即聚簇索引）和辅助索引（非聚簇索引） 。</p><ul><li>聚簇索引：表中的数据按照主键顺序存储，是索引组织表，在InnoDB中就是按照主键顺序构建B+ Tree，叶子节点就是行记录，数据行和主键值存储在一起。<strong>只能创建一个</strong>。<ul><li>为了充分利用聚簇索引的特性，表的主键尽量使用有序id，不建议使用UUID，HASH等方式。</li></ul></li><li>辅助索引（二级索引）：根据索引列构建B+ Tree，B+ Tree每一个叶子节点的data域存储主键值，查询到主键后，再去聚簇索引中进行回表查询。</li></ul><p>聚簇索引占用的空间就是整个表数据量的大小，而二级索引只是存储主键值，主要提高查询效率。</p><p>对于没有指定主键的表，InnoDB会自己选择合适的字段作为主键，选择顺序如下：</p><ol><li>显式主键</li><li>第一个唯一索引</li><li>内置的6字节ROWID</li></ol><p>根据<strong>索引列个数和功能描述</strong>不同索引也可以分为：联合索引和覆盖索引。</p><ul><li><strong>联合索引是指在多个字段联合组建的。</strong></li><li>当通过索引即可查询到所有记录，不需要回表到聚簇索引时，这类索引称为<strong>覆盖索引</strong>。</li><li>主键查询是天然的覆盖索引，联合索引也可以是覆盖索引。</li></ul><p>从功能逻辑上说，主要分为：</p><ul><li><strong>普通索引（NORMAL）</strong>：不附加任何限制条件，可以创建在任何数据类型中。</li><li><strong>唯一性索引（UNIQUE）</strong>：使用UNIQUE参数设置为唯一性索引，限制该索引必须是唯一的，允许空值。</li><li><strong>全文索引（FULLTEXT）</strong>：对于长文本查询，可以创建该索引以提高查询效率。</li><li><strong>主键索引</strong>：特殊的唯一性索引，NOT NULL + UNIQUE，一个表只能由一个主键索引。</li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句为<code>select ID from T where k between 3 and 5</code>，这时只需要查ID的值，而ID的值已经在k索引树上了，因此不需要回表，也就是，索引k已经覆盖了我们的我们的查询请求，这被称为<strong>覆盖索引</strong>。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树在插入新值的时候必须做必要的维护，如果添加新值的时候，所在数据页已经满了，这时需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为<strong>页分裂</strong>。如果删除数据，可能导致页的合并。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树这种索引结构，可以利用索引的最左前缀，来定位记录。</p><p> 问题：在建立联合索引的时候，如何安排索引内的字段顺序？</p><ul><li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往是需要优先考虑采用的。</li></ul><p>如果有一个联合索引(a,b)，查询条件里面如果只有b的语句，是无法使用这个联合索引的。</p><p>这时候需要考虑的原则就是空间。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>以联合索引(name, age)为例，如果查找”名字第一个字是张，年龄是10岁的所有男孩”，SQL语句如下：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;张%&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> ismale <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><p>根据最左前缀原则，找到第一个满足第一个字是张的记录之后，判断其他条件是否满足。</p><p>在MySQL 5.6之前，只能从该记录开始一个个回表，到主键索引树上找到指定数据行，进行字段值比对。</p><p>在MySQL5.6引入<strong>索引下推优化</strong>，可以在索引遍历的过程中，对索引中包含的字段先进行判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h3 id="索引代价"><a href="#索引代价" class="headerlink" title="索引代价"></a>索引代价</h3><ul><li>空间上的代价：每一个索引都会建立一颗B+ Tree，每个节点则是一个数据页，默认页大小为16KB，添加索引的同时也要考虑到空间消耗。</li><li>时间上的消耗：数据进行增删改操作，都需要去维护索引，包括页面分裂、页面回收等操作。</li></ul><h3 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h3><p>从MySQL8.x开始支持<strong>隐藏索引（invisible indexes）</strong>，将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引，确定隐藏索引后系统不受任何相应，就可以彻底删除索引。（<strong>软删除</strong>）</p><p>显式删除存在的问题：删除索引后出现错误，又需要重新将索引创建回来，性能消耗非常大。</p><h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><h3 id="创建索引规范"><a href="#创建索引规范" class="headerlink" title="创建索引规范"></a>创建索引规范</h3><ul><li>命名规范</li><li>单张表索引数量不超过5个，单个索引的字段不超过5个</li><li>禁止冗余索引，重复索引，索引维护需要成本，新增索引时优先考虑基于现有索引进行rebuild</li><li>JOIN连接的场景<ul><li>连接表的数量尽量不要超过三张</li><li>对WHERE条件创建索引</li><li>对连接的字段创建索引，连接字段的类型必须一致</li></ul></li><li>选择区分度大的列（最好<strong>唯一性</strong>）建立索引</li><li>对过长的VARCHAR段建立索引，优先考虑前缀索引，例如<code>index(address(10))</code>，取前10字符建立<strong>前缀索引</strong>。</li><li>频繁作为<strong>WHERE</strong>查询条件的字段</li><li>经常<strong>GROUP BY</strong>和<strong>ORDER BY</strong>的列</li><li>UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引</li><li>DISTINCT 字段需要创建索引</li><li>不在低基数列创建索引（性别）</li><li>避免对经常更新的表创建过多的索引</li><li>不建议使用无序的值作为索引</li><li>删除很少使用的索引</li></ul><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3><ul><li>计算、函数、类型转换、不等于（!&#x3D;）导致索引失效</li><li>在WHERE子句中，OR的前后存在非索引列，索引失效</li><li>like查询以通配符%开头的索引失效</li><li>IS NULL可以使用索引，IS NOT NULL无法使用索引</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索MySQL的事务与锁机制</title>
    <link href="/2020/MySQL/%E6%8E%A2%E7%B4%A2MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/MySQL/%E6%8E%A2%E7%B4%A2MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h1><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。MySQL中事务支持是在存储引擎层实现的。事务拥有四个重要的特性：原子性、一致性、隔离性、持久性，简称为ACID特性，下文将逐一解释。</p><h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><ul><li>原子性（Atomicity）<ul><li>事务开始后所有操作步骤，要么全部完成，要么全部不做，不存在只执行一部分的情况。</li></ul></li><li>一致性（Consistency）<ul><li>事务执行前后，数据从一个合法性状态变换到另一个合法性状态。<ul><li>A、B转账业务，总金额不变。</li></ul></li><li>分为数据一致性和约束一致性。</li></ul></li><li>隔离性（Isolation）<ul><li>在一个事务未执行完毕时，其它事务无法读取该事务的数据。</li><li>MySQL通过锁机制来保证事务的隔离性。</li></ul></li><li>持久性（Durability）<ul><li>事务一旦提交，数据将被保存下来，即使发生宕机等故障，数据库也能将数据恢复。</li><li>MySQL使用<code>redo log</code>来保证事务的持久性。当通过事务对数据进行修改时，首先会将操作记录到<code>redo log</code>中，然后对数据库对应行进行修改，这样即使数据库宕机，也能通过<code>redo log</code>进行恢复。</li></ul></li></ul><p>ACID关系如下图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/structure/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png" alt="ACID关系"></p><h2 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h2><p>开始事务：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;  或<span class="hljs-keyword">START</span> TRANSACTION;</code></pre></div><p>两者区别：</p><ul><li><code>START TRANSACTION</code>后面可以跟随几个修饰符：<ul><li>READ ONLY：标识为只读事务，该事务只能读取数据。</li><li>READ WRITE：标识为读写事务，该事务可以读写数据。</li><li>WITH CONSISTENT SNAPSHOT ：启动一致性读。</li></ul></li></ul><p>完成事务：</p><div class="code-wrapper"><pre><code class="hljs sql"># 提交事务<span class="hljs-keyword">COMMIT</span>;#回滚事务<span class="hljs-keyword">ROLLBACK</span>;#将事务回滚到某个保存点。<span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> [<span class="hljs-keyword">SAVEPOINT</span>]</code></pre></div><h2 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;</code></pre></div><p>隐式提交数据的情况：</p><ol><li>数据定义语言：CREATE、ALTER、DROP</li><li>隐式修改mysql数据库中的表</li><li>事务控制（连续两次BEGIN，第一个BEGIN后面的语句会自动提交）或关于锁定的语句</li><li>加载数据的语句</li><li>MySQL复制的语句</li></ol><h2 id="completion-type"><a href="#completion-type" class="headerlink" title="completion_type"></a>completion_type</h2><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-variable">@completion_type</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><p>该变量有三种取值：</p><ul><li>0：默认值，当我们执行COMMIT时会提交事务，再执行下一个事务时，还需要使用BEGIN来开启。</li><li>1：提交事务后，相当于执行了<code>COMMIT AND CHAIN</code>，开启链式事务，当我们提交事务后会开启一个相同隔离级别的事务。</li><li>2：相当于<code>COMMIT AND RELEASE</code>，提交事务后，与服务器断开连接。</li></ul><h2 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h2><ul><li>扁平事务：最简单的一种，使用BEGIN开启，由COMMIT或ROLLBACK结束。</li><li>带有保存点的扁平事务：支持回滚到指定保存点的事务。</li><li>链式事务：一个事务由多个子事务构成，提交前一个事务，触发下一个事务。</li><li>嵌套事务：由顶层事务控制下面各个层次的事务。</li><li>分布式事务：分布式系统中的扁平事务。</li></ul><h1 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h1><h2 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h2><p>事务A覆盖了事务B未提交的更新数据。</p><p>任何隔离级别都可以解决该问题。</p><h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><p><strong>丢失更新</strong>就是两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务更新的情况。这是一种并发写入的问题。基本情景如下表：</p><table><thead><tr><th align="center">时间</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">开启事务</td><td align="center">开启事务</td></tr><tr><td align="center">2</td><td align="center">a &#x3D; 100</td><td align="center">a &#x3D; 100</td></tr><tr><td align="center">3</td><td align="center">&#x2F;</td><td align="center">a -&#x3D; 10</td></tr><tr><td align="center">4</td><td align="center">&#x2F;</td><td align="center">commit</td></tr><tr><td align="center">5</td><td align="center">&#x2F;</td><td align="center">&#x2F;</td></tr><tr><td align="center">6</td><td align="center">a +&#x3D; 20</td><td align="center">&#x2F;</td></tr><tr><td align="center">7</td><td align="center">commit</td><td align="center">&#x2F;</td></tr></tbody></table><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>一个事务读取了另一个未提交的事务写的数据，被称为脏读。基本情景如下：</p><table><thead><tr><th align="center">时间</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">开启事务</td><td align="center">开启事务</td></tr><tr><td align="center">2</td><td align="center">a &#x3D; 100</td><td align="center">a &#x3D; 100</td></tr><tr><td align="center">3</td><td align="center">&#x2F;</td><td align="center">a &#x3D; 110</td></tr><tr><td align="center">4</td><td align="center">a &#x3D; 110</td><td align="center">&#x2F;</td></tr><tr><td align="center">5</td><td align="center">&#x2F;</td><td align="center">rollback</td></tr></tbody></table><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>事务A读取一个字段，然后事务B<strong>更新</strong>了字段，事务A再次读取发现两次值不相等。</p><table><thead><tr><th align="center">时间</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">开启事务</td><td align="center">开启事务</td></tr><tr><td align="center"></td><td align="center">a &#x3D; 100</td><td align="center">a &#x3D; 100</td></tr><tr><td align="center">3</td><td align="center">&#x2F;</td><td align="center">a &#x3D; 110</td></tr><tr><td align="center">4</td><td align="center">a &#x3D; 110</td><td align="center">commit</td></tr></tbody></table><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>事务A读取一个字段，然后事务B<strong>插入</strong>了满足条件的数据，事务A再次读取发现两次值不一样。</p><table><thead><tr><th align="center">时间</th><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">开启事务</td><td align="center">开启事务</td></tr><tr><td align="center">2</td><td align="center">select * from table where id &#x3D; 1(记录为0条)</td><td align="center">&#x2F;</td></tr><tr><td align="center">3</td><td align="center">&#x2F;</td><td align="center">insert into table (id) value(1)</td></tr><tr><td align="center">4</td><td align="center">&#x2F;</td><td align="center">commit</td></tr><tr><td align="center">5</td><td align="center">insert into table (id) value(1)</td><td align="center">&#x2F;</td></tr><tr><td align="center">6</td><td align="center">commit(报错，主键冲突)</td><td align="center">&#x2F;</td></tr></tbody></table><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>由于数据库在并发事务中带来一些问题，数据库提供了事务隔离机制来解决相对应的问题。数据库的锁也是为了构建这些隔离级别而存在的。</p><table><thead><tr><th>隔离级别</th><th>脏读（Dirty Read）</th><th>不可重复读（NonRepeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>未提交读(Read uncommited)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读(Read commited)</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatable read)</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化(Serializable)</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ul><li>未提交读(Read Uncommitted)：在该隔离级别下，所有事务都能看到其他未提交事务的执行结果，会导致脏读、不可重复读、幻读。</li><li>提交读(Read Committed)：一个事务只能看见已经提交事务所做的改变，不能避免不可重复读、幻读。</li><li>可重复读(Repeated Read)：<strong>默认的隔离级别</strong>，事务A读取到一个数据后，事务B进行了修改并提交，事务A再次读取该数据，还是读取到原来的内容。不能避免幻读问题。</li><li>可串行化(Serializable)：对于同一行记录，写会加写锁，读会加读锁，当出现读写冲突的时候，后面的事务必须等待前一个事务执行完成才能继续执行。</li></ul><p><strong>隔离级别越高，数据库的并发性能越差。</strong></p><p>查询与修改隔离级别的SQL语句：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 查看系统隔离级别：</span><span class="hljs-keyword">select</span> @@<span class="hljs-keyword">global</span>.tx_isolation;<span class="hljs-comment">-- 查看当前会话隔离级别</span><span class="hljs-keyword">select</span> @@tx_isolation;<span class="hljs-comment">-- 设置当前会话隔离级别</span><span class="hljs-keyword">SET</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">serializable</span>;<span class="hljs-comment">-- 设置全局系统隔离级别</span><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> <span class="hljs-keyword">UNCOMMITTED</span>;</code></pre></div><h1 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h1><p>事务日志有两种：</p><ul><li>REDO LOG：重做日志，提供再写入操作、恢复提交事务修改的页操作，用来保证事务的持久性。是存储引擎层生成的日志，记录<strong>物理页</strong>的修改操作（包括页号、偏移量等），主要保证数据的可靠性。</li><li>UNDO LOG：回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。是存储引擎层生成的日志，记录<strong>逻辑操作</strong>日志，用于<strong>事务回滚</strong>和<strong>一致性非锁定读</strong>。</li></ul><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>InnoDB以页为单位管理存储空间，读取页首先要将<strong>磁盘</strong>中的页读取到内存中的Buffer Pool再访问，所有的更新都先更新缓冲池数据，缓冲池中的<strong>脏页</strong>会以一定的频率被刷入磁盘（<strong>checkpoint</strong>机制），以此来抵消CPU和磁盘的差距。</p><h3 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h3><p>由于checkpoint机制是定时触发，当出现事务提交后，刚写完缓冲池，数据库宕机，那么会发生数据丢失，不符合<strong>持久性</strong>的要求。</p><p>解决思路：</p><ul><li>每次提交的数据都进行刷盘操作，存在以下问题：<ul><li>修改量和刷盘工作量不成比例：修改1KB内容，刷盘16KB。</li><li>随机IO刷新较慢：一个事务内修改的物理页不一定连续。</li></ul></li><li>使用redo log进行记录，包括物理页、偏移量、修改值等数据。<ul><li>降低了频繁刷盘的效率。</li></ul></li></ul><p>InnoDB采取的是WAL（<strong>Write-Ahead Logging</strong>），先写日志，后写磁盘，发生宕机后通过redo log进行恢复，<strong>保证持久性，这就是redo log的作用。</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>redo日志<strong>顺序写入磁盘</strong>：磁盘顺序写的性能和写内存差不多。</li><li>事务执行过程中，redo日志不断记录。<ul><li>bin log直到事务提交，才会一次性写入到bin log中。</li></ul></li><li>占用空间比较小。</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>主要分为两部分：</p><ul><li>redo log buffer：保存在内存中<ul><li>innodb_log_buffer_size：默认16M</li></ul></li><li>redo log file：保存在磁盘中</li></ul><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>以更新事务为例，基本流程如下：</p><ol><li>先将原始数据从磁盘读取到内存中，并进行更新。</li><li>生成一条redo log entry并写入redo log buffer。</li><li>当事务commit后，将redo log buffer中的内容刷新到redo log file，采用append方式。</li><li>定期将内存中修改的数据刷新到磁盘中。</li></ol><h3 id="redo-log-buffer的刷盘策略"><a href="#redo-log-buffer的刷盘策略" class="headerlink" title="redo log buffer的刷盘策略"></a>redo log buffer的刷盘策略</h3><p>该流程是保证数据持久化的核心环节，这里的刷盘并不直接刷到磁盘，而实刷入<strong>Page Cache（内存）</strong>中（write），真正的刷盘工作（fsync）交给OS去做。如果此时系统宕机，那么数据会丢失。因此InnoDB提供了<code>innodb_flush_log_at_trx_commit</code>参数来控制何时将redo log buffer中的日志刷入redo log file。默认值为1。</p><ul><li>0：redo log buffer每隔一秒将其数据刷入page cache，该模式下事务提交不会触发刷盘操作。<ul><li>mysql进程崩溃会导致数据丢失。</li></ul></li><li>1：每次事务提交都会将将redo log buffer中数据刷入page cache，并立刻刷入磁盘。效率较低也为安全。</li><li>2：每次事务提交都会将redo log buffer中数据刷入page cache，由OS同步到磁盘。（每秒一次）<ul><li>mysql进程崩溃不会有数据丢失，当时OS宕机会有数据丢失。</li></ul></li></ul><h3 id="redo-log-buffer的写入过程"><a href="#redo-log-buffer的写入过程" class="headerlink" title="redo log buffer的写入过程"></a>redo log buffer的写入过程</h3><p>Mini-Transaction：MySQL将对底层页面中的一次原子访问的过程称为Mini-Transaction（mtr）。例如：向默认索引对应的B+ Tree中插入一条记录就是一次mtr。每个mtr会包含一组redo log entry，在进行恢复数据时，一组redo日志作为不可分割的整体。</p><p>写入是顺序写入，先往前面的block中写，当写满后，往后续的block写入，提供了<code>buf_free</code>的全局变量用来指明写到了哪个block。</p><p>一个block共512字节（磁盘扇区为512，避免非原子性写入），block由以下几个部分组成：</p><ul><li>log block header：12字节，保存一些block元数据。</li><li>log block body：492字节，存储redo log信息。</li><li>log block trailer：8字节，保存校验值。</li></ul><h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><p>相关配置参数：</p><ul><li>innodb_log_group_home_dir：指定redo log文件存储路径，默认为<code>./</code>，表示在数据库的数据目录中（默认为<code>var/lib/mysql</code>）</li><li>innodb_log_files_in_group：指定redo log file的个数，命名方式如：ib_logfile0，默认为2，最大100</li><li>innodb_log_file_size：单个redo log file的大小，默认为48M</li></ul><p>采用循环使用的方式进行写入，整个日志组有两个重要的属性：</p><ul><li>write pos：当前记录的位置，一边写一边后移。</li><li>checkpoint：当前要擦除的位置，也是往后推移。</li></ul><p>每次刷盘redo log，write pos就往后更新，每次MySQL加载日志文件恢复数据，会清空加载过的日志，并将checkpoint后移更新，两个变量之间的部分用做空闲空间来写入新数据，类似于一个<strong>环形队列</strong>。</p><p>当两者相遇，表示文件组已满。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log保证了事务的原子性，主要用来实现事务回滚操作。</p><h3 id="为什么需要undo-log"><a href="#为什么需要undo-log" class="headerlink" title="为什么需要undo log"></a>为什么需要undo log</h3><p>事务需要保证<strong>原子性</strong>，如果出现意外情况，例如mysql进程崩溃，OS宕机、断电，或者是事务本身<code>ROLLBACK</code>，都需要对数据进行<strong>回滚</strong>，因此使用undo log完成该项任务。</p><p>undo log会产生redo log，因为undo log也需要持久性的保护。</p><h3 id="undo-log作用"><a href="#undo-log作用" class="headerlink" title="undo log作用"></a>undo log作用</h3><ul><li><strong>回滚数据</strong>：undo并不是<strong>物理</strong>恢复（数据页操作），undo log是<strong>逻辑日志</strong>，只是将数据库逻辑上恢复到原来的样子。</li><li><strong>MVCC</strong>：InnoDB中的MVCC通过undo来完成的，当用户读取一行记录时，若该纪录已被其他事务占用，当前事务可以通过undo读取之前的版本，以此实现<strong>非锁定读</strong>。</li></ul><h3 id="undo存储结构"><a href="#undo存储结构" class="headerlink" title="undo存储结构"></a>undo存储结构</h3><p>采用段的方式进行管理（回滚段），每个回滚段记录了1024个<code>undo log segment</code>，在每个<code>undo log segment</code>中进行undo页的写入。</p><p>回滚段和事务的关系：</p><ul><li>每个事务只使用一个回滚段，一个回滚段在同一时刻服务于多个事务。</li><li>事务开始时，会指定一个回滚段，在事务执行过程中，当数据被修改，原始数据会复制到回滚段。</li><li>回滚段中事务不断填冲盘区，使用完会扩展下一个盘区，所有已分配的盘区都被用完，会覆盖最初的盘区。</li><li>事务提交时，存储引擎处理两个事情：<ul><li>将undo log放在列表中，以供后续的purge操作。</li><li>判断undo log所在页是否可重用<ul><li>该页会被放入链表，并判断可用空间是否小于四分之三，小于则可以被重用，不被回收。</li></ul></li></ul></li></ul><h3 id="回滚数据分类"><a href="#回滚数据分类" class="headerlink" title="回滚数据分类"></a>回滚数据分类</h3><ul><li>未提交的回滚数据：此时事务暂未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li>已提交但未过期的回滚数据：事务已提交，受<code>undo retention</code>参数的保持时间的影响。</li><li>事务已经提交并过期的回滚数据：数据保存时间超过<code>undo retention</code>指定的时间，回滚段满了后，优先覆盖此部分数据。</li></ul><h3 id="undo-log参数"><a href="#undo-log参数" class="headerlink" title="undo log参数"></a>undo log参数</h3><ul><li>innodb_undo_directory：设置undo log存储路径，默认值为<code>./</code>。</li><li>innodb_undo_logs：设置<code>rollback segment</code>的个数，默认为128</li><li>innodb_undo_tablespaces：设置<code>rollback segment</code>文件的数量。默认为2。</li></ul><h3 id="undo类型"><a href="#undo类型" class="headerlink" title="undo类型"></a>undo类型</h3><p>InnoDB中undo log分为以下两种：</p><ul><li>insert undo log：在insert操作下产生的log，只对事务本身可见，对其他事务不可见（隔离性的要求），事务提交后直接删除，不需要purge。</li><li>update undo log：delete和update操作产生的log，需要提供MVCC机制，因此不能直接删除，<strong>等待purge线程进行删除。</strong></li></ul><h2 id="ACID的实现"><a href="#ACID的实现" class="headerlink" title="ACID的实现"></a>ACID的实现</h2><h3 id="原子性的实现"><a href="#原子性的实现" class="headerlink" title="原子性的实现"></a>原子性的实现</h3><p>每一个写事务，都会修改Buffer Pool，并产生对应的Redo日志，Redo日志以Write Ahead Log方式写，如果不写日志，数据库宕机恢复后，事务无法回滚，无法保证原子性。</p><h3 id="持久性的实现"><a href="#持久性的实现" class="headerlink" title="持久性的实现"></a>持久性的实现</h3><p>通过WAL可以保证逻辑上的持久性，物理上的持久性通过存储引擎的数据刷盘实现。</p><h3 id="隔离性的实现"><a href="#隔离性的实现" class="headerlink" title="隔离性的实现"></a>隔离性的实现</h3><p>通常用Read View表示一个事务的可见性，读提交状态每一条读操作语句都会获得一次Read View，每次更新都会获取最新事务的提交状态，即每条语句执行都会更新其可见性视图。可重复读的隔离级别下，可见性视图只有在自己当前事务提交之后，才会更新，所以与其他事务没有关系。</p><p><strong>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，可以得到之前一个状态的值</strong>。假设一个值从1被按照顺序改成了2，3，4，在回滚日志中会有类似下面的记录。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/transaction/1.jpg" alt="记录"></p><p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的<code>read-view</code>，在视图A、B、C中，记录的值分别为1、2、4。同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC ）。对于<code>read-view A</code>要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>即使现在有另外一个事务正在将 4 改成 5，这个事务跟 <code>read-view A、B、C </code>对应的事务是不会冲突的。</p><h3 id="一致性的实现"><a href="#一致性的实现" class="headerlink" title="一致性的实现"></a>一致性的实现</h3><p>一致性是通过其它三个特性来保证的。而其它三个特性由Redo、Undo来保证的。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul><li>对数据的操作类型划分<ul><li>读锁&#x2F;共享锁</li><li>写锁&#x2F;排他锁</li></ul></li><li>粒度划分<ul><li>表级锁</li><li>行级锁</li><li>页级锁</li></ul></li><li>对锁的态度划分<ul><li>悲观锁</li><li>乐观锁</li></ul></li><li>加锁方式<ul><li>显式锁</li><li>隐式锁</li></ul></li></ul><h2 id="InnoDB的锁"><a href="#InnoDB的锁" class="headerlink" title="InnoDB的锁"></a>InnoDB的锁</h2><p>InnoDB中，锁分为行锁和表锁，行锁包括两种锁。</p><ul><li>共享锁（S）：共享锁锁定的资源可以被其它用户读取，但不能修改，在进行SELECT的时候，会将对象进行共享锁锁定，数据读取完毕，释放共享锁，保证在读取的过程中不被修改。</li><li>排他锁（X）：锁定的数据只允许进行锁定操作的事务使用，其它事务无法对已锁定的数据进行查询和修改</li></ul><div class="code-wrapper"><pre><code class="hljs SQL"># 给product_comment加上共享锁LOCK <span class="hljs-keyword">TABLE</span> product_comment READ;# 解锁UNLOCK <span class="hljs-keyword">TABLE</span>;# 对 user_id<span class="hljs-operator">=</span><span class="hljs-number">912178</span> 的数据行加上共享锁<span class="hljs-keyword">SELECT</span> comment_id, product_id, comment_text, user_id <span class="hljs-keyword">FROM</span> product_comment <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">912178</span> LOCK <span class="hljs-keyword">IN</span> SHARE MODE# 给 product_comment 数据表添加排它锁LOCK <span class="hljs-keyword">TABLE</span> product_comment WRITE;# 解锁UNLOCK <span class="hljs-keyword">TABLE</span>;# 对 user_id<span class="hljs-operator">=</span><span class="hljs-number">912178</span> 的数据行加上排他锁<span class="hljs-keyword">SELECT</span> comment_id, product_id, comment_text, user_id <span class="hljs-keyword">FROM</span> product_comment <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">912178</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;</code></pre></div><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB为了允许行锁和表锁共存，实现多粒度锁机制，意向锁就是其中的一种表锁。</p><ul><li>意向锁的存在是为了协调行锁和表锁的关系</li><li>意向锁是一种不与行级锁冲突的表级锁</li><li>表明某个事物正在某些行持有了锁或该事务准备去持有锁。</li></ul><p>InnoDB还有两种内部使用的意向锁，也都是表锁，表锁分为三种：</p><ul><li><p>意向共享锁（IS）：事务计划给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p></li><li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p></li><li><p>自增锁（AUTO-INC Locks）：特殊表锁，自增长计数器通过该“锁”来获得子增长计数器最大的计数值。自增主键会涉及自增锁，在INSERT结束后立即释放。</p></li><li><p>如果事务想要获取数据表中某些数据的共享锁，就会在表上添加<strong>意向共享锁</strong>。</p></li><li><p>如果事务想要获取数据表中某些数据的排他锁，就会在表上添加<strong>意向排他锁</strong>。</p></li></ul><p>意向锁主要为了<strong>提高效率</strong>，避免线程去逐个检查行锁。</p><p>在加行锁之前必须先获得表级意向锁，否则等<code>innodb_lock_wait_timeout</code> 超时后根据<code>innodb_rollback_on_timeout</code> 决定是否回滚事务。</p><p>插入数据的方式分为三类：</p><ul><li>Simple inserts：预先确定插入的行数，<ul><li><code>INSERT VALUES()</code>、<code>REPLACE</code></li></ul></li><li>bulk inserts：事先不知道插入的行数，每处理一行，为AUTO_INCREMENT分配一个新值。<ul><li><code>INSERT ... SELECT</code>、<code>LOAD DATA</code></li><li>mixed-mode inserts：是simple inserts语句，但是指定部分新行的自动递增值</li></ul></li></ul><p>AUTO-INC锁是当插入数据中含有<code>AUTO_INCREMENT</code>字段时进行lock的表级锁。并发性能较差。</p><p>InnoDB通过<code>innodb_autoinc_lock_mode</code>来提供不同的锁定机制。</p><ul><li>0：所有insert语句都会获得同一个AUTO-INC锁</li><li>1：bulk inserts仍使用AUTO-INC锁，Simple inserts由于确定插入条数，在获取自增锁后会释放</li><li>2：所有insert语句都不会使用表级AUTO-INC锁，自增值保证所有insert语句获得的值是唯一的，由于多个语句同时生成，生成值可能不是连续的。</li></ul><p>锁关系矩阵如下图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/transaction/%E9%94%81%E5%85%BC%E5%AE%B9%E7%9F%A9%E9%98%B5.png" alt="InnoDB锁关系矩阵"></p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MySQL5.5引入了meta data lock，简称MDL锁（表锁），其作用是保证读写的正确性。当对一个表做增删改查操作时，加MDL读锁，当对表结构做变更操作时，加MDL写锁。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB行锁是通过对索引数据页上的记录加锁实现的，在存储引擎层实现。</p><p>主要有三种锁：</p><ul><li><p>Record锁（LOCK_REC_NOT_GAP）：单个行记录的锁（锁数据，不锁Gap）</p></li><li><p>Gap锁：间隙锁，锁定一个范围，不包括记录本身（不锁数据，锁数据前面的Gap）</p><ul><li>为了防止插入幻影记录而提出的</li></ul></li><li><p>Next-key锁：锁数据并且锁Gap，可以解决幻读问题。</p><ul><li><strong>既想锁住某条记录，又想阻止其他事务在该记录前面的间隙插入新纪录。</strong></li></ul></li><li><p>插入意向锁（Insert Intention Locks）：插入一条记录需要判断是否存在gap锁，有的话需要等待。InnoDB规定事务在等待的时候也需要在内存中生成一个<strong>锁结构</strong>，<strong>表明有事务想在某个间隙中插入新记录</strong>，这个锁结构被称为<code>Insert Intention Locks</code>。</p><ul><li>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</li></ul></li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>对<strong>整个数据库实例</strong>加锁，整个数据库处于<strong>只读状态</strong>，，使用场景为：<strong>全库逻辑备份</strong>。</p><div class="code-wrapper"><pre><code class="hljs sql">Flush tables <span class="hljs-keyword">with</span> read lock</code></pre></div><h3 id="InnoDB死锁"><a href="#InnoDB死锁" class="headerlink" title="InnoDB死锁"></a>InnoDB死锁</h3><p>由于InnoDB是逐行加锁的，极容易产生死锁，产生死锁的四个条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程以获得的资源，在没有使用完之前，不能强行剥夺。</li><li>循环等待条件：多个进程之前形成的一种互相循环等待资源的关系。</li></ul><h3 id="InnoDB中如何处理死锁"><a href="#InnoDB中如何处理死锁" class="headerlink" title="InnoDB中如何处理死锁"></a>InnoDB中如何处理死锁</h3><ul><li>等待，直到超时：<code>innodb_lock_wait_timeout</code>参数进行控制，默认为50s，超时回对事务进行<strong>回滚</strong>。</li><li>使用死锁检测进行处理：InnoDB使用<code>wait-for graph</code>算法来主动进行死锁检测，每次加锁请求无法立即满足时，都会触发此算法。<ul><li>这是一种主动的检测机制，要求数据库保存<strong>锁的信息链表</strong>和<strong>事务等待链表</strong>两部分信息。</li><li>基于这两部分信息，绘制<code>wait-for graph</code></li><li>一旦检测到回路，引擎会选择回滚<strong>undo量最小的事务</strong>，让其他食物继续执行。（此部分通过<code>innodb_deadlock_detect</code>参数控制）</li></ul></li><li></li></ul><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul><li>更新SQL的where条件尽量用索引</li><li>合理设置索引，加锁索引准确，缩小锁定范围，减少锁竞争。</li><li>减少范围更新，尤其非主键&#x2F;非唯一索引的范围更新。</li><li>控制事务大小，减少锁定数据量和锁定时间长度</li><li>加锁顺序一致，尽可能一次性锁定所有所需的数据行。</li><li>并发要求高的系统，不要显式加锁。</li></ul><h3 id="锁的结构"><a href="#锁的结构" class="headerlink" title="锁的结构"></a>锁的结构</h3><p>如果出现以下情况，多个逻辑上的锁会放在一个锁结构中：</p><ul><li>同一个事务中进行加锁</li><li>被加锁的记录在同一个页面</li><li>加锁的类型是一样的</li><li>等待状态一样</li></ul><p>锁结构包含以下字段：</p><ul><li>锁所在事务信息：记录哪个事务生成了这个锁结构，指针。</li><li>索引信息：对于行锁，需要记录加锁的记录属于哪个索引，指针。</li><li>表锁&#x2F;行锁信息：用于区分此类型。<ul><li>表锁记录：表信息、其他信息</li><li>行锁记录：<ul><li>Space ID：所在的表空间</li><li>Page Number：记录所在页号</li><li>n_bits：一条记录对应一个bit位，用不同的bit位区分哪一条记录加了锁。</li></ul></li></ul></li><li>type_mode：32bit，分为以下几个部分<ul><li>lock_mode：低4位。<ul><li>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是IS锁 。 </li><li>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是IX锁 。</li><li>LOCK_S （十进制的 2 ）：表示共享锁，也就是S锁 。</li><li>LOCK_X （十进制的 3 ）：表示独占锁，也就是X锁 </li><li>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。</li></ul></li><li>lock_type：低5-8位，目前只有第5、6位被使用<ul><li>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。 </li><li>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>rec_lock_type：其余位。<ul><li>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。 </li><li>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。 </li><li>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示记录锁 。 </li><li>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。</li></ul></li></ul></li></ul><h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><p>可以检查<code>InnoDB_row_lock</code>变量来分析锁状态。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_row_lock%&#x27;</span>;Variable_name  <span class="hljs-keyword">Value</span>Innodb_row_lock_current_waits<span class="hljs-number">0</span>Innodb_row_lock_time<span class="hljs-number">297</span>Innodb_row_lock_time_avg<span class="hljs-number">42</span>Innodb_row_lock_time_max<span class="hljs-number">83</span>Innodb_row_lock_waits<span class="hljs-number">7</span></code></pre></div><p>各字段含义分别如下：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量； </li><li>Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长） </li><li>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是 <code>INNODB_TRX</code> 、 <code>data_locks</code>（8.0更新） 和 <code>data_lock_waits</code>（8.0更新） 。</p><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><h2 id="单版本控制-锁"><a href="#单版本控制-锁" class="headerlink" title="单版本控制-锁"></a>单版本控制-锁</h2><p>锁用独占的方式保证只有一个版本的情况下事务相互隔离。</p><h2 id="多版本控制-MVCC"><a href="#多版本控制-MVCC" class="headerlink" title="多版本控制-MVCC"></a>多版本控制-MVCC</h2><p>MVCC（Multi-Version Concurrency Control）即多版本并发控制。</p><p>MVCC 是通过保存数据在<strong>某个时间点的快照</strong>来实现并发控制的。简单来说它的思想就是<strong>保存数据的历史版本</strong>。这样我们就可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁也可以保证事务的隔离效果。</p><p>每次对数据库的修改，都会在Undo日志中记录当前修改记录的<strong>事务版本号</strong>以及<strong>修改前数据状态的存储地址</strong>，以便在必要的时候可以回滚到老的数据版本。</p><p>MVCC的实现依赖于：Undo Log、Read View、隐藏字段。</p><p>MVCC没有正式的标准，在不同DBMS中实现方式也不同。</p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>MVCC主要解决以下几个问题：</p><ul><li>读写之间阻塞的问题，通过MVCC可以让读写互相不阻塞，提高并发处理能力。</li><li>降低了死锁的概率，MVCC采用了乐观锁的方式，读取数据时不需要加锁，对于写操作，只锁定必要的行。</li><li>解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li></ul><p>MVCC最大的<strong>好处</strong>是<strong>读不加锁，读写不冲突</strong>，在MVCC中，读操作可分为快照读（Snapshot Read）和当前读（Current Read）。 </p><ul><li>快照读：读取的是记录的可见版本，不用加锁</li><li>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其它事务不会并发修改这条记录。</li></ul><div class="code-wrapper"><pre><code class="hljs SQL"># 不加锁的<span class="hljs-keyword">SELECT</span>都是快照读<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">WHERE</span> ...# 加锁的<span class="hljs-keyword">SELECT</span>和增删改都是用当前读<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player LOCK <span class="hljs-keyword">IN</span> SHARE MODE;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> player <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> player <span class="hljs-keyword">values</span> ...</code></pre></div><p><strong>MVCC只在<code>Read Commited</code>和<code>Repeatable Read</code>两种级别下工作。核心是Undo Log + Read View。</strong></p><h3 id="Read-VIew"><a href="#Read-VIew" class="headerlink" title="Read VIew"></a>Read VIew</h3><p>在 MVCC 机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log 里。而Read View保存了不应该让这个事务看到的其他的事务ID列表。</p><p>Read View就是事务使用MVCC机制进行快照读操作时产生的读视图，事务启动时，会产生数据库系统当前的一个快照。</p><p><strong>主要问题</strong>：判断版本链中哪个版本是当前事务可见的。</p><p>ReadView主要包含以下内容：</p><ul><li>creator_trx_id：创建这个Read View的事务ID。</li><li>trx_ids：生成Read View时系统中活跃的读写事务的<strong>事务id列表</strong>。</li><li>up_limit_id：活跃的事务中最小的事务ID。</li><li>low_limit_id：生成Read View时系统中应该分配给下一个事务的id</li></ul><h3 id="ReadView规则"><a href="#ReadView规则" class="headerlink" title="ReadView规则"></a>ReadView规则</h3><p>根据以下步骤判断记录中某个版本是否可见：</p><ul><li>如果被访问版本的<code>trx_id = ReadView 中的 creator_trx_id </code> ，表示当前事务在访问它修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的<code>trx_id &lt; ReadView 中的 creator_trx_id </code>，表明生成该版本的事务已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值 &gt;&#x3D; ReadView中的 low_limit_id 值，表明生成该版本的事 务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>在其中，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>不在其中，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h3 id="MVCC流程"><a href="#MVCC流程" class="headerlink" title="MVCC流程"></a>MVCC流程</h3><p>查询一条记录时，MVCC工作流程如下：</p><ol><li>首先获取事务的<code>trx_id</code></li><li>获取对应的ReadView</li><li>查询读到的数据，与ReadView中的<code>trx_id</code>进行比较</li><li>如果不符合上述规则，从<code>Undo Log</code>中获取历史快照。</li><li>返回最终符合规则的数据。</li></ol><p><strong>MySQL怎么解决脏读、不可重复读、幻读等问题呢？</strong></p><ul><li>读操作使用MVCC，写操作进行加锁</li></ul><p>MVCC会生成一个<strong>ReadView</strong>，通过<code>ReadView</code>找到符合条件的记录版本，查询语句只能读到在生成ReadView之前<strong>已提交事务做的更改</strong>。</p><p>在不同隔离级别下使用MVCC会有不同结果：</p><ul><li><code>READ COMMITED</code>：每次执行SELECT操作都会生成一个ReadView，ReadView本身就保证了只能读到已提交事务的数据，避免了脏读的现象，但是会有不可重复读和幻读问题。</li><li><code>REPEATABLE READ</code>：一个事务在执行过程中，只有<strong>第一次执行SELECT操作</strong>才会生成一个ReadView，之后的读操作<strong>复用</strong>这个ReadView，避免了不可重复读和幻读的问题。<ul><li>此隔离级别下，<strong>快照读直接通过MVCC即可解决。</strong></li><li><strong>当前读通过<code>Next-key Lock</code>来锁定本记录和索引区间防止插入情况，从而避免幻读。</strong></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocalRondom原理剖析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/threadlocal-rondom/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/threadlocal-rondom/</url>
    
    <content type="html"><![CDATA[<p>ThreadLocalRondom是JDK 7在并发包中新增的随机数生成器，该类弥补了Random类在并发环境下的缺陷。</p><h2 id="Random的局限性"><a href="#Random的局限性" class="headerlink" title="Random的局限性"></a>Random的局限性</h2><p>Random生成随机数的方法如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextInt</span><span class="hljs-params">(<span class="hljs-type">int</span> bound)</span> &#123;    <span class="hljs-comment">//参数校验</span>        <span class="hljs-keyword">if</span> (bound &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(BadBound);<span class="hljs-comment">//根据老的种子生成新的种子</span>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> next(<span class="hljs-number">31</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> bound - <span class="hljs-number">1</span>;    <span class="hljs-comment">//根据新种子计算随机数</span>        <span class="hljs-keyword">if</span> ((bound &amp; m) == <span class="hljs-number">0</span>)            r = (<span class="hljs-type">int</span>)((bound * (<span class="hljs-type">long</span>)r) &gt;&gt; <span class="hljs-number">31</span>);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> r;                 u - (r = u % bound) + m &lt; <span class="hljs-number">0</span>;                 u = next(<span class="hljs-number">31</span>))                ;        &#125;        <span class="hljs-keyword">return</span> r;    &#125;</code></pre></div><p>next方法通过计算生成新的种子。用原子变量来存放种子，多线程的情况下，CAS操作会保证只有一个线程可以更新老的种子为新种子，更新失败的线程进行自旋，这降低了并发性能，所以产生了ThreadLocalRandom。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> bits)</span> &#123;        <span class="hljs-type">long</span> oldseed, nextseed;        <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">seed</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.seed;        <span class="hljs-keyword">do</span> &#123;            oldseed = seed.get();            <span class="hljs-comment">//seed计算公式，通过CAS操作进行更新</span>            nextseed = (oldseed * multiplier + addend) &amp; mask;        &#125; <span class="hljs-keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));    <span class="hljs-comment">//将得到的值进行逻辑右移</span>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(nextseed &gt;&gt;&gt; (<span class="hljs-number">48</span> - bits));    &#125;</code></pre></div><h2 id="ThreadLocalRandom简介"><a href="#ThreadLocalRandom简介" class="headerlink" title="ThreadLocalRandom简介"></a>ThreadLocalRandom简介</h2><p>ThreadLocalRandom和ThreadLocal的原理相似，ThreadLocalRandom使得每个线程都维护自己独有的种子变量，这样就不存在竞争问题，大大提高并发性能。</p><h2 id="current方法"><a href="#current方法" class="headerlink" title="current方法"></a>current方法</h2><p>在current方法中，获得ThreadLocalRandom实例并初始化。seed不再是一个AtomicLong变量，在Thread类中有三个变量。</p><ul><li>threadLocalRandomSeed：使用它来控制随机数种子。</li><li>threadLocalRandomProbe：使用它来控制初始化。</li><li>threadLocalRandomSecondarySeed：二级种子。</li></ul><p>这三个变量都加了<code>sun.misc.Contended</code>注解，用来避免伪共享问题。</p><div class="code-wrapper"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocalRandom <span class="hljs-title function_">current</span><span class="hljs-params">()</span> &#123;       <span class="hljs-comment">//判断是否初始化</span>       <span class="hljs-keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="hljs-number">0</span>)           <span class="hljs-comment">//进行初始化</span>           localInit();       <span class="hljs-keyword">return</span> instance;   &#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localInit</span><span class="hljs-params">()</span> &#123;       <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> probeGenerator.addAndGet(PROBE_INCREMENT);       <span class="hljs-type">int</span> <span class="hljs-variable">probe</span> <span class="hljs-operator">=</span> (p == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : p; <span class="hljs-comment">// skip 0</span>       <span class="hljs-type">long</span> <span class="hljs-variable">seed</span> <span class="hljs-operator">=</span> mix64(seeder.getAndAdd(SEEDER_INCREMENT));       <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();       UNSAFE.putLong(t, SEED, seed);       UNSAFE.putInt(t, PROBE, probe);   &#125;<span class="hljs-comment">/** The current seed for a ThreadLocalRandom */</span>   <span class="hljs-meta">@sun</span>.misc.Contended(<span class="hljs-string">&quot;tlr&quot;</span>)   <span class="hljs-type">long</span> threadLocalRandomSeed;   <span class="hljs-comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span>   <span class="hljs-meta">@sun</span>.misc.Contended(<span class="hljs-string">&quot;tlr&quot;</span>)   <span class="hljs-type">int</span> threadLocalRandomProbe;   <span class="hljs-comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span>   <span class="hljs-meta">@sun</span>.misc.Contended(<span class="hljs-string">&quot;tlr&quot;</span>)   <span class="hljs-type">int</span> threadLocalRandomSecondarySeed;</code></pre></div><h2 id="Unsafe机制"><a href="#Unsafe机制" class="headerlink" title="Unsafe机制"></a>Unsafe机制</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SEED;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> PROBE;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SECONDARY;<span class="hljs-keyword">static</span> &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//获取Unsafe实例</span>        UNSAFE = sun.misc.Unsafe.getUnsafe();        Class&lt;?&gt; tk = Thread.class;        <span class="hljs-comment">//获取Thread类里面threadLocalRandomSeed变量在Thread实例的偏移量</span>        SEED = UNSAFE.objectFieldOffset            (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSeed&quot;</span>));        <span class="hljs-comment">//获取Thread类里面threadLocalRandomProbe变量在Thread实例的偏移量</span>        PROBE = UNSAFE.objectFieldOffset            (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomProbe&quot;</span>));        <span class="hljs-comment">//获取Thread类里面threadLocalRandomSecondarySeed变量在Thread实例的偏移量</span>        SECONDARY = UNSAFE.objectFieldOffset            (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSecondarySeed&quot;</span>));    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);    &#125;&#125;</code></pre></div><h2 id="nextInt方法"><a href="#nextInt方法" class="headerlink" title="nextInt方法"></a>nextInt方法</h2><p>nextInt方法用于获取下一个随机数。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextInt</span><span class="hljs-params">(<span class="hljs-type">int</span> bound)</span> &#123;       <span class="hljs-comment">//参数校验</span>       <span class="hljs-keyword">if</span> (bound &lt;= <span class="hljs-number">0</span>)           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(BadBound);       <span class="hljs-comment">//根据当前线程中的种子计算新种子</span>       <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> mix32(nextSeed());       <span class="hljs-comment">//根据新种子计算随机数</span>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> bound - <span class="hljs-number">1</span>;       <span class="hljs-keyword">if</span> ((bound &amp; m) == <span class="hljs-number">0</span>) <span class="hljs-comment">// power of two</span>           r &amp;= m;       <span class="hljs-keyword">else</span> &#123;           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> r &gt;&gt;&gt; <span class="hljs-number">1</span>;                u + m - (r = u % bound) &lt; <span class="hljs-number">0</span>;                u = mix32(nextSeed()) &gt;&gt;&gt; <span class="hljs-number">1</span>)               ;       &#125;       <span class="hljs-keyword">return</span> r;   &#125;</code></pre></div><h2 id="nextSeed方法"><a href="#nextSeed方法" class="headerlink" title="nextSeed方法"></a>nextSeed方法</h2><p>获取当前线程的threadLocalRandomSeed变量值，然后加上GAMMA值作为新种子。可参照上文Unsafe机制。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextSeed</span><span class="hljs-params">()</span> &#123;    Thread t; <span class="hljs-type">long</span> r;    UNSAFE.putLong(t = Thread.currentThread(), SEED,                   r = UNSAFE.getLong(t, SEED) + GAMMA);    <span class="hljs-keyword">return</span> r;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java并发编程之美》</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据存储结构</title>
    <link href="/2020/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2020/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p>在InnoDB存储引擎中，表是根据主键顺序组织存放的，这种存储方式的表称为索引组织表，每张表都有一个主键，如果创建时没有显式定义主键，InnoDB存储引擎会按照如下方式进行创建主键：</p><ul><li>判断表中是否有非空的唯一索引，如果有，则该列为主键。</li><li>如果不符合上列条件，InnoDB存储引擎会自动创建一个6字节大小的指针。</li><li>当表中有多个非空唯一索引，InnoDB会选择第一个定义的非空唯一索引作为主键。</li></ul><h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p>所有的数据被逻辑存放在表空间，表空间又由段，区，页（块）组成。存储结构如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0064.PNG" alt="InnoDB逻辑存储结构"></p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。如果开启了<code>innodb_file_per_table</code>，每张表的数据可以单独放到一个表空间中。但是每张表的表空间存放的只是数据、索引和插入缓冲Bitmap页。其他类的数据，例如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲等还是存放在原来的共享表空间中。</p><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>表空间由各个段构成，常见的段有：数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据，数据段即为B+树的叶子节点，索引段即为B+树的非索引节点。在InnoDB存储引擎中，对段的管理都是由引擎自身完成，DBA不能也没有必要对其进行控制。</p><p><strong>引入段的目的</strong>：对于范围查询，会对B+ Tree节点进行顺序扫描，如果不区分叶子节点和非叶子节点，如果将两者放到同一个区当中，查询效率大打折扣，因此引入段来区分不同类型的页面。</p><h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>区是由连续页组成的空间，在任何情况下每个区的大小都为1MB，为了保证区的连续性，InnoDB一次从磁盘申请4~5个区，在默认情况下，页的大小为16KB，即一个区中共有64个连续页。</p><p><strong>引入区的目的</strong>：B+ Tree底层通过页存储数据，相邻的两个页物理地址可能离得非常远（产生随机IO），因此分配空间时，直接按区进行分配，这样会将相邻的页在物理上也是连续的，可以消除很多次随机IO，同时会造成空间浪费，整体利远大于弊。</p><p>为了考虑以完整的区为单位分配给某个段对于<strong>数据量较小</strong>的表而浪费存储空间的情况，InnoDB提出了<strong>碎片区</strong>的概念，碎片区中的页属于不同段。</p><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>页是InnoDB磁盘管理的最小单位，默认每个页大小为16KB，可以通过参数<code>innodb_page_size</code>将页的大小设置为4K，8K、16K。</p><p>常见的页类型有：</p><ul><li>数据页</li><li>undo页</li><li>系统页</li><li>事务数据页</li><li>插入缓冲位图页</li><li>插入缓冲空闲列表页</li><li>未压缩的二进制大对象页</li><li>压缩的二进制大对象页</li></ul><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB存储引擎是面向行（row-oriented）的，每个页最多存放16K&#x2F;2~200行的记录（7992行）。</p><h2 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h2><h3 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h3><p>该格式在MySQL5.0中引入，其设计目的是高效地存储数据。简单说，一个页存放的行数据越多，其性能就越高。它的存储方式如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0065%2820200416-174412%29.PNG" alt="Compact行记录格式"></p><ul><li><p>变长字段长度列表：对于变长字段的真实数据占用的字节长度都存放这里。</p><ul><li>逆序排放，非NULL</li><li>如果变长列的长度小于255 bytes，则用1 byte表示，否则用2 byte表示。</li></ul></li><li><p>NULL标志位：如果该数据行存在NULL值，使用1表示，该部分占用1 byte。</p></li><li><p>头信息固定5字节（40位），每位的含义如下：</p></li></ul><p>设置<code>deleted_flag</code>的原因：如果物理删除的话，记录在磁盘上需要重新排列，导致性能消耗，被删除掉的记录会形成一个<strong>垃圾链表（可重用空间）</strong>，如果之后有新纪录插入到表中，这部分空间将被覆盖掉。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0066.PNG" alt="Compact记录头信息"></p><p>最后的部分就是实际存储每个列的数据，<strong>NULL不占用任何空间</strong>，除了之前的标志位，每行数据除了用户定义的列之外，还有两个隐藏列，<strong>事务ID列（6字节）</strong>和<strong>回滚指针列（7字节）</strong>。如果没有定义主键，还会增加一个<strong>rowid</strong>列做为主键（6字节）。</p><h3 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h3><p>行溢出概念：在Compact行格式中，当列长度（例如varchar、BLOB等）达到768 byte后，会将该列的前768byte当作prefix存放在行中，多出来的数据溢出存放到溢出页中，然后通过一个偏移量指针将两者关联起来。</p><p>Dynamic和Compressed行格式不会存储prefix数据，直接全部溢出，只存储页地址。</p><h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>InnoDB数据页由以下七个部分构成，如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0067.PNG" alt="数据页结构"></p><p>其中<code>File Header、Page Header、File Trailer</code>的大小是固定的，这些空间是用来标记该页的一些信息，如Checksum，数据页所在的B+树索引的层数。</p><h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h3><p>该部分用来记录各种页的通用信息，共由八个部分组成，占用38字节。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0068.PNG" alt="File Header组成部分"></p><h3 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h3><p>该部分用来记录数据页的状态信息，由14个部分组成，占用56字节，如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/table/IMG_0069.PNG" alt="Page Header组成部分"></p><h3 id="Infimun和Supremum-Records"><a href="#Infimun和Supremum-Records" class="headerlink" title="Infimun和Supremum Records"></a>Infimun和Supremum Records</h3><p>Infimun用来记录是比该页中任何主键值都要小的值，Supremum Records指比任何值都大的值。这两个值在页创建时被建立。</p><h3 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h3><p>User Record是实际存储行记录的内容。Free Space指的是空闲空间（暂未被使用的空间），是一个链表数据结构，在一条记录被删除后，该空间会被加入到空闲链表中。</p><h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><p>该部分存放了<strong>记录的相对位置</strong>，有时这些记录指针称为<strong>Slots</strong>或Directory Slots，一个槽可能包含多个记录。B+树索引本身并不能找到具体的一条记录，只能找到该记录所在的页，数据库把页载入内存，通过Page Directory进行二分查找。</p><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>该部分是为了检测页是否已经完整地写入磁盘，File Trailer只有一个<code>FIL_PAGE_END_LSN</code>部分，占用8字节，前四个字节代表该页地checksum值，最后四个字节和File Header中的<code>FIL_PAGE_LSN</code>相同。将这两个值与File Header中的<code>FIL_PAGE_SPACE_OR_CHKSUM</code>和<code>FIL_PAGE_LSN</code>的值进行比较，看是否一致，以此来保证页的完整性。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束机制用来保证数据库中数据的完整性。<br>完整性有以下三种形式：</p><ol><li>实体完整性保证表中有一个主键。</li><li>域完整性保证数据每列的值满足特定的条件，域完整性通过以下几种方式来保证：<ul><li>选择合适的数据类型确保一个数据值满足特定条i教案</li><li>外键约束</li><li>编写触发器</li></ul></li><li>参照完整性保证两张表之间的关系。</li></ol><p>对于InnoDB存储引擎，提供了以下几种约束：</p><ul><li>Primary Key</li><li>Unique Key</li><li>Foreign Key</li><li>Default</li><li>NOT NULL</li></ul><p>约束和索引的区别：约束是一个逻辑上的概念，用来保证数据的完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库上还代表着物理存储的方式。</p><h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>分区功能并不是在存储引擎层完成的，不是只有InnoDB存储引擎支持分区，MySQL5.1添加了对分区的支持，分区的过程就是将一个表或索引分解为多个更小的、更可管理的部分。从逻辑上讲，只有一个表或一个索引，但是物理上这个表或索引可能由数十个物理分区组成，每个分区都是独立的对象。</p><p>MySQL支持的分区类型为水平分（将同一表中不同行的记录分配到不同的物理文件中），不支持垂直分（将同一表中不同列的记录分配到不同的物理文件中）。MySQL的分区是局部分区索引，一个分区既存放了数据又存放了索引，而全局分区是指，数据存放在各个分区中，数据的索引放在一个对象中。</p><p>MySQL支持以下几种类型的分区：</p><ul><li>RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区。</li><li>LIST分区：面向离散值的分区。</li><li>HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</li><li>KEY分区：根据MySQL数据库提供的Hash函数进行分区。</li></ul><p>无论哪种分区方式，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。</p><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><p>子分区是在分区的基础上再进行分区，也成为复合分区，MySQL允许在RANGE和LIST分区上再进行HASH和KEY的子分区。<br>子分区需要注意以下几个问题：</p><ul><li>每个子分区的数量必须相同。</li><li>要在一个分区表的任何分区上使用SUBPARTITION来明确定义任何子分区，就必须定义所有的子分区。</li><li>每个SUBPARTITION子句必须包括子分区的一个名字。</li><li>子分区的名字必须是唯一的。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《MySQL技术内幕：InnoDB存储引擎(第二版)》</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL文件种类分析</title>
    <link href="/2020/MySQL/mysql-file/"/>
    <url>/2020/MySQL/mysql-file/</url>
    
    <content type="html"><![CDATA[<h2 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h2><p>当MySQL实例启动，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及部分初始化参数。</p><p>可以通过<code>SHOW VARIABLES</code>查看数据库中所有参数，可以通过<code>LIKE</code>过滤参数名。</p><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>MySQL中参数分为两类：</p><ul><li>动态参数<ul><li>在MySQL实例运行中进行更改。</li></ul></li><li>静态参数<ul><li>在实例的整个生命周期内都不得进行更改。</li></ul></li></ul><p>可以通过set命令对动态参数进行修改，例如<code>SET read_buffer_size=524288</code>。<br>对变量的修改，在这次的实例生命周期内有效，下次此洞MySQL实例还是会读取参数文件。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志对MySQL的启动、运行、关闭过程进行了记录，该文件不仅记录了所有的错误信息，也记录了一些警告信息或正确的信息。</p><p>可以在配置文件中设置存储位置：</p><div class="code-wrapper"><pre><code class="hljs inform7"><span class="hljs-comment">[mysqld]</span>log-error=<span class="hljs-comment">[path/<span class="hljs-comment">[filename]</span>]</span></code></pre></div><p>或通过查询变量来获取错误日志信息：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;log_err%&#x27;</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs log">2020-04-13T03:04:23.391925Z 75 [Note] Aborted connection 75 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:04:23.391954Z 76 [Note] Aborted connection 76 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.802373Z 77 [Note] Aborted connection 77 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.802390Z 82 [Note] Aborted connection 82 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.809111Z 79 [Note] Aborted connection 79 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.809298Z 81 [Note] Aborted connection 81 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.809495Z 80 [Note] Aborted connection 80 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.809647Z 83 [Note] Aborted connection 83 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.818503Z 84 [Note] Aborted connection 84 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.820436Z 85 [Note] Aborted connection 85 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.822052Z 86 [Note] Aborted connection 86 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:08:39.809996Z 78 [Note] Aborted connection 78 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.627802Z 87 [Note] Aborted connection 87 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.627848Z 88 [Note] Aborted connection 88 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.627864Z 89 [Note] Aborted connection 89 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.627891Z 90 [Note] Aborted connection 90 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.627917Z 91 [Note] Aborted connection 91 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.627949Z 92 [Note] Aborted connection 92 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.627994Z 93 [Note] Aborted connection 93 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.628018Z 94 [Note] Aborted connection 94 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.628034Z 95 [Note] Aborted connection 95 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T03:17:12.628055Z 96 [Note] Aborted connection 96 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T05:29:24.573237Z 34 [Note] Aborted connection 34 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T05:29:24.573406Z 35 [Note] Aborted connection 35 to db: &#x27;dev&#x27; user: &#x27;root&#x27; host: &#x27;localhost&#x27; (Got an error reading communication packets)2020-04-13T09:49:37.346162Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 4528ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)2020-04-14T01:35:39.190069Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 43183898ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)2020-04-14T07:30:03.500507Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 9873804ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)2020-04-15T02:39:20.019686Z 0 [Note] InnoDB: page_cleaner: 1000ms intended loop took 46274005ms. The settings might not be optimal. (flushed=0 and evicted=0, during the time.)</code></pre></div><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志可以帮助DBA定位存在查询较慢的SQL语句，从而实现SQL语句层面的优化。可以通过<code>long_query_time</code>来设置慢查询阈值。默认值为10s.<br>默认情况下，MySQL不开启慢查询日志，需要手动将<code>log_slow_queries</code>设置为ON。另一个和慢查询相关的参数<code>log_queries_not_using_indexes</code>，这个参数如果是ON，就会将运行的SQL语句没有使用索引的，记录到慢查询日志中。<br>MySQL 5.6.5中新增一个参数<code>log_throttle_queries_not_using_indexes</code>，用来表示每分钟允许记录到慢查询日志且未使用索引的SQL语句次数。默认为0，表示没有限制。</p><p>如果用户希望得到执行时间最长的10条SQL语句，可以使用<code>mysqldumpslow -s -al -n 10 slow.log</code>。</p><p>InnoSQL加强了对SQL语句的捕获方式，在原版的基础上在慢查询日志上增加了对于逻辑读取和物理读取的统计。逻辑读取是指从磁盘进行IO读取的次数，逻辑读取包含磁盘和缓冲池的读取。可以通过参数<code>long_query_io</code>将超过指定逻辑IO次数的SQL语句记录到慢查询日志中，该值默认为100。为了兼容原MySQL运行方式，增加了参数<code>slow_query_type</code>，用来表示启用慢查询日志的方式，可选值如下：</p><ul><li>0表示不将SQL语句记录到slow log</li><li>1表示根据运行时间将SQL语句记录到slow log</li><li>2表示根据逻辑IO次数将SQL语句记录到slow log</li><li>3表示根据运行时间以及逻辑IO次数将SQL语句记录到slow log</li></ul><h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>通用查询日志用来<strong>记录用户的所有操作</strong> ，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给MySQL数据库服务器的所有 SQL 指令等。默认文件名：主机名.log。</p><div class="code-wrapper"><pre><code class="hljs sql"># 查看日志状态<span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%general%&#x27;</span>;general_logOFFgeneral_log_file<span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span><span class="hljs-number">0</span>deff425ac75.log# 开启通用查询日志<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> general_log<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;# 使用下面的指令刷新MySQL数据目录mysqladmin <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p flush<span class="hljs-operator">-</span>logs</code></pre></div><h3 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h3><p>二进制日志记录了对MySQL执行<strong>更改</strong>的所有操作，不包括SELECT和SHOW这类操作，用于<strong>主从服务器之间的数据同步</strong>。<br>二进制日志包括了执行数据库更改操作的时间等其他额外信息，二进制日志主要有以下几种作用：</p><ul><li><strong>数据恢复</strong>：某些数据的恢复需要二进制日志，例如，一个数据库全备文件恢复后，用户通过二进制日志进行point-in-time的恢复</li><li><strong>数据复制</strong>：通过复制和执行二进制日志使MySQL数据库与另一台salve进行实时同步。</li><li><strong>数据审计</strong>：用户通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击或者其他行为。</li></ul><p>它以<strong>事件形式</strong>记录并保存在<strong>二进制文件</strong>中，通过这些信息可以再现数据更新操作的全过程。</p><div class="code-wrapper"><pre><code class="hljs sql"># 查看和binlog有关的参数<span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;</code></pre></div><p>通过配置参数<code>log-bin[=name]</code>可以启动二进制日志，如果不指定name，则默认名为主机名，后缀名为二进制日志的序列号，所在路径为数据库所在目录。</p><p>二进制日志文件在默认情况没有启动，需要手动指定参数来启动。开启二进制日志对性能下降1%左右。binlog有以下配置参数，含义分别如下：</p><ul><li>max_binlog_size<ul><li>指定了单个二进制日志文件的最大值，如果超过该值，则产生新的二进制日志文件，后缀名+1,MySQL5.0开始默认值为1073741824(1G)</li></ul></li><li>binlog_cache_size<ul><li>当使用事务的引擎（如InnoDB）,所有未提交的二进制日志会被记录到一个缓存中去，等事务提交时将缓存中的日志写入二进制日志文件，缓冲大小由该参数指定，默认为32K，该参数基于会话，一个事务分配一个缓存。</li></ul></li><li>sync_log<ul><li>默认情况下，二进制日志并不是每次写的时候同步到磁盘（缓冲写），因此如果数据库宕机，还会有一部分数据没有写入日志文件。该参数值N，表示每缓冲写多少次就同步到磁盘。默认值为0，设置为1表示不用缓存，直接进行磁盘写，但是有个问题，在COMMIT之前，部分操作已经写入日志，此时宕机，那么下次启动，由于COMMIT未发生，这个事务会被回滚，但是日志文件不能回滚。该问题通过<code>innodb_support_xa</code>设置为1来解决</li></ul></li><li>binlog-do-db&#x2F;binlog-ignore-db<ul><li>表示需要写入或忽略写入哪些库的日志，默认为空，表示需要同步所有库的日志到二进制日志。</li></ul></li><li>log-slave-update<ul><li>如果当前数据库为slave角色，则它不会将从master取得并执行的二进制日志写入自己二进制日志文件，如需写入，设置该参数。</li></ul></li><li>binlog_format<ul><li>影响记录二进制日志的格式，可设置的值有<code>STATEMENT</code>、<code>ROW</code>、<code>MIXED</code></li><li><code>STATEMENT</code>记录的是日志的逻辑SQL语句</li><li><code>ROW</code>记录行更改情况，设置为<code>ROW</code>可以将InnoDB的事务隔离级别基本设为<code>READ_COMMITED</code>，以获得更好的并发性。</li><li><code>MIXED</code>默认使用<code>STATEMENT</code>格式存储，会在一些情况下使用<code>ROW</code>格式存储，可能的情况有：<ul><li>表存储引擎为NDB，</li><li>使用了UUID()、USER()、CURRENT_USER()、FOUND_ROWS()、ROW_COUNT()等不确定函数</li><li>使用了INSERT DELAY语句</li><li>使用用户定义函数</li><li>使用了临时表</li></ul></li><li>通常情况下，采用<code>ROW</code>格式存储，这可以为数据库的恢复和复制带来更好的可靠性，但是会导致文件大小增加</li></ul></li></ul><p>二进制日志文件采用<code>mysqlbinlog</code>查看日志内容。</p><div class="code-wrapper"><pre><code class="hljs sql">mysqlbinlog <span class="hljs-comment">--no-defaults --help</span></code></pre></div><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><div class="code-wrapper"><pre><code class="hljs sql">mysqlbinlog [option] filename<span class="hljs-operator">|</span>mysql –uuser <span class="hljs-operator">-</span>ppass;</code></pre></div><p>option中有两对较为重要参数：</p><ul><li>–start-date 和 –stop-date ：可以指定恢复数据库的起始时间点和结束时间点。</li><li>–start-position和–stop-position ：可以指定恢复数据的开始位置和结束位置。</li></ul><h4 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h4><p>MySQL提供了<code>PURGE MASTER LOGS</code>删除指定部分的二进制文件，<code>RESET MASTER</code> 删除所有的二进制日志文 件。</p><div class="code-wrapper"><pre><code class="hljs crmsh">PURGE &#123;<span class="hljs-keyword">MASTER</span> <span class="hljs-title">| BINARY</span>&#125; LOGS TO ‘指定日志文件名’PURGE &#123;<span class="hljs-keyword">MASTER</span> <span class="hljs-title">| BINARY</span>&#125; LOGS BEFORE ‘指定日期’</code></pre></div><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p>事务执行过程中，先把日志写到<code>binlog cache</code>，提交后将<code>binlog cache</code>写到binlog文件中，OS会给每个事务线程分配一块内存作为<code>binlog cache</code>。使用<code>sync_binlog</code>来控制write和fsync的时机。取值如下：</p><ul><li>0：默认值，每次提交事务都write，由OS控制<code>fsync</code>来将cache数据写入磁盘。</li><li>1：每次提交事务后，都执行fsync进行刷盘。</li><li>N：N &gt; 1，表示每次提交后都write，积累N个事务再进行fsync。</li></ul><h4 id="与redo-log对比"><a href="#与redo-log对比" class="headerlink" title="与redo log对比"></a>与redo log对比</h4><ul><li>redo log：物理日志，记录在某个数据页上做了什么修改，属于InnoDB存储引擎层产生。实现崩溃恢复的功能。</li><li>binlog：逻辑日志，记录语句的原始逻辑，属于MySQL Server层。实现集群架构的数据一致性。</li></ul><h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>在更新过程中，会记录<code>redo log</code>和<code>binlog</code>，以事务为单位，redo log在事务执行过程中不断写入，而binlog在提交事务时才写入，写入时机不一样，MySQL使用<strong>二阶段提交</strong>来解决两个日志的逻辑一致的问题。</p><h3 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h3><p>该日志只存在于主从架构中的Slave节点中，Slave从Master中读取binlog，并存储于自己的<code>relay log</code>，使用线程读取<code>relay log</code>进行<strong>数据同步</strong>的任务。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h3><p>在UNIX系统下本地连接MySQL可以采用UNIX域套接字方式连接，一般位于<code>/tmp</code>目录下，名为<code>mysql.sock</code>。</p><h3 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h3><p>当MySQL实例启动后，会将自己的进程ID写入一个文件，该文件文件名为<code>主机名.pid</code></p><h3 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h3><p>MySQL数据的存储时根据表进行的，每个表都有对应的文件，frm后缀的文件记录了该表的表结构定义，frm文件哈用来存放视图的定义。</p><h3 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h3><h4 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h4><p>InnoDB采用将存储的数据俺好表空间进行存放的设计，在默认配置下会有一个初始大小为10MB，名为ibdata1的文件，该文件就是默认的表空间文件，可以通过<code>innodb_data_file_path</code>进行设置。如果设置了<code>innodb_file_per_table</code>，则可以将每个基于InnoDB引擎的表产生一个独立表空间。命名规则为<code>表名.ibd</code>。</p><h4 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h4><p>在默认情况下，InnoDB存储引擎的目录下会有名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，这就是重做日志文件（redo log file）。它们记录了对于InnoDB存储引擎的事务日志。当数据库因为掉电导致实例失败，InnoDB存储引擎可以通过重做日志恢复到掉电前的时刻，来保证数据完整性。</p><p>每个InnoDB存储引擎至少有一个重做日志组，每个文件组下至少有两个重做日志文件，设置多个日志组，可以提高可靠性。</p><p>以下参数影响重做日志的属性：</p><ul><li>innodb_log_file_size<ul><li>指定每个重做日志文件的大小。</li></ul></li><li>innodb_log_files_in_group<ul><li>指定了日志文件组中重做日志文件的数量，默认为2</li></ul></li><li>innodb_mirrored_log_groups<ul><li>指定了日志镜像文件组的数量，默认为1，表示只有一个日志文件组，没有镜像</li></ul></li><li>innodb_log_group_home_dir<ul><li>指定了日志文件所在的路径，默认为<code>./</code></li></ul></li></ul><p>重做日志的大小设置对于InnoDB存储引擎的性能有着很大的影响，过大的话再恢复的时候需要很长时间，过小的话，会导致一个事务的日志需要切换重做日志文件与频繁地发生<code>async checkpoint</code>。</p><p>重做日志文件与二进制日志文件的区别：</p><ol><li>二进制日志会记录所有于MySQL数据库有关的日志记录，包括所有引擎的日志，而重做日志文件只存储和InnoDB相关的事务日志。</li><li>二进制日志文件记录的是关于一个事务的具体操作内容，重做日志记录的是关于每个页的更改的物理情况。</li><li>写入的时间也不同，二进制日志文件仅在事务提交前进行提交，只写磁盘一次。重做日志在事务期间会不断的写。</li></ol><p>重做日志的条目结构由四部分组成：</p><ul><li>redo_log_type占用1字节，表示重做日志的类型。</li><li>space表示表空间的ID，采用压缩的方式，占用空间小于4字节</li><li>page_no表示页的偏移量，采用压缩的方式</li><li>redo_log_body表示每个重做日志的数据部分，恢复时需要调用相应的函数进行解析。</li></ul><p>写入重做日志文件不是直接写，而是写入一个日志缓冲，然后按照顺序写入日志文件。流程如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/mysql/file/redo%E8%BF%87%E7%A8%8B.png" alt="重做日志写入过程"></p><p>从缓冲往磁盘写入时，写入最小单位为扇区，也就是512字节，因此可以保证写入是成功的。<br>触发磁盘写的过程由<code>innodb_flush_log_at_trx_commit</code>控制，表示在提交操作时，处理重做日志的方式，共有0，1.2三种取值。</p><ul><li>0：代表提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。</li><li>1：表示在执行commit时间重做日志缓冲同步写道到磁盘</li><li>2：表示间重做日志异步写到磁盘</li></ul><p>为了保证事务的ACID中的持久性，必须将该参数设置为1，也就是每当有事务提交，就必须保证事务都已经写入重做日志文件中。如果数据库发生宕机，可以通过重做日志恢复已经提交的事务，如果设置为0或2，会导致部分事务的丢失。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《MySQL技术内幕：InnoDB存储引擎(第二版)》</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS原理与源码分析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/aqs/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/aqs/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组键的基础框架，它使用了一个int成员变量<strong>state</strong>表示同步状态，通过CLH队列完成获取资源的线程排队工作。</p><p>AQS的主要使用方式是继承，字类通过继承同步器并实现它的抽象方法来管理同步状态。AQS本身只是定义若干同步状态获取和释放的方法提供给字类来实现。</p><p>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节。AQS是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理，线程的排队，等待与唤醒等底层操作。</p><p>AQS定义了两种资源共享的方式：</p><ul><li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock，其中又可分为公平锁和非公平锁：<ul><li>公平锁：线程按照队列的顺序获取锁</li><li>非公平锁：线程无视顺序，去抢锁</li></ul></li><li>Share（共享）：多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。</li></ul><p>AQS的设计是基于模板方法模式的，使用者继承AbstractQueuedSynchronizer并重写指定方法，重写的方法是对同步状态<code>state</code>的获取释放等操作。</p><p>可重写方法如下，arg参数为获取锁的次数。</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">protected boolean tryAcquire(int arg)</td><td align="center">独占方式，尝试获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后通过CAS设置同步状态，成功返回true，失败返回false</td></tr><tr><td align="center">protected boolean tryRelease(int arg)</td><td align="center">独占方式，尝试释放同步状态，成功返回true，失败则返回false</td></tr><tr><td align="center">protected int tryAcquireShared(int arg)</td><td align="center">共享方式，尝试获取同步状态，返回0表示成功，但是没有剩余可用资源，负数表示失败，正数表示成功，并且有剩余资源。</td></tr><tr><td align="center">protected boolean tryReleaseShared(int arg)</td><td align="center">共享方式，尝试释放同步状态，成功返回true，失败返回false</td></tr><tr><td align="center">protected boolean isHeldExclusively()</td><td align="center">判断当前线程是否正在独占资源</td></tr></tbody></table><p>模板方法：</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void acquire(int arg)</td><td align="center">独占锁获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法会调用重写的tryAcquire()方法</td></tr><tr><td align="center">void acquireInterruptibly(int arg)</td><td align="center">与acquire相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列，如果当前线程被中断，该方法会抛出<code>InterruptedException</code>并返回。</td></tr><tr><td align="center">boolean tryAcquireNanos(int arg, long nanosTimeout)</td><td align="center">在acquireInterruptibly的基础上增加了超时限制，如果当前线程在超时时间之内没有获取同步状态，那么将会返回false，获取到了返回true</td></tr><tr><td align="center">void acquireShared(int arg)</td><td align="center">共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占锁获取的主要区别式同一时刻可以有多个线程获取同步状态</td></tr><tr><td align="center">void acquireSharedInterruptibly(int arg)</td><td align="center">与acquireShared相同，响应中断</td></tr><tr><td align="center">boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td><td align="center">加了超时限制</td></tr><tr><td align="center">boolean release(int arg)</td><td align="center">独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中的第一个节点线程唤醒</td></tr><tr><td align="center">boolean releaseShared(int arg)</td><td align="center">共享式的释放同步状态</td></tr><tr><td align="center">Collection<Thread> getQueuedThreads()</td><td align="center">获取等待在同步队列上的线程集合</td></tr></tbody></table><p>模板方法基本分成3类：独占式获取与释放，共享式获取与释放，查询同步队列中的情况。</p><p>AQS整体方法架构可以参照下图（来源：美团技术团队）</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/aqs/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="AQS方法架构"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>核心思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，就将请求资源的线程加入CLH队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的双向队列（FIFO），每一个节点都是等待资源的线程。</p><p>AQS使用一个volatile修饰的int类型的成员变量<code>state</code>来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS方式完成对<code>state</code>的修改。</p><h2 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h2><p><code>AbstractQueuedSynchronizer</code>继承自<code>AbstractOwnableSynchronizer</code>，并且实现<code>Serializable</code>接口。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;</code></pre></div><p><code>AbstractOwnableSynchronizer</code>抽象类可以设置独占资源线程和获取独占资源的线程。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;        <span class="hljs-comment">// 版本序列号</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">3737899427754241961L</span>;    <span class="hljs-comment">// 构造方法</span>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;    <span class="hljs-comment">// 独占模式下的线程</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;        <span class="hljs-comment">// 设置独占线程 </span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> &#123;        exclusiveOwnerThread = thread;    &#125;        <span class="hljs-comment">// 获取独占线程 </span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> exclusiveOwnerThread;    &#125;&#125;</code></pre></div><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>每一个阻塞的线程都会被封装成一个Node节点，放入Sync Queue。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;        <span class="hljs-comment">//线程节点的两种状态，独享模式和共享模式</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">//表示当前节点已取消调度</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;        <span class="hljs-comment">//表示后继节点在等待当前节点唤醒，后继节点入队时，会见前继节点状态更新为SIGNAL</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-comment">//表示节点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取锁。</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;        <span class="hljs-comment">//SHARED模式下，前继节点不仅会唤醒后继节点，也可能唤醒后继的后继节点</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;        <span class="hljs-comment">//当前节点的状态</span>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;        <span class="hljs-comment">//前继节点</span>        <span class="hljs-keyword">volatile</span> Node prev;        <span class="hljs-comment">//后继节点</span>        <span class="hljs-keyword">volatile</span> Node next;        <span class="hljs-comment">//处于当前节点的线程</span>        <span class="hljs-keyword">volatile</span> Thread thread;        <span class="hljs-comment">//指向下一个处于CONDITION状态的节点</span>        Node nextWaiter;        <span class="hljs-comment">//判断是否是SHARED状态</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShared</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">return</span> nextWaiter == SHARED;        &#125;        <span class="hljs-comment">//返回前继节点</span>        <span class="hljs-keyword">final</span> Node <span class="hljs-title function_">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> prev;            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">return</span> p;        &#125;        Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span>        &#125;        Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span>            <span class="hljs-built_in">this</span>.nextWaiter = mode;            <span class="hljs-built_in">this</span>.thread = thread;        &#125;        Node(Thread thread, <span class="hljs-type">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span>            <span class="hljs-built_in">this</span>.waitStatus = waitStatus;            <span class="hljs-built_in">this</span>.thread = thread;        &#125;    &#125;</code></pre></div><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><p>该类实现了<code>Condition</code>接口，该接口定义了如下规范：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Condition</span> &#123;    <span class="hljs-comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;        <span class="hljs-comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span>;        <span class="hljs-comment">//等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 </span>    <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;        <span class="hljs-comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;        <span class="hljs-comment">// 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException;        <span class="hljs-comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span>;        <span class="hljs-comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;        <span class="hljs-comment">//condition队列的头节点</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;        <span class="hljs-comment">//condition队列的尾节点</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;        <span class="hljs-comment">//构造方法</span>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConditionObject</span><span class="hljs-params">()</span> &#123; &#125;        <span class="hljs-comment">// Internal methods</span>        <span class="hljs-comment">//添加新的waiter到wait队列</span>        <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">//保存尾节点</span>            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;            <span class="hljs-comment">//尾节点不为空，并且尾节点的状态不为CONDITION</span>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;                <span class="hljs-comment">//清除状态为CONDITION的结点</span>                unlinkCancelledWaiters();                t = lastWaiter;            &#125;            <span class="hljs-comment">//将当前线程设置为node，状态为CONDITION</span>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<span class="hljs-comment">//尾节点为空</span>                <span class="hljs-comment">//设置头节点为node</span>                firstWaiter = node;            <span class="hljs-keyword">else</span>                <span class="hljs-comment">//设置尾节点的next指向node</span>                t.nextWaiter = node;            <span class="hljs-comment">//更新condition队列的尾节点</span>            lastWaiter = node;            <span class="hljs-keyword">return</span> node;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Removes and transfers nodes until hit non-cancelled one or</span><span class="hljs-comment">         * null. Split out from signal in part to encourage compilers</span><span class="hljs-comment">         * to inline the case of no waiters.</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> first (non-null) the first node on condition queue</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)                    lastWaiter = <span class="hljs-literal">null</span>;                first.nextWaiter = <span class="hljs-literal">null</span>;            &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;                     (first = firstWaiter) != <span class="hljs-literal">null</span>);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Removes and transfers all nodes.</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> first (non-null) the first node on condition queue</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignalAll</span><span class="hljs-params">(Node first)</span> &#123;            lastWaiter = firstWaiter = <span class="hljs-literal">null</span>;            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;                first.nextWaiter = <span class="hljs-literal">null</span>;                transferForSignal(first);                first = next;            &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Unlinks cancelled waiter nodes from condition queue.</span><span class="hljs-comment">         * Called only while holding lock. This is called when</span><span class="hljs-comment">         * cancellation occurred during condition wait, and upon</span><span class="hljs-comment">         * insertion of a new waiter when lastWaiter is seen to have</span><span class="hljs-comment">         * been cancelled. This method is needed to avoid garbage</span><span class="hljs-comment">         * retention in the absence of signals. So even though it may</span><span class="hljs-comment">         * require a full traversal, it comes into play only when</span><span class="hljs-comment">         * timeouts or cancellations occur in the absence of</span><span class="hljs-comment">         * signals. It traverses all nodes rather than stopping at a</span><span class="hljs-comment">         * particular target to unlink all pointers to garbage nodes</span><span class="hljs-comment">         * without requiring many re-traversals during cancellation</span><span class="hljs-comment">         * storms.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;            <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;                <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;                    t.nextWaiter = <span class="hljs-literal">null</span>;                    <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)                        firstWaiter = next;                    <span class="hljs-keyword">else</span>                        trail.nextWaiter = next;                    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)                        lastWaiter = trail;                &#125;                <span class="hljs-keyword">else</span>                    trail = t;                t = next;            &#125;        &#125;        <span class="hljs-comment">// public methods</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Moves the longest-waiting thread, if one exists, from the</span><span class="hljs-comment">         * wait queue for this condition to the wait queue for the</span><span class="hljs-comment">         * owning lock.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><span class="hljs-comment">         *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (!isHeldExclusively())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();            <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;            <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)                doSignal(first);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Moves all threads from the wait queue for this condition to</span><span class="hljs-comment">         * the wait queue for the owning lock.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><span class="hljs-comment">         *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (!isHeldExclusively())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();            <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;            <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)                doSignalAll(first);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Implements uninterruptible condition wait.</span><span class="hljs-comment">         * &lt;ol&gt;</span><span class="hljs-comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="hljs-doctag">@link</span> #getState&#125;.</span><span class="hljs-comment">         * &lt;li&gt; Invoke &#123;<span class="hljs-doctag">@link</span> #release&#125; with saved state as argument,</span><span class="hljs-comment">         *      throwing IllegalMonitorStateException if it fails.</span><span class="hljs-comment">         * &lt;li&gt; Block until signalled.</span><span class="hljs-comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span><span class="hljs-comment">         *      &#123;<span class="hljs-doctag">@link</span> #acquire&#125; with saved state as argument.</span><span class="hljs-comment">         * &lt;/ol&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;                LockSupport.park(<span class="hljs-built_in">this</span>);                <span class="hljs-keyword">if</span> (Thread.interrupted())                    interrupted = <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)                selfInterrupt();        &#125;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * For interruptible waits, we need to track whether to throw</span><span class="hljs-comment">         * InterruptedException, if interrupted while blocked on</span><span class="hljs-comment">         * condition, versus reinterrupt current thread, if</span><span class="hljs-comment">         * interrupted while blocked waiting to re-acquire.</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">/** Mode meaning to reinterrupt on exit from wait */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REINTERRUPT</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;        <span class="hljs-comment">/** Mode meaning to throw InterruptedException on exit from wait */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THROW_IE</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Checks for interrupt, returning THROW_IE if interrupted</span><span class="hljs-comment">         * before signalled, REINTERRUPT if after signalled, or</span><span class="hljs-comment">         * 0 if not interrupted.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;            <span class="hljs-keyword">return</span> Thread.interrupted() ?                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :                <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Throws InterruptedException, reinterrupts current thread, or</span><span class="hljs-comment">         * does nothing, depending on mode.</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span>            <span class="hljs-keyword">throws</span> InterruptedException &#123;            <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)                selfInterrupt();        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Implements interruptible condition wait.</span><span class="hljs-comment">         * &lt;ol&gt;</span><span class="hljs-comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span><span class="hljs-comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="hljs-doctag">@link</span> #getState&#125;.</span><span class="hljs-comment">         * &lt;li&gt; Invoke &#123;<span class="hljs-doctag">@link</span> #release&#125; with saved state as argument,</span><span class="hljs-comment">         *      throwing IllegalMonitorStateException if it fails.</span><span class="hljs-comment">         * &lt;li&gt; Block until signalled or interrupted.</span><span class="hljs-comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span><span class="hljs-comment">         *      &#123;<span class="hljs-doctag">@link</span> #acquire&#125; with saved state as argument.</span><span class="hljs-comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span><span class="hljs-comment">         * &lt;/ol&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;            <span class="hljs-keyword">if</span> (Thread.interrupted())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;                LockSupport.park(<span class="hljs-built_in">this</span>);                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)                interruptMode = REINTERRUPT;            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span>                unlinkCancelledWaiters();            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)                reportInterruptAfterWait(interruptMode);        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Implements timed condition wait.</span><span class="hljs-comment">         * &lt;ol&gt;</span><span class="hljs-comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span><span class="hljs-comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="hljs-doctag">@link</span> #getState&#125;.</span><span class="hljs-comment">         * &lt;li&gt; Invoke &#123;<span class="hljs-doctag">@link</span> #release&#125; with saved state as argument,</span><span class="hljs-comment">         *      throwing IllegalMonitorStateException if it fails.</span><span class="hljs-comment">         * &lt;li&gt; Block until signalled, interrupted, or timed out.</span><span class="hljs-comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span><span class="hljs-comment">         *      &#123;<span class="hljs-doctag">@link</span> #acquire&#125; with saved state as argument.</span><span class="hljs-comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span><span class="hljs-comment">         * &lt;/ol&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span>                <span class="hljs-keyword">throws</span> InterruptedException &#123;            <span class="hljs-keyword">if</span> (Thread.interrupted())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;                    transferAfterCancelledWait(node);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)                    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;                nanosTimeout = deadline - System.nanoTime();            &#125;            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)                interruptMode = REINTERRUPT;            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)                unlinkCancelledWaiters();            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)                reportInterruptAfterWait(interruptMode);            <span class="hljs-keyword">return</span> deadline - System.nanoTime();        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Implements absolute timed condition wait.</span><span class="hljs-comment">         * &lt;ol&gt;</span><span class="hljs-comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span><span class="hljs-comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="hljs-doctag">@link</span> #getState&#125;.</span><span class="hljs-comment">         * &lt;li&gt; Invoke &#123;<span class="hljs-doctag">@link</span> #release&#125; with saved state as argument,</span><span class="hljs-comment">         *      throwing IllegalMonitorStateException if it fails.</span><span class="hljs-comment">         * &lt;li&gt; Block until signalled, interrupted, or timed out.</span><span class="hljs-comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span><span class="hljs-comment">         *      &#123;<span class="hljs-doctag">@link</span> #acquire&#125; with saved state as argument.</span><span class="hljs-comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span><span class="hljs-comment">         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span><span class="hljs-comment">         * &lt;/ol&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span>                <span class="hljs-keyword">throws</span> InterruptedException &#123;            <span class="hljs-type">long</span> <span class="hljs-variable">abstime</span> <span class="hljs-operator">=</span> deadline.getTime();            <span class="hljs-keyword">if</span> (Thread.interrupted())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);            <span class="hljs-type">boolean</span> <span class="hljs-variable">timedout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;                <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;                    timedout = transferAfterCancelledWait(node);                    <span class="hljs-keyword">break</span>;                &#125;                LockSupport.parkUntil(<span class="hljs-built_in">this</span>, abstime);                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)                interruptMode = REINTERRUPT;            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)                unlinkCancelledWaiters();            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)                reportInterruptAfterWait(interruptMode);            <span class="hljs-keyword">return</span> !timedout;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Implements timed condition wait.</span><span class="hljs-comment">         * &lt;ol&gt;</span><span class="hljs-comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span><span class="hljs-comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="hljs-doctag">@link</span> #getState&#125;.</span><span class="hljs-comment">         * &lt;li&gt; Invoke &#123;<span class="hljs-doctag">@link</span> #release&#125; with saved state as argument,</span><span class="hljs-comment">         *      throwing IllegalMonitorStateException if it fails.</span><span class="hljs-comment">         * &lt;li&gt; Block until signalled, interrupted, or timed out.</span><span class="hljs-comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span><span class="hljs-comment">         *      &#123;<span class="hljs-doctag">@link</span> #acquire&#125; with saved state as argument.</span><span class="hljs-comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span><span class="hljs-comment">         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span><span class="hljs-comment">         * &lt;/ol&gt;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span>                <span class="hljs-keyword">throws</span> InterruptedException &#123;            <span class="hljs-type">long</span> <span class="hljs-variable">nanosTimeout</span> <span class="hljs-operator">=</span> unit.toNanos(time);            <span class="hljs-keyword">if</span> (Thread.interrupted())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;            <span class="hljs-type">boolean</span> <span class="hljs-variable">timedout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;                    timedout = transferAfterCancelledWait(node);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)                    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;                nanosTimeout = deadline - System.nanoTime();            &#125;            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)                interruptMode = REINTERRUPT;            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)                unlinkCancelledWaiters();            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)                reportInterruptAfterWait(interruptMode);            <span class="hljs-keyword">return</span> !timedout;        &#125;        <span class="hljs-comment">//  support for instrumentation</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Returns true if this condition was created by the given</span><span class="hljs-comment">         * synchronization object.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if owned</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOwnedBy</span><span class="hljs-params">(AbstractQueuedSynchronizer sync)</span> &#123;            <span class="hljs-keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Queries whether any threads are waiting on this condition.</span><span class="hljs-comment">         * Implements &#123;<span class="hljs-doctag">@link</span> AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if there are any waiting threads</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><span class="hljs-comment">         *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasWaiters</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (!isHeldExclusively())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;                <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION)                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Returns an estimate of the number of threads waiting on</span><span class="hljs-comment">         * this condition.</span><span class="hljs-comment">         * Implements &#123;<span class="hljs-doctag">@link</span> AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> the estimated number of waiting threads</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><span class="hljs-comment">         *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWaitQueueLength</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (!isHeldExclusively())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;                <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION)                    ++n;            &#125;            <span class="hljs-keyword">return</span> n;        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Returns a collection containing those threads that may be</span><span class="hljs-comment">         * waiting on this Condition.</span><span class="hljs-comment">         * Implements &#123;<span class="hljs-doctag">@link</span> AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> the collection of threads</span><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><span class="hljs-comment">         *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title function_">getWaitingThreads</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">if</span> (!isHeldExclusively())                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();            ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Thread&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;                <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION) &#123;                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)                        list.add(t);                &#125;            &#125;            <span class="hljs-keyword">return</span> list;        &#125;    &#125;</code></pre></div><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>AQS中有一个state字段，为同步状态，用volatile修饰。AQS中提供了几个访问该字段的方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//返回当前state</span>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;       <span class="hljs-keyword">return</span> state;   &#125;<span class="hljs-comment">//设置state</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;       state = newState;   &#125;<span class="hljs-comment">//CAS方式更新state</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;       <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);   &#125;</code></pre></div><p>可以通过修改<code>state</code>字段来实现独占模式和共享模式。</p><ul><li>独占模式下只能有一个线程进入。<ol><li>初始化<code>state</code>为0</li><li>线程A申请独占操作</li><li>判断<code>state</code>是否为0</li><li>如果不为0，则线程A阻塞</li><li>为0则设置<code>state</code>为1，表示独占</li></ol></li><li>共享模式下可以有多个线程进入<ol><li>初始化<code>state = n</code></li><li>线程A,B,C,D进行共享操作</li><li>判断<code>state</code>是否大于0</li><li>不大于0则线程阻塞</li><li>大于0则进行CAS自减</li></ol></li></ul><h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//头节点</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;尾节点<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<span class="hljs-comment">//state</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<span class="hljs-comment">//unsafe</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<span class="hljs-comment">//通过内存偏移地址来修改变量值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> stateOffset;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> headOffset;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> tailOffset;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> waitStatusOffset;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> nextOffset;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">spinForTimeoutThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<span class="hljs-comment">//获取各个变量的内存偏移地址</span><span class="hljs-keyword">static</span> &#123;    <span class="hljs-keyword">try</span> &#123;        stateOffset = unsafe.objectFieldOffset            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>));        headOffset = unsafe.objectFieldOffset            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;head&quot;</span>));        tailOffset = unsafe.objectFieldOffset            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));        waitStatusOffset = unsafe.objectFieldOffset            (Node.class.getDeclaredField(<span class="hljs-string">&quot;waitStatus&quot;</span>));        nextOffset = unsafe.objectFieldOffset            (Node.class.getDeclaredField(<span class="hljs-string">&quot;next&quot;</span>));    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;&#125;</code></pre></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>protected</code>修饰，供子类调用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractQueuedSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;</code></pre></div><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>独占模式下获取共享资源，如果当前线程获取共享资源成功，则由该方法返回，否则，将会进入同步队列等待，直到获取资源为止，整个过程忽略中断。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))           selfInterrupt();   &#125;</code></pre></div><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><p>尝试去获取独占资源，如果获取成功，直接返回true，否则返回false。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();   &#125;</code></pre></div><p>在AQS中只是定义一个接口，具体的资源获取和释放方式交给自定义的同步器去实现。</p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>此方法将当前线程加到队尾，并返回当前线程所在的节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;       <span class="hljs-comment">//将当前线程和模式构造成节点</span>       <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);       <span class="hljs-comment">//pred指向尾节点tail</span>       <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;       <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;           <span class="hljs-comment">//新构造的节点加入队尾</span>           node.prev = pred;           <span class="hljs-comment">//比较pred是否为尾节点，是则将尾节点设置为node</span>           <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;               <span class="hljs-comment">//设置尾节点的next</span>               pred.next = node;               <span class="hljs-keyword">return</span> node;           &#125;       &#125;       <span class="hljs-comment">//如果队列为空，使用enq方法入队</span>       enq(node);       <span class="hljs-keyword">return</span> node;   &#125;</code></pre></div><h4 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h4><p><code>enq</code>使用自旋方式来确保节点的插入</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;    <span class="hljs-comment">//CAS自旋，直到成功加入队尾</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;             <span class="hljs-comment">//队列为空时，创建一个空节点作为head节点</span>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))                tail = head;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//尾节点不为空时，将node节点的prev连接到t</span>            node.prev = t;            <span class="hljs-comment">//比较节点t是否为尾节点，若是则将尾节点设置为node</span>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;                <span class="hljs-comment">//设置尾节点的next指向node</span>                t.next = node;                <span class="hljs-keyword">return</span> t;            &#125;        &#125;    &#125;&#125;</code></pre></div><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>如果执行到此方法，说明该线程获取资源失败，已被放入队列尾部。acquireQueued方法具体流程如下：</p><ol><li>节点进入队尾后，判断如果前驱节点是头节点就尝试获取资源，如果成功，直接返回</li><li>否则就通过shouldParkAfterFailedAcquire判断前驱节点状态是否为SIGNAL，是则park当前节点，否则不进行park操作。</li><li>如果park了当前线程，之后某个线程对本线程的unpark后，本线程会被唤醒，将</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-comment">//标记是否成功拿到锁</span>       <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//标记是否被中断</span>           <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;           <span class="hljs-comment">//自旋</span>           <span class="hljs-keyword">for</span> (;;) &#123;               <span class="hljs-comment">//定义p为该节点的前驱节点</span>               <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();               <span class="hljs-comment">//如果前驱节点是head，并且成功获得锁</span>               <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                   <span class="hljs-comment">//将头结点设置为当前节点</span>                   setHead(node);                   p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>                   <span class="hljs-comment">//成功获取锁</span>                   failed = <span class="hljs-literal">false</span>;                   <span class="hljs-comment">//返回等待过程中是否被中断过</span>                   <span class="hljs-keyword">return</span> interrupted;               &#125;               <span class="hljs-comment">//获取资源失败就通过shouldParkAfterFailedAcquire方法判断节点状态是否为SIGNAL</span>               <span class="hljs-comment">//如果是SIGNAL状态，执行parkAndCheckInterrupt方法挂起线程，如果被唤醒，检查是否被中断</span>               <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                   parkAndCheckInterrupt())                   <span class="hljs-comment">//是中断的话，将中断标志设置为true</span>                   interrupted = <span class="hljs-literal">true</span>;           &#125;       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-comment">//如果获取资源失败，就取消节点在队列中的等待</span>           <span class="hljs-keyword">if</span> (failed)               cancelAcquire(node);       &#125;   &#125;</code></pre></div><h5 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h5><p>此方法用于检查状态，检查是否进入SIGNAL状态。只有当前节点的前驱节点的状态为<code>SIGNAL</code>时，才对该节点内部线程进行<code>park</code>操作。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;    <span class="hljs-comment">//定义pred节点的状态</span>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)            <span class="hljs-comment">//表示pred节点处于SIGNAL状态，可以进行park操作</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//CANCELLED状态，表示获取锁的请求取消</span>            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-comment">//如果前驱节点放弃了请求，就一直往前找到正常等待状态的节点</span>                node.prev = pred = pred.prev;            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);            <span class="hljs-comment">//改变pred的next域</span>            pred.next = node;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果前驱节点正常，就把前驱节点地状态设置为SIGNAL</span>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        &#125;        <span class="hljs-comment">//不能进行park操作</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;</code></pre></div><h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h5><p>此方法主要用于挂起当前线程，并返回中断标志。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//调用park方法使线程进入waiting状态</span>        LockSupport.park(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">//如果被唤醒，检查是否是被中断，并清除中断标记位</span>        <span class="hljs-keyword">return</span> Thread.interrupted();    &#125;</code></pre></div><h4 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h4><p>acquireQueued方法中，获取资源失败执行的方法。主要功能就是取消当前线程对资源的获取，即设置该节点的状态为CANCELLED。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-comment">//过滤空节点</span>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//将该节点中保存的线程信息删除</span>        node.thread = <span class="hljs-literal">null</span>;    <span class="hljs-comment">//定义pred节点为node的前驱节点</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;    <span class="hljs-comment">//通过前驱节点找到不为CANCELLED状态的节点</span>        <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)            node.prev = pred = pred.prev;        <span class="hljs-comment">//过滤后的前驱节点的后继节点</span>        <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;       <span class="hljs-comment">//将node状态设置为CANCELLED</span>        node.waitStatus = Node.CANCELLED;        <span class="hljs-comment">//如果node节点是尾节点，则设置尾节点是pred节点</span>        <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;            <span class="hljs-comment">//将tail的后继节点设置为null</span>            compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//node节点不为尾节点，或者compareAndSet失败</span>            <span class="hljs-type">int</span> ws;            <span class="hljs-comment">//如果pred不是头节点</span>            <span class="hljs-comment">//判断状态是否为SIGNAL，不是的话，将节点状态设置为SIGNAL看是否成功</span>            <span class="hljs-comment">//判断当前节点的线程是否为null</span>            <span class="hljs-keyword">if</span> (pred != head &amp;&amp;                ((ws = pred.waitStatus) == Node.SIGNAL ||                 (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;                pred.thread != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">//当前节点的前驱节点的后继指针指向当前节点的后继节点</span>                <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;                <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)                    compareAndSetNext(pred, predNext, next);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//上述条件不满足，那就唤醒当前节点的后继节点</span>                unparkSuccessor(node);            &#125;            node.next = node; <span class="hljs-comment">// help GC</span>        &#125;    &#125;</code></pre></div><h4 id="acquire小结"><a href="#acquire小结" class="headerlink" title="acquire小结"></a>acquire小结</h4><p>具体流程：</p><ol><li>调用自定义同步器的tryAcquire()方法尝试直接获取资源，如果成功直接返回。</li><li>没有成功就将线程加入等待队列尾部，并标记为独占状态。</li><li>acquireQueued()使在等待队列挂起，有机会（被unpark）会去尝试获取资源，获取到资源直接返回，如果这个过程被中断，就返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的，只有获取资源后自我中断selfInterrupt()。</li></ol><p>acquire的流程也就是<code>ReentrantLock.lock()</code>方法的流程。通过调用<code>acquire(1);</code>实现。</p><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>独占模式下释放共享资源，如果释放资源成功（state &#x3D; 0），它会唤醒同步队列中第一个节点，这也是<code>unlock()</code>的语义。 </p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-comment">//调用tryRelease</span>       <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;           <span class="hljs-comment">//头节点</span>           <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;           <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)               unparkSuccessor(h);           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   &#125;</code></pre></div><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h4><p>和<code>tryAcquire()</code>一样，这个方法需要自定义同步器实现。此方法尝试去释放资源</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();   &#125;</code></pre></div><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h4><p>此方法用于唤醒队列中最前面的非CANCELED状态的线程。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;       <span class="hljs-comment">//判断节点的状态是否为非CANCELLED状态</span>       <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;       <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)           <span class="hljs-comment">//如果是非CANCELLED状态，将状态设置为0</span>           compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<span class="hljs-comment">//定义s为node的后继节点</span>       <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;       <span class="hljs-comment">//判断s是否为空节点或者是否为CANCELLED状态</span>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;           s = <span class="hljs-literal">null</span>;           <span class="hljs-comment">//从尾节点往前找到最前面那个为非CANCELLED状态的线程</span>           <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)               <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)                   s = t;       &#125;       <span class="hljs-comment">//如果该节点不为空，就unpark当前节点</span>       <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)           LockSupport.unpark(s.thread);   &#125;</code></pre></div><h4 id="release小结"><a href="#release小结" class="headerlink" title="release小结"></a>release小结</h4><p>release()在独占模式下释放资源。如果release时出现异常，没有unpark队列中的其他节点。会导致线程永远挂起，无法被唤醒。</p><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><p>共享模式的获取共享资源的入口，如果当前线程未获取到共享资源，将会进入同步队列等待。  </p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)           doAcquireShared(arg);   &#125;</code></pre></div><p>流程：</p><ol><li><p>tryAcquireShared()尝试获取资源，成功则直接返回；</p></li><li><p>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</p></li></ol><h4 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4><p>tryAcquireShared由自定义同步器实现。在acquireShared方法中，已经将返回值的语义定义好了，负值表示获取失败，0代表获取成功，但是没有剩余资源，正数表示获取成功，还有剩余资源，其它线程还可以获取。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();   &#125;</code></pre></div><h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h4><p>此方法将当前线程加入等待队列尾部进行休息，直到其他线程释放资源唤醒自己。自己拿到资源后才返回。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-comment">//加入队列尾部</span>       <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);       <span class="hljs-comment">//是否获取资源成功标记</span>       <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//是否被中断标记</span>           <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;           <span class="hljs-keyword">for</span> (;;) &#123;               <span class="hljs-comment">//前驱节点</span>               <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();               <span class="hljs-comment">//如果前驱节点是头节点</span>               <span class="hljs-keyword">if</span> (p == head) &#123;                   <span class="hljs-comment">//尝试获取资源</span>                   <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);                   <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;                       <span class="hljs-comment">//获取成功，将head指向node节点</span>                       setHeadAndPropagate(node, r);                       p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>                       <span class="hljs-comment">//如果等待过程中被中断</span>                       <span class="hljs-keyword">if</span> (interrupted)                           <span class="hljs-comment">//自我中断</span>                           selfInterrupt();                       failed = <span class="hljs-literal">false</span>;                       <span class="hljs-keyword">return</span>;                   &#125;               &#125;               <span class="hljs-comment">//进入park状态，等待被unpark</span>               <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                   parkAndCheckInterrupt())                   interrupted = <span class="hljs-literal">true</span>;           &#125;       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">if</span> (failed)               cancelAcquire(node);       &#125;   &#125;</code></pre></div><h4 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;       <span class="hljs-comment">//保存老的头节点</span>       <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;       <span class="hljs-comment">//将头节点指向自己</span>       setHead(node);       <span class="hljs-comment">//传进来的propagate为线程执行tryAcquireShared的返回值</span>       <span class="hljs-comment">//大于0代表获取资源成功，并且还有剩余资源</span>       <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||           (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;           <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;           <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())               doReleaseShared();       &#125;   &#125;</code></pre></div><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><p>共享模式下的线程释放共享资源的顶层入口。释放掉资源，唤醒后继节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;       <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;           doReleaseShared();           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   &#125;</code></pre></div><h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h4><p>此方法用于唤醒后继节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;              <span class="hljs-keyword">for</span> (;;) &#123;           <span class="hljs-comment">//保存头节点</span>           <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;           <span class="hljs-comment">//如果头节点不为空，并且不是尾节点</span>           <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;               <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;               <span class="hljs-comment">//判断头节点的线程状态是否为SIGNAL</span>               <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;                   <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                       <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">//唤醒后继节点</span>                   unparkSuccessor(h);               &#125;               <span class="hljs-comment">//不是SIGNAL，就继续自旋</span>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                        !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))                   <span class="hljs-keyword">continue</span>;                          &#125;           <span class="hljs-comment">//如果是头节点就直接跳出</span>           <span class="hljs-keyword">if</span> (h == head)               <span class="hljs-keyword">break</span>;       &#125;   &#125;</code></pre></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>AQS作为并发编程的底层框架，为其它很多同步工具提供了很多应用场景。大致如表所述：</p><table><thead><tr><th align="center">同步工具</th><th>与AQS的关联</th></tr></thead><tbody><tr><td align="center">ReentrantLock</td><td>使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td align="center">Semaphore</td><td>使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td align="center">CountDownLatch</td><td>使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td align="center">ReentrantReadWriteLock</td><td>使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td align="center">ThreadPoolExecutor</td><td>Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p><p>《Java并发编程的艺术》</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析Java中的锁</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/java-lock/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/java-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>锁是用来控制多个线程访问共享资源的方式，在Lock接口出现之前，Java是靠synchronized关键字实现锁功能的。而Java 1.5之后，并发包中新增了Lock接口与其实现类用来实现锁功能，只是需要手动获取释放锁，虽然它缺少了同步关键字隐式获取释放的便捷性，但却拥有了可操作性，可中断的获取锁以及超时获取锁等功能。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Java中会按照是否有某一特性来定义锁，下图通过各种特性对锁进行分类：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/lock/Java%E7%9A%84%E9%94%81.png" alt="Java中的锁"></p><h3 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁 &#x2F; 乐观锁"></a>悲观锁 &#x2F; 乐观锁</h3><p>这两种锁不是具体类型的锁，体现了看待线程同步的角度，再Java和数据库中都有此概念对应的实际应用。</p><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候，一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，在Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据的时候，不会有其他线程修改数据，所以不会添加锁，只是在更新数据的时候，去判断之前有没有别的线程更新了数据，如果没有被更新，当前线程将自己修改的数据成功写入。如果数据已被其他线程更新。则根据不同的实现方式执行不同的操作（报错或自动重试）。</p><p>乐观锁在Java中是通过无锁编程来实现，最常采用是CAS算法，Java原子类中的递增就是通过CAS自旋来实现的。</p><p>悲观锁适合写操作多的场景，先加锁可以保证数据准确性。</p><p>乐观锁适合读操作多的场景，不加锁能够提高性能。</p><h3 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁 &#x2F; 适应性自旋锁"></a>自旋锁 &#x2F; 适应性自旋锁</h3><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而实采用循环的方式去获取锁，这样做的好处是减少线程上下文切换的消耗。</p><p>但是自旋锁本身是有缺点的，它不能代替阻塞，自旋虽然避免了上下文切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待的效果很好，但是如果锁占用时间过长，自旋只会白白浪费处理器资源。所以自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，通过**-XX:PreBlockSpin**修改）没有成功获得锁，就挂起线程，停止自旋。</p><p>自旋锁的实现原理是CAS算法。自旋锁在JDK 1.4.2引入，使用**-XX:UseSpinning**开启，JDK 6开始默认开启，并且引入了自适应的自旋锁。</p><p>自适应意味着自旋的时间不再固定，而实由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么JVM会认为这次自选也是很有可能再次成功，进而它将自旋等待持续更长的时间。如果某个锁自旋很少成功获得，那么就会直接省略掉自旋过程，直接阻塞线程。</p><p>在自旋锁中，有三种常见的锁形式：TicketLock、CLHlock、MCSlock</p><h3 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 &#x2F; 偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁"></a>无锁 &#x2F; 偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁</h3><p>这四种指锁的状态，并且是针对<code>Synchronized</code>关键字，是通过<code>Mark Word</code>中的字段表明的。</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点是修改操作在循环内进行，线程会不断尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。CAS原理就是无锁的实现。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程就会自动获得锁，降低获得锁的代价。</p><p>当一个线程通过同步代码块获得锁的时候，会在<code>Mark Word</code>中存储锁偏向的线程ID。在线程进入或退出同步代码块时不再通过CAS操作来加锁解锁，而是检查<code>Mark Word</code>中是否存储着指向当前线程的偏向锁，引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁的执行，因为轻量级锁较偏向锁消耗性能。</p><p>偏向锁只有遇到其他线程竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动释放偏向锁。</p><p>偏向锁在JDK 6以后是默认启用的，可以通过<code>-XX:UseBiasedLocking=false</code>关闭，关闭之后，程序默认进入轻量级锁状态。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程通过自旋的方式尝试获取锁，不会阻塞。从而提高性能。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>若当前只有一个等待线程，则该线程通过自旋进行等待，但是当自旋超过一定次数，或是一个线程在持有锁，一个在自旋，又有第三个线程访问时，轻量级锁升级为重量级锁。</p><p>综上，偏向锁通过对比<code>Mark Word</code>解决加锁问题，避免执行CAS操作，而轻量级锁通过CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒影响性能。重量级锁将除了拥有锁的线程以外所有线程都阻塞。</p><h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 &#x2F; 非公平锁"></a>公平锁 &#x2F; 非公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列进行排序，队列中第一个线程才能获得锁。</p><p>公平锁的优点时等待的线程不会饿死，缺点是整体吞吐效率相对非公平锁较低，等待队列中除第一个线程以外所有线程都阻塞，CPU唤醒阻塞线程的开销较非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获得锁，获得不到才会进入等待队列中等待。如果此时锁刚好可用，那么线程可以无需阻塞直接获取到锁。非公平锁的优点是可以减少唤醒线程的开销，整体吞吐效率高，因为线程有几率不阻塞直接获得锁，缺点是处于等待队列的线程可能会饿死，或者等待很久才能获得锁。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁又称为递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自当获得锁（前提是锁对象是同一个对象），不会因为之前获取过还没释放而阻塞，Java中<code>ReentrantLock</code>和<code>Synchronized</code>都是可重入锁，可重入锁的一个优点就是可一定程度避免死锁。</p><p>下面是一个可重入锁的一个案例。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setA</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;Thread.sleep(<span class="hljs-number">1000</span>);setB();&#125;<span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setB</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125;</code></pre></div><h4 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁 &#x2F; 共享锁"></a>独享锁 &#x2F; 共享锁</h4><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有，如果线程T对数据A加上独享锁之后，则其他线程不再对A加任何类型的锁，获得独享锁的数据即能读数据又能修改数据。</p><p>共享锁是指该锁可被多个线程所持有，如果线程T对数据A加上共享锁之后，则其他线程只能对A加共享锁，而不能加独享锁，获得到共享锁的线程只能读数据，而不能修改数据。</p><p>独享锁和共享锁通过AQS实现。通过实现不同的方法来实现独享或共享。在Java中，<code>ReentrantLock</code>、<code>Synchronized</code>和<code>ReadWriteLock</code>都是独享锁。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java并发编程的艺术》</p><p><a href="https://www.cnblogs.com/qifengshi/p/6831055.html">Java中的锁分类</a></p><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存模型解析</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>并发编程中，需要处理两个关键问题：</p><ol><li>线程之间如何通信</li><li>线程之间如何同步</li></ol><p>通信指线程之间以何种机制来交换信息，线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p><p>同步指程序中用于控制不同线程间操作发生相对顺序的机制。</p><p>Java采用的是共享内存模型，Java线程之间的通信由Java内存模型（JMM）控制。Java内存模型的主要目的是定义程序中各种变量的访问规则。</p><h2 id="主内存和本地内存"><a href="#主内存和本地内存" class="headerlink" title="主内存和本地内存"></a>主内存和本地内存</h2><p>JMM规定了线程之间共享变量存储在主内存中，每个线程都有私有的本地内存，本地内存存储了共享变量的副本，Java内存模型的示意图如图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/JMM/IMG_0043.PNG" alt="Java内存模型抽象结构"></p><p>从图来看，线程A和线程B之间要通信的话，会进行以下操作：</p><ol><li>线程A把本地内存中更新过的共享变量刷新到主内存中。</li><li>线程B去主内存中读取线程A之前更新的变量。</li></ol><h3 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h3><p>关于如何将一个变量从主内存拷贝到本地内存中，JMM定义了以下八种操作来完成，JVM必须保证每种操作是原子性的。</p><ul><li>lock：作用于主内存的变量，将一个变量标识为一个线程独占状态。</li><li>unlock：作用于主内存的变量，将处于线程独占状态的变量释放出来。</li><li>read：作用于主内存的变量，将一个变量的值从主内存传输到线程的本地内存中。</li><li>load：作用于本地内存的变量，将read操作得到的变量放入本地内存的变量副本中。</li><li>use：作用于本地内存的变量，将本地内存的一个变量值传递给执行引擎。</li><li>assign：作用于本地内存的变量，它把一个从执行引擎接收到的值赋值给本地内存中的变量。</li><li>store：作用于本地内存的变量，将本地内存的值传送到主内存中</li><li>write：作用于主内存的变量，将store操作得到的变量值放入主内存的变量中。</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序时指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，重排序分为三种类型：</p><ol><li>编译器优化的重排序</li><li>指令并行的重排序，处理器使用指令级并行技术来将多条指令重叠执行。</li><li>内存系统的重排序，由于处理器使用了缓存技术和读&#x2F;写缓冲区技术。</li></ol><p>重排序会导致多线程程序出现内存可见性问题，对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器，JMM要求编译器生成指令序列的时候，插入内存屏障指令来禁止重排序。</p><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖性分三种类型，如下表所示：</p><table><thead><tr><th align="center">名称</th><th align="center">代码实例</th></tr></thead><tbody><tr><td align="center">写后读</td><td align="center">a &#x3D; 1; b &#x3D; a;</td></tr><tr><td align="center">写后写</td><td align="center">a &#x3D; 1; a &#x3D; 2;</td></tr><tr><td align="center">读后写</td><td align="center">a &#x3D; b; b &#x3D; 1;</td></tr></tbody></table><p>上述现象如果执行顺序发生改变，执行结果就会被改变。</p><p>编译器和处理器在重排序时，会遵守数据依赖性原则，不会改变存在依赖关系的两个操作的执行顺序。</p><h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h2><p>JSR-133使用<code>Happens-Before</code>的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在<code>Happens-Before</code>关系。A <code>Happens-Before</code> B 意味着：<strong>A操作的结果对B是可见的</strong>。</p><p>通俗而言，即：A运行完成后数据结果，B都能读取到。</p><p><code>Happens-Before</code>原则如下：</p><ol><li>程序顺序规则：在一个线程内，在程序前面的操作先行发生于后面的操作。</li><li>管程锁规则：一个<code>unlock</code>操作先行发生于后面对同一个锁的<code>lock</code>操作。</li><li>volatile变量规则：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读。</li><li>传递性</li><li>线程<code>start()</code>规则：<code>start()</code>方法调用先行发生于此线程的每一个动作。</li><li>线程<code>join()</code>规则：线程的结束先行发生于<code>join()</code>方法返回。</li><li>线程<code>interrupt()</code>规则：对线程的<code>interrupt()</code>方法的调用先行发生于被中断线程代码检测到中断事件的发生</li><li>对象终结规则：一个对象的初始化完成先行发生于它的<code>finalize()</code>方法的开始。</li></ol><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>共享资源的安全程度按照强弱顺序分为以下五类：</p><ul><li>不可变（Immutable）：一定是线程安全，不需要任何措施进行保护。<ul><li>final修饰的变量</li><li>String</li><li>枚举</li><li>Number部分子类：Long，Double，BigInteger，BigDecimal</li></ul></li><li>绝对线程安全：不需要做任何额外的同步措施。</li><li>相对线程安全：需要保证对这个对象的单独的操作是线程安全的，不需要做额外的保障措施。但是一些特定顺序的连续的调用，需要做同步措施。</li><li>Java中大部分线程安全类属于该类，Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</li><li>线程兼容：指对象本身并不是现成安全的，但是可以通过在调用端正确使用同步手段来保证对象在并发环境中可以安全的使用。<ul><li>Java中大部分类属于线程兼容的，例如：ArrayList、HashMap。</li></ul></li><li>线程对立：无法通过同步手段实现线程安全。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Alibaba Nacos</title>
    <link href="/2020/Spring%20Cloud/spring-cloud-alibaba-nacos/"/>
    <url>/2020/Spring%20Cloud/spring-cloud-alibaba-nacos/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Nacos"><a href="#什么是Nacos" class="headerlink" title="什么是Nacos"></a>什么是Nacos</h2><blockquote><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。<br>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p></blockquote><p>Nacos的关键特性包括：</p><ul><li>服务发现和服务健康监测</li><li>动态配置服务</li><li>动态 DNS 服务</li><li>服务及其元数据管理</li></ul><h2 id="Nacos架构"><a href="#Nacos架构" class="headerlink" title="Nacos架构"></a>Nacos架构</h2><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/nacos1.jpeg" alt="Nacos架构"></p><p>其中Nacos整体分为两大块，分别是<code>Nacos Server</code>和<code>Nacos Console</code>，<code>Nacos Server</code>为核心，其中包括<code>Naming Service</code>，<code>Config Service</code>，<code>Naming Service</code>主要提供服务发现和DNS功能，<code>Config Service</code>相当于Netflix时期的Spring Cloud Config提供的分布式配置中心的功能，使得配置信息在线读取。</p><h2 id="Nacos安装"><a href="#Nacos安装" class="headerlink" title="Nacos安装"></a>Nacos安装</h2><p>这里笔者使用Docker方式安装，具体安装流程可以参照如下：</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/nacos-group/nacos-docker.git<span class="hljs-built_in">cd</span> nacos-docker/exampledocker-compose -f standalone-mysql-5.7.yaml up -d</code></pre></div><p>Nacos 控制台：<a href="http://192.168.252.128:8848/nacos">http://192.168.252.128:8848/nacos</a></p><h2 id="服务注册功能案例"><a href="#服务注册功能案例" class="headerlink" title="服务注册功能案例"></a>服务注册功能案例</h2><ol><li><p>引入Nacos Discovery Starter依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>配置Nacos Server地址与其他信息</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">spring.application.name</span>=service-provider<span class="hljs-attr">server.port</span>=<span class="hljs-number">8081</span><span class="hljs-attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">252.128</span>:<span class="hljs-number">8848</span></code></pre></div></li><li><p>使用 @EnableDiscoveryClient 注解开启服务注册与发现功能</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudAlibabaNacosExampleApplication</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(SpringCloudAlibabaNacosExampleApplication.class, args);    &#125;&#125;</code></pre></div><p>启动应用后，通过Nacos控制台可以看到服务已注册。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/nacos-register.png" alt="Nacos控制台服务注册情况"></p><h2 id="服务发现功能案例"><a href="#服务发现功能案例" class="headerlink" title="服务发现功能案例"></a>服务发现功能案例</h2><ol><li><p>创建Consumer案例，引入Nacos Discovery Starter依赖与Feign依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>填写相关配置</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">spring.application.name</span>=service-consumer<span class="hljs-attr">server.port</span>=<span class="hljs-number">8282</span><span class="hljs-attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">252.128</span>:<span class="hljs-number">8848</span></code></pre></div></li><li><p>添加相关注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudAlibabaNaocsConsumerApplication</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(SpringCloudAlibabaNaocsConsumerApplication.class, args);    &#125;&#125;</code></pre></div></li><li><p>编写通过Feign调用服务代码</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;service-provider&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EchoService</span> &#123;        <span class="hljs-meta">@GetMapping(value = &quot;/echo/&#123;str&#125;&quot;)</span>    String <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;str&quot;)</span> String str)</span>;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> EchoService echoService;    <span class="hljs-meta">@GetMapping(value = &quot;/feign/&#123;str&#125;&quot;)</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">feign</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String str)</span> &#123;        <span class="hljs-keyword">return</span> echoService.echo(str);    &#125;&#125;</code></pre></div><p>通过访问：<a href="http://localhost:8282/feign/xxx">http://localhost:8282/feign/xxx</a></p><p>可以看出，成功通过Feign调用service-provider服务</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/res.png" alt="调用结果"></p><h2 id="负载均衡案例"><a href="#负载均衡案例" class="headerlink" title="负载均衡案例"></a>负载均衡案例</h2><p>首先修改controller代码。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoController</span> &#123;    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String port;    <span class="hljs-meta">@GetMapping(&quot;echo/&#123;str&#125;&quot;)</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String str)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Nacos Discovery &quot;</span> + str + <span class="hljs-string">&quot; from port: &quot;</span> + port;    &#125;&#125;</code></pre></div><p>开启允许多个实例运行的配置：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/run.png" alt="运行多个实例配置"></p><p>将配置文件中运行端口改为8083，Nacos控制台如图所示：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/demo.png" alt="Nacos控制台情况"></p><p>可以看出，provider运行了两个实例。下面通过消费者服务进行服务调用。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/demo1.png" alt="运行结果1"></p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/demo2.png" alt="运行结果2"></p><h2 id="配置中心案例"><a href="#配置中心案例" class="headerlink" title="配置中心案例"></a>配置中心案例</h2><ol><li><p>创建项目，导入Nacos Config Server依赖。添加<code>@EnableDiscoveryClient</code>注解</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>创建配置文件<code>bootstrap.properties</code>，填写如下配置：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">spring.application.name</span>=nacos-config-example<span class="hljs-attr">server.port</span>=<span class="hljs-number">18084</span><span class="hljs-attr">spring.cloud.nacos.config.server-addr</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">252.128</span>:<span class="hljs-number">8848</span></code></pre></div></li><li><p>在Nacos控制台新添加如下配置：<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/config.png" alt="Nacos添加配置"></p></li><li><p>编写Controller代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;    <span class="hljs-meta">@Value(&quot;$&#123;user.id&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String id;    <span class="hljs-meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@GetMapping(&quot;test&quot;)</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id + <span class="hljs-string">&quot;, Hello &quot;</span>+ name;    &#125;&#125;</code></pre></div></li><li><p>访问：<a href="http://localhost:18084/test">http://localhost:18084/test</a><br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/spring-cloud/nacos/res1.png" alt="访问结果"><br>可以看到，通过Nacos配置中心，成功读取到配置文件的内容。</p></li></ol><p>下面列出Nacos的其它配置项：</p><table><thead><tr><th align="left">配置项</th><th align="center">key</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td align="left">服务端地址</td><td align="center">spring.cloud.nacos.discovery.server-addr</td><td></td><td></td></tr><tr><td align="left">服务名</td><td align="center">spring.cloud.nacos.discovery.service</td><td>spring.application.name</td><td></td></tr><tr><td align="left">权重</td><td align="center">spring.cloud.nacos.discovery.weight</td><td>1</td><td>取值范围 1 到 100，数值越大，权重越大</td></tr><tr><td align="left">网卡名</td><td align="center">spring.cloud.nacos.discovery.network-interface</td><td></td><td>当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址</td></tr><tr><td align="left">注册的IP地址</td><td align="center">spring.cloud.nacos.discovery.ip</td><td></td><td>优先级最高</td></tr><tr><td align="left">注册的端口</td><td align="center">spring.cloud.nacos.discovery.port</td><td>-1</td><td>默认情况下不用配置，会自动探测</td></tr><tr><td align="left">命名空间</td><td align="center">spring.cloud.nacos.discovery.namespace</td><td></td><td>常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</td></tr><tr><td align="left">AccessKey</td><td align="center">spring.cloud.nacos.discovery.access-key</td><td></td><td></td></tr><tr><td align="left">SecretKey</td><td align="center">spring.cloud.nacos.discovery.secret-key</td><td></td><td></td></tr><tr><td align="left">Metadata</td><td align="center">spring.cloud.nacos.discovery.metadata</td><td></td><td>使用Map格式配置</td></tr><tr><td align="left">日志文件名</td><td align="center">spring.cloud.nacos.discovery.log-name</td><td></td><td></td></tr><tr><td align="left">接入点</td><td align="center">spring.cloud.nacos.discovery.endpoint</td><td>UTF-8</td><td>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</td></tr><tr><td align="left">是否集成Ribbon</td><td align="center">ribbon.nacos.enabled</td><td>true</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring Cloud</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程基础知识</title>
    <link href="/2020/Java%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/Java%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>操作系统在运行一个程序时，会为其创建一个进程，操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，多个线程共享进程的堆和方法区两块内存空间。</p><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ul><li><p><strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。</strong></p></li><li><p>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</p></li><li><p>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</p></li><li><p>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</p></li></ul><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换是指CPU从一个进程（线程）切换到另一个进程（线程）。<strong>上下文是指某一个时间点CPU寄存器和PC的数据</strong>。</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li>并发：同一时刻有多个任务在运行。</li><li>并行：同一时间有多个任务在运行。</li></ul><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>线程创建方式争议较多，在Oracle官方文档给出的创建方式为两种，分别是继承Thread类和实现Runnable接口。</p><blockquote><p>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of <code>Thread</code>. This subclass should override the <code>run</code> method of class <code>Thread</code>. An instance of the subclass can then be allocated and started. </p><p>The other way to create a thread is to declare a class that implements the <code>Runnable</code> interface. That class then implements the <code>run</code> method. An instance of the class can then be allocated, passed as an argument when creating <code>Thread</code>, and started. </p></blockquote><p>实现Runnable和Callable接口的类只能当作是一个可以在线程中运行的任务，不是真正意义上的线程。</p><p>线程对象在构建的时候需要提供线程所需的属性，如线程所属的线程组，线程优先级，是否守护线程等信息，下面贴出<code>Thread.init()</code>方法。</p><ul><li>g：线程组，指定该线程在哪个线程组下</li><li>target：指定要执行的任务</li><li>name：线程的名称</li><li>acc：用来初始化私有变量<code>inheritedAccessControlContext</code>，<code>exit</code>时会将该变量置为<code>null</code>，用来做线程的权限控制</li><li>inheritThreadLocals：可继承的<code>ThreadLocal</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span><span class="hljs-params">                      <span class="hljs-type">long</span> stackSize, AccessControlContext acc,</span><span class="hljs-params">                      <span class="hljs-type">boolean</span> inheritThreadLocals)</span> &#123;        <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;name cannot be null&quot;</span>);        &#125;<span class="hljs-comment">//设置线程名称</span>        <span class="hljs-built_in">this</span>.name = name;<span class="hljs-comment">//设置当前线程为该线程的父线程</span>        <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> currentThread();            <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">security</span> <span class="hljs-operator">=</span> System.getSecurityManager();        <span class="hljs-keyword">if</span> (g == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">/* Determine if it&#x27;s an applet or not */</span>            <span class="hljs-comment">/* If there is a security manager, ask the security manager</span><span class="hljs-comment">               what to do. */</span>            <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;                g = security.getThreadGroup();            &#125;            <span class="hljs-comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span><span class="hljs-comment">               use the parent thread group. */</span>            <span class="hljs-keyword">if</span> (g == <span class="hljs-literal">null</span>) &#123;                g = parent.getThreadGroup();            &#125;        &#125;        <span class="hljs-comment">/* checkAccess regardless of whether or not threadgroup is</span><span class="hljs-comment">           explicitly passed in. */</span>        g.checkAccess();        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Do we have the required permissions?</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">if</span> (security != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (isCCLOverridden(getClass())) &#123;                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);            &#125;        &#125;        g.addUnstarted();        <span class="hljs-built_in">this</span>.group = g;    <span class="hljs-comment">//将daemon、priority属性设置位父线程的对应属性</span>        <span class="hljs-built_in">this</span>.daemon = parent.isDaemon();        <span class="hljs-built_in">this</span>.priority = parent.getPriority();        <span class="hljs-comment">//设置线程上下文类加载器</span>        <span class="hljs-keyword">if</span> (security == <span class="hljs-literal">null</span> || isCCLOverridden(parent.getClass()))            <span class="hljs-built_in">this</span>.contextClassLoader = parent.getContextClassLoader();        <span class="hljs-keyword">else</span>            <span class="hljs-built_in">this</span>.contextClassLoader = parent.contextClassLoader;        <span class="hljs-built_in">this</span>.inheritedAccessControlContext =                acc != <span class="hljs-literal">null</span> ? acc : AccessController.getContext();        <span class="hljs-built_in">this</span>.target = target;        setPriority(priority);        <span class="hljs-comment">//将父线程的InheritThreadLocal复制过来</span>        <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)            <span class="hljs-built_in">this</span>.inheritableThreadLocals =                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);        <span class="hljs-comment">//设置指定的堆栈大小</span>        <span class="hljs-built_in">this</span>.stackSize = stackSize;        <span class="hljs-comment">//设置线程ID</span>        tid = nextThreadID();    &#125;</code></pre></div><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();        myThread.start();    &#125;</code></pre></div><p>lambda简化代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);        &#125;).start();</code></pre></div><h5 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h5><p><code>Runnable</code>是一个函数式接口。提供了<code>Lambda</code>方式进行简化。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>()).start();    &#125;</code></pre></div><h4 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h4><p><code>Callable</code>与<code>Runnable</code>类似，都是函数式接口，不过<code>Callable</code>提供的接口有返回值。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;&#125;</code></pre></div><p><code>Callable</code>一般配合<code>ExecutorService</code>使用。</p><div class="code-wrapper"><pre><code class="hljs java">&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;</code></pre></div><p>Demo：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableDemo</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();        <span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();        Future&lt;Integer&gt; result = executor.submit(task);        <span class="hljs-comment">// 注意调用get方法会阻塞当前线程，直到得到结果。</span>        <span class="hljs-comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span>        System.out.println(result.get());    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 模拟计算需要一秒</span>        Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;&#125;</code></pre></div><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p><code>Future</code>就是对具体的<code>Runnable</code>或者<code>Callable</code>任务执行结果进行取消，查询是否完成，获取结果。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;    <span class="hljs-comment">//取消任务</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> paramBoolean)</span>;    <span class="hljs-comment">//任务是否被取消</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//是否已经完成</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//用来获取执行结果，产生阻塞，知道任务执行完毕才返回</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;    <span class="hljs-comment">//获取执行结果，指定时间未完成，返回null</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> paramLong, TimeUnit paramTimeUnit)</span>            <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;&#125;</code></pre></div><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p><code>FutureTask</code>实现了<code>Future</code>接口。<code>FutureTask</code>是实现的<code>RunnableFuture</code>接口的，而<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;            Thread.sleep(<span class="hljs-number">1000</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();            FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());            executor.submit(futureTask);            System.out.println(futureTask.get());        &#125;    &#125;</code></pre></div><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p><code>ThreadGroup</code>可以对线程进行批量控制。每个<code>Thread</code>必然属于一个<code>ThreadGroup</code>。创建新线程是不显式指定，默认将父线程所属线程组设置成自己的线程组。</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(Thread.currentThread().getThreadGroup().getName());</code></pre></div><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干个时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配，线程分配到的时间片多少决定线程使用处理器资源的多少，而线程优先级就是决定线程需要多或少分配一些处理器资源的线程属性。</p><p>在<code>Java</code>线程中，通过一个priority来控制优先级，优先级范围从1~10，在线程构建的时候，可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级为5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p><p>Java只是给操作系统一个优先级的<strong>参考值</strong>，线程最终<strong>在操作系统的优先级</strong>是由操作系统的<strong>线程调度算法</strong>决定的。</p><p>可以通过<code>Thread</code>中的<code>setPriority()</code>方法设置线程的优先级</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java线程在运行的生命周期中可能处于6种不同的状态，在给定的时刻，线程只能处于其中的一种状态。</p><table><thead><tr><th align="center">状态名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NEW</td><td align="center">初始状态，线程被构建，但是还没有调用start()方法</td></tr><tr><td align="center">RUNNABLE</td><td align="center">运行状态，Java线程将操作系统中的就绪和运行两种状态统称为运行</td></tr><tr><td align="center">BLOCKED</td><td align="center">阻塞状态，表示线程阻塞</td></tr><tr><td align="center">WAITING</td><td align="center">等待状态，进入该状态表示当前线程需要等待其他线程做出一些动作（通知或中断）</td></tr><tr><td align="center">TIME_WAITING</td><td align="center">限期等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的</td></tr><tr><td align="center">TERMINATED</td><td align="center">终止状态，表示当前线程执行完毕</td></tr></tbody></table><p>Java线程状态转换如图所示：</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/concurrency/IMG_0041.PNG" alt="Java线程状态转换"></p><h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持性线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个JVM种不存在非Daemon线程的时候，JVM将会退出。可以通过<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程。</p><p>在JVM退出时，Daemon线程中的finally块并不一定会执行。因此，在构建Daemon线程时，不能依靠finally块中的内存来确保执行关闭或清理资源的逻辑。</p><ul><li>垃圾回收线程是一种守护线程</li><li>Tomcat中的Acceptor和Poller线程都是守护线程。</li></ul><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作，其他线程通过调用该线程的<code>interrupt()</code>方法对其进行中断操作。</p><p>线程通过检查自身是否被中断来进行响应。线程通过<code>isinterrupted()</code>方法来判断是否被中断，也可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位。</p><p>在许多声明抛出<code>InterruptedException</code>的方法中，在抛出<code>InterruptedException</code>方法之前，JVM会将该线程的中断标识位清除，然后抛出，此时调用<code>isinterrupted()</code>将返回false。</p><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h3><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">notify()</td><td align="center">通知一个在对象的waitSet上等待的线程，使其从wait()方法返回，而返回的前提时该线程获得到了对象的锁</td></tr><tr><td align="center">notifyAll()</td><td align="center">通知所有等待在该对象上的线程</td></tr><tr><td align="center">wait()</td><td align="center">调用该方法的线程进入WAITING状态，<strong>进入waitSet等待</strong>。只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁</td></tr><tr><td align="center">wait(long)</td><td align="center">超时等待一段时间，这里的参数是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回</td></tr><tr><td align="center">wait(long,int)</td><td align="center">对于超时时间更细粒度的控制，可以达到纳秒</td></tr></tbody></table><p>等待&#x2F;通知机制，是指一个线程A调用了对象O的<code>wait()</code>方法进入等待状态，而另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>返回，进而执行后续操作。</p><p>使用等待&#x2F;通知机制需要注意以下细节：</p><ol><li>使用<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>时需要先对调用对象加锁。</li><li>调用<code>wait()</code>方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。</li><li><code>notify()</code>、<code>notifyAll()</code>方法调用后，等待线程依旧不会从<code>wait()</code>返回，需要调用<code>notify()</code>或<code>notifyAll()</code>的线程释放锁之后，等待线程才有机会从<code>wait()</code>返回。</li><li><code>notify()</code>方法将等待队列的一个等待线程从等待队列移到同步队列中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移同步队列，被移动的线程状态由WAITING变为BLOCKED。</li><li>从<code>wait()</code>方法返回的前提是获得了调用对象的锁。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2020/4/4 21:07</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>：</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">Thread</span> <span class="hljs-variable">waitThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wait</span>(),<span class="hljs-string">&quot;waitThread&quot;</span>);        waitThread.start();        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        <span class="hljs-type">Thread</span> <span class="hljs-variable">notifyThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Notify</span>(),<span class="hljs-string">&quot;notifyThread&quot;</span>);        notifyThread.start();    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wait</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">//加锁，拥有lock的监视器</span>            <span class="hljs-keyword">synchronized</span> (lock)&#123;                <span class="hljs-comment">//当条件不满足时，继续wait，同时释放了lock的锁</span>                <span class="hljs-keyword">while</span> (flag)&#123;                    <span class="hljs-keyword">try</span> &#123;                        System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;flag is true. wait @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));                        lock.wait();                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;                    &#125;                &#125;                <span class="hljs-comment">//条件满足时，完成工作</span>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;flag is false, running @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));            &#125;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Notify</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-comment">//加锁</span>            <span class="hljs-keyword">synchronized</span> (lock)&#123;                <span class="hljs-comment">//获取lock的锁，然后进行通知，通知时不会释放lock的锁</span>                <span class="hljs-comment">//直到当前线程释放了lock后，waitThread才能从wait方法返回</span>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;hold lock, notify @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));                lock.notifyAll();                flag = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-comment">//再次加锁</span>            <span class="hljs-keyword">synchronized</span> (lock)&#123;                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;hold lock again,sleep @&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5000</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Thread</span>[waitThread,<span class="hljs-number">5</span>,main]flag is true. wait @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">08</span><span class="hljs-attribute">Thread</span>[notifyThread,<span class="hljs-number">5</span>,main]hold lock, notify @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">09</span><span class="hljs-attribute">Thread</span>[notifyThread,<span class="hljs-number">5</span>,main]hold lock again,sleep @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">14</span><span class="hljs-attribute">Thread</span>[waitThread,<span class="hljs-number">5</span>,main]flag is false, running @<span class="hljs-number">21</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span></code></pre></div><p>WaitThread首先获取了对象的锁，然后调用对象的<code>wait()</code>方法，从而放弃了锁并进入了对象的等待队列<code>WaitQueue</code>，进入等待状态，由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用了对象的<code>notify()</code>方法，将WaitThread从<code>WaitQueue</code>移到<code>SynchronizedQueue</code>中，此时WaitThread的状态变为阻塞状态，NotifyThread释放了锁之后，WaitThread再次获取到锁并从<code>wait()</code>方法返回继续执行。</p><p>本例可以提炼出等待&#x2F;通知的经典范式，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。</p><p>消费者遵循如下原则：</p><ol><li>获取对象的锁</li><li>如果条件不满足，那么调用对象的<code>wait()</code>方法，被通知仍要检查条件。</li><li>条件满足则执行对应的逻辑。</li></ol><p>对应伪代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象)&#123;    <span class="hljs-keyword">while</span>(条件不满足)&#123;        对象.wait();    &#125;    对应的处理逻辑&#125;</code></pre></div><p>生产者遵循如下原则：</p><ol><li>获得对象的锁</li><li>改变条件</li><li>通知所有等待在对象上的线程</li></ol><p>对应的伪代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象)&#123;    改变条件    对象.notifyAll();&#125;</code></pre></div><h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><p>如果线程A执行了<code>thread.join()</code>方法，那么当前线程A等待thread线程终止之后才从<code>thread.join()</code>返回。</p><h3 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h3><ul><li>当一个线程执行sleep方法后，调用线程会暂时让出指定时间的执行权，也就是这段时间不参与CPU的调度，<strong>但是该线程持有的锁是不让出的。</strong>指定睡眠时间到了后该函数就会正常返回。</li><li>调用sleep会从Running状态进入Timed Waiting状态</li><li>其他线程可以使用<code>interrupt</code>方法</li><li><code>while(true)</code>语句中使用<code>sleep</code>可以避免CPU空转</li></ul><h3 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h3><ul><li>当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器会获取到一个优先级最高的线程。</li><li>调用yield会让当前线程从Running进入Runnable状态。</li><li>具体实现依赖于OS的任务调度器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之字节码执行引擎（九）</title>
    <link href="/2020/JVM/jvm09-bytecode-engine/"/>
    <url>/2020/JVM/jvm09-bytecode-engine/</url>
    
    <content type="html"><![CDATA[<h2 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h2><p>执行引擎是JVM核心的组成部分之一，虚拟机是一个相对于物理机的概念，物理机的执行引擎是直接建立在存储器、缓存、指令集和操作系统上的，而虚拟机的执行引擎完全由软件自行实现。因此可以不受物理条件制约地定制指令集与执行引擎地结构体系。</p><p>执行引擎在执行字节码地时候，通常会有解释执行和编译执行两种选择。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>JVM以方法为最基本地执行单元，栈帧是用于支持JVM进行方法调用和方法执行背后地数据结构，它是JVM运行时数据区中虚拟机栈地栈元素，每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面的入栈到出栈的过程。</p><p>对于执行引擎来说，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是在运行的，被称为<strong>当前栈帧</strong>，与这个栈帧相关联的方法被称为<strong>当前方法</strong>。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽为最小单位。</p><p>当一个方法被调用时，JVM会使用局部变量表完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过<strong>this</strong>来访问到这个参数，其余参数按照参数表顺序排列，占用从1开始的局部变量槽。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也被称为操作栈，它是一个后入先出栈，操作数栈的最大深度在编译时写入到Code属性的max_stacks数据项之中，操作数栈的每一个元素都可以是包括long和double在内的任何Java数据类型，32位数据类型所占的栈容量为1，64位数据类型栈容量为2.</p><p>当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。</p><p>操作数栈中的数据类型必须与字节码指令的序列严格匹配，在编译程序代码时，编译器需要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p><p>在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但在大多数JVM实现里会进行一些优化操作，令两个栈帧出现一部分重叠，让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起。不仅可以节约空间，更重要的是在方法调用时可以直接共用一部分数据，无需进行额外的参数复制传递了。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有两种方式退出这个方法，第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时可能会有返回值传递给上层的方法调用者，方法是否有返回之以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>正常调用完成</strong>。</p><p>另一种方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是JVM内部异常，还是代码中使用了<code>athrow</code>指令产生的异常，只要在笨方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为<strong>异常调用完成</strong>，异常调用完成的方式退出，不会给它的调用者提供任何返回值。</p><p>方法退出的过程实际上等同于当前栈帧出栈，因此退出时可能执行饿操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>在类加载的解析阶段，会将其中的一部分符号引用转换成直接引用，这种解析能成立的前提是：方法在程序运行之前就有一个可确定的调用版本，并且方法的调用版本在运行期不可改变的。</p><p>在Java语言中符合“编译期可知，运行期不可知”的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问。这两种方法各自的特点决定了都不可能通过继承或别的方式重写出其他版本，因此都适合在类加载阶段进行解析。</p><p>调用不同种类的方法有不同的字节码指令，分别是：</p><ul><li>invokestatic：调用静态方法</li><li>invokespecial：用于调用实例构造器<init>()方法、私有方法和父类中的方法</li><li>invokevirtual：用于调用所有的虚方法</li><li>invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象</li><li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后执行该方法</li></ul><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言中符合这个条件的有静态方法、私有方法、实例构造器、父类方法，被final修饰的方法，这五种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为<strong>非虚方法</strong>。</p><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>另一种主要的方法调用形式：分派调用则复杂许多，他可能是静态的，可能是动态的，按照分派依据的宗量数可分为单分派和多分派，这两种分派方式两两组合可以得到四种分派组合情况。</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticDispatch</span> &#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Human guy)</span>&#123;System.out.println(<span class="hljs-string">&quot;hello,guy!&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Man guy)</span>&#123;System.out.println(<span class="hljs-string">&quot;hello,gentlemen!&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(Woman guy)</span>&#123;System.out.println(<span class="hljs-string">&quot;hello,lady!&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;Human man=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();Human woman=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();sayHello(man);sayHello(woman);&#125;&#125;</code></pre></div><p>运行结果为：</p><div class="code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-built_in">hello,</span>guy!<span class="hljs-built_in">hello,</span>guy!</code></pre></div><div class="code-wrapper"><pre><code class="hljs java">Human man=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();</code></pre></div><p>上面代码的Human称为变量的静态类型或者叫外观类型，后面的Man称为变量的实际类型或者叫运行时类型，静态类型和实际类型在程序中都可能发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期间可知的，而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><p>JVM在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</p><p>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用表现就是方法重载，静态分派发生在编译阶段。</p><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>动态分派与Java语言多态性的——重写有着很密切的关系，以之前Human为例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicDispatch</span> &#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123; <span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;man say hello!&quot;</span>);&#125;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Human</span>&#123; <span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123; System.out.println(<span class="hljs-string">&quot;woman say hello!&quot;</span>);&#125;&#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;Human man=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();Human woman=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();man.sayHello();woman.sayHello();man=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>();man.sayHello(); &#125;&#125;</code></pre></div><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs inform7"><span class="hljs-keyword">man</span> <span class="hljs-keyword">say</span> hello!<span class="hljs-keyword">woman</span> <span class="hljs-keyword">say</span> hello!<span class="hljs-keyword">woman</span> <span class="hljs-keyword">say</span> hello!</code></pre></div><p>JVM如何判断应该调用哪个方法呢？</p><p>显然，这里不可能再根据静态类型来决定，因为静态类型同样是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？<br>我们从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果验证通过则返回这个方法的直接引用，查找过程结束；如果验证不通过，则抛出java.lang.IllegalAccessError异常。</li><li>否则未找到，就按照继承关系从下往上依次对类型C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常。</li></ol><p>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h4 id="JVM动态分派的实现"><a href="#JVM动态分派的实现" class="headerlink" title="JVM动态分派的实现"></a>JVM动态分派的实现</h4><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接受者类型的方法元数据中搜索合适的目标方法，因此JVM基于执行性能的考虑，真正运行时不会如此频繁地区搜索类型元数据。面对这种情况，一种基础且常见的优化手段是为类型在方法区中建立一个虚方法表，与之对应地，在invokeinterface执行时也会用到接口方法表。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/methodTable.png" alt="图1-方法表结构"></p><p>虚方法表中存放着各个方法地实际入口地址，如果某个方法在子类中没有被重写，那么子类地虚方法表中唔到地址入口和父类相同方法的地址入口时一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之类加载机制（八）</title>
    <link href="/2020/JVM/jvm08-class-load/"/>
    <url>/2020/JVM/jvm08-class-load/</url>
    
    <content type="html"><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><blockquote><p>JVM把Class描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为类加载机制。</p></blockquote><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>类加载机制的整个生命周期将经历：</p><ul><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ul><p>其中验证，准备，解析三部分统称为连接。<br>加载，验证，准备，初始化，卸载这五个阶段的顺序是确定的，而解析阶段则不一定，他在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或者晚期绑定）。</p><p>关于在什么情况下进行类加载的第一个过程，JVM规范并没有强制约束，这点交给虚拟机的具体实现来自由把握，但是对于初始化阶段，JVM严格规定了有且仅有六种情况必须立即对类进行初始化（加载验证准备自然在此之前）：</p><ul><li>遇到new，getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则需要先出发其初始化阶段，主要场景有：<ul><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类型的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）</li><li>调用一个类型的静态方法的时候</li></ul></li><li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要触发初始化</li><li>当初始化类的时候，如果发现其父类没有进行初始化，则需要先对父类进行初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li><li>当使用JDK 7新加入的动态语言支持时，如果使用一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。</li><li>当一个接口定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那么该接口要在其之前被初始化</li></ul><p>这六种场景中的行为被称为<strong>对一个类型的主动引用</strong>，除此之外，所有引用类型的方式不会触发初始化，称为<strong>被动引用</strong>。</p><h4 id="被动引用的Demo"><a href="#被动引用的Demo" class="headerlink" title="被动引用的Demo"></a>被动引用的Demo</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 被动引用 Demo1:</span><span class="hljs-comment"> * 通过子类引用父类的静态字段，不会导致子类初始化。</span><span class="hljs-comment"> */</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;SuperClass init!&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperClass</span> &#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;SubClass init!&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(SubClass.value);        <span class="hljs-comment">// SuperClass init!</span>    &#125;&#125;</code></pre></div><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 被动引用 Demo2:</span><span class="hljs-comment"> * 通过数组定义来引用类，不会触发此类的初始化。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SuperClass[] superClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperClass</span>[<span class="hljs-number">10</span>];    &#125;&#125;</code></pre></div><p>这段代码不会触发父类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 被动引用 Demo3:</span><span class="hljs-comment"> * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstClass</span> &#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;ConstClass init!&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HELLO_BINGO</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello Bingo&quot;</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotInitialization</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(ConstClass.HELLO_BINGO);    &#125;&#125;</code></pre></div><p>编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。<br><br></p><h3 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h3><p>接口的加载过程与类加载过程稍有不同。<br>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部完成了初始化，当真正用到父接口的时候才会完成初始化。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载过程，JVM需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化成方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li></ul><h4 id="获取二进制字节流"><a href="#获取二进制字节流" class="headerlink" title="获取二进制字节流"></a>获取二进制字节流</h4><ul><li>从zip包中读取，jar，war，ear</li><li>从网络中读取，Web Applet</li><li>运行时计算生成，使用最多的是动态代理技术</li><li>由其他文件生成，典型场景是JSP应用，由JSP生成对应的Class文件</li><li>从数据库中读取</li><li>从加密文件中获取</li></ul><h4 id="非数组类型与数据类加载比较"><a href="#非数组类型与数据类加载比较" class="headerlink" title="非数组类型与数据类加载比较"></a>非数组类型与数据类加载比较</h4><ul><li>非数组类型的加载阶段可以使用JVM内置的引导类加载器，也可以使用用户自定义的类加载器，开发人员通过定义自己的类加载器区控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()）</li><li>数组类本身不通过类加载器创建，它通过JVM直接在内存中动态构造出来的，再由类加载器创建数组中的元素类</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的是确保Class文件的字节流中包含的信息符和JVM规范中的全部约束要求。保证这些信息被当作代码运行后不会危害JVM自身的安全。</p><h4 id="验证的过程"><a href="#验证的过程" class="headerlink" title="验证的过程"></a>验证的过程</h4><ul><li>文件格式验证：验证字节流是否符和Class规范，并且能被当前版本的虚拟机处理，这一阶段包括以下验证点：<ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前JVM处理范围内</li><li>常量池的常量是否有不被支持</li><li>指向常量的索引值中是否有不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li><li>Class文件中各个部分以及文件本身是否有被删除的或附加的其他信息</li></ul></li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述信息符和Java语言规范<ul><li>这个类是否有父类（除Object之外，所有的类都有父类）</li><li>这个类是否继承了不被允许继承的类（被final修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾</li></ul></li><li>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。<ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li><li>保证任何跳转指令都不会跳转到方法体意外的字节码指令上</li><li>保证方法体中的类型转换总是有效的</li></ul></li><li>符号引用验证：发正在解析阶段，可以看作是对类自身以外的各类信息进行匹配性验证，确定该类是否缺少或者被禁止访问它以来的某些外部类、方法、字段等资源，本阶段需要校验以下内容：<ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符和方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的可访问性是否可被当前类访问</li></ul></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。<br>初始值“通常情况下”是数据类型的零值（0, null…），假设一个类变量的定义为：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;</code></pre></div><p>那么变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法。</p><p>存在“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;</code></pre></div><p>那么在准备阶段虚拟机会根据 ConstantValue 的设置将 value 赋值为 123。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。</p><ul><li>类或接口的解析</li><li>字段解析</li><li>方法解析</li><li>接口方法解析</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行内构造器<code>&lt;clinit&gt;()</code>方法的过程，此方法是由Javac自动生成的。</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而产生的。收集顺序由语句在源代码中出现的顺序决定</p><p>静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。如下方代码所示：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">static</span> &#123;        i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 给变量赋值可以正常编译通过</span>        System.out.println(i);  <span class="hljs-comment">// 这句编译器会提示“非法向前引用”</span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><p><code>&lt;clinit&gt;()</code>方法与类的构造方法不同，它不需要显式地调用父类构造器，JVM会保证在子类地<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</p><p>由于父类的<code>&lt;clinit&gt;()</code> 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。如下方代码所示：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> &#123;        A = <span class="hljs-number">2</span>;    &#125;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> A;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    System.out.println(Sub.B); <span class="hljs-comment">// 输出 2</span>&#125;</code></pre></div><p><code>&lt;clinit&gt;()</code>方法不是必需的，如果一个类中没有静态代码块，也没有对类变量的赋值操作，那么编译器将不生成<code>&lt;clinit&gt;()</code>方法。</p><p>接口中不能使用静态代码块，但接口也需要通过 <code>&lt;clinit&gt;()</code> 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的<code>&lt;clinit&gt;()</code> 方法不需要先执行父类的<code>&lt;clinit&gt;()</code> 方法，只有当父接口中定义的变量使用时，父接口才会初始化。</p><p>JVM必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中能被正常的加锁同步，如果多个线程区执行<code>&lt;clinit&gt;()</code>方法，那么只会有一个线程能执行<code>&lt;clinit&gt;()</code>方法，其他线程需要阻塞等待。直至活动线程执行完毕。</p><br><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>任意一个类，都必须由类加载器和这个类本身共同确立其在JVM中的唯一性。每个类加载器都有一个独立的类名称空间。</p><p>因此要比较两个类是否相等，只有在这两个类是同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个Class文件，被同一个JVM加载，只要类加载器不同，这两个类就必定不相等。</p><p>这里的相等代表类的Class对象的equals方法，isAssignableFrom()方法，inInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定的各种情况。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>JVM存在三层类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）<ul><li>负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或被-Xbootclasspath参数指定的目录存放的，而且能被JVM识别的（如rt.jar,tools.jar）类库加载到内存中</li></ul></li><li>扩展类加载器（Extension Classloader）<ul><li>负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库</li></ul></li><li>应用程序类加载器（Application Classloader）<ul><li>也称为系统类加载器，负责加载用户类路径上的所有类库。</li></ul></li></ul><p>类加载器之间的层次关系被称为类加载器的<strong>双亲委派模型</strong>，双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应有自己的父类加载器。</p><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，他首先不会自己区尝试加载这个类，而是把这个请求委派给父类加载器区完成，每一个层次的类加载器都是如此，因此所有的类加载器最终都应该传送到最顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求的时候，子加载器才会尝试自己去完成加载。</p><p>使用双亲委派模型的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如Object类由启动类加载器加载，同时也是所有类的父类。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之字节码指令（七）</title>
    <link href="/2020/JVM/jvm07-bytecode/"/>
    <url>/2020/JVM/jvm07-bytecode/</url>
    
    <content type="html"><![CDATA[<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>Java虚拟机的指令是由一个字节长度的，代表某种特定操作含义的数字（称为操作码，Opcode），以及跟随其后的零至多个代表此操作的参数，称为操作数（Operand）构成。由于Java虚拟机面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码。指令参数存放在操作数栈中。</p><p>由于Java虚拟机操作码的长度为一个字节（0-255），这意味着指令集的操作码总数不能超过256条。</p><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><ul><li>将一个局部变量加载到操作数栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n></li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n></li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i></li><li>扩充局部变量表的访问索引的指令</li></ul><br><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul><br><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>JVM直接支持小范围类型向大范围类型的安全转换：</p><ul><li>int -&gt; long&#x2F;float&#x2F;double</li><li>long -&gt; float&#x2F;double</li><li>float -&gt; double</li></ul><p>处理窄化类型转换时，要用转换指令来完成。包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f.</p><p>在将int或long类型窄化转换成整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度。这将可能导致转换结果与输入值的正负号不同。</p><br><h3 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h3><p>虽然类实例和数组都是对象，但是JVM对类实例和数组的创建使用不同的字节码指令，对象创建后，可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，包括：</p><ul><li>创建类实例指令：new</li><li>创建数组的指令：newarray，anewarray，multianewarray</li><li>访问类字段（static字段）和实例字段（非static字段）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li><li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul><br><h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><ul><li>将操作数栈的栈顶一个或者两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值交换：swap</li></ul><br><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>可以认为控制指令就是在有条件或者无条件地修改PC寄存器地值，控制指令包括：</p><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne</li><li>复合条件分支：tableswitch、lookupswitch</li><li>无条件分支：goto、goto_w、jsr、jsr_w，ret</li></ul><br><h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><p>方法调用指令包括：</p><ul><li>invokevirtual：用于调用对象地实例方法，根据对象地实际类型进行分派</li><li>invokeinterface：用于调用接口方法，他会在运行时搜索一个实现了这个接口地方法地对象，找出合适地方法进行调用</li><li>invokespecial：用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法</li><li>invokestatic：用于调用类静态方法</li><li>invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。</li></ul><p>方法返回指令包括</p><ul><li>ireturn（返回值为Boolean，char，short，int时使用）</li><li>lreturn</li><li>freturn</li><li>dreturn</li><li>areturn</li><li>return（void）</li></ul><br><h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p>Java程序中显式抛出异常的操作（throw）都由athrow指令来实现。JVM规范规定许多运行时异常会在其他Java虚拟机指令检测到异常状态时自动抛出。<br>处理异常不是由字节码实现的，而是采用异常表实现的。</p><h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，也被称为锁）来实现的。</p><p>方法的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作中。JVM可以从方法常量池的方法表结构中<code>ACC_SYNCHRONIZED</code>访问标志得知一个方法是否被声明为同步方法，当方法调用时，调用指令将会检查方法的该标志是否被设置，如果设置，执行线程就要求先成功持有管程，然后才能执行方法。最后当方法完成时释放管程。</p><p>同步一段指令集通常时由Java语言中的synchronized语句块来表示的，JVM指令集中由monitorenter和monitorexit两条指令来支持synchronized关键字的语义。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之类文件结构（六）</title>
    <link href="/2020/JVM/jvm06-class-file/"/>
    <url>/2020/JVM/jvm06-class-file/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实现语言无关性的基础是虚拟机和字节码存储格式。Java虚拟机不与任何程序语言绑定，它只与Class文件这种特定的二进制文件格式所关联。Class文件中包含了Java虚拟机指令集，符号表以及若干其他辅助信息。</p><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>任何一个Class文件对应着唯一的一个类或者接口的定义信息，Class文件是一组以八个字节为基础单位的<strong>二进制流</strong>，各个数据项目严格按照顺序紧凑的排列，中间没有任何分隔符，Class文件只有两种类型：<strong>无符号数</strong>、<strong>表</strong>。</p><ul><li>无符号数属于基本数据类型，以u1,u2,u4,u8分别代表1&#x2F;2&#x2F;4&#x2F;8个字节的无符号数，无符号数用来描述数字，索引引用，数量值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型。</li></ul><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>Class文件的头4个字节被称为魔数，它的唯一作用就是确定这个文件是否为一个能被JVM接受的Class文件，魔数的十六进制表示为<code>0xCAFEBABE</code>。</p><h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><p>紧接着魔数的4个字节的是版本信息，第5-6字节是次版本号，7-8字节是主版本号，表示Class文件使用的JDK版本。<br>高版本的JDK能向下兼容，但是不能向上兼容。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>版本信息之后是常量池入口，常量池主要存放两大类常量：<strong>字面量</strong>、<strong>符号引用</strong>。</p><p>常量池中常量的数量是不固定的，所以在入口需要放置一项u2类型的数据，代表常量池容量计数值。</p><p>字面量接近于常量概念，如字符串、被声明为final的值。<br>符号引用属于编译原理方面的概念：主要包括：</p><ul><li>被模块导出或开放的包</li><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li><li>方法句柄和方法类型</li><li>动态调用点和动态产量</li></ul><p>常量池的每个常量都是一个表，共有17钟不同类型的常量。表开始的第一位是个u1类型的标志位，代表当前常量属于哪种常量类型。</p><p>17种常量类型：</p><table><thead><tr><th>类型</th><th>tag</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标识方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><br>对于 CONSTANT_Class_info（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下：<table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr></tbody></table><p>tag 是标志位，用于区分常量类型；name_index 是一个索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name_index 值若为 0x0002，也即是指向了常量池中的第二项常量。</p><br>CONSTANT_Utf8_info 型常量的结构如下：<table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u1</td><td>bytes</td><td>length</td></tr></tbody></table><p>tag 是当前常量的类型；length表示这个字符串的长度；bytes 是这个字符串的内容（采用缩略的 UTF8 编码）</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>常量池结束后，紧接着的两个字节表示访问标志，用来识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否定义为abstract类型，是否被final修饰。</p><h3 id="类索引，父类索引，接口索引集合"><a href="#类索引，父类索引，接口索引集合" class="headerlink" title="类索引，父类索引，接口索引集合"></a>类索引，父类索引，接口索引集合</h3><p>类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合，Class文件由这三项数据来确定该类的继承关系，类索引用来确定这个类的父类的全限定名。，父类索引只有一个，除了<code>java.lang.Object</code>之外，所有的Java类都有父类。接口索引集合用来描述这个类实现了哪些接口，这些接口按<code>implements</code>关键字后面的顺序从左到右排列在接口索引集合内。接口索引集合的第一项为u2类型的数据，表示索引表的容量，接下来就是接口的名字索引。</p><p>类索引，父类索引引用两个u2类型的索引值标识，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。</p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用来描述接口或者类种声明的变量，包括实例变量和类变量，但是不包括方法中的局部变量。<br>每个字段表只表示一个变量，本类中所有的成员变量构成字段表集合，字段表结构如下所示：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>说明</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td><td>字段的访问标志，与类稍有不同</td></tr><tr><td>u2</td><td>name_index</td><td>1</td><td>字段名字的索引</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td><td>描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td><td>属性表集合的长度</td></tr><tr><td>u2</td><td>attributes</td><td>attributes_count</td><td>属性表集合，用于存放属性的额外信息，如属性的值。</td></tr></tbody></table><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>对方法的描述和对字段的描述采取了几乎完全一致的方式。依次包括访问标志，名称索引，描述符索引，属性表集合。</p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有这两项。</p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p><p>属性表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之内存分配策略（五）</title>
    <link href="/2020/JVM/jvm05-memory-allocate/"/>
    <url>/2020/JVM/jvm05-memory-allocate/</url>
    
    <content type="html"><![CDATA[<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>Java技术体系的自动内存管理，最根本性的目标是自动化解决两个问题：自动给对象分配内存，以及自动回收分配给对象的内存。</p><p>对象的内存分配，就是在堆上分配（也有可能经过JIT编译后被拆散为标量空间类型间接地在栈上分配），新生对象主要分配在新生代中，少数情况（大小超过阈值）会被分配在老年代，分配规则不固定，取决于当前使用的垃圾收集器与JVM参数设置。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden去中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><ul><li>Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>Major GC &#x2F; Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。</li></ul><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串，或者元素数量很庞大的数组。</p><p>JVM提供了一个<code>-XX:PretenureSizeThreshold</code>，指定大于该设置值的对象直接在老年代分配，这样做的目的是避免在Eden区和两个Survivor区之间来回复制，产生大量内存复制操作。</p><h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>为了决策哪些存活对象存储在新生代，哪些对象存储在老年代，，JVM给每个对象定义了一个对象年龄计数器，存储在对象头中，对象通常在Eden区诞生，如果经历一次Miror GC后仍然存活，并且能被Survivor容纳，该对象就会被移动到Survivor，并将该对象年龄设为1岁，对象每经历一次Miror GC，年龄就增加1岁，当年龄达到一定程度（默认15），就会被移动到老年代，对象年龄阈值可以通过<code>-XX:MaxTenuringThreshold</code>设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果当前新生代的Survivor中，相同年龄的所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象可以进入老年代，无需等到MaxTenuringThreshold 中要求的年龄。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>JDK 6 Update 24 之前，在发生Miror GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次的Miror GC可以确保是安全的，如果不成立，则虚拟机会查看 HandlePromotionFailure 值是否设置为允许担保失败， 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 Minor GC,尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那此时也要改为进行一次 Full GC。</p><p>JDK 6 Update 24 之后的规则变为：<br> 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p><h3 id="哪些情况会使JVM进行Full-GC？"><a href="#哪些情况会使JVM进行Full-GC？" class="headerlink" title="哪些情况会使JVM进行Full GC？"></a>哪些情况会使JVM进行Full GC？</h3><ul><li>System.gc() 方法的调用</li></ul><p>此方法是建议JVM进行Full GC，我们可以通过 -XX:+ DisableExplicitGC 来禁止调用 System.gc()。</p><ul><li>老年代空间不足</li></ul><p>老年代空间不足会触发 Full GC操作，若进行该操作后空间依然不足，则会抛出如下错误：<br><code>java.lang.OutOfMemoryError: Java heap space</code></p><ul><li><p>永久代空间不足<br>JVM 规范中运行时数据区域中的方法区，在 HotSpot 虚拟机中也称为永久代（Permanet Generation），存放一些类信息、常量、静态变量等数据，当系统要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，会触发 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：<br><br><code>java.lang.OutOfMemoryError: PermGen space </code></p></li><li><p>CMS GC 时出现 promotion failed 和 concurrent mode failure<br>promotion failed，就是上文所说的担保失败，而 concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。</p></li><li><p>统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之垃圾收集算法与垃圾收集器（四）</title>
    <link href="/2020/JVM/jvm04-gc-algorithrms/"/>
    <url>/2020/JVM/jvm04-gc-algorithrms/</url>
    
    <content type="html"><![CDATA[<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为<strong>引用计数式垃圾收集</strong>和<strong>追踪式垃圾收集</strong>，由于引用计数式垃圾收集在主流JVM并未涉及，所以追踪式垃圾收集为主。</p><p>当前的JVM大多数遵循了<strong>分代收集</strong>理论进行设计，它主要建立在两个分代假说上面：<strong>弱分代假说</strong>和<strong>强分代假说</strong>。分代假说奠定了收集器的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>  <strong>标记</strong>过程：遍历所有的<code>GC Roots</code>，然后将<code>GC Roots</code>可达对象标记为存活的对象。</p><p>  <strong>清除</strong>过程：将没有标记的对象全部清除。</p><p>  主要缺点：</p><ul><li>执行效率不稳定</li><li>内存空间碎片化问题</li></ul><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>也被简称为复制算法，它将可用内存划分成大小相等的两块，每次只使用其中的一块，当这一块的内存用完，就把还存活的对象复制到另外一块上面，然后再把这一块内存全部清除。这种算法有优有劣。</p><ul><li>优点：不会出现内存碎片的问题</li><li>缺点：可用内存缩为原来的一半，浪费空间</li></ul><p>  为了提高空间利用率的问题，可以将新生代分为一块较大的<code>Eden</code>区，和两块较小的<code>Survivor</code>区，比例为<code>8:1:1</code>,每次 分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor区，然后清理掉Eden和已用过的Survivor区，这样只有10%的内存被浪费掉。<br>  但是不能保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存区域（老年代）进行分配担保。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>  <strong>标记</strong>过程：与<strong>标记-清除算法</strong>一样，将存活的对象标记。<br>  <strong>整理</strong>过程：让所有存活的对象都向内存空间一端移动，然后直接清理掉边界之外的内存。</p><p>  这是一种老年代的垃圾收集算法，老年代对象的生命周期较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次效率很低。</p><h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><h3 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h3><h4 id="Serial收集器（单线程）"><a href="#Serial收集器（单线程）" class="headerlink" title="Serial收集器（单线程）"></a>Serial收集器（单线程）</h4><p>  Serial收集器是一个新生代垃圾收集器，它在垃圾收集时，必须暂停其它所有工作线程,知道它收集结束（Stop the World）。<br>  对于内存资源受限的环境，它时所有收集器里面额外内存消耗最小的，对于单核处理器或者处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，壮美做垃圾收集自然可以获得最高的单线程手机效率。</p><h4 id="ParNew收集器（多线程）"><a href="#ParNew收集器（多线程）" class="headerlink" title="ParNew收集器（多线程）"></a>ParNew收集器（多线程）</h4><p>  ParNew收集器实质上时Serial收集器的多线程并行版本，由多条GC线程并行的进行垃圾清理，清理过程仍需Stop The World。在多 CPU 环境下性能比 Serial 会有一定程度的提升；但<strong>线程切换需要额外的开销</strong>，因此在单 CPU 环境中表现不如 Serial。</p><h4 id="Parallel-Scavenge收集器（多线程）"><a href="#Parallel-Scavenge收集器（多线程）" class="headerlink" title="Parallel Scavenge收集器（多线程）"></a>Parallel Scavenge收集器（多线程）</h4><p>  Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点：</p><ul><li>Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。</li><li>ParNew：追求降低用户停顿时间，适合交互式应用。</li></ul><p>  吞吐量 &#x3D; 运行用户代码时间 &#x2F; (运行用户代码时间 + 垃圾收集时间)</p><h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><h4 id="Serial-Old收集器（单线程）"><a href="#Serial-Old收集器（单线程）" class="headerlink" title="Serial Old收集器（单线程）"></a>Serial Old收集器（单线程）</h4><p>  Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用<strong>标记-整理</strong>算法；Serial 工作在新生代，使用<strong>标记-复制</strong>算法。</p><h4 id="Parallel-Old收集器（多线程）"><a href="#Parallel-Old收集器（多线程）" class="headerlink" title="Parallel Old收集器（多线程）"></a>Parallel Old收集器（多线程）</h4><p>  Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>  CMS(Concurrent Mark Sweep，并发标记清除)收集器是一种以获取最短回收停顿时间为目标的收集器，它在垃圾收集时用户线程和GC线程并发执行，因此在手机过程不会有明显的卡顿。<br>  CMS收集器是基于<strong>标记-清除</strong>算法实现的。它的运作过程分为四个步骤：</p><ul><li>初始标记：Stop The World，仅使用一条初始标记线程对所有与GC Roots直接关联的对象进行标记</li><li>并发标记：使用多条标记线程，与用户线程并发执行，标记出所有废弃的对象。</li><li>重新标记：Stop The World，为了修正并发标记期间，由于用户进程继续运作而导致标记产生变动的那一部分对象的标记记录。</li><li>并发清除：清理删除掉标记阶段判断已经死亡的对象，这个阶段也是可以与用户线程同时并发的。</li></ul><p>  并发标记和并发清除阶段耗时最长，且可以与用户线程一起工作，总体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>  缺点：</p><ul><li>吞吐量低</li><li>无法处理浮动垃圾，导致频繁Full GC</li><li>使用标记-清除算法，会有大量的空间碎片产生</li></ul><p>  对于空间碎片的问题，可以通过开启<code> -XX:+UseCMSCompactAtFullCollection</code>，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的。这样空间碎片问题解决，但是停顿时间又会变长，因此还有一个参数<code> -XX:CMSFullGCsBefore-Compaction</code>，作用是要求CMS收集器在执行过若干次不整理空间的Full GC之后，下一次进入Full GC之前进行碎片整理。</p><h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>  G1是一款主要面向服务端应用的垃圾收集器，他没有新生代和老年代的概念，它可以面向对内存任何部分来组成回收集（CSet）进行回收，它把连续的Java堆划分为多个大小相等的独立区域（Region），Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要大小超过一个Region容量一半的对象即可判定为大对象。</p><p>  G1收集器还有细节问题需要妥善解决：</p><ul><li>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</li></ul><p>  使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用要复杂很多，每一个Region都有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别再哪些卡页的范围之内记忆集再存储结构的本质上是一种哈希表，key是Region的起始地址，value是一个集合，存储的是卡表的索引号。</p><ul><li>在并发阶段如何保证收集线程与用户线程互不干扰地运行？</li></ul><p>  G1用过原始快照（SATB）算法来实现的。</p><p>  G1收集器的运作过程分为以下几个步骤：</p><ul><li>初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。并且修改TAMS指针的值。让下一个阶段用户线程i把那个发运行时，能正确地在可用地Region中分配新对象。</li><li>并发标记：使用一条标记线程与用户线程并发执行，此过程进行可达性分析，递归扫描整个堆中地对象图，找出要回收的对象，耗时较长，能与用户线程并发执行，扫描完成之后，需要重新处理SATB记录下的并发时有引用变动地对象。</li><li>最终标记：Stop The World，对用户线程做出另一个短暂的暂停，用户处理并发阶段结束后仍遗留下来的SATB记录。</li><li>筛选回收：负责更新Region的统计数据，Region的回收价值和成本进行排序，把回收的那一部分Region的存活对象复制到空的Region中，在清除掉旧Region的全部空间，整个过程Stop The World。</li></ul><h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><p>  衡量垃圾收集器的三项最重要指标是：内存占用，吞吐量和延迟。三者构成了一个<strong>不可能三角</strong>，优秀的垃圾收集器通常最多可以同时达成其中的两项。延迟是垃圾收集器最被重视的性能指标</p><h3 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h3><p>  非官方的收集器，Oracle拒绝在OracleJDK 12中支持Shenandoah收集器，只有在OpenJDK才会包含。<br>  它和G1有着相似的堆内存布局，在初始标记，并发标记等许多阶段的处理思路都高度一致，但是有三个明显的不同之处：</p><ul><li>支持并发的整理算法，G1的回收阶段是可以多线程并行的，但是不能与用户线程并发。</li><li>默认不使用分代收集，不会有新生代Region和老年代Region的存在</li><li>摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为”连接矩阵”的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针的记忆集维护，也降低了伪共享问题的发生概率。</li></ul><h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><p>  它和Shenandoah收集器的目标是高度相似的，都希望在尽可能对吞吐量影响不大的前提下，尽量减少延迟。ZGC也采用基于Region的堆内存布局，但是ZGC的Region具有动态性（动态创建和销毁），以及动态的区域容量大小。ZGC的并发整理算法通过染色指针计数实现。ZGC地运作过程可以分为四个阶段，四个阶段都可以并发执行。两个阶段之间会有短暂的停顿。</p><ul><li>并发标记：与G1一样，遍历对象图做可达性分析，ZGC的标记是在指针上进行的，而不是在对象上进行</li><li>并发预备重分配：根据特定的查询条件统计出本次收集要清理哪些Region，将这些Region组成重分配集</li><li>并发重分配：重分配阶段把重分配集中存活对象复制到新的Region上，并为重分配集中的每一个Region维护一个转发表，记录从旧对象到新对象的转向关系。</li><li>并发重映射：修正整个堆中指向重分配集的就对象的所有引用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之垃圾收集策略（三）</title>
    <link href="/2020/JVM/jvm03-gc-strategy/"/>
    <url>/2020/JVM/jvm03-gc-strategy/</url>
    
    <content type="html"><![CDATA[<h2 id="垃圾收集策略"><a href="#垃圾收集策略" class="headerlink" title="垃圾收集策略"></a>垃圾收集策略</h2><p>程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而执行入栈和出栈操作，每个栈帧分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的分配和回收具备确定性。在这几个区域不需要过多考虑如何回收的问题，当方法执行结束或者线程结束，内存自然就跟随着回收。<br>而Java堆和方法区，只有程序运行期间才知道会创建多少对象，这部分内存的分配和回收都是动态的，GC关注的正是这部分内存。</p><h3 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h3><p>如果一个对象不被任何对象或变量引用，那么他就是无效对象，需要被回收。判断是存活主要有以下几种算法。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>在对象中添加一个引用计数器，每当有一个对地方引用它时，计数器值就加一，当引用失效时，计数器值就减一，任何时刻计数器为零的对象就是不可能再被使用的。<br>引用计数原理简单，判定效率也高，但是主流的JVM并没有选用引用计数来管理内存，主要原因是这个算法有很多例外情况需要考虑，比如对象之间相互循环引用。</p><blockquote><p>对象 objA 和 objB 都有字段 instance，令 objA.instance &#x3D; objB 并且 objB.instance &#x3D; objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。</p></blockquote><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>所有和 <code>GC Roots</code> 直接或间接关联的对象都是有效对象，和 <code>GC Roots</code> 没有关联的对象就是无效对象。</p><p>从<code>GC Roots</code>作为起始节点，根据引用关系向下搜索，搜索过程所走过的路径称为<strong>引用链</strong>，如果某个对象到<code>GC Roots</code>之间没有任何引用链相连，就证明此对象不可能在被使用的。</p><p>在Java技术体系里面，固定可作为<code>GC Roots</code>的对象包括：</p><ul><li>在虚拟机栈（栈帧的本地变量表）中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等</li><li>在方法区中常量引用的对象，比如字符串常量池里面的引用</li><li>在本地方法栈中<code>JNI</code>（Native）引用的对象</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象，比如<code>NullPointerException</code>，<code>OutofMemoryError</code>等，还有系统类加载器</li><li>所有被同步锁（synchronized）持有的对象</li><li>反映Java虚拟机内部情况的<code>JMXBean</code>，<code>JVMTI</code>中注册的回调，本地代码缓存等</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾手收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种。不同的引用类型，主要体现的是对象不同的可达性状态<code>reachable</code>和垃圾收集的影响。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>类似<code>Object object = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些还有用，但非必须的对象，只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收。即如果还有空闲内存，即暂时保存，当内存不足时清理掉。JDK1.2之后提供了<code>SoftReference</code>来实现软引用。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用用来描述那些非必须对象，它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。JDK 1.2之后提供<code>WeakReference</code>类来实现弱引用</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用也成为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存空间构成影响。也无法通过虚引用来获取一个对象实例，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知，在JDK1.2之后提供<code>PhantomReference</code>类来实现虚引用。</p><h3 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h3><p>对于可达性分析中不可达的对象，那么它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，假如对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”，那么对象基本上就真的被回收了。</p><p>如果对象被判定为有必要执行<code>finalize()</code>方法，那么对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机自动创建的，低调度的优先级的<code>Finalizer</code>线程去执行它们的<code>finalize()</code>方法，但并不确保所有的<code>finalize()</code>方法都会执行结束，如果方法出现耗时操作，虚拟机就会直接停止该方法，将对象清除。</p><p>如果在执行<code>finalize()</code>方法时，将this赋给了某一个引用，那么对象就重生。<br>任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次。</p><h3 id="回收方法区内存"><a href="#回收方法区内存" class="headerlink" title="回收方法区内存"></a>回收方法区内存</h3><p>由于方法区中主要存放生命周期较长的类信息，常量，静态变量，所以方法区的垃圾回收成果往往低于堆的回收成果。方法区的垃圾回收主要回收两种垃圾：</p><ul><li>废弃的常量</li><li>不再使用的类型</li></ul><h4 id="判定废弃常量"><a href="#判定废弃常量" class="headerlink" title="判定废弃常量"></a>判定废弃常量</h4><p>只要常量池中的常量不被任何变量或者对象引用，那么这些常量就会被清除掉，常量池中其他类信息，方法，字段的符号引用也类似。</p><h4 id="判定无用的类"><a href="#判定无用的类" class="headerlink" title="判定无用的类"></a>判定无用的类</h4><p>判定一个无用的类，需要同时满足下面三个条件：</p><ul><li>该类的所有实例都已被回收，也就是Java堆中不存在该类及任何派生子类的实例</li><li>加载该类的类加载器已经被回收</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之HotSpot VM对象（二）</title>
    <link href="/2020/JVM/jvm02-java-object/"/>
    <url>/2020/JVM/jvm02-java-object/</url>
    
    <content type="html"><![CDATA[<h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>当JVM遇到一条字节码new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那么先执行相应的类加载过程。</p><h3 id="为新生对象分配内存"><a href="#为新生对象分配内存" class="headerlink" title="为新生对象分配内存"></a>为新生对象分配内存</h3><p>对象所需内存的大小再类加载完成后便可完全确定（对象的字段存储的时基本类型值，对象和数组的引用），接下来从Java堆中划分出对应大小的内存块给新的对象，分配方式有两种：</p><ul><li><strong>指针碰撞</strong></li></ul><p>假设Java堆中内存时绝对规整的，所有被使用的内存都被放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么所分配内存就仅仅是把那个指针向空闲空间方向挪动一段所需大小的距离。</p><ul><li><strong>空闲列表</strong></li></ul><p>如果Java堆中内存并不是规整的，使用的内存和未使用的内存交错在一起，此时无法使用指针碰撞方法，JVM需要维护一个列表，记录哪些内存块空闲可用，再分配的时候，从列表中找出一块足够大的空间划分给对象实例，并更新列表上的记录。</p><p>Java堆是否规整，取决于采用的垃圾收集器是否具有空间压缩整理（Compact）的能力决定。使用<code>Serial</code>、<code>ParNew</code>等收集器时，采取指针碰撞方法，当使用CMS这种基于清除（Sweep）算法的收集器时，采用较为复杂的空闲列表来分配内存。</p><p>如何保证并发情况下的线程安全问题？</p><ul><li>对分配内存空间的动作进行同步处理，实际上JVM是采用CAS配上失败重试的方式保证更新操作的原子性</li><li>把内存分配的动作按照线程划分再不同的空间之中进行，即每个线程在Java堆预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程要分配内存，在哪个本地缓冲区进行分配。本地缓冲区用完了，分配新的缓存区才需要同步锁定。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>分配完内存之后，JVM将内存空间都初始化为零值，这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。</p><h3 id="设置信息"><a href="#设置信息" class="headerlink" title="设置信息"></a>设置信息</h3><p>设置对象头信息：</p><ul><li>对象是哪个类的实例</li><li>如何才能找到类的元数据信息</li><li>对象的哈希码（真正调用<code>Object::hashCode()</code>时才计算）</li><li>对象的GC分代年龄</li></ul><h3 id="执行构造函数"><a href="#执行构造函数" class="headerlink" title="执行构造函数"></a>执行构造函数</h3><p>执行之前，对象的所有字段都为默认的零值，通过Class文件中的<code>&lt;init&gt;()</code>完成对象的创建过程。</p><p>虚拟机层面完成对象创建工作时，Java程序刚开始执行构造函数，此时别的线程读取该对象不为Null（引用存了地址），但是内部无值。如果在并发环境下，由于指令重排序的存在，可能还未读到初始化变量。可以使用<code>volitale</code>配合<code>Double Check</code>完成工作。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/jvm-object.png" alt="对象的内存布局"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头存储两类信息，第一类用于存储对象自身的运行时数据，称为<code>Mark Word</code>，包括以下信息：</p><ul><li>哈希码</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul><p><code>Mark Word</code>在32位，64位下分别为<code>32bit</code>和<code>64bit</code>，32位HotSpot虚拟机中，对象未被同步锁锁定的状态下，<code>Mark Word</code>的<code>32bit</code>中<code>25bit</code>用于存储对象哈希码，<code>4bit</code>用于存储对象分代年龄，<code>2bit</code>用于存储锁标志位,<code>1bit</code>固定为0。</p><p>类型指针即对象指向它的类型元数据的指针，JVM通过这个指针来确定对象是哪个类的实例。但类型指针并不是一定存在的。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象成员变量的值，包括父类继承下来的成员变量和本类的成员变量。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>不是必然存在的，起到占位符的作用，因为HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，对象头部分正好是整数倍，当实例数据部分没有对齐时，通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>对象的存储空间在堆上分配，对象的引用在栈上分配，通过这个引用找到具体的对象，主流的访问方式有使用句柄和直接指针两种。</p><h3 id="句柄访问方式"><a href="#句柄访问方式" class="headerlink" title="句柄访问方式"></a>句柄访问方式</h3><p>堆中需要划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。句柄访问的最大好处就是引用中存放的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/IMG_0038.PNG" alt="通过句柄访问对象"></p><h3 id="直接指针访问方式"><a href="#直接指针访问方式" class="headerlink" title="直接指针访问方式"></a>直接指针访问方式</h3><p>直接指针访问的最大好处就是速度更快，节省了一次指针定位的时间开销。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/IMG_0037.PNG" alt="直接指针访问对象"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之Java内存结构（一）</title>
    <link href="/2020/JVM/jvm01-java-memory-structure/"/>
    <url>/2020/JVM/jvm01-java-memory-structure/</url>
    
    <content type="html"><![CDATA[<h1 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h1><p>数据区域主要分为五个部分：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p>其中所有线程共享区域有：方法区和堆。</p><p>每个线程独享区域有：虚拟机栈，本地方法栈，程序计数器<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/jvm/java-memory.png" alt="Java运行时数据区域"></p><h2 id="线程独享的区域"><a href="#线程独享的区域" class="headerlink" title="线程独享的区域"></a>线程独享的区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p> 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，如果当前线程执行的是一个本地方法，那么此时计数器的值为<code>undefined</code>，是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p> 虚拟机栈描述的是Java方法执行的线程内存模型，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存放以下内容：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口</li></ul><p>其中局部变量表包括以下内容：</p><ul><li>八大基本数据类型</li><li>对象引用</li><li>returnAddress类型（保存的是return后要执行的字节码的指令地址）</li></ul><p>这些数据类型在局部变量表中的存储空间以局部变量槽来表示，64位长度的<code>long</code>和<code>double</code>类型占用两个变量槽，其余的占用一个。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变局部变量表的大小。</p><p>Java 虚拟机栈会出现两种异常：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverFlowError</code></li><li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够内存会抛出<code>OutOfMemoryError</code></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈是为JVM使用到的<code>Native</code>方法准备的空间。</p><h2 id="线程共享的区域"><a href="#线程共享的区域" class="headerlink" title="线程共享的区域"></a>线程共享的区域</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>主要特点：</p><ul><li>堆是被所有线程共享的一块内存区域</li><li>在虚拟机启动时创建</li><li>堆的唯一目的就是存放对象实例</li><li>堆是垃圾回收管理的内存区域</li><li>可分为新生代，老年代，永久代等（一部分垃圾收集器的共同特性或者设计风格，不是具体实现的固有内存布局）</li><li>从分配内存的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（TLAB）以提升对象分配的效率，这样做可以更好地回收内存或者更快的分配内存。</li><li>堆的大小可以通过<code>-Xmx</code>和<code>-Xms</code>设定。</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。<br>用于存储以下内容：</p><ul><li>已被虚拟机加载的类信息</li><li>常量</li><li>静态变量</li><li>即时编译器编译后的代码</li></ul><p>方法区内的主要回收目标是对常量池的回收和对类型的卸载。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。主要存放以下内容：</p><ul><li>类信息（版本，字段，方法，接口等描述信息）</li><li>常量池表（用于存放编译期生成的各种字面量与符号引用）</li></ul><p>Java并不要求常量一定在编译期间产生，并非Class文件中常量池的内容才能进入运行时常量池，运行期间产生的新的常量也能放入池中。比如<code>String</code>类的<code>intern()</code>方法。<br>当常量池无法再申请到内存会抛出<code>OutOfMemoryError</code></p><h3 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是会被频繁地使用，也可能导致<code>OutOfMemoryError</code><br>直接内存的分配不受JVM控制，但是会受到本机总内存（物理内存，SWAP分区，分页文件）以及处理器寻址空间的限制。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2020/%E7%AE%97%E6%B3%95/sort-algorithm/"/>
    <url>/2020/%E7%AE%97%E6%B3%95/sort-algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>稳定性指相等的元素经过排序之后相对顺序是否发生了改变。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于基于比较的排序算法的时间复杂度，较好的性能是$O(nlogn)$，坏的性能是$O(n^2)$。一个排序算法的理想性能是$O(n)$，但是平均而言不可能达到。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>Selection sort</strong>是较为简单的一种排序算法，每次找到第$i$小的元素，然后将这个元素与数组的第$i$个位置上的元素交换。换句话说：每次找到未完成排序的数组中最小的值，然后将其与边界（已排序和未排序元素的边界）进行交换。</p><ul><li>由于swap操作的存在，因此该算法是一种不稳定的排序算法</li><li>选择排序的最优、平均、最坏时间复杂度都是$O(n^2)$。两层for</li></ul><p>Java：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selection</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex])&#123;                    minIndex = j;                &#125;            &#125;            swap(arr, i, minIndex);        &#125;    &#125;</code></pre></div><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>Bubble Sort</strong>由于在算法的执行过程中，较小的元素像气泡一样慢慢浮到数组的顶端，故称为冒泡排序。</p><p>工作原理：每次检查相邻的两个元素，如果满足排序条件，则交换。经过$i$次扫描，数组末尾的$i$项必然是第$i$大的元素，因此冒泡排序最多需要扫描$n - 1$遍数组就能完成排序。</p><ul><li>稳定的排序算法</li><li>序列完全有序时，冒泡排序只需遍历一次数组，不用执行任何交换操作，时间复杂度位$O (n) $</li><li>最坏情况下，需要进行$\frac{(n - 1)n}{2} $次交换操作。</li><li>平均时间复杂度为$O(n)$</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (flag) &#123;            flag = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length -<span class="hljs-number">1</span>; i++) &#123;                <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;                    flag = <span class="hljs-literal">true</span>;                    swap(arr, i, i + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;</code></pre></div><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>Insertion Sort</strong>：将待排序元素划分为已排序和未排序两部分，每次从未排序元素中选择一个插入到已排序的的元素中的正确位置。</p><p>案例：打扑克牌时，从桌上抓一张牌，按牌的大小插入正确的位置。</p><ul><li>稳定的排序算法</li><li>最优的时间复杂度是$O(n)$</li><li>插入排序的最坏、平均时间复杂度为$O(n^2)$</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                    swap(arr, j, j + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;</code></pre></div><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><strong>Counting Sort</strong>：是一种线性时间的排序算法。</p><p>工作原理：使用一个额外的数组$C$，其中第$i$个元素是待排序数组$A$中值等于$i$的元素的个数，然后通过数组$C$来将$A$中的元素排到正确的位置。</p><p>分为三个步骤：</p><ol><li>计算每个数出现的次数</li><li>求除每个数出现次数的前缀和</li><li>利用出现次数的前缀和，从右至左计算每个数的排名</li></ol><ul><li>稳定的排序算法</li><li>时间复杂度为$O(n + w)$，其中$w$代表待排序数据的值域大小。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] countingSort(<span class="hljs-type">int</span>[] A)&#123;    <span class="hljs-comment">//k是元素大小的上界</span>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;    <span class="hljs-type">int</span>[] C = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];    <span class="hljs-type">int</span>[] B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;        C[A[i]]++;    &#125;    <span class="hljs-comment">//求前缀和</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; i++) &#123;        C[i] = C[i] + C[i -<span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> A.length -<span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> A[j];        B[C[a] - <span class="hljs-number">1</span>] = a;        C[a]--;    &#125;    <span class="hljs-keyword">return</span> B;&#125;</code></pre></div><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>merge sort</strong>：是一种采用了分治思想的排序算法。</p><p>主要分为三个步骤：</p><ul><li>将数组划分为两部分</li><li>递归地对两个子序列进行归并排序 </li><li>合并两个子序列</li></ul><p>性质：</p><ul><li>是一种稳定的排序算法</li><li>最优、最坏、平均时间复杂度均为$O(nlogn)$</li><li>归并排序的空间复杂度为$O(n)$</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low + high) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-comment">//递归地对左右两边进行排序</span>        mergeSort(arr, low, mid);        mergeSort(arr, mid + <span class="hljs-number">1</span>, high);        <span class="hljs-comment">//合并</span>        merge(arr, low, mid, high);    &#125;&#125;<span class="hljs-comment">//merge实际上是将两个有序数组合并成一个有序数组</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> &#123;    <span class="hljs-comment">//temp数组用于暂存合并的结果</span>    <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high - low + <span class="hljs-number">1</span>];    <span class="hljs-comment">//左半边的指针</span>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low;    <span class="hljs-comment">//右半边的指针</span>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">//合并后数组的指针</span>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//将记录由小到大地放进temp数组</span>    <span class="hljs-keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j])            temp[k] = arr[i++];        <span class="hljs-keyword">else</span>            temp[k] = arr[j++];    &#125;    <span class="hljs-comment">//接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中</span>    <span class="hljs-keyword">while</span> (i &lt;= mid)        temp[k++] = arr[i++];    <span class="hljs-keyword">while</span> (j &lt;= high)        temp[k++] = arr[j++];    <span class="hljs-comment">//将temp数组中的元素写入到待排数组中</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; temp.length; l++)        arr[low + l] = temp[l];&#125;</code></pre></div><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>Heap Sort</strong>：利用数据结构中的堆设计的一种排序算法。</p><p>工作原理：对所有待排序元素建堆， 利用最大堆（最小堆）的特性，依次取出堆顶元素，就可以得到排好序的数组。</p><p>当前节点的下为$i$时，它的父结点、左子节点、右子节点的获取方式如下：</p><div class="code-wrapper"><pre><code class="hljs makefile">//向下舍入parent = floor((i -  1) /2);leftChild = 2* i + 1;rightChild = 2 * i + 2;</code></pre></div><ul><li>不稳定的排序算法</li><li>最优、平均、最坏时间复杂度均为$O(nlogn)$。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;        <span class="hljs-comment">//生成大根堆</span>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            heapify(arr, i, len);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length -<span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;            swap(arr, <span class="hljs-number">0</span>, j);            heapify(arr, <span class="hljs-number">0</span>, j);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; length; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">//如果左子节点小于右子节点，k指向右子节点</span>            <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="hljs-number">1</span>]) &#123;                k++;            &#125;            <span class="hljs-keyword">if</span> (arr[k] &gt; temp)&#123;                <span class="hljs-comment">//如果子节点大于父结点，将子节点值赋值给父结点</span>                arr[i] = arr[k];                i = k;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        arr[i] = temp;    &#125;</code></pre></div><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>Quick Sort</strong>：简称为快排，也成为分区交换排序。是一种广泛运用的排序算法。</p><p>基本原理：通过分治思想实现排序。</p><ol><li>选取基准值，以基准值为界，将比它大的和比它小的分别放在两边。</li><li>对子序列进行递归快排，直至序列为空或者只有一个元素。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;        <span class="hljs-keyword">if</span> (start &gt;= end) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partition(arr, start, end);        quickSort(arr, start, pivotIndex - <span class="hljs-number">1</span>);        quickSort(arr, pivotIndex + <span class="hljs-number">1</span>, end);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 分治</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;        <span class="hljs-comment">//将第一个元素作为基准元素</span>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[start];        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start;        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;        <span class="hljs-keyword">while</span> (left != right) &#123;            <span class="hljs-comment">//控制right并左移</span>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;                right--;            &#125;            <span class="hljs-comment">//控制left并右移</span>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;                left++;            &#125;            <span class="hljs-keyword">if</span> (left &lt; right) &#123;                swap(arr, left, right);            &#125;        &#125;        <span class="hljs-comment">//pivot和指针重合点交换</span>        arr[start] = arr[left];        arr[left] = pivot;        <span class="hljs-keyword">return</span> left;    &#125;</code></pre></div><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>Shell Sort</strong>：最小增量排序，是插入排序的一种改进版本。</p><p>工作原理：对不相邻的记录进行比较和移动。</p><ol><li>将待排序数组分成若干个子序列（每个子序列的元素在原始数组中间距相同）</li><li>对这些子序列进行插入排序</li><li>减少每个子序列中元素之间的间距，重复上述过程直至间距减少为1。</li></ol><ul><li>不稳定的排序算法</li><li>最优时间复杂度为$O(n)$。</li><li>平均时间复杂度和最坏时间复杂度与间距序列的选取有关，已知最好的最坏时间复杂度为$O(nlog^2n)$。</li><li>空间复杂度为$O(n)$。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> length)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>) &#123;            h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> h; i &lt; length; i++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123;                    swap(arr, j, j - h);                &#125;            &#125;            h = h / <span class="hljs-number">3</span>;        &#125;&#125;</code></pre></div><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>Radix Sort</strong>：是一种非比较型整数排序算法。</p><p>工作原理：将待排序的元素拆分为$k$个关键字，然后先对第$k$个关键字进行稳定排序，再对第$k - 1$个关键字进行稳定排序，……最后对第一个关键字进行稳定排序。</p><p>大白话：先根据个位排序，再根据十位排序，再按照百位排序……</p><p>基数排序中需要借助一种<strong>稳定算法</strong>完成内层对关键字的排序。</p><p>基数排序根据两种不同的排序顺序，可以分为：</p><ul><li>LSD（Least significant digital）：从低位开始</li><li>MSD（Most significant digital）：从高位开始</li></ul><p>性质：</p><ul><li>基数排序是一种稳定的排序算法。</li><li>如果每个关键字的值域不大，可以使用<strong>计数排序</strong>作为内层排序，此时复杂度为$O(kn + \sum\limits_{i&#x3D;1}^{k}w_i)$，其中$w_i$为第$i$个关键字值域的大小，如果关键字值域很大，就可以使用基于比较的$O(nklogn)$的排序。</li><li>空间复杂度$O(k + n)$</li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><strong>Bucket Sort</strong>：是排序算法的一种，适用于待排序数据值域较大但分布较为均匀的情况。</p><p>步骤：</p><ol><li>设置一个定量的数组当作空桶</li><li>遍历序列，将元素一个个的放入对应的桶中</li><li>对每个不是空的桶中元素取出来，按序放入序列。</li></ol><p>性质：</p><ul><li>如果使用稳定的内层排序，并且将元素插入桶中时不改变元素的相对顺序，那么桶排序是一种稳定的排序算法。</li><li>桶排序的平均时间复杂度为$O(n + n^2&#x2F;k + k)$，（将值域平均分成n块 + 排序 + 重新合并元素），当$k \approx n $时为$O(n)$。</li><li>最坏时间复杂度为$O(n^2)$。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> step)</span> &#123;        <span class="hljs-keyword">return</span> (a - min) / step;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>], min = arr[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : arr) &#123;            <span class="hljs-keyword">if</span> (max &lt; a)                max = a;            <span class="hljs-keyword">if</span> (min &gt; a)                min = a;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">bucketNum</span> <span class="hljs-operator">=</span> max / <span class="hljs-number">10</span> - min / <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;        <span class="hljs-type">List</span> <span class="hljs-variable">buckList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();        <span class="hljs-comment">// create bucket</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= bucketNum; i++) &#123;            buckList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());        &#125;        <span class="hljs-comment">// push into the bucket</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> indexFor(arr[i], min, <span class="hljs-number">10</span>);            ((ArrayList&lt;Integer&gt;) buckList.get(index)).add(arr[i]);        &#125;        ArrayList&lt;Integer&gt; bucket = <span class="hljs-literal">null</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketNum; i++) &#123;            bucket = (ArrayList&lt;Integer&gt;) buckList.get(i);            insertSort(bucket);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : bucket) &#123;                arr[index++] = k;            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(List&lt;Integer&gt; bucket)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; bucket.size(); i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> bucket.get(i);            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span> &amp;&amp; bucket.get(j) &gt; temp; j--) &#123;                bucket.set(j + <span class="hljs-number">1</span>, bucket.get(j));            &#125;            bucket.set(j + <span class="hljs-number">1</span>, temp);        &#125;    &#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>OI WIKI</p><p>Wikipedia</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁的实现方案</title>
    <link href="/2020/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2020/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。</p></blockquote><p>分布式锁需要具备的条件：</p><ul><li>互斥性：在任意一个时刻，只有一个客户端持有锁。</li><li>无死锁：即使持有锁的客户端崩溃或者其他意外事件，锁仍然可以被获取。</li><li>容错：只要大部分Redis节点都活着，客户端可以获取和释放锁。</li></ul><p>分布式锁的主要实现方式：</p><ul><li>数据库</li><li>Redis等缓存数据库，<code>redis</code>的<code>setnx</code></li><li>Zookeeper 临时节点</li></ul><h3 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h3><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span> &#123;    Integer <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;lock&quot;</span>);    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">lock</span> == <span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-number">1</span>);        <span class="hljs-comment">//todo</span>        del(<span class="hljs-string">&quot;lock&quot;</span>);        <span class="hljs-keyword">return</span>;    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//自旋</span>        hello();    &#125;&#125;</code></pre></div><p>存在的问题：</p><ul><li>请求同时打进来，所有请求都获取不到锁</li></ul><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>使用<code>setnx</code>设置锁</p><p><code>setnx</code>在key不存在时可以设置，存在当前key则不操作</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;   String <span class="hljs-keyword">lock</span> = setnx(<span class="hljs-string">&quot;lock&quot;</span>); <span class="hljs-comment">//0代表没有保存数据，说明有人占坑了，1代表占坑成功</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">lock</span> != <span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//todo</span>        del(<span class="hljs-string">&quot;lock&quot;</span>);    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//自旋</span>        hello();    &#125; &#125;</code></pre></div><p>存在的问题：</p><ul><li>由于各种问题（未捕获的异常，断电）等导致锁未释放，其他人永远获取不到锁</li></ul><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;    String <span class="hljs-keyword">lock</span> = setnx(<span class="hljs-string">&quot;lock&quot;</span>);    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">lock</span> != <span class="hljs-number">0</span>)&#123;        expire(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-number">10</span>s);        <span class="hljs-comment">//todo</span>        del(<span class="hljs-string">&quot;lock&quot;</span>);    &#125;<span class="hljs-keyword">else</span> &#123;        hello();    &#125;&#125;</code></pre></div><p>存在的问题：</p><ul><li>刚拿到锁，服务器出现问题，没来得及设置过期时间</li></ul><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">String</span> result = <span class="hljs-title function_">setnxex</span>(<span class="hljs-string">&quot;lock&quot;</span>,10s);    <span class="hljs-keyword">if</span>(result == <span class="hljs-string">&quot;ok&quot;</span>)&#123;        <span class="hljs-comment">//加锁成功</span>        <span class="hljs-comment">//执行业务逻辑</span>        <span class="hljs-comment">//释放锁</span>    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-title function_">hello</span>();    &#125;&#125;</code></pre></div><p>存在的问题：</p><ul><li>如果业务逻辑超时，导致锁自动删除，业务执行完又删除了一遍，至少多个人都获取到了锁。</li></ul><h3 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h3><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title class_">String</span> token = <span class="hljs-variable constant_">UUID</span>;    <span class="hljs-title class_">String</span> result = <span class="hljs-title function_">setnxex</span>(<span class="hljs-string">&quot;lock&quot;</span>,token,10s);    <span class="hljs-keyword">if</span>(result == <span class="hljs-string">&quot;ok&quot;</span>)&#123;        <span class="hljs-comment">//执行业务</span>        <span class="hljs-comment">//释放锁,保证删除自己的锁</span>        <span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;lock&quot;</span>) == token ? <span class="hljs-title function_">del</span>(<span class="hljs-string">&quot;lock&quot;</span>) : <span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre></div><p>存在的问题：</p><ul><li>获取锁的时候，锁的值正在返回的过程中，锁过期，redis删除了锁，但是我们拿到了值，对比成功（此时另一个请求创建了锁），但是该线程又删除了一次锁。</li></ul><p>原因：</p><ul><li>删锁不是原子性的</li><li>解决：<code>Lua</code>脚本</li></ul><h3 id="第六阶段"><a href="#第六阶段" class="headerlink" title="第六阶段"></a>第六阶段</h3><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span> &#123;    String token = UUID;    String <span class="hljs-keyword">lock</span> = redis.setnxex(<span class="hljs-string">&quot;lock&quot;</span>,token,<span class="hljs-number">10</span>s);    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">lock</span> == <span class="hljs-string">&quot;ok&quot;</span>)&#123;        <span class="hljs-comment">//执行业务</span>        <span class="hljs-comment">//脚本删除锁</span>    &#125;<span class="hljs-keyword">else</span> &#123;        hello();    &#125;&#125;</code></pre></div><h2 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h2><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span> &#123;    Rlock <span class="hljs-keyword">lock</span> = redisson.getLock(<span class="hljs-string">&quot;lock&quot;</span>);    <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();    <span class="hljs-comment">//todo</span>    <span class="hljs-keyword">lock</span>.unlock();&#125;</code></pre></div><h2 id="其他方向考虑"><a href="#其他方向考虑" class="headerlink" title="其他方向考虑"></a>其他方向考虑</h2><ul><li>自旋<ul><li>自旋次数</li><li>自旋超时</li></ul></li><li>原子的加锁释放没问题</li><li>锁设置<ul><li>锁粒度：细，记录级别<ul><li>查询商品详情：进缓存-&gt;击穿，穿透，雪崩，不同ID的商品不同的锁</li><li>分析好粒度，不要锁住无关数据，一种数据一种锁，一条数据一个锁</li></ul></li></ul></li><li>锁类型<ul><li>读写锁</li><li>可重入锁</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019和2020</title>
    <link href="/2019/%E9%9A%8F%E7%AC%94/2019-summary/"/>
    <url>/2019/%E9%9A%8F%E7%AC%94/2019-summary/</url>
    
    <content type="html"><![CDATA[<h3 id="2019总结"><a href="#2019总结" class="headerlink" title="2019总结"></a>2019总结</h3><p>在<a href="https://l1n.wang/2019/">2018的总结</a>中，我的2019<code>TodoList</code>都大概实现，在2019年，参加了几个实验室老师的科研项目（搬砖仔），暑假因为实验室项目的原因，并未能出去实习，而是留在学校做项目。</p><p>本年个人完成了以下成绩：</p><ul><li>大创项目 - 基于微信小程序和SSM框架的宿舍服务平台</li><li>在线考试系统</li><li>基于微信小程序的危险品驾驶员安全培训平台</li><li>人力资源大数据分析及智能化服务平台</li><li>智能垃圾桶云平台管理系统</li></ul><p>对自己有满意的环节，也有不满意的环节，总的来说新的一年继续努力，冲冲冲。希望新的一年自己能形成<strong>任务驱动学习</strong>的学习方式。</p><h3 id="展望2020"><a href="#展望2020" class="headerlink" title="展望2020"></a>展望2020</h3><p>希望在2020年的这个时候，能完成下列的<code>TodoList</code>：</p><ul><li>加强算法能力</li><li>读完所有买的书</li><li>继续加强Java技术栈的学习</li><li>多记笔记，多写博客</li><li>适度拓展技术宽度</li><li>争取能在大三下学期去大厂实习</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git命令记录</title>
    <link href="/2019/%E5%B7%A5%E5%85%B7/git-note/"/>
    <url>/2019/%E5%B7%A5%E5%85%B7/git-note/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> notes<span class="hljs-built_in">cd</span> notes<span class="hljs-comment"># 初始化一个git仓库 </span>git init<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;my notes&quot;</span> &gt; readme.md<span class="hljs-comment"># 查看状态</span>git status<span class="hljs-comment"># 查看修改内容</span>git diff readme.md<span class="hljs-comment"># 添加文件到仓库</span>git add readme.md<span class="hljs-comment"># 提交更改</span>git commit -m <span class="hljs-string">&quot;add readme&quot;</span><span class="hljs-comment"># 查看提交日志</span>git <span class="hljs-built_in">log</span><span class="hljs-comment"># 回退到上一个版本</span>git reset --hard HEAD^<span class="hljs-comment"># HEAD: 当前版本</span><span class="hljs-comment"># HEAD^: 上一个版本</span><span class="hljs-comment"># HEAD~100: 前一百个版本</span><span class="hljs-comment"># 58a65b: 指定版本</span></code></pre></div><h4 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h4><div class="code-wrapper"><pre><code class="hljs gherkin">|<span class="hljs-string">-------</span>|<span class="hljs-string">            </span>|<span class="hljs-string">-------</span>|<span class="hljs-string">               </span>|<span class="hljs-string">-------</span>||<span class="hljs-string"> 工作区 </span>|<span class="hljs-string"> -- add --&gt; </span>|<span class="hljs-string"> 暂存区 </span>|<span class="hljs-string"> -- commit --&gt; </span>|<span class="hljs-string"> 主分支 </span>||<span class="hljs-string">-------</span>|<span class="hljs-string">            </span>|<span class="hljs-string">-------</span>|<span class="hljs-string">               </span>|<span class="hljs-string">-------</span>|<span class="hljs-comment"># 查看工作区与暂存区文件的差异</span>git diff readme.md<span class="hljs-comment"># 查看工作区和版本库最新版本的差异</span>git diff HEAD -- readme.md<span class="hljs-comment"># 放弃工作区的修改(未执行 git add 命令)</span>git checkout -- readme.md<span class="hljs-comment"># 撤销暂存区（已经执行了 git add 命令）</span>git reset HEAD readme.md</code></pre></div><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-comment"># 删除文件</span>rm <span class="hljs-keyword">test</span>.txtgit add <span class="hljs-keyword">test</span>.txtgit commit -m <span class="hljs-string">&quot;rm test.txt&quot;</span><span class="hljs-comment"># 直接从版本库中删除文件</span>git rm <span class="hljs-keyword">test</span>.txtgit commit -m <span class="hljs-string">&quot;git rm test.txt&quot;</span><span class="hljs-comment"># 还原文件</span>git reset --hard CommitID</code></pre></div><h3 id="2-远程仓库"><a href="#2-远程仓库" class="headerlink" title="2. 远程仓库"></a>2. 远程仓库</h3><h4 id="Github仓库"><a href="#Github仓库" class="headerlink" title="Github仓库"></a>Github仓库</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 在本地创建一个 gitlearn 目录，并进入</span><span class="hljs-built_in">mkdir</span> gitlearn<span class="hljs-built_in">cd</span> gitlearn<span class="hljs-comment"># 使用命令 git init 初始化一个库</span>git init<span class="hljs-comment"># 添加远程库 origin</span>git remote add origin git@github.com:l1nker4/gitlearn.git<span class="hljs-comment"># 添加 readme.md 文件</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;git learn is very easy!&quot;</span> &gt; readme.md<span class="hljs-comment"># 添加文件并提交到仓库</span>git add readme.mdgit commit -m <span class="hljs-string">&quot;add readme&quot;</span><span class="hljs-comment"># 执行向远程仓库 origin master 分支推送更新（-u 参数用于关联远程仓库）</span>git push -u origin master</code></pre></div><h4 id="更新远程仓库"><a href="#更新远程仓库" class="headerlink" title="更新远程仓库"></a>更新远程仓库</h4><div class="code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 查看当前分支的关联远程仓库</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">vv</span><span class="hljs-comment"># 查看远程仓库的 URL</span><span class="hljs-string">git</span> <span class="hljs-string">remote</span> -<span class="hljs-string">v</span><span class="hljs-comment"># 重新设置远程仓库的 URL</span><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">git</span>@<span class="hljs-string">github</span>.<span class="hljs-string">com:l1nker4/</span><span class="hljs-string">gitlearn</span>.<span class="hljs-string">git</span><span class="hljs-comment"># 将当前修改更新到远程 master 分支</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">origin</span> <span class="hljs-string">master</span></code></pre></div><h3 id="3-分支管理"><a href="#3-分支管理" class="headerlink" title="3.分支管理"></a>3.分支管理</h3><h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><div class="code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-comment"># 查看当前分支</span>git branch <span class="hljs-comment"># 基于当前分支创建新分支</span>git branch dev<span class="hljs-comment"># 切换分支</span>git checkout dev<span class="hljs-comment"># 创建并切换分支</span>git checkout -b dev<span class="hljs-comment"># 切换到 master 分支</span>git checkout <span class="hljs-keyword">master</span><span class="hljs-title"># 合并指定分支到当前分支(合并 dev</span> 分支到 <span class="hljs-keyword">master</span> <span class="hljs-title">分支)</span><span class="hljs-title">git</span> merge dev <span class="hljs-comment"># 删除分支</span>git branch -d dev</code></pre></div><h4 id="冲突管理"><a href="#冲突管理" class="headerlink" title="冲突管理"></a>冲突管理</h4><p>在 master 分支上修改 readme.md，新增一行内容。提交修改。 在 dev 分支上修改 readme.md，也新增一行内容。提交修改。</p><p>然后切换到 master 分支，将 dev 分支的内容合并。</p><div class="code-wrapper"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> dev</code></pre></div><p>会有冲突提醒。打开 readme.md:</p><div class="code-wrapper"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<span class="hljs-section">Creating a new branch is quick &amp; simple.</span><span class="hljs-section">=======</span>Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre></div><p>然后修改内容。再次提交。</p><div class="code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 查看分支合并情况</span><span class="hljs-string">git</span> <span class="hljs-string">log</span> <span class="hljs-built_in">--graph</span>  <span class="hljs-built_in">--pretty=oneline</span> <span class="hljs-built_in">--abbrev-commit</span><span class="hljs-comment"># 工作现场“储藏”</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span><span class="hljs-comment"># 查看储藏的你内容</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">list</span><span class="hljs-comment"># 恢复储藏的内容，并删除</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">pop</span><span class="hljs-comment"># 也可以指定恢复储藏的内容</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">apply</span> <span class="hljs-string">stash</span>@&#123;<span class="hljs-string">0</span>&#125;<span class="hljs-comment"># 删除储藏的内容</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">drop</span></code></pre></div><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 查看远程库的信息</span>git remotegit remote -v<span class="hljs-comment"># 推送分支(推送本地分支到远程分支 master 上)</span>git push <span class="hljs-keyword">origin </span>master <span class="hljs-comment"># 创建本地分支</span>git checkout -<span class="hljs-keyword">b </span>dev <span class="hljs-keyword">origin/dev</span><span class="hljs-keyword"></span><span class="hljs-comment"># 设置本地 dev 分支与远程 origin/dev 分支的链接</span>git <span class="hljs-keyword">branch </span>--set-upstream dev <span class="hljs-keyword">origin/dev</span><span class="hljs-keyword"></span><span class="hljs-comment"># 拉取分支</span>git pull</code></pre></div><h3 id="4-命令表"><a href="#4-命令表" class="headerlink" title="4.命令表"></a>4.命令表</h3><div class="code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">add</span> .                                     <span class="hljs-comment"># 增加当前子目录下所有更改过的文件至index</span><span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">FILENAME</span>                              <span class="hljs-comment"># 添加一个文件到git index</span><span class="hljs-string">git</span> <span class="hljs-string">blame</span> <span class="hljs-string">FILENAME</span>                            <span class="hljs-comment"># 显示文件每一行的修改记录(提交ID, 修改人员)</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span>                                    <span class="hljs-comment"># 显示本地分支</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">a</span>                                 <span class="hljs-comment"># 显示所有分支</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">r</span>                                 <span class="hljs-comment"># 查看远程所有分支</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">vv</span>                                <span class="hljs-comment"># 查看本地和远程的关联关系</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> <span class="hljs-string">branch_0</span>.<span class="hljs-string">1</span> <span class="hljs-string">master</span>                  <span class="hljs-comment"># 从主分支master创建branch_0.1分支</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> <span class="hljs-built_in">--contains</span> <span class="hljs-string">50089</span>                   <span class="hljs-comment"># 显示包含提交50089的分支</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">D</span> <span class="hljs-string">hotfixes</span>/<span class="hljs-string">BJVEP933</span>               <span class="hljs-comment"># 强制删除分支hotfixes/BJVEP933</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">d</span> <span class="hljs-string">hotfixes</span>/<span class="hljs-string">BJVEP933</span>               <span class="hljs-comment"># 删除分支hotfixes/BJVEP933</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">D</span> <span class="hljs-string">master</span> <span class="hljs-string">develop</span>                  <span class="hljs-comment"># 删除本地库develop</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">m</span> <span class="hljs-string">branch_0</span>.<span class="hljs-string">1</span> <span class="hljs-string">branch_1</span>.<span class="hljs-string">0</span>           <span class="hljs-comment"># 将branch_0.1重命名为branch_1.0</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">m</span> <span class="hljs-string">master</span> <span class="hljs-string">master_copy</span>              <span class="hljs-comment"># 本地分支改名</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> <span class="hljs-built_in">--merged</span>                           <span class="hljs-comment"># 显示所有已合并到当前分支的分支</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> <span class="hljs-built_in">--no-merged</span>                        <span class="hljs-comment"># 显示所有未合并到当前分支的分支</span><span class="hljs-string">git</span> <span class="hljs-string">branch</span> -<span class="hljs-string">r</span> -<span class="hljs-string">d</span> <span class="hljs-string">branch_remote_name</span>           <span class="hljs-comment"># 删除远程branch</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> -- <span class="hljs-string">README</span>                        <span class="hljs-comment"># 检出head版本的README文件（可用于修改错误回退）</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> -<span class="hljs-string">b</span> <span class="hljs-string">dev</span>                           <span class="hljs-comment"># 建立一个新的本地分支dev</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> -<span class="hljs-string">b</span> <span class="hljs-string">devel</span> <span class="hljs-string">origin</span>/<span class="hljs-string">develop</span>          <span class="hljs-comment"># 从远程分支develop创建新本地分支devel并检出</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> -<span class="hljs-string">b</span> <span class="hljs-string">master</span> <span class="hljs-string">master_copy</span>            <span class="hljs-comment"># 上面的完整版</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> -<span class="hljs-string">b</span> <span class="hljs-string">master_copy</span>                   <span class="hljs-comment"># 从当前分支创建新分支master_copy并检出</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> <span class="hljs-string">branch_1</span>.<span class="hljs-string">0</span>/<span class="hljs-string">master</span>                <span class="hljs-comment"># 切换到branch_1.0/master分支</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> <span class="hljs-string">dev</span>                              <span class="hljs-comment"># 切换到本地dev分支</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> <span class="hljs-string">features</span>/<span class="hljs-string">performance</span>             <span class="hljs-comment"># 检出已存在的features/performance分支</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> <span class="hljs-built_in">--track</span> <span class="hljs-string">hotfixes</span>/<span class="hljs-string">BJVEP933</span>        <span class="hljs-comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> <span class="hljs-built_in">--track</span> <span class="hljs-string">origin</span>/<span class="hljs-string">dev</span>               <span class="hljs-comment"># 切换到远程dev分支</span><span class="hljs-string">git</span> <span class="hljs-string">checkout</span> <span class="hljs-string">v2</span>.<span class="hljs-string">0</span>                             <span class="hljs-comment"># 检出版本v2.0</span><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">ff44785404a8e</span>                 <span class="hljs-comment"># 合并提交ff44785404a8e的修改</span><span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">GIT_REPO_LINK</span>                       <span class="hljs-comment"># 从服务器上将代码给拉下来</span><span class="hljs-string">git</span> <span class="hljs-string">commit</span> -<span class="hljs-string">am</span> <span class="hljs-string">&#x27;xxx&#x27;</span>                          <span class="hljs-comment"># 将add和commit合为一步</span><span class="hljs-string">git</span> <span class="hljs-string">commit</span> -<span class="hljs-string">m</span> <span class="hljs-string">&#x27;xxx&#x27;</span>                           <span class="hljs-comment"># 提交</span><span class="hljs-string">git</span> <span class="hljs-string">commit</span> -<span class="hljs-string">a</span> -<span class="hljs-string">m</span>                              <span class="hljs-comment"># add/commit</span><span class="hljs-string">git</span> <span class="hljs-string">commit</span> -<span class="hljs-string">a</span> -<span class="hljs-string">v</span>                              <span class="hljs-comment"># 一般提交命令</span><span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-built_in">--amend</span> -<span class="hljs-string">m</span> <span class="hljs-string">&#x27;xxx&#x27;</span>                   <span class="hljs-comment"># 合并上一次提交（用于反复修改）</span><span class="hljs-string">git</span> <span class="hljs-string">commit</span> -<span class="hljs-string">v</span>                                 <span class="hljs-comment"># 当你用－v参数的时候可以看commit的差异</span><span class="hljs-string">git</span> <span class="hljs-string">clean</span> -<span class="hljs-string">df</span>                                 <span class="hljs-comment"># 清理临时文件</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">color</span>.<span class="hljs-string">branch</span> <span class="hljs-string">auto</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">color</span>.<span class="hljs-string">diff</span> <span class="hljs-string">auto</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">color</span>.<span class="hljs-string">interactive</span> <span class="hljs-string">auto</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">color</span>.<span class="hljs-string">status</span> <span class="hljs-string">auto</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">color</span>.<span class="hljs-string">ui</span> <span class="hljs-string">true</span>             <span class="hljs-comment"># git status等命令自动着色</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">user</span>.<span class="hljs-string">email</span> <span class="hljs-string">&quot;xxx@xxx.com&quot;</span>  <span class="hljs-comment"># 配置邮件</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-string">user</span>.<span class="hljs-string">name</span> <span class="hljs-string">&quot;xxx&quot;</span>           <span class="hljs-comment"># 配置用户名</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--list</span>                             <span class="hljs-comment"># 看所有用户</span><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--system</span>                           <span class="hljs-comment"># 配置所有用户公用配置</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span>                                      <span class="hljs-comment"># 显示所有未添加至index的变更</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">HEAD</span>^                                <span class="hljs-comment"># 比较与上一个版本的差异</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">COMMITID1</span> <span class="hljs-string">COMMITID2</span> <span class="hljs-built_in">--name-only</span>      <span class="hljs-comment"># 显示两个节点之间的所有差异文件名</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-built_in">--cached</span>                             <span class="hljs-comment"># 显示所有已添加index但还未commit的变更</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-built_in">--staged</span>                             <span class="hljs-comment"># 同上</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">HEAD</span> -- ./<span class="hljs-string">lib</span>                        <span class="hljs-comment"># 比较与HEAD版本lib目录的差异</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">origin</span>/<span class="hljs-string">master</span>..<span class="hljs-string">master</span>                <span class="hljs-comment"># 比较远程分支master上有本地分支master上没有的</span><span class="hljs-string">git</span> <span class="hljs-string">diff</span> <span class="hljs-string">origin</span>/<span class="hljs-string">master</span>..<span class="hljs-string">master</span> <span class="hljs-built_in">--stat</span>         <span class="hljs-comment"># 只显示差异的文件，不显示具体内容</span><span class="hljs-string">git</span> <span class="hljs-string">fetch</span>                                     <span class="hljs-comment"># 获取所有远程分支（不更新本地分支，另需merge）</span><span class="hljs-string">git</span> <span class="hljs-string">fetch</span> <span class="hljs-built_in">--prune</span>                             <span class="hljs-comment"># 获取所有原创分支并清除服务器上已删掉的分支</span><span class="hljs-string">git</span> <span class="hljs-string">format-patch</span>  <span class="hljs-string">CMTID</span>                       <span class="hljs-comment"># 生成所有的补丁(CMTID, HEAD]  </span><span class="hljs-string">git</span> <span class="hljs-string">am</span> <span class="hljs-string">0001-Fix1</span>.<span class="hljs-string">patch</span>                        <span class="hljs-comment"># 按生成顺序0001,0002应用补丁即可</span><span class="hljs-string">git</span> <span class="hljs-string">fsck</span><span class="hljs-string">git</span> <span class="hljs-string">gc</span><span class="hljs-string">git</span> <span class="hljs-string">grep</span> <span class="hljs-string">&quot;delete from&quot;</span>                        <span class="hljs-comment"># 文件中搜索文本“delete from”</span><span class="hljs-string">git</span> <span class="hljs-string">grep</span> -<span class="hljs-string">e</span> <span class="hljs-string">&#x27;#define&#x27;</span> <span class="hljs-built_in">--and</span> -<span class="hljs-string">e</span> <span class="hljs-string">SORT_DIRENT</span><span class="hljs-string">git</span> <span class="hljs-string">init</span>                                      <span class="hljs-comment"># 初始化本地git仓库（创建新仓库）</span><span class="hljs-string">git</span> <span class="hljs-string">log</span>                                       <span class="hljs-comment"># 显示提交日志</span><span class="hljs-string">git</span> <span class="hljs-string">log</span> -<span class="hljs-string">1</span>                                    <span class="hljs-comment"># 显示1行日志 -n为n行</span><span class="hljs-string">git</span> <span class="hljs-string">log</span> -<span class="hljs-string">5</span><span class="hljs-string">git</span> <span class="hljs-string">log</span> <span class="hljs-built_in">--stat</span>                                <span class="hljs-comment"># 显示提交日志及相关变动文件</span><span class="hljs-string">git</span> <span class="hljs-string">log</span> <span class="hljs-string">v2</span>.<span class="hljs-string">0</span>                                  <span class="hljs-comment"># 显示v2.0的日志</span><span class="hljs-string">git</span> <span class="hljs-string">ls-files</span>                                  <span class="hljs-comment"># 列出git index包含的文件</span><span class="hljs-string">git</span> <span class="hljs-string">ls-tree</span> <span class="hljs-string">HEAD</span>                              <span class="hljs-comment"># 内部命令：显示某个git对象</span><span class="hljs-string">git</span> <span class="hljs-string">merge</span> <span class="hljs-string">origin</span>/<span class="hljs-string">dev</span>                          <span class="hljs-comment"># 将分支dev与当前分支进行合并</span><span class="hljs-string">git</span> <span class="hljs-string">merge</span> <span class="hljs-string">origin</span>/<span class="hljs-string">master</span>                       <span class="hljs-comment"># 合并远程master分支至当前分支</span><span class="hljs-string">git</span> <span class="hljs-string">mv</span> <span class="hljs-string">README</span> <span class="hljs-string">README2</span>                         <span class="hljs-comment"># 重命名文件README为README2</span><span class="hljs-string">git</span> <span class="hljs-string">pull</span>                                      <span class="hljs-comment"># 本地与服务器端同步</span><span class="hljs-string">git</span> <span class="hljs-string">pull</span> <span class="hljs-string">origin</span> <span class="hljs-string">master</span>                        <span class="hljs-comment"># 获取远程分支master并merge到当前分支</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">remote_repo</span> <span class="hljs-string">branch_name</span>              <span class="hljs-comment"># 将本地分支推送到服务器上去。</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-built_in">--force</span>                              <span class="hljs-comment"># 推送会失败，可用强制推送</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">origin</span> :<span class="hljs-string">branch_remote_name</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">origin</span> :<span class="hljs-string">hotfixes</span>/<span class="hljs-string">BJVEP933</span>            <span class="hljs-comment"># 删除远程仓库的hotfixes/BJVEP933分支</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">origin</span> <span class="hljs-string">master</span>                        <span class="hljs-comment"># 将当前分支push到远程master分支</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">origin</span> <span class="hljs-string">master:hb-</span><span class="hljs-string">dev</span>                 <span class="hljs-comment"># 将本地库与服务器上的库进行关联</span><span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-built_in">--tags</span>                               <span class="hljs-comment"># 把所有tag推送到远程仓库</span><span class="hljs-string">git</span> <span class="hljs-string">rebase</span> <span class="hljs-string">upstream</span>/<span class="hljs-string">branch</span>                    <span class="hljs-comment"># 合并分支</span><span class="hljs-string">git</span> <span class="hljs-string">rebase</span> -<span class="hljs-string">i</span> <span class="hljs-string">408700955</span>                       <span class="hljs-comment"># 合并多次提交为一次提交</span><span class="hljs-string">git</span> <span class="hljs-string">reflog</span>                                    <span class="hljs-comment"># 显示所有提交，包括孤立节点</span><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">add</span> <span class="hljs-string">upstream</span>  <span class="hljs-string">URL</span>                  <span class="hljs-comment"># 增加远程定义（用于push/pull/fetch）</span><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">show</span> <span class="hljs-string">origin</span>                        <span class="hljs-comment"># 显示远程库origin里的资源</span><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">show</span>                               <span class="hljs-comment"># 查看远程库</span><span class="hljs-string">git</span> <span class="hljs-string">reset</span> <span class="hljs-built_in">--hard</span> <span class="hljs-string">HEAD</span>                         <span class="hljs-comment"># 将当前版本重置为HEAD（</span><span class="hljs-string">git</span> <span class="hljs-string">revert</span> <span class="hljs-string">dfb02e6e4</span>                          <span class="hljs-comment"># 撤销提交 dfb02e6e4</span><span class="hljs-string">git</span> <span class="hljs-string">rev-parse</span> <span class="hljs-string">v2</span>.<span class="hljs-string">0</span>                            <span class="hljs-comment"># 内部命令：显示某个ref对于的SHA1 HASH</span><span class="hljs-string">git</span> <span class="hljs-string">rm</span> [<span class="hljs-string">file</span> <span class="hljs-string">name</span>]                            <span class="hljs-comment"># 删除一个文件</span><span class="hljs-string">git</span> <span class="hljs-string">rm</span> <span class="hljs-string">a</span>.<span class="hljs-string">a</span>                                    <span class="hljs-comment"># 移除文件(从暂存区和工作区中删除)</span><span class="hljs-string">git</span> <span class="hljs-string">rm</span> <span class="hljs-built_in">--cached</span> <span class="hljs-string">a</span>.<span class="hljs-string">a</span>                           <span class="hljs-comment"># 移除文件(只从暂存区中删除)</span><span class="hljs-string">git</span> <span class="hljs-string">rm</span> -<span class="hljs-string">f</span> <span class="hljs-string">a</span>.<span class="hljs-string">a</span>                                 <span class="hljs-comment"># 强行移除修改后文件(从暂存区和工作区中删除)</span><span class="hljs-string">git</span> <span class="hljs-string">rm</span> -<span class="hljs-string">r</span> *                                   <span class="hljs-comment"># 递归删除</span><span class="hljs-string">git</span> <span class="hljs-string">rm</span> <span class="hljs-string">xxx</span>                                    <span class="hljs-comment"># 删除index中的文件</span><span class="hljs-string">git</span> <span class="hljs-string">rm</span> <span class="hljs-string">FILENAME</span>                               <span class="hljs-comment"># 从git中删除指定文件</span><span class="hljs-string">git</span> <span class="hljs-string">show</span>                                      <span class="hljs-comment"># 等价于 git show HEAD</span><span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">CMTID</span>                                <span class="hljs-comment"># 显示某个提交的详细内容</span><span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">CMTID</span> <span class="hljs-built_in">--name-only</span><span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">HEAD</span>                                 <span class="hljs-comment"># 显示HEAD提交日志</span><span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">HEAD</span>@&#123;<span class="hljs-string">5</span>&#125;<span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">HEAD</span>^                                <span class="hljs-comment"># 显示HEAD的父（上一个版本）的提交日志 </span><span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">HEAD</span>~<span class="hljs-string">3</span><span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">master</span>@&#123;<span class="hljs-string">yesterday</span>&#125;                   <span class="hljs-comment"># 显示master分支昨天的状态</span><span class="hljs-string">git</span> <span class="hljs-string">show</span> -<span class="hljs-string">s</span> <span class="hljs-built_in">--pretty=raw</span> <span class="hljs-string">CMTID</span><span class="hljs-string">git</span> <span class="hljs-string">show</span> <span class="hljs-string">v2</span>.<span class="hljs-string">0</span>                                 <span class="hljs-comment"># 显示v2.0的日志及详细内容</span><span class="hljs-string">git</span> <span class="hljs-string">show-branch</span>                               <span class="hljs-comment"># 图示当前分支历史</span><span class="hljs-string">git</span> <span class="hljs-string">show-branch</span> <span class="hljs-built_in">--all</span>                         <span class="hljs-comment"># 图示所有分支历史</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span>                                     <span class="hljs-comment"># 暂存当前修改，将所有至为HEAD状态</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">apply</span> <span class="hljs-string">stash</span>@&#123;<span class="hljs-string">0</span>&#125;                     <span class="hljs-comment"># 应用第一次暂存</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">list</span>                                <span class="hljs-comment"># 查看所有暂存</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">pop</span>                                 <span class="hljs-comment"># 将文件从临时空间pop下来</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">push</span>                                <span class="hljs-comment"># 将文件给push到一个临时空间中</span><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">show</span> -<span class="hljs-string">p</span> <span class="hljs-string">stash</span>@&#123;<span class="hljs-string">0</span>&#125;                   <span class="hljs-comment"># 参考第一次暂存</span><span class="hljs-string">git</span> <span class="hljs-string">status</span>                                    <span class="hljs-comment"># 查看当前版本状态（是否修改）</span><span class="hljs-string">git</span> <span class="hljs-string">tag</span>                                       <span class="hljs-comment"># 显示已存在的tag</span><span class="hljs-string">git</span> <span class="hljs-string">tag</span> -<span class="hljs-string">a</span> <span class="hljs-string">v2</span>.<span class="hljs-string">0</span> -<span class="hljs-string">m</span> <span class="hljs-string">&#x27;xxx&#x27;</span>                      <span class="hljs-comment"># 增加v2.0的tag</span><span class="hljs-string">git</span> <span class="hljs-string">whatchanged</span>                               <span class="hljs-comment"># 显示提交历史对应的文件修改</span><span class="hljs-string">git</span> <span class="hljs-string">update-index</span> <span class="hljs-built_in">--assume-unchanged</span> <span class="hljs-string">file</span>      <span class="hljs-comment"># 忽略修改，git status不会显示</span><span class="hljs-string">git</span> <span class="hljs-string">update-index</span> <span class="hljs-built_in">--no-assume-unchanged</span> <span class="hljs-string">file</span>   <span class="hljs-comment"># 添加被忽略文件，git status会显示</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/2019/%E5%B7%A5%E5%85%B7/docker/"/>
    <url>/2019/%E5%B7%A5%E5%85%B7/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker概念"><a href="#1-Docker概念" class="headerlink" title="1.Docker概念"></a>1.Docker概念</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/docker/docker.png" alt="docker.png"></p><ul><li>虚拟机运行在虚拟的硬件上，应用运行在虚拟机内核上，而Docker是机器上的一个进程，Docker应用是Docker的一个子进程。</li><li>Docker是对Linux容器（LXC）的一种封装，提供简单易用的接口，Docker是目前最流行的Linux容器解决方案。</li></ul><h3 id="Docker用途"><a href="#Docker用途" class="headerlink" title="Docker用途"></a>Docker用途</h3><ul><li>提供一次性的环境。主要用于测试。</li><li>提供云服务</li><li>组建微服务架构。</li></ul><h3 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h3><p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p><ul><li>一种服务器，它是一种称为守护进程并且长时间运行的程序。</li><li>REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。</li><li>一个有命令行界面工具的客户端。</li></ul><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/docker/620140640_31678.png" alt="620140640_31678.png"></p><h3 id="Docker系统架构"><a href="#Docker系统架构" class="headerlink" title="Docker系统架构"></a>Docker系统架构</h3><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器和对象的关系可以类似于对象和类。</p><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/docker/262150629_86976.png" alt="262150629_86976.png"></p><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>在Linux下，内核启动会挂载<code>root</code>文件系统，Docker镜像就相当于一个<code>root</code>文件系统，它除了提供容器运行时所需的程序，资源，配置之外，还有一些配置参数（匿名卷，环境变量，用户）。</p><p>Docker镜像使用分层存储技术，它并非像ISO镜像那样的文件，镜像是一个虚拟的概念，它是由一组文件系统构成。</p><h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><p>容器的本质是进程，容器进程运行于属于自己的命名空间，它可以拥有自己的<code>root</code>文件系统，自己的网络配置等宿主机可以有的东西。</p><p>每一个容器运行时，都是以镜像为基础层，在其上创建一个当前容器的存储层，可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p><h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>存放镜像的地方</p><h2 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2.安装Docker"></a>2.安装Docker</h2><h4 id="1-获取脚本并下载"><a href="#1-获取脚本并下载" class="headerlink" title="1.获取脚本并下载"></a>1.获取脚本并下载</h4><div class="code-wrapper"><pre><code class="hljs dsconfig">//从官网获取安装脚本$ <span class="hljs-string">curl</span> -<span class="hljs-string">fsSL</span> <span class="hljs-string">get</span>.<span class="hljs-string">docker</span>.<span class="hljs-string">com</span> -<span class="hljs-string">o</span> <span class="hljs-built_in">get-docker.sh</span>//使用<span class="hljs-string">AzureChinaCloud</span>镜像脚本$ <span class="hljs-string">sudo</span> <span class="hljs-string">sh</span> <span class="hljs-built_in">get-docker.sh</span> <span class="hljs-built_in">--mirror</span> <span class="hljs-string">AzureChinaCloud</span></code></pre></div><h4 id="2-启动Docker"><a href="#2-启动Docker" class="headerlink" title="2.启动Docker"></a>2.启动Docker</h4><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker</span><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> systemctl start docker</span></code></pre></div><h4 id="3-建立Docker用户组"><a href="#3-建立Docker用户组" class="headerlink" title="3.建立Docker用户组"></a>3.建立Docker用户组</h4><p>docker命令只有root用户和docker组的用户才能访问docker引擎</p><h5 id="建立Docker组"><a href="#建立Docker组" class="headerlink" title="建立Docker组"></a>建立Docker组</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> groupadd docker</span></code></pre></div><h5 id="将当前用户加入Docker组"><a href="#将当前用户加入Docker组" class="headerlink" title="将当前用户加入Docker组"></a>将当前用户加入Docker组</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span></span></code></pre></div><h5 id="校验是否安装成功"><a href="#校验是否安装成功" class="headerlink" title="校验是否安装成功"></a>校验是否安装成功</h5><div class="code-wrapper"><pre><code class="hljs shell">l1nker4@zero:~$ docker version Client: Version:           18.09.6 API version:       1.39 Go version:        go1.10.8 Git commit:        481bc77 Built:             Sat May  4 02:35:57 2019 OS/Arch:           linux/amd64 Experimental:      falseServer: Docker Engine - Community Engine:  Version:          18.09.6  API version:      1.39 (minimum version 1.12)  Go version:       go1.10.8  Git commit:       481bc77  Built:            Sat May  4 01:59:36 2019  OS/Arch:          linux/amd64  Experimental:     false</code></pre></div><h4 id="4-添加镜像加速器"><a href="#4-添加镜像加速器" class="headerlink" title="4. 添加镜像加速器"></a>4. 添加镜像加速器</h4><h5 id="新建daemon-json文件"><a href="#新建daemon-json文件" class="headerlink" title="新建daemon.json文件"></a>新建daemon.json文件</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">touch</span> /etc/docker/daemon.json</span></code></pre></div><h5 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h5><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3.常用命令"></a>3.常用命令</h2><h4 id="1-镜像操作"><a href="#1-镜像操作" class="headerlink" title="1.镜像操作"></a>1.镜像操作</h4><table><thead><tr><th align="center">名称</th><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">搜索</td><td align="center">docker search xxx</td><td align="center">搜索镜像</td></tr><tr><td align="center">拉取</td><td align="center">docker pull xxx</td><td align="center">从仓库拉取镜像</td></tr><tr><td align="center">列表</td><td align="center">docker images</td><td align="center">列出所有镜像</td></tr><tr><td align="center">删除</td><td align="center">docker rmi imageID</td><td align="center">删除镜像</td></tr></tbody></table><h4 id="2-容器操作"><a href="#2-容器操作" class="headerlink" title="2.容器操作"></a>2.容器操作</h4><table><thead><tr><th align="center">名称</th><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">运行</td><td align="center">docker run –name container-name -d image-name</td><td align="center">–name：自定义容器名，-d：后台运行，image-name：指定镜像模板</td></tr><tr><td align="center">列表</td><td align="center">docker ps</td><td align="center">查看运行中的容器，-a：查看所有容器</td></tr><tr><td align="center">停止</td><td align="center">docker stop container-name&#x2F;container-id</td><td align="center">停止当前你运行的容器</td></tr><tr><td align="center">启动</td><td align="center">docker start container-name&#x2F;container-id</td><td align="center">启动容器</td></tr><tr><td align="center">删除</td><td align="center">docker rm container-id</td><td align="center">s删除指定容器</td></tr><tr><td align="center">端口映射</td><td align="center">-p 6379:6379</td><td align="center">-p：主机端口映射到容器内部端口</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8888</span>:<span class="hljs-number">8080</span> tomcat</code></pre></div><p>-d：后台运行，-p：端口映射</p><h2 id="3-Dockerfile制作镜像"><a href="#3-Dockerfile制作镜像" class="headerlink" title="3. Dockerfile制作镜像"></a>3. Dockerfile制作镜像</h2><h3 id="1-FROM指定基础镜像"><a href="#1-FROM指定基础镜像" class="headerlink" title="1.FROM指定基础镜像"></a>1.FROM指定基础镜像</h3><p>举例：</p><div class="code-wrapper"><pre><code class="hljs bash">FROM tomcat</code></pre></div><h3 id="2-RUN执行命令"><a href="#2-RUN执行命令" class="headerlink" title="2.RUN执行命令"></a>2.RUN执行命令</h3><p>RUN每条运行的命令都会创建一层新的镜像。 可以使用<code>&amp;&amp;</code>进行命令的连接。</p><h4 id="1-shell格式"><a href="#1-shell格式" class="headerlink" title="1.shell格式"></a>1.shell格式</h4><div class="code-wrapper"><pre><code class="hljs bash">FROM tomcatRUN <span class="hljs-built_in">echo</span> “hello docker” &gt; /usr/local/tomcat/webapps/ROOT/index.html</code></pre></div><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><div class="code-wrapper"><pre><code class="hljs bash">docker build -t <span class="hljs-built_in">test</span> .</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">Sending build context to Docker daemon  2.048kBStep 1/2 : FROM tomcat ---&gt; 3639174793baStep 2/2 : RUN <span class="hljs-built_in">echo</span> “hello docker” &gt; /usr/local/tomcat/webapps/ROOT/index.html ---&gt; Running <span class="hljs-keyword">in</span> c96cba308c1fRemoving intermediate container c96cba308c1f ---&gt; caafbd6ff4d7Successfully built caafbd6ff4d7Successfully tagged <span class="hljs-built_in">test</span>:latest</code></pre></div><h3 id="COPY指令"><a href="#COPY指令" class="headerlink" title="COPY指令"></a>COPY指令</h3><div class="code-wrapper"><pre><code class="hljs bash">COPY xxx.zip /usr/local/tomcat/webapps/ROOTRUN unzip xxx.zip</code></pre></div><h3 id="WORKDIR指令"><a href="#WORKDIR指令" class="headerlink" title="WORKDIR指令"></a>WORKDIR指令</h3><p>指定一个工作目录</p><div class="code-wrapper"><pre><code class="hljs bash">WORKDIR /usr/local/tomcat/webapps/ROOT</code></pre></div><h4 id="构建一个tomcat项目镜像"><a href="#构建一个tomcat项目镜像" class="headerlink" title="构建一个tomcat项目镜像"></a>构建一个tomcat项目镜像</h4><div class="code-wrapper"><pre><code class="hljs bash">FROM tomcatWORKDIR /usr/local/tomcat/webapps/ROOTRUN <span class="hljs-built_in">rm</span> -rf *COPY xxx.zop .RUN unzip xxx.zipRUN <span class="hljs-built_in">rm</span> -rf xxx.zipWORKDIR /usr/local/tomcat</code></pre></div><p>构建</p><div class="code-wrapper"><pre><code class="hljs bash">l1nker4@zero:/usr/local/docker/tomcat$ docker build -t xxx .Sending build context to Docker daemon   38.4kBStep 1/7 : FROM tomcat ---&gt; 3639174793baStep 2/7 : WORKDIR /usr/local/tomcat/webapps/ROOT ---&gt; Running <span class="hljs-keyword">in</span> ee67259a7a84Removing intermediate container ee67259a7a84 ---&gt; 32c64a82f43bStep 3/7 : RUN <span class="hljs-built_in">rm</span> -rf * ---&gt; Running <span class="hljs-keyword">in</span> 9c44abff5efdRemoving intermediate container 9c44abff5efd ---&gt; 20a5867132f8Step 4/7 : COPY xxx.zip . ---&gt; c182ed4b79c8Step 5/7 : RUN unzip xxx.zip ---&gt; Running <span class="hljs-keyword">in</span> 445e7367894fArchive:  xxx.zip  inflating: rbac.jpg.jpeg           Removing intermediate container 445e7367894f ---&gt; d567880bc000Step 6/7 : RUN <span class="hljs-built_in">rm</span> -rf xxx.zip ---&gt; Running <span class="hljs-keyword">in</span> 2875fbb6a7f8Removing intermediate container 2875fbb6a7f8 ---&gt; 08ee1b530f77Step 7/7 : WORKDIR /usr/local/tomcat ---&gt; Running <span class="hljs-keyword">in</span> 96a93d9b9091Removing intermediate container 96a93d9b9091 ---&gt; a15ba09df769Successfully built a15ba09df769Successfully tagged xxx:latest</code></pre></div><h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><p>和COPY的格式和性质类似，但是有新增的功能。源路径可以是一个<code>URL</code>，下载后文件权限设置为<code>600</code>（当前用户可读可写，小组无权限，其他组无权限）</p><p>如果源路径是一个<code>tar</code>压缩文件，可以自动解压。</p><h2 id="4-Docker守护态运行"><a href="#4-Docker守护态运行" class="headerlink" title="4.Docker守护态运行"></a>4.Docker守护态运行</h2><p>同时启动两个tomcat</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -p 8080:8080 --name tomcat -d tomcatdocker run -p 8081:8080 --name tomcat1 -d tomcat</code></pre></div><h2 id="5-数据卷"><a href="#5-数据卷" class="headerlink" title="5.数据卷"></a>5.数据卷</h2><ul><li>数据卷是一个或多个容器使用的特殊目录</li><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立刻更新</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器删除</li></ul><p>问题：容器被销毁，容器中的数据将一并被销毁，容器中的数据不是持久化存在的。</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -p 8080:8080 --name tomcat -d -v /usr/local/docker/tomcat/ROOT:/usr/local/tomcat/webapps/ROOT</code></pre></div><p>相当于将宿主机的目录映射到docker容器中目录。</p><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><div class="code-wrapper"><pre><code class="hljs bash">docker run -p 3306:3306 --name mysql \-v /usr/local/docker/conf:/etc/mysql \-v /usr/local/docker/logs:/var/log/mysql \-v /usr/local/docker/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \-d mysql:5.7.22</code></pre></div><h2 id="6-Docker-Compose"><a href="#6-Docker-Compose" class="headerlink" title="6.Docker Compose"></a>6.Docker Compose</h2><p>Docker官方开源项目，Compose定位是定义和运行多个Docker容器的应用。</p><p>两个概念</p><ul><li>服务：一个应用的容器，可以运行多个相同镜像的容器实例。</li><li>项目：由一组关联的应用容器组成一个完整的业务单元，在<code>docker-compose.yml</code>中定义。</li></ul><h3 id="1-安装Docker-compose"><a href="#1-安装Docker-compose" class="headerlink" title="1.安装Docker-compose"></a>1.安装Docker-compose</h3><div class="code-wrapper"><pre><code class="hljs bash">curl -L https://github.com/docker/compose/releases/download/1.25.0-rc1/docker-compose-`<span class="hljs-built_in">uname</span> -s`-`<span class="hljs-built_in">uname</span> -m` -o /usr/local/bin/docker-compose<span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose</code></pre></div><h4 id="Docker-Compose部署Tomcat"><a href="#Docker-Compose部署Tomcat" class="headerlink" title="Docker Compose部署Tomcat"></a>Docker Compose部署Tomcat</h4><p><code>docker-compose.yml</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">tomcat:</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">tomcat</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span></code></pre></div><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker入门教程</a></p><p><a href="http://jm.taobao.org/2016/05/12/introduction-to-docker">Docker 容器概念</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FastDFS使用入门</title>
    <link href="/2019/Linux/fastdfs-01/"/>
    <url>/2019/Linux/fastdfs-01/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FastDFS是一个开源的分布式文件系统，主要有以下功能。</p><p>分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 </p><p>FastDFS主要有以下特点：</p><ul><li>文件存储</li><li>文件同步</li><li>文件访问（上传、下载）</li><li>存取负载均衡</li><li>在线扩容</li></ul><h2 id="FastDFS的架构"><a href="#FastDFS的架构" class="headerlink" title="FastDFS的架构"></a>FastDFS的架构</h2><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/1526205318630.png" alt="1526205318630.png"></p><p>由三个部分组成：Client，Tracker Server，Storage Server。</p><p>Client是上传下载数据的服务器，Tracker Server是跟踪服务器，主要做调度工作，起到负载均衡，管理所有的Storage Server。Storage Server：存储服务器，主要提供容量和备份服务。</p><h2 id="FastDFS安装"><a href="#FastDFS安装" class="headerlink" title="FastDFS安装"></a>FastDFS安装</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>操作系统：Ubuntu 18.04</p><h4 id="下载libfastcommon"><a href="#下载libfastcommon" class="headerlink" title="下载libfastcommon"></a>下载libfastcommon</h4><div class="code-wrapper"><pre><code class="hljs bash">wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz</code></pre></div><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><div class="code-wrapper"><pre><code class="hljs bash">tar -zxvf V1.0.7.tar.gz<span class="hljs-built_in">cd</span> libfastcommon-1.0.7</code></pre></div><h4 id="编译-安装"><a href="#编译-安装" class="headerlink" title="编译 安装"></a>编译 安装</h4><div class="code-wrapper"><pre><code class="hljs bash">./make.sh./make.sh install</code></pre></div><h4 id="设置软链接"><a href="#设置软链接" class="headerlink" title="设置软链接"></a>设置软链接</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so<span class="hljs-built_in">ln</span> -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so<span class="hljs-built_in">ln</span> -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so<span class="hljs-built_in">ln</span> -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</code></pre></div><h4 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h4><div class="code-wrapper"><pre><code class="hljs bash">wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gztar -zxvf V5.05.tar.gz<span class="hljs-built_in">cd</span> fastdfs-5.05./make.sh./make.sh install</code></pre></div><h4 id="配置Tracker服务器"><a href="#配置Tracker服务器" class="headerlink" title="配置Tracker服务器"></a><strong>配置Tracker服务器</strong></h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/fdfs<span class="hljs-built_in">cp</span> tracker.conf.sample tracker.confvim tracker.conf</code></pre></div><p>修改<code>base_path</code>为指定目录</p><h4 id="启动Tracker服务器"><a href="#启动Tracker服务器" class="headerlink" title="启动Tracker服务器"></a>启动Tracker服务器</h4><div class="code-wrapper"><pre><code class="hljs bash">fdfs_trackerd /etc/fdfs/tracker.conf start</code></pre></div><h4 id="关闭Tracker服务器"><a href="#关闭Tracker服务器" class="headerlink" title="关闭Tracker服务器"></a>关闭Tracker服务器</h4><div class="code-wrapper"><pre><code class="hljs bash">fdfs_trackerd /etc/fdfs/tracker.conf stop</code></pre></div><p>启动后查看是否运行成功</p><div class="code-wrapper"><pre><code class="hljs bash">netstat -unltp|grep fdfs</code></pre></div><h4 id="配置Storage服务器"><a href="#配置Storage服务器" class="headerlink" title="配置Storage服务器"></a>配置Storage服务器</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/fdfs<span class="hljs-built_in">cp</span> storage.conf.sample storage.confvim storage.conf</code></pre></div><p>修改 <code>base_path</code>，<code>store_path0</code>，<code>tracker_server</code>三个配置项</p><h4 id="启动Storage服务器"><a href="#启动Storage服务器" class="headerlink" title="启动Storage服务器"></a>启动Storage服务器</h4><div class="code-wrapper"><pre><code class="hljs bash">fdfs_storaged /etc/fdfs/storage.conf start</code></pre></div><p>查看存储节点的集群状态信息</p><div class="code-wrapper"><pre><code class="hljs bash">/usr/bin/fdfs_monitor /etc/fdfs/storage.conf</code></pre></div><h3 id="测试文件上传"><a href="#测试文件上传" class="headerlink" title="测试文件上传"></a>测试文件上传</h3><div class="code-wrapper"><pre><code class="hljs bash">/usr/bin/fdfs_upload_file client.conf /tmp/1.txt</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis学习笔记</title>
    <link href="/2019/Java%E5%9F%BA%E7%A1%80/mybatis-note/"/>
    <url>/2019/Java%E5%9F%BA%E7%A1%80/mybatis-note/</url>
    
    <content type="html"><![CDATA[<h3 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h3><p>开源免费框架，原名叫iBatis</p><p>作用：数据访问层框架，底层是对JDBC的封装</p><p>优点：</p><ul><li>使用mybatis时不需要编写实现类，只需要写执行的sql命令</li></ul><h3 id="Mybatis简单使用"><a href="#Mybatis简单使用" class="headerlink" title="Mybatis简单使用"></a>Mybatis简单使用</h3><p>mybatis-config.xml：全局配置文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3308/learnjsp?useSSL=false&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>mapper.xml文件：编写需要执行的SQL命令，把XML文件理解成实现类</p><p>UserMapper.xml：配置了sql语句，以及sql的封装规则</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace:命名空间--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.UserMapper&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">    id:sql语句的唯一标识</span><span class="hljs-comment">    parameterType:定义参数类型</span><span class="hljs-comment">    resultType:返回值类型</span><span class="hljs-comment">    如果方法返回值返回的是list,在resultType中写List的泛型</span><span class="hljs-comment">#&#123;id&#125;:外部传入的参数</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.model.User&quot;</span>&gt;</span>        select uid,uname,pwd,sex,age from t_user where id = #&#123;id&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.test;<span class="hljs-keyword">import</span> com.test.model.User;<span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ：L1nker4</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> ： 创建于  2019/3/10 17:19</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>： test</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);        <span class="hljs-comment">//获取sqlSession实例，能直接执行已经映射的sql语句</span>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">openSession</span> <span class="hljs-operator">=</span>  sqlSessionFactory.openSession();        List&lt;User&gt; user = openSession.selectList(<span class="hljs-string">&quot;com.test.UserMapper.selectUser&quot;</span>);        System.out.println(user);        <span class="hljs-comment">//关闭session</span>        openSession.close();    &#125;&#125;</code></pre></div><p>Mybatis使用步骤：</p><ol><li><p>根据配置文件，创建一个SqlSessionFactory对象</p></li><li><p>sql映射文件，配置sql语句</p></li><li><p>将sql映射文件注册到全局配置文件中</p></li><li><p>写代码</p><ol><li>根据全局配置文件得到SqlSessionFactory</li><li>使用sqlSession工厂，获取到sqlSession对象使用它来执行增删改查，一个SqlSession就是代表和数据库的一次会话，用完关闭。</li><li>使用sql的唯一标识来告诉Mybatis执行哪个sql，sql语句都保存在sql映射文件中。</li></ol></li></ol><p>接口式编程</p><div class="code-wrapper"><pre><code class="hljs">原生：Dao====&gt;DaoImplMybatis      Mapper ====&gt;xxMapper.xml</code></pre></div><p>mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。</p><p>mybatis的配置文件：包含数据库连接池的信息，事务管理器信息等，系统运行环境。</p><p>sql映射文件：保存了每一个sql语句的映射信息。</p><h3 id="Mybatis全局配置文件"><a href="#Mybatis全局配置文件" class="headerlink" title="Mybatis全局配置文件"></a>Mybatis全局配置文件</h3><p>Mybatis的配置文件包含了影响Mybatis行为的设置（setting）和属性（properties）信息。</p><p>configuration 配置</p><div class="code-wrapper"><pre><code class="hljs">properties属性settings 设置typeAliases 类型命名typeHandlers 类型处理器objectFactory 对象工厂plugins插件environments 环境    environment 环境变量        transactionManager事务管理器        dataSource 数据源</code></pre></div><p>databaseIdProvider 提供多个数据库厂商</p><p>mappers 映射器</p><h4 id="properties-引入配置"><a href="#properties-引入配置" class="headerlink" title="properties 引入配置"></a>properties 引入配置</h4><p>引入外部properties配置文件的内容</p><p>resource：类路径下的资源</p><p>url：引入网络路径i心爱的资源</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><h4 id="setting-Mybatis设置"><a href="#setting-Mybatis设置" class="headerlink" title="setting Mybatis设置"></a>setting Mybatis设置</h4><p><img src="C:\Users\l1nke\AppData\Roaming\Typora\typora-user-images\1553326004994.png" alt="1553326004994"></p><p>setting：用来设置每一个设置项</p><div class="code-wrapper"><pre><code class="hljs">name：设置项名value：值</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre></div><h4 id="typeAliases-别名处理器"><a href="#typeAliases-别名处理器" class="headerlink" title="typeAliases 别名处理器"></a>typeAliases 别名处理器</h4><p>typeAliases：可以为Java类型起别名</p><div class="code-wrapper"><pre><code class="hljs">type：指定要起别名的类型全类名，默认别名就是类名小写alias：指定新的别名，</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.model.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre></div><h5 id="package：批量起别名"><a href="#package：批量起别名" class="headerlink" title="package：批量起别名"></a>package：批量起别名</h5><div class="code-wrapper"><pre><code class="hljs">name：指定包名（为当前包以及下面的所有后代包的每一个类都起一个默认别名）</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.test.entities&quot;</span>&gt;</span></code></pre></div><p>批量起别名的情况下，使用@Alias注解为某个类型指定新的别名</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Alias(&quot;per&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;    &#125;</code></pre></div><h4 id="environments-环境"><a href="#environments-环境" class="headerlink" title="environments 环境"></a>environments 环境</h4><p>Mybatis可以配置多种环境，default属性指定使用某种环境</p><p>environment：配置一个具体的环境信息，必须有以下两个标签，id代表当前环境的唯一标识</p><div class="code-wrapper"><pre><code class="hljs">transactionManager：事务管理器，        type：事务管理器的类型，JDBC和MANAGED        自定义事务管理器，实现TransactionFactory接口即可dataSource：数据源        type：数据源类型，UNPOOLED，POOLED，JNDI        自定义数据源：实现DataSourceFactory接口</code></pre></div><p>​</p><h4 id="databaseIdProvider-提供多数据库厂商"><a href="#databaseIdProvider-提供多数据库厂商" class="headerlink" title="databaseIdProvider 提供多数据库厂商"></a>databaseIdProvider 提供多数据库厂商</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">databaseIdProvider</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;DB_VENDOR&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!--为不同的数据库厂商起别名--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MySQL&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Oracle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;oracle&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">databaseIdProvider</span>&gt;</span></code></pre></div><p>在sql映射文件中使用databaseId指定查询哪个数据库（值由配置文件中的别名决定）</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">databaseId</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span>        select uid,uname,pwd,sex,age from t_user;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h4 id="mappers-映射"><a href="#mappers-映射" class="headerlink" title="mappers 映射"></a>mappers 映射</h4><p>将sql映射注册到全局配置中</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><p>注册配置文件</p><p>resource：引入类路径下的映射文件</p><p>url：引入磁盘或者网络路径下的映射文件</p><p>注册接口</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.dao.UserMapper&quot;</span> /&gt;</span></code></pre></div><p>class：引用接口</p><p>接口和映射文件同名，并且存在于同一目录下</p><h5 id="批量注册"><a href="#批量注册" class="headerlink" title="批量注册"></a>批量注册</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx.com.dao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span></code></pre></div><p>配置文件和dao一个目录</p><h3 id="Mybatis映射文件"><a href="#Mybatis映射文件" class="headerlink" title="Mybatis映射文件"></a>Mybatis映射文件</h3><p>cache：命名空间的二级缓存配置</p><p>cache-ref：其他命名空间缓存配置的引用。</p><p>resultMap：自定义结果集映射</p><p>sql：抽取可重用语句块</p><p>insert：映射插入语句</p><p>update：映射更新语句</p><p>delete：映射删除语句</p><p>select：映射查询语句</p><p>mybatis允许增删改直接定义为：long，boolen，Integer。void</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//这种方式需要手动提交事务，openSession.commit();</span><span class="hljs-type">SqlSession</span> <span class="hljs-variable">openSession</span> <span class="hljs-operator">=</span>  sqlSessionFactory.openSession();<span class="hljs-comment">//这种不需要提交事务</span><span class="hljs-type">SqlSession</span> <span class="hljs-variable">openSession</span> <span class="hljs-operator">=</span>  sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);</code></pre></div><p>MySQL支持自增主键，自增主键的获取，mybatis利用statement.getGenratedKeys()，</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">insert</span> id<span class="hljs-operator">=</span>&quot;addUser&quot; parameterType<span class="hljs-operator">=</span>&quot;com.test.model.User&quot; useGeneratedKeys<span class="hljs-operator">=</span>&quot;true&quot; keyProperty<span class="hljs-operator">=</span>&quot;id&quot;<span class="hljs-operator">&gt;</span>        <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user(uname, pwd, sex, age)        <span class="hljs-keyword">values</span> (#&#123;uname&#125;,#&#123;pwd&#125;,#&#123;sex&#125;,#&#123;age&#125;)<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">insert</span><span class="hljs-operator">&gt;</span></code></pre></div><p>useGeneratedKeys&#x3D;”true”，使用自增主键获取主键值策略</p><h4 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h4><p>单个参数</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span>&gt;</span>        delete from t_user where uid = #&#123;uid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></code></pre></div><p>多个参数（多个参数会被封装成一个map）</p><p>key：param1，paramN</p><p>value：传入的参数值</p><p>#{}是从map中获取指定的key的值</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByIdAndUname&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>        select * from t_user where uid = #&#123;param1&#125; and uname = #&#123;param2&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h6 id="使用-Param注解"><a href="#使用-Param注解" class="headerlink" title="使用@Param注解"></a>使用@Param注解</h6><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserByIdAndUname</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> Integer uid, <span class="hljs-meta">@Param(&quot;uname&quot;)</span> String uname)</span>;</code></pre></div><p>@Param注解指定对应的key值</p><h4 id="和-的取值区别"><a href="#和-的取值区别" class="headerlink" title="#和$的取值区别"></a>#和$的取值区别</h4><p>${}：取出的值直接拼接在sql语句中，会有安全问题</p><p>#{}：是以预编译的形式，将参数设置到sql语句中，PreparedStatement</p><p>大多情况下，取参数都应该使用#{}</p><p>原生jdbc不支持占位符的地方，可以使用$进行取值</p><p>比如 ：分表，按照年份分表拆分</p><div class="code-wrapper"><pre><code class="hljs xml">select * from $&#123;year&#125;_salary where xxx;</code></pre></div><p>#{}可以规定参数的一些规则</p><p>javaType，jdbcType，mode（存储过程），numericScale，resultMap，typeHandler，jdbcTypeName，</p><p>jdbcType</p><h4 id="select元素"><a href="#select元素" class="headerlink" title="select元素"></a>select元素</h4><p>id：唯一标识符</p><p>parameterType：参数类型</p><p>resultType：返回值类型，如果返回的是一个集合，要写集合中元素的类型。</p><h6 id="多条记录封装成一个map"><a href="#多条记录封装成一个map" class="headerlink" title="多条记录封装成一个map"></a>多条记录封装成一个map</h6><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUnameReturnMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.model.User&quot;</span>&gt;</span>        select * from t_user where uname like #&#123;uname&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@MapKey(&quot;uid&quot;)</span>    <span class="hljs-keyword">public</span> Map&lt;Integer,User&gt; <span class="hljs-title function_">getUserByUnameReturnMap</span><span class="hljs-params">(String uname)</span>;MapKey标注某个元素为主键</code></pre></div><h6 id="association指定联合的JavaBean对象"><a href="#association指定联合的JavaBean对象" class="headerlink" title="association指定联合的JavaBean对象"></a>association指定联合的JavaBean对象</h6><p>property：指定哪个属性是联合的对象</p><p>javaType：指定这个属性对象的类型</p><h6 id="association定义关联对象的封装规则"><a href="#association定义关联对象的封装规则" class="headerlink" title="association定义关联对象的封装规则"></a>association定义关联对象的封装规则</h6><p>select：表明当前属性是调用select指定的方法查出的结果</p><p>column：指定将哪一列的值传给这个方法</p><p>流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.test.dao.UserMapper.getUserByIdAndUname&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;d_id&quot;</span>/&gt;</span></code></pre></div><h5 id="延时加载"><a href="#延时加载" class="headerlink" title="延时加载"></a>延时加载</h5><p>在关联查询中，例如：查询用户订单情况时，只查用户信息而不查订单，可以启用延时加载</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre></div><h5 id="collection定义关联集合"><a href="#collection定义关联集合" class="headerlink" title="collection定义关联集合"></a>collection定义关联集合</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;MyUser&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.model.User&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uid&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;uname&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pwd&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;com.test.model.Department&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs">    ofType：指定集合里面元素类型</code></pre></div><p>collection封装一个集合</p><h6 id="将多列的值传递过去"><a href="#将多列的值传递过去" class="headerlink" title="将多列的值传递过去"></a>将多列的值传递过去</h6><p>将多列的值封装map传递过去</p><p>column&#x3D;{key1&#x3D;column1,key2&#x3D;column2}</p><h4 id="discriminator鉴别器"><a href="#discriminator鉴别器" class="headerlink" title="discriminator鉴别器"></a>discriminator鉴别器</h4><p>mybatis可以通过discriminator判断某列的值，然后根据某列的值改变封装行为</p><p>例如：如果查出的是女生，就把部门信息查询出来，否则不查询</p><div class="code-wrapper"><pre><code class="hljs">   如果是男生，就把username赋值给email</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">discriminator</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span>            <span class="hljs-comment">&lt;!--女生 resultType：指定封装的结果类型--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">case</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.test.dao.UserMapper.getUserByIdAndUname&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;d_id&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">case</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.test.dao.UserMapper.getUserByIdAndUname&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;d_id&quot;</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">case</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">discriminator</span>&gt;</span></code></pre></div><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><h4 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByConditionIf&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.model.User&quot;</span>&gt;</span>        select * from t_user        where            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;uid != null&quot;</span>&gt;</span>                uid = #&#123;uid&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;uname != null&quot;</span>&gt;</span>                and uname = #&#123;&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>test：OGNL表达式</p><p>遇见特殊字符需要转义</p><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>可以防止因为if语句不显示，直接拼接and报错</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;uid != null&quot;</span>&gt;</span>       uid = #&#123;uid&#125;   <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;uname != null&quot;</span>&gt;</span>       and uname = #&#123;&#125;   <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span></code></pre></div><p>where标签会将所有的查询条件都包括在内。mybatis会将where标签中拼接的sql多出来的and</p><p>或者or去掉，<strong>where只会去掉第一个多出来的and或者or</strong></p><h4 id="Trim-字符串截取"><a href="#Trim-字符串截取" class="headerlink" title="Trim 字符串截取"></a>Trim 字符串截取</h4><p>自定义字符串截取规则</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></code></pre></div><p>prefix：前缀，trim标签体中是整个字符串拼串后的结果，prefix给拼串后的整个字符加一个前缀</p><p>prefixOverrides：前缀覆盖，去掉整个字符串前面多余的字符</p><p>suffix：后缀，suffix给拼串后的整个字符加一个后缀</p><p>suffixOverrides：后缀覆盖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span></code></pre></div><p>上述代码解释：在字符串前面加一个where，将后缀的and去掉</p><h4 id="choose-when-otherwise-分支选择"><a href="#choose-when-otherwise-分支选择" class="headerlink" title="choose-when-otherwise 分支选择"></a>choose-when-otherwise 分支选择</h4><p>相当于switch-case</p><p>需求：如果带了id就用id查，如果带了lastName就用lastName查</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUnameReturnMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.model.User&quot;</span>&gt;</span>        select * from t_user        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id!=null&quot;</span>&gt;</span>                    id = #&#123;id&#125;                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;uname!=null&quot;</span>&gt;</span>                    uname = #&#123;uname&#125;                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set元素可以用于动态包含需要更新的列,可以动态删除多余的逗号</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item_id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>       #&#123;item_id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span></code></pre></div><p>collection：指定要遍历的集合<br>        list类型的参数会特殊处理封装在map中，map的key就叫list<br>item：将当前遍历出的元素赋值给指定的变量<br>separator：每个元素中的分隔符<br>open：遍历死哦有的结果拼接一个开始的字符<br>close：拼接一个结束的字符<br>index：索引</p><h4 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h4><p>不止方法传过来的参数可以用来判断并取值</p><p>mybatis默认还有两个内置参数</p><p>_parameter：代表整个参数</p><div class="code-wrapper"><pre><code class="hljs">单个参数：_parameter就是这个参数多个参数：参数会被封装成一个map，_parameter就代表这个map</code></pre></div><p>_databaseId：如果配置了databaseIdProvider标签，_databaseId就代表当前数据库的别名</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;_databaseId==&#x27;mysql&#x27;&quot;</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;_parameter!=null&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></code></pre></div><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>可以将OGNL表达式的值绑定到一个变量中的值</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_lastName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lastName&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>    select * from users where lastName = #&#123;_lastName&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>&gt;</span>    emp_id, emp_name, gender, email, d_id  <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmp&quot;</span>&gt;</span>insert into tbl_emp (    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    )    values xxxxx<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><p>sql标签里面只能用<code>$&#123;&#125;</code>进行取值</p><h3 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h3><p>分为一级缓存（本地缓存）和二级缓存（全局缓存）</p><ul><li>默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启</li><li>二级缓存需要手动开启和配置，基于namespace级别的缓存</li><li>为了提高拓展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来自定义二级缓存</li></ul><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><p>与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果获取相同的数据，直接去缓存中取。</p><p>失效情况：</p><ul><li>sqlsession不同</li><li>sqlsession相同，查询条件不同</li><li>sqlsession相同，两次查询之间执行了增删改操作</li><li>sqlsession相同，手动清除了一级缓存</li></ul><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>基于namespace级别的缓存，一个namespace对应一个二级缓存。</p><h5 id="开启全局二级缓存配置"><a href="#开启全局二级缓存配置" class="headerlink" title="开启全局二级缓存配置"></a>开启全局二级缓存配置</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span></code></pre></div><h5 id="mapper-xml中配置"><a href="#mapper-xml中配置" class="headerlink" title="mapper.xml中配置"></a>mapper.xml中配置</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><ul><li>eviction：缓存回收策略<ul><li>LRU最近最少使用的：移除最长时间不被使用的对象</li><li>FIFO        先进先出，按对象进入缓存的顺序来移除他们 </li><li>SOFT       软引用，移除基于垃圾回收器状态和软引用规则的对象</li><li>WEAK      弱引用，更积极地移除基于垃圾回收器状态和弱引用规则的对象</li><li>默认是LRU</li></ul></li><li>flushInterval：缓存刷新间隔（默认不清空）单位 毫秒</li><li>readOnly：是否只读<ul><li>true：只读，mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据，不安全，速度快</li><li>false：非只读</li></ul></li><li>size：缓存中存放多少元素</li><li>type：指定自定义缓存的全类名，实现Cache接口</li></ul><h5 id="实体类实现序列化接口"><a href="#实体类实现序列化接口" class="headerlink" title="实体类实现序列化接口"></a>实体类实现序列化接口</h5>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习笔记（一）</title>
    <link href="/2019/Java%E5%9F%BA%E7%A1%80/spring01/"/>
    <url>/2019/Java%E5%9F%BA%E7%A1%80/spring01/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Spring介绍"><a href="#Spring介绍" class="headerlink" title="Spring介绍"></a>Spring介绍</h2><ol><li>Spring是一个开源框架。</li><li>Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。</li><li>Spring是一个IOC(DI)和AOP容器框架。</li><li>轻量级：Spring是非侵入式的-基于Spring开发的应用中的对象可以不依赖于Spring的API</li><li>依赖注入(DI)：Dependency Injection，IOC</li><li>面向切面编程（AOP-aspect oriented programming）</li><li>容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期</li><li>框架：Spring实现了使用简单的组件配置组合成一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象。</li><li>一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库</li></ol><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ul><li>IoC容器</li><li>Spring事件</li><li>资源管理</li><li>国际化</li><li>校验</li><li>数据绑定</li><li>类型转换</li><li>Spring表达式</li><li>面向切面编程</li></ul><h3 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><p>IOC（Inversion of Control）：其思想是反转资源获取的方向。</p><p>传统的资源查找方式要求组件向容器发起请求查找资源，作为回应，容器适时的返回资源，而应用了IOC之后，则是容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源，这种行为 也被称为查找的被动形式。</p><p>IoC容器的职责：</p><ul><li>依赖处理<ul><li>依赖查找</li><li>依赖注入</li></ul></li><li>生命周期管理<ul><li>容器</li><li>托管的资源</li></ul></li><li>配置<ul><li>容器</li><li>外部化配置</li><li>托管资源</li></ul></li></ul><p>DI：IOC的另一种表述方式，即组件以一些预先定义好的方式（例如：setter方法）接受来自如容器的资源注入，相对于IOC而言，这种表述更直接。</p><h3 id="配置Bean"><a href="#配置Bean" class="headerlink" title="配置Bean"></a>配置Bean</h3><p>配置形式：基于XML文件的方式，基于注解的方式</p><p>Bean的配置方式：通过全类名（反射），通过工厂方法（静态工厂方法&amp;实例工厂方法），FactoryBean</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--配置Bean--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloWorld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;HelloWorld&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>class：bean的全类名，通过反射的方式在IOC容器中创建bean，所以要求bean要有无参构造器</p><p>id：标识容易中的bean，id唯一</p><p>Spring提供了两种类型的IOC容器实现：</p><ul><li>BeanFactory：IOC容器的基本实现</li><li>ApplicationContext 提供了更多的高级特大型，是BeanFactory的子接口</li></ul><p>BeanFactory是Spring框架的基础设施，面向Spring本身</p><p>ApplicationContext 面向使用Spring框架的开发者，几乎所有的应用场合都直接使用ApplicationContext</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<span class="hljs-type">HelloWorld</span> <span class="hljs-variable">helloWorld</span> <span class="hljs-operator">=</span> (HelloWorld) ctx.getBean(<span class="hljs-string">&quot;helloWorld&quot;</span>);</code></pre></div><p>利用id定位到IOC容器中的Bean</p><p>ApplicationContext 代表IOC容器</p><p>ApplicationContext的两个实现类</p><p>ClassPathXmlApplicationContext 是从类路径下加载配置文件</p><p>FileSystemXmlApplicationContext从文件系统中加载配置文件</p><h3 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h3><h4 id="属性注入-最常用"><a href="#属性注入-最常用" class="headerlink" title="属性注入(最常用)"></a>属性注入(最常用)</h4><p>即通过setter方法注入Bean的属性值或依赖的对象</p><p>属性注入使用<code>&lt;property&gt;</code>元素，使用name属性指定bean的属性名称，value属性，或者value子节点指定属性值</p><p>属性注入是实际应用中最常用的注入方式</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span></code></pre></div><h4 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h4><p>通过构造方法注入Bean的属性值或者依赖的对象，他保证了Bean实例在实例化后就可以使用。</p><p>构造器注入在<code>&lt;constructor-arg&gt;元素里声明属性</code></p><p><code>&lt;constructor-arg&gt;</code>中没有name属性</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以指定参数的位置和参数的类型，以区分重载的构造器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Car&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BMW&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Shanghai&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>240<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></code></pre></div><p>若注入的值含有特殊字符，可以使用<code>&lt;![CDATA[]]&gt;将字面值包起来</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&lt;![CDATA[&lt;shanghai^]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></code></pre></div><h4 id="工厂方式注入"><a href="#工厂方式注入" class="headerlink" title="工厂方式注入"></a>工厂方式注入</h4><p>（很少使用，不推荐）</p><h5 id="在Bean中引用其他Bean"><a href="#在Bean中引用其他Bean" class="headerlink" title="在Bean中引用其他Bean"></a>在Bean中引用其他Bean</h5><p>（ref元素）</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Preson&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Tom&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;24&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;car2&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>也可以在属性或构造器里包含Bean的声明</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--内部bean，不能被外部引用，只能在内部使用--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;car&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Car&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ford&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Chanan&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;200000&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;double&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div><h4 id="null-值和级联属性"><a href="#null-值和级联属性" class="headerlink" title="null 值和级联属性"></a>null 值和级联属性</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></code></pre></div><p>级联属性</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;car.price&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20000&quot;</span>/&gt;</span></code></pre></div><p>为级联属性赋值：属性需要先初始化后才能为级联属性赋值，否则会有异常。</p><h3 id="集合属性"><a href="#集合属性" class="headerlink" title="集合属性"></a>集合属性</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--测试配置集合属性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.collection.Person&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mike&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;27&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cars&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;car&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;car2&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>数组也用<code>&lt;list&gt;</code></p><p>Set使用<code>&lt;set&gt;</code></p><p>Map类型</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置map属性值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;newPerson&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.collection.NewPerson&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;rose&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;28&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cars&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;AA&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;car&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;BB&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;car2&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div><p>Properties类型</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置Properties属性值--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.collection.DataSource&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://xxx<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;DriverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h4 id="p命名空间"><a href="#p命名空间" class="headerlink" title="p命名空间"></a>p命名空间</h4><p>通过p命名空间为bean的属性赋值，需要先导入p命名空间</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person5&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.collection.Person&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;Queen&quot;</span> <span class="hljs-attr">p:cars-ref</span>=<span class="hljs-string">&quot;cars&quot;</span>/&gt;</span></code></pre></div><h3 id="Spring自动装配"><a href="#Spring自动装配" class="headerlink" title="Spring自动装配"></a>Spring自动装配</h3><p>在<code>&lt;bean&gt;</code>的autowire属性里面指定自动装配的模式。</p><h5 id="原始方式"><a href="#原始方式" class="headerlink" title="原始方式"></a>原始方式</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Address&quot;</span> <span class="hljs-attr">p:city</span>=<span class="hljs-string">&quot;Beijing&quot;</span> <span class="hljs-attr">p:street</span>=<span class="hljs-string">&quot;tiananmen&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Car&quot;</span> <span class="hljs-attr">p:brand</span>=<span class="hljs-string">&quot;Audi&quot;</span> <span class="hljs-attr">p:price</span>=<span class="hljs-string">&quot;300000&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Person&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;Tom&quot;</span> <span class="hljs-attr">p:address-ref</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">p:car-ref</span>=<span class="hljs-string">&quot;car&quot;</span>/&gt;</span></code></pre></div><h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Person&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;Tom&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>/&gt;</span></code></pre></div><p><strong>使用autowire属性指定自动装配的方式</strong></p><p>byName：根据bean的名字和当前bean的setter风格的属性名进行自动装配</p><p>ByType：根据bean的类型和当前bean的属性的类型进行自动装配，若IOC容器中有一个以上的类型匹配的Bean，则抛异常。</p><h5 id="自动装配的缺点"><a href="#自动装配的缺点" class="headerlink" title="自动装配的缺点"></a>自动装配的缺点</h5><p>不够灵活，autowire要么根据类型自动匹配，要么根据名称自动匹配，不能兼有。</p><p>实际的项目中很少使用自动装配</p><h3 id="Bean之间的关系"><a href="#Bean之间的关系" class="headerlink" title="Bean之间的关系"></a>Bean之间的关系</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Address&quot;</span> <span class="hljs-attr">p:city</span>=<span class="hljs-string">&quot;BeiJing&quot;</span> <span class="hljs-attr">p:street</span>=<span class="hljs-string">&quot;WuDaoKou&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Address&quot;</span> <span class="hljs-attr">p:street</span>=<span class="hljs-string">&quot;DaZongShi&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span></code></pre></div><ul><li>Spring允许继承Bean的配置</li><li>子Bean从父Bean中继承配置，包括Bean的属性配置</li><li>子Bean也可以覆盖从父Bean继承过来的配置</li><li>父Bean可以作为配置模板，也可以作为Bean实例，若想把父Bean作为模板，可以<strong>设置<code>&lt;bean&gt;</code>的abstract属性为True</strong>，这样Spring将不会实例化这个Bean，这个抽象Bean就是用来继承的。</li><li>并不是Bean元素里面所有属性都会被继承，比如：autowire，abstract等</li><li>也可以忽略父Bean的class属性，让子Bean指定自己的类，而共享相同的属性配置，但此时必须设为true</li></ul><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>需求：在配置Person时，必须有一个关联的car，换句话说person这个Bean依赖于car这个Bean</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Car&quot;</span> <span class="hljs-attr">p:brand</span>=<span class="hljs-string">&quot;Audi&quot;</span> <span class="hljs-attr">p:price</span>=<span class="hljs-string">&quot;300000&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.autowire.Person&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;tom&quot;</span> <span class="hljs-attr">p:address-ref</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">depends-on</span>=<span class="hljs-string">&quot;car&quot;</span>/&gt;</span></code></pre></div><ul><li>Spring允许用户通过depends-on属性设定Bean前置依赖的Bean，前置依赖的Bean会在本Bean实例化之前创建好。</li><li>如果前置依赖于多个Bean，则可以通过逗号，空格的方式配置Bean的名称</li></ul><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>在 Spring 中, 可以在 <code>&lt;bean&gt; </code>元素的 scope 属性里设置 Bean 的作用域. </p><p>singleton：默认值，容器初始化时创建bean实例，在整个容器的生命周期内只创建这一个bean，单例的。</p><p>prototype：原型的，容器初始化时不创建bean实例 ，而在每次请求时都创建一个新的Bean实例，并返回</p><h3 id="使用外部属性文件"><a href="#使用外部属性文件" class="headerlink" title="使用外部属性文件"></a>使用外部属性文件</h3><p>在配置文件里面配置Bean的时候，有时候需要在Bean的配置里面混入系统部署的细节信息（文件路径，数据源配置信息），而这些部署细节实际上需要和Bean配置相分离。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入属性文件--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">context:properties</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;db.properties&quot;</span>/&gt;</span>  <span class="hljs-comment">&lt;!--使用外部属性文件的属性--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;user&#125;&quot;</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driverclass&#125;&quot;</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbcUrl&#125;&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h3 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h3><ul><li>Spring表达式语言：是一个支持运行时查询和操作对象圈的强大的表达式语言。</li><li>语法类似于EL，SpEL使用#{—}作为定界符</li><li>SpEL为Bean的属性进行动态赋值提供了便利。</li></ul><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ul><li>Spring IOC容器可以管理Bean的生命周期，Spring允许在Bean生命周期的特定点执行定制的任务。</li><li>在Bean的声明里面设置init-method和destory-method属性，为Bean指定初始化和销毁方法。</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.cycle.Car&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destory&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;brand&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Audi&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans-cycle.xml&quot;</span>);        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> (Car) ctx.getBean(<span class="hljs-string">&quot;car&quot;</span>);        System.out.println(car);        ctx.close();    &#125;</code></pre></div><h3 id="Bean的后置处理器"><a href="#Bean的后置处理器" class="headerlink" title="Bean的后置处理器"></a>Bean的后置处理器</h3><ul><li>Bean的后置处理器允许在调用初始化方法前后对Bean进行额外的处理</li><li>Bean后置处理器对IOC容器里面的所有Bean实例逐一处理。而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性。</li></ul><p>实现<strong>BeanPostProcessor</strong>接口，并实现：</p><blockquote><p>Object postProcessBeforeInitialization(Object bean, String beanName)&#x2F;&#x2F;init-method之前被调用<br>Object postProcessAfterInitialization(Object bean, String beanName)&#x2F;&#x2F;init-method之后被调用</p></blockquote><p>bean：bean实例本身</p><p>beanName：IOC容器配置的Bean的名字</p><p>返回值：是实际上返回给用户的那个Bean，注意：可以在以上两个方法中修改返回的Bean，甚至返回一个新的Bean</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置bean的后置处理器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.cycle.MyBeanPostProcessor&quot;</span>/&gt;</span></code></pre></div><p><code>MyBeanPostProcessor.java</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object o, String s)</span> <span class="hljs-keyword">throws</span> BeansException &#123;        System.out.println(<span class="hljs-string">&quot;postProcessBeforeInitialization：&quot;</span>+o+<span class="hljs-string">&quot;,&quot;</span>+s);        <span class="hljs-keyword">return</span> o;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object o, String s)</span> <span class="hljs-keyword">throws</span> BeansException &#123;        System.out.println(o+s);        <span class="hljs-keyword">return</span> o;    &#125;&#125;</code></pre></div><h3 id="工厂方法配置Bean"><a href="#工厂方法配置Bean" class="headerlink" title="工厂方法配置Bean"></a>工厂方法配置Bean</h3><h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><p>直接调用某一个类的静态方法就可以返回Bean实例</p><blockquote><p>通过静态工厂方法来配置Bean，不是配置静态工厂方法实例，而是配置Bean实例。</p></blockquote><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.factory.StaticCarFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getCar&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Audi&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p>class：指向静态工厂方法的全类名</p><p>factory-method：只想静态工厂方法的名字</p><p>constructor-arg：配置传入的参数</p><h4 id="实例工厂方法"><a href="#实例工厂方法" class="headerlink" title="实例工厂方法"></a>实例工厂方法</h4><p>现需要创建工厂本身，再调用工厂的实例方法来返回Bean实例</p><h3 id="FactoryBean配置"><a href="#FactoryBean配置" class="headerlink" title="FactoryBean配置"></a>FactoryBean配置</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.spring.FactoryBean.CarFactoryBean&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;brand&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BMW&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><p><code>com.test.spring.FactoryBean.CarFactoryBean</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span> &#123;    <span class="hljs-keyword">private</span> String brand;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBrand</span><span class="hljs-params">(String brand)</span> &#123;        <span class="hljs-built_in">this</span>.brand = brand;    &#125;    <span class="hljs-comment">//返回bean的对象</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(brand, <span class="hljs-number">400000</span>);    &#125;    <span class="hljs-comment">//返回bean的类型</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;        <span class="hljs-keyword">return</span> Car.class;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><h3 id="注解配置Bean"><a href="#注解配置Bean" class="headerlink" title="注解配置Bean"></a>注解配置Bean</h3><h4 id="在classpath中扫描组件"><a href="#在classpath中扫描组件" class="headerlink" title="在classpath中扫描组件"></a>在classpath中扫描组件</h4><ul><li><p>Spring能够从classpath下自动扫描，侦测和实例化具有特定注解的组件</p></li><li><p>组件包括：</p><ul><li>@Component：基本注解，标识了一个受Spring管理的组件</li><li>@Respository：标识持久层组件</li><li>@Service：标识业务层组件</li><li>@Controller：标识表现层组件           UserService    userService</li></ul></li><li><p>对于扫描到的组件，Spring有默认的命名策略，使用非限定类名，第一个字母小写，<strong>也可以在注解中通过value属性标识组件的名称</strong></p></li><li><p>在组件类上使用了特定的注解之后，还需要在Spring的配置文件中声明 <code>&lt;context:component-scan&gt;</code></p><ul><li>base-package属性指定一个需要扫描的基类包，Spring容器会将扫描的这个基类包里及其子包中的所有类</li><li>resource-pattern属性扫描的资源</li><li><code>&lt;context:include-filter&gt;</code>子节点表示要包含的目标类</li><li><code>&lt;context:exclude-filter&gt;</code>子节点表示要排除在外的目标类，需要use-default-filters配合使用</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.test.spring.annotation.entity&quot;</span> <span class="hljs-attr">resource-pattern</span>=<span class="hljs-string">&quot;repository/*.class&quot;</span>/&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.test.spring.annotation.entity&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre></div><p><code>&lt;context:component-scan&gt;</code>元素还会自动注册AutowiredAnnotationBeanPostProcessor实例，该实例可以自动装配具有**@Autowired和@Resource，@Inject注解**的属性</p><h4 id="使用-Autowired自动装配Bean"><a href="#使用-Autowired自动装配Bean" class="headerlink" title="使用@Autowired自动装配Bean"></a>使用@Autowired自动装配Bean</h4><p>@Autowired注解自动装配具有兼容类型的单个Bean属性</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018和2019</title>
    <link href="/2018/%E9%9A%8F%E7%AC%94/2018-summary/"/>
    <url>/2018/%E9%9A%8F%E7%AC%94/2018-summary/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><p>其实对过去也没什么好说的，记性不怎么好，高三以来的零模一模二模高考，暑假也算真正的体验了一下社会，在一家Web服务外包的小公司做了一个月的实习，主要也就是网站运营，简单的代码审计，还帮他们搭了一个Tomcat服务器来跑客服系统，（上班一小时 划水八小时）总的来说，965的工作制挺好的。</p><p>然后就是大学，学生会的组织一个都没加，可能感觉自己的性格不适合集体。加了实验室，要感谢丁工程学长和刘凡学长在学习中的帮助。</p><h3 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h3><p>下面这段话是某位大佬发在知乎上面的关于技术的学习方法，很喜欢这些观点，就贴在这里了。</p><blockquote><p>不要搞个人崇拜，止于跟比自己弱的吹牛逼和捧着比自己强的臭脚，欺软怕硬几句话就跳脚，玻璃心，戾气深重之辈。不要做这样的人，技术本来就是一个唯我独尊的道路。</p><p>同上，戒骄戒躁，让内心真正的平静，安安静静的去研究技术少吹牛逼、水、浪费时间这句话你我共勉。</p><p>同学圈&amp;同事圈是否认可合不合群（安全研究大多喜欢独身但心思单纯常为社会生活关系问题困扰），而身边通常没有志同道合的人往往没有圈子。没有圈子就是最好的圈子，人若无名便可专心练剑是亘古不变的道理。现在学的大多是青少年学生，不要怕被人孤立，长大后你会发现根本没有孤立不孤立这回事，你今后的大部分人生跟这些人完全没有交集，你只要不听不看不问不想，专研你的技术成为你梦想成为的那个人，路上的冷言嘲讽只是一个历练过程，你会碰到更好的人，会有一个很好的家庭，记得孝顺父母，赡养老人。</p></blockquote><p>对自己有几个小目标：</p><ul><li>学好Java后端开发，能快速的接触到实验室的项目开发中</li><li>暑假实习积累经验</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PHP-Challenge-1</title>
    <link href="/2018/Web%E5%AE%89%E5%85%A8/PHP-Challenge-1/"/>
    <url>/2018/Web%E5%AE%89%E5%85%A8/PHP-Challenge-1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="0x01-弱类型"><a href="#0x01-弱类型" class="headerlink" title="0x01 弱类型"></a>0x01 弱类型</h1><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-title function_ invoke__">show_source</span>(<span class="hljs-keyword">__FILE__</span>);<span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;xxxx&quot;</span>;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;time&#x27;</span>]))&#123;         <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;time&#x27;</span>]))&#123;                 <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;The time must be number.&#x27;</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;time&#x27;</span>] &lt; <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> * <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//5184000</span>                        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;This time is too short.&#x27;</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;time&#x27;</span>] &gt; <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span> * <span class="hljs-number">3</span>)&#123; <span class="hljs-comment">//7776000</span>                        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;This time is too long.&#x27;</span>;         &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-title function_ invoke__">sleep</span>((<span class="hljs-keyword">int</span>)<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;time&#x27;</span>]);                 <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;         &#125;                 <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;hr&gt;&#x27;</span>; &#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>程序逻辑大致如下： </p><ol><li>通过<strong>is_numeric</strong>判断<strong>time</strong>是否为数字</li><li>要求输入的<strong>time</strong>位于<strong>5184000</strong>和<strong>7776000</strong>之间</li><li>将输入的<strong>time</strong>转换为<strong>int</strong>并传入**sleep()**函数</li></ol><p>如果真的将传入的<strong>time</strong>设置为上述的区间，那么程序的**sleep()**函数将会让我们一直等。</p><p>这里运用到PHP弱类型的性质就可以解决，<strong>is_numeric()<strong>函数支持十六进制字符串和科学记数法型字符串，而</strong>int</strong>强制转换下，会出现错误解析。</p><blockquote><p>5184000  -&gt;   0x4f1a00</p></blockquote><p>因此第一种方法，我们可以传入**?time&#x3D;0x4f1a01**</p><p>还有就是科学记数法类型的**?time&#x3D;5.184001e6**，五秒钟还是可以等的。</p><h1 id="0x02-配置文件写入问题"><a href="#0x02-配置文件写入问题" class="headerlink" title="0x02 配置文件写入问题"></a>0x02 配置文件写入问题</h1><blockquote><p>index.php</p></blockquote><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$str</span> = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;option&#x27;</span>]);<span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;xxxxx/option.php&#x27;</span>);<span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;|\$option=\&#x27;.*\&#x27;;|&#x27;</span>, <span class="hljs-string">&quot;\$option=&#x27;<span class="hljs-subst">$str</span>&#x27;;&quot;</span>, <span class="hljs-variable">$file</span>);<span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&#x27;xxxxx/option.php&#x27;</span>, <span class="hljs-variable">$file</span>);</code></pre></div><blockquote><p>xxxxx&#x2F;option.php</p></blockquote><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$option</span>=<span class="hljs-string">&#x27;test&#x27;</span>;<span class="hljs-meta">?&gt;</span></code></pre></div><p>程序逻辑大致如下：</p><ol><li>将传入的<strong>option</strong>参数进行**addslashes()**字符串转义操作</li><li>通过正则将**$file<strong>中的</strong>test<strong>改为</strong>$str**的值</li><li>将修改后的值写入文件</li></ol><p>这个问题是在p师傅的知识星球里面提出来的，CHY师傅整理出来的，这种情景通常出现在配置文件写入中。</p><h3 id="方法一：换行符突破"><a href="#方法一：换行符突破" class="headerlink" title="方法一：换行符突破"></a>方法一：换行符突破</h3><blockquote><div class="code-wrapper"><pre><code class="hljs php">?option=aaa<span class="hljs-string">&#x27;;%0aphpinfo();//</span></code></pre></div></blockquote><p>经过<strong>addslashes()<strong>处理过后，</strong>$str &#x3D; aaa\‘;%0aphpinfo();&#x2F;&#x2F;</strong></p><p>通过正则匹配过后写入文件，<strong>option.php</strong>的内容变为如下内容</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$option</span>=<span class="hljs-string">&#x27;aaa\&#x27;;</span><span class="hljs-string">phpinfo();//&#x27;</span>;<span class="hljs-meta">?&gt;</span></code></pre></div><p>可以看出后一个单引号被转义，所以单引号并没有被闭合，那么<strong>phpinfo</strong>就不能执行，所以再进行一次写入。</p><blockquote><p>?option&#x3D;xxx</p></blockquote><p>再次进行正则匹配时候，则会将引号里面的替换为<strong>xxx</strong>，此时<strong>option.php</strong>内容如下：</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$option</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>;<span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-comment">//&#x27;;</span><span class="hljs-meta">?&gt;</span></code></pre></div><p>这时候就可以执行<strong>phpinfo</strong>。</p><h3 id="方法二：preg-replace-的转义"><a href="#方法二：preg-replace-的转义" class="headerlink" title="方法二：preg_replace()的转义"></a>方法二：preg_replace()的转义</h3> <div class="code-wrapper"><pre><code class="hljs php">?option=aaa\<span class="hljs-string">&#x27;;phpinfo();//</span></code></pre></div><p><strong>addslashes()<strong>转换过后</strong>$str &#x3D; aaa\\\‘;phpinfo();&#x2F;&#x2F;</strong></p><p>经过<strong>preg_replace()<strong>匹配过后，会对</strong>\</strong>进行转义处理，所以写入的信息如下：</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$option</span>=<span class="hljs-string">&#x27;aaa\\&#x27;</span>;<span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-comment">//&#x27;;</span><span class="hljs-meta">?&gt;</span></code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Reference：</p><blockquote><p><a href="http://www.cnblogs.com/iamstudy/articles/config_file_write_vue.html">http://www.cnblogs.com/iamstudy/articles/config_file_write_vue.html</a></p><p>P师傅知识星球</p></blockquote><p>不断的学习</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
      <tag>安全</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP数组整数键名截断问题</title>
    <link href="/2018/Web%E5%AE%89%E5%85%A8/phpBug-69892/"/>
    <url>/2018/Web%E5%AE%89%E5%85%A8/phpBug-69892/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间在做CHY师傅整理的CTF代码审计题目，遇到较难或者比较有意思的题目，都会记下笔记，这次分享一篇关于PHP处理数组时的一个漏洞，这里给出CHY师傅的题目地址：</p><blockquote><p><a href="https://github.com/CHYbeta/Code-Audit-Challenges/">https://github.com/CHYbeta/Code-Audit-Challenges/</a></p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先看看PHP官方对这个错误的介绍：</p><blockquote><p><a href="https://bugs.php.net/bug.php?id=69892">https://bugs.php.net/bug.php?id=69892</a></p></blockquote><blockquote><p>var_dump([0 &#x3D;&gt; 0] &#x3D;&#x3D;&#x3D; [0x100000000 &#x3D;&gt; 0]); &#x2F;&#x2F; bool(true)</p></blockquote><p>下面来看代码：</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">/*******************************************************************</span><span class="hljs-comment"> * PHP Challenge 2015</span><span class="hljs-comment"> *******************************************************************</span><span class="hljs-comment"> * Why leave all the fun to the XSS crowd?</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Do you know PHP?</span><span class="hljs-comment"> * And are you up to date with all its latest peculiarities?</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Are you sure?</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * If you believe you do then solve this challenge and create an</span><span class="hljs-comment"> * input that will make the following code believe you are the ADMIN.</span><span class="hljs-comment"> * Becoming any other user is not good enough, but a first step.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Attention this code is installed on a Mac OS X 10.9 system</span><span class="hljs-comment"> * that is running PHP 5.4.30 !!!</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * TIPS: OS X is mentioned because OS X never runs latest PHP</span><span class="hljs-comment"> *       Challenge will not work with latest PHP</span><span class="hljs-comment"> *       Also challenge will only work on 64bit systems</span><span class="hljs-comment"> *       To solve challenge you need to combine what a normal</span><span class="hljs-comment"> *       attacker would do when he sees this code with knowledge</span><span class="hljs-comment"> *       about latest known PHP quirks</span><span class="hljs-comment"> *       And you cannot bruteforce the admin password directly.</span><span class="hljs-comment"> *       To give you an idea - first half is:</span><span class="hljs-comment"> *          orewgfpeowöfgphewoöfeiuwgöpuerhjwfiuvuger</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * If you know the answer please submit it to info<span class="hljs-doctag">@sektioneins</span>.de</span><span class="hljs-comment"> ********************************************************************/</span><span class="hljs-variable">$users</span> = <span class="hljs-keyword">array</span>(        <span class="hljs-string">&quot;0:9b5c3d2b64b8f74e56edec71462bd97a&quot;</span> ,        <span class="hljs-string">&quot;1:4eb5fb1501102508a86971773849d266&quot;</span>,        <span class="hljs-string">&quot;2:facabd94d57fc9f1e655ef9ce891e86e&quot;</span>,        <span class="hljs-string">&quot;3:ce3924f011fe323df3a6a95222b0c909&quot;</span>,        <span class="hljs-string">&quot;4:7f6618422e6a7ca2e939bd83abde402c&quot;</span>,        <span class="hljs-string">&quot;5:06e2b745f3124f7d670f78eabaa94809&quot;</span>,        <span class="hljs-string">&quot;6:8e39a6e40900bb0824a8e150c0d0d59f&quot;</span>,        <span class="hljs-string">&quot;7:d035e1a80bbb377ce1edce42728849f2&quot;</span>,        <span class="hljs-string">&quot;8:0927d64a71a9d0078c274fc5f4f10821&quot;</span>,        <span class="hljs-string">&quot;9:e2e23d64a642ee82c7a270c6c76df142&quot;</span>,        <span class="hljs-string">&quot;10:70298593dd7ada576aff61b6750b9118&quot;</span>);<span class="hljs-variable">$valid_user</span> = <span class="hljs-literal">false</span>;<span class="hljs-variable">$input</span> = <span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;user&#x27;</span>];<span class="hljs-variable">$input</span>[<span class="hljs-number">1</span>] = <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$input</span>[<span class="hljs-number">1</span>]);<span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$users</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$user</span>)&#123;        <span class="hljs-variable">$user</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-variable">$user</span>);        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$input</span> === <span class="hljs-variable">$user</span>) &#123;                <span class="hljs-variable">$uid</span> = <span class="hljs-variable">$input</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>;                <span class="hljs-variable">$valid_user</span> = <span class="hljs-literal">true</span>;        &#125;&#125;<span class="hljs-keyword">if</span> (!<span class="hljs-variable">$valid_user</span>) &#123;        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;not a valid user\n&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-variable">$uid</span> == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello Admin How can I serve you today?\n&quot;</span>;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;SECRETS ....\n&quot;</span>;&#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Welcome back user\n&quot;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>首先来看看代码逻辑：</p><blockquote><ul><li>从<strong>cookie</strong>中获取<strong>user</strong></li><li>遍历定义的<strong>users</strong>数组，判断传入的数据<strong>input</strong>是否等于它</li></ul></blockquote><p>这里我们要绕过两个条件判断，经过md5解密网站的测试，发现只能解出这一条。</p><blockquote><p>06e2b745f3124f7d670f78eabaa94809      &#x2F;&#x2F;hund</p></blockquote><p>初步可以判断传入的数据为：<strong>Cookie: user[0]&#x3D;5;user[1]&#x3D;hund;</strong><br>这样传入数据，就可以成功绕过第一个判断，接下来只要让<strong>uid</strong>为0即可。<br>根据前面给出的数组处理漏洞，分析一下PHP源码<strong>php-src&#x2F;Zend&#x2F;zend_hash.c</strong></p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-comment">//php5.2.14</span>ZEND_API <span class="hljs-type">int</span> <span class="hljs-title function_">zend_hash_compare</span><span class="hljs-params">(HashTable *ht1, HashTable *ht2, <span class="hljs-type">compare_func_t</span> compar, zend_bool ordered TSRMLS_DC)</span>&#123;Bucket *p1, *p2 = <span class="hljs-literal">NULL</span>;<span class="hljs-type">int</span> result;<span class="hljs-type">void</span> *pData2;IS_CONSISTENT(ht1);IS_CONSISTENT(ht2);HASH_PROTECT_RECURSION(ht1); HASH_PROTECT_RECURSION(ht2); result = ht1-&gt;nNumOfElements - ht2-&gt;nNumOfElements;<span class="hljs-keyword">if</span> (result!=<span class="hljs-number">0</span>) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> result;&#125;p1 = ht1-&gt;pListHead;<span class="hljs-keyword">if</span> (ordered) &#123;p2 = ht2-&gt;pListHead;&#125;<span class="hljs-keyword">while</span> (p1) &#123;<span class="hljs-keyword">if</span> (ordered &amp;&amp; !p2) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">/* That&#x27;s not supposed to happen */</span>&#125;<span class="hljs-keyword">if</span> (ordered) &#123;<span class="hljs-keyword">if</span> (p1-&gt;nKeyLength==<span class="hljs-number">0</span> &amp;&amp; p2-&gt;nKeyLength==<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* numeric indices */</span>result = p1-&gt;h - p2-&gt;h;<span class="hljs-keyword">if</span> (result!=<span class="hljs-number">0</span>) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> result;&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* string indices */</span>result = p1-&gt;nKeyLength - p2-&gt;nKeyLength;<span class="hljs-keyword">if</span> (result!=<span class="hljs-number">0</span>) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> result;&#125;result = <span class="hljs-built_in">memcmp</span>(p1-&gt;arKey, p2-&gt;arKey, p1-&gt;nKeyLength);<span class="hljs-keyword">if</span> (result!=<span class="hljs-number">0</span>) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> result;&#125;&#125;pData2 = p2-&gt;pData;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (p1-&gt;nKeyLength==<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* numeric index */</span><span class="hljs-keyword">if</span> (zend_hash_index_find(ht2, p1-&gt;h, &amp;pData2)==FAILURE) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* string index */</span><span class="hljs-keyword">if</span> (zend_hash_quick_find(ht2, p1-&gt;arKey, p1-&gt;nKeyLength, p1-&gt;h, &amp;pData2)==FAILURE) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125;&#125;result = compar(p1-&gt;pData, pData2 TSRMLS_CC);<span class="hljs-keyword">if</span> (result!=<span class="hljs-number">0</span>) &#123;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> result;&#125;p1 = p1-&gt;pListNext;<span class="hljs-keyword">if</span> (ordered) &#123;p2 = p2-&gt;pListNext;&#125;&#125;HASH_UNPROTECT_RECURSION(ht1); HASH_UNPROTECT_RECURSION(ht2); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>bucket结构体：</p><div class="code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bucket</span> &#123;</span>ulong h;<span class="hljs-comment">/* Used for numeric indexing */</span>uint nKeyLength;<span class="hljs-type">void</span> *pData;<span class="hljs-type">void</span> *pDataPtr;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bucket</span> *<span class="hljs-title">pListNext</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bucket</span> *<span class="hljs-title">pListLast</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bucket</span> *<span class="hljs-title">pNext</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bucket</span> *<span class="hljs-title">pLast</span>;</span><span class="hljs-type">char</span> arKey[<span class="hljs-number">1</span>]; <span class="hljs-comment">/* Must be last element */</span>&#125; Bucket;</code></pre></div><p>关键点就在<strong>result &#x3D; p1-&gt;h - p2-&gt;h</strong>，在<strong>unsigned long</strong>转为<strong>int</strong>时会少掉4个字节。<br>4294967296转为int就为0。<br>最终payload：</p><blockquote><p><strong>Cookie: user[4294967296]&#x3D;5;user[1]&#x3D;hund;</strong></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不断的前进</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
      <tag>安全</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP弱类型产生的安全问题</title>
    <link href="/2018/Web%E5%AE%89%E5%85%A8/php-weak-type/"/>
    <url>/2018/Web%E5%AE%89%E5%85%A8/php-weak-type/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PHP作为一种弱类型编程语言，在定义变量时无需像C++等强类型时定义数据类型。</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$a</span> = <span class="hljs-number">1</span>;<span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-variable">$a</span> = [];<span class="hljs-meta">?&gt;</span></code></pre></div><p>上述代码可以正常运行，在PHP中可以随时将变量改成其他数据类型。下面再来看一个例子：</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$a</span> = <span class="hljs-string">&#x27;1&#x27;</span>;   <span class="hljs-comment">//a现在是字符串&#x27;1&#x27;</span><span class="hljs-variable">$a</span> *= <span class="hljs-number">2</span>;    <span class="hljs-comment">//a现在是整数2</span><span class="hljs-meta">?&gt;</span></code></pre></div><p>下面就从具体的实例中总结一下弱类型产生的安全问题。</p><h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>PHP有这些比较运算符</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//相等</span><span class="hljs-variable">$a</span> === <span class="hljs-variable">$b</span>;  <span class="hljs-comment">//全等</span><span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//不等</span><span class="hljs-variable">$a</span> &lt;&gt; <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//不等</span><span class="hljs-variable">$a</span> !== <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//不全等</span><span class="hljs-variable">$a</span> &lt; <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//小于</span><span class="hljs-variable">$a</span> &gt; <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//大于</span><span class="hljs-variable">$a</span> &lt;= <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//小于等于</span><span class="hljs-variable">$a</span> &gt;= <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//大于等于</span><span class="hljs-variable">$a</span> &lt;==&gt; <span class="hljs-variable">$b</span>;   <span class="hljs-comment">//太空船运算符：当$a小于、等于、大于$b时分别返回一个小于、等于、大于0的integer 值。 PHP7开始提供.  </span><span class="hljs-variable">$a</span> ?? <span class="hljs-variable">$b</span> ?? <span class="hljs-variable">$c</span>;   <span class="hljs-comment">//NULL 合并操作符 从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL。PHP7开始提供。 </span><span class="hljs-meta">?&gt;</span></code></pre></div><p>存在安全问题的一般都是运算符在类型转换时产生的。给出PHP手册中比较的表格。</p><blockquote><p><a href="http://php.net/manual/zh/types.comparisons.php">http://php.net/manual/zh/types.comparisons.php</a></p></blockquote><p>下面看一段从PHP手册中摘的一段：</p><blockquote><p>如果该字符串没有包含 ‘.’，’e’ 或 ‘E’ 并且其数字值在整型的范围之内（由 PHP_INT_MAX 所定义），该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。 </p></blockquote><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$foo</span> = <span class="hljs-number">1</span> + <span class="hljs-string">&quot;10.5&quot;</span>;                <span class="hljs-comment">// $foo is float (11.5)</span><span class="hljs-variable">$foo</span> = <span class="hljs-number">1</span> + <span class="hljs-string">&quot;-1.3e3&quot;</span>;              <span class="hljs-comment">// $foo is float (-1299)</span><span class="hljs-variable">$foo</span> = <span class="hljs-number">1</span> + <span class="hljs-string">&quot;bob-1.3e3&quot;</span>;           <span class="hljs-comment">// $foo is integer (1)</span><span class="hljs-variable">$foo</span> = <span class="hljs-number">1</span> + <span class="hljs-string">&quot;bob3&quot;</span>;                <span class="hljs-comment">// $foo is integer (1)</span><span class="hljs-variable">$foo</span> = <span class="hljs-number">1</span> + <span class="hljs-string">&quot;10 Small Pigs&quot;</span>;       <span class="hljs-comment">// $foo is integer (11)</span><span class="hljs-variable">$foo</span> = <span class="hljs-number">4</span> + <span class="hljs-string">&quot;10.2 Little Piggies&quot;</span>; <span class="hljs-comment">// $foo is float (14.2)</span><span class="hljs-variable">$foo</span> = <span class="hljs-string">&quot;10.0 pigs &quot;</span> + <span class="hljs-number">1</span>;          <span class="hljs-comment">// $foo is float (11)</span><span class="hljs-variable">$foo</span> = <span class="hljs-string">&quot;10.0 pigs &quot;</span> + <span class="hljs-number">1.0</span>;        <span class="hljs-comment">// $foo is float (11)     </span><span class="hljs-meta">?&gt;</span></code></pre></div><p>可以看到字符串中如果有’.’或者e(E)，字符串将会被解析为整数或者浮点数。这些特性在处理Hash字符串时会产生一些安全问题。</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-string">&quot;0e132456789&quot;</span>==<span class="hljs-string">&quot;0e7124511451155&quot;</span> <span class="hljs-comment">//true</span><span class="hljs-string">&quot;0e123456abc&quot;</span>==<span class="hljs-string">&quot;0e1dddada&quot;</span><span class="hljs-comment">//false</span><span class="hljs-string">&quot;0e1abc&quot;</span>==<span class="hljs-string">&quot;0&quot;</span>     <span class="hljs-comment">//true</span><span class="hljs-string">&quot;0admin&quot;</span> == <span class="hljs-string">&quot;0&quot;</span>     <span class="hljs-comment">//ture</span><span class="hljs-string">&quot;0x1e240&quot;</span>==<span class="hljs-string">&quot;123456&quot;</span><span class="hljs-comment">//true</span><span class="hljs-string">&quot;0x1e240&quot;</span>==<span class="hljs-number">123456</span><span class="hljs-comment">//true</span><span class="hljs-string">&quot;0x1e240&quot;</span>==<span class="hljs-string">&quot;1e240&quot;</span><span class="hljs-comment">//false</span><span class="hljs-meta">?&gt;</span></code></pre></div><p>若Hash字符串以0e开头，在进行!&#x3D;或者&#x3D;&#x3D;运算时将会被解析为科学记数法，即0的次方。<br>或字符串为0x开头，将会被当作十六进制的数。</p><p>下面给出几个以0e开头的MD5加密之后的密文。</p><div class="code-wrapper"><pre><code class="hljs dns">QNKCDZO<span class="hljs-number">0</span>e830400451993494058<span class="hljs-number">024219903391</span>  s1885207154a<span class="hljs-number">0</span>e5093672134182067008<span class="hljs-number">42008763514</span>  s1836677006a<span class="hljs-number">0</span>e4810364908676611132<span class="hljs-number">60034900752</span>  s155964671a<span class="hljs-number">0</span>e342768416822451524<span class="hljs-number">974117254469</span>  s1184209335a<span class="hljs-number">0</span>e072485820392773389<span class="hljs-number">523109082030</span></code></pre></div><p>下面从具体函数理解弱类型带来的问题。</p><h1 id="具体函数"><a href="#具体函数" class="headerlink" title="具体函数"></a>具体函数</h1><h2 id="md5"><a href="#md5" class="headerlink" title="md5()"></a>md5()</h2><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;Username&#x27;</span>]) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;    <span class="hljs-variable">$logined</span> = <span class="hljs-literal">true</span>;    <span class="hljs-variable">$Username</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;Username&#x27;</span>];    <span class="hljs-variable">$password</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>];     <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">ctype_alpha</span>(<span class="hljs-variable">$Username</span>)) &#123;<span class="hljs-variable">$logined</span> = <span class="hljs-literal">false</span>;&#125;     <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$password</span>) ) &#123;<span class="hljs-variable">$logined</span> = <span class="hljs-literal">false</span>;&#125;     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$Username</span>) != <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$password</span>)) &#123;<span class="hljs-variable">$logined</span> = <span class="hljs-literal">false</span>;&#125;     <span class="hljs-keyword">if</span> (<span class="hljs-variable">$logined</span>)&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;successful&quot;</span>;      &#125;<span class="hljs-keyword">else</span>&#123;           <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;login failed!&quot;</span>;        &#125;    &#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>要求输入的username为字母，password为数字，并且两个变量的MD5必须一样，这时就可以考虑以0e开头的MD5密文。<strong>md5(‘240610708’) &#x3D;&#x3D; md5(‘QNKCDZO’)</strong> 可以成功得到flag。</p><h2 id="sha1"><a href="#sha1" class="headerlink" title="sha1()"></a>sha1()</h2><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;flag&quot;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) === <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]))      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;</span>;&#125;<span class="hljs-keyword">else</span>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;</span>;<span class="hljs-meta">?&gt;</span></code></pre></div><p>sha1函数需要传入的数据类型为字符串类型，如果传入数组类型则会返回NULL</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-title function_ invoke__">sha1</span>([<span class="hljs-number">1</span>]));<span class="hljs-comment">//NULL</span></code></pre></div><p>因此传入<strong>name[]&#x3D;1&amp;password[]&#x3D;2</strong> 即可成功绕过</p><h2 id="strcmp-php-version-5-3"><a href="#strcmp-php-version-5-3" class="headerlink" title="strcmp()   php version &lt; 5.3"></a>strcmp()   php version &lt; 5.3</h2><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-variable">$password</span>=<span class="hljs-string">&quot;***************&quot;</span>     <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]))&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-variable">$password</span>) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Right!!!login success&quot;</span>;n            <span class="hljs-keyword">exit</span>();        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Wrong password..&quot;</span>;        &#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>和sha1()函数一样，strcmp()是字符串处理函数，如果给strcmp()函数传入数组，无论数据是否相等都会返回0，当然这只存在与PHP版本小于5.3之中。</p><h2 id="intval"><a href="#intval" class="headerlink" title="intval()"></a>intval()</h2><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[id]) &#123;   <span class="hljs-title function_ invoke__">mysql_connect</span>(SAE_MYSQL_HOST_M . <span class="hljs-string">&#x27;:&#x27;</span> . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);  <span class="hljs-title function_ invoke__">mysql_select_db</span>(SAE_MYSQL_DB);  <span class="hljs-variable">$id</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$_GET</span>[id]);  <span class="hljs-variable">$query</span> = @<span class="hljs-title function_ invoke__">mysql_fetch_array</span>(<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">&quot;select content from ctf2 where id=&#x27;<span class="hljs-subst">$id</span>&#x27;&quot;</span>));  <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[id]==<span class="hljs-number">1024</span>) &#123;      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;</span>;  &#125;  <span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span>(<span class="hljs-variable">$query</span>[content]);  &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>intval()函数获取变量的整数值,程序要求从浏览器获得的id值不为1024，因此输入<strong>1024.1</strong>即可获得flag。</p><h2 id="json-decode"><a href="#json-decode" class="headerlink" title="json_decode()"></a>json_decode()</h2><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;message&#x27;</span>])) &#123;    <span class="hljs-variable">$message</span> = <span class="hljs-title function_ invoke__">json_decode</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;message&#x27;</span>]);    <span class="hljs-variable">$key</span> =<span class="hljs-string">&quot;*********&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$message</span>-&gt;key == <span class="hljs-variable">$key</span>) &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;flag&quot;</span>;    &#125;     <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;fail&quot;</span>;    &#125; &#125; <span class="hljs-keyword">else</span>&#123;     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;~~~~&quot;</span>; &#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>需要POST的message中的key值等于程序中的key值，如果传入的key为整数0，那么在比较运算符&#x3D;&#x3D;的运算下，将会判定字符串为整数0，那么只需要传入数据：<strong>message&#x3D;{“key”:0}</strong></p><h2 id="array-search-和-in-array"><a href="#array-search-和-in-array" class="headerlink" title="array_search() 和  in_array()"></a>array_search() 和  in_array()</h2><p>上面两个函数和前面d额是一样的问题，会存在下面的一些转换为题：</p><blockquote><p>“admin” &#x3D;&#x3D; 0; &#x2F;&#x2F;true<br>“1admin” &#x3D;&#x3D; 1; &#x2F;&#x2F;true</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>熬夜写文章已经很晚了，就懒得再写总结了。以后每周总结一篇关于代码审计的小知识点。</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
      <tag>安全</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-南京之行</title>
    <link href="/2018/%E9%9A%8F%E7%AC%94/2018-nanjing/"/>
    <url>/2018/%E9%9A%8F%E7%AC%94/2018-nanjing/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>终于趁着学校开运动会和周末一共四天的时间去了一趟南京。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/nanjing/la.jpg"><br>下车就是南京的玄武区，第一感觉就是有点脏乱，没有想象中的好，随后立马去板仓街找在携程上面订的宾馆。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/nanjing/bancang.jpg"><br>宾馆离太阳宫很近，走路十分钟就能到，随后骑单车在玄武湖公园走走逛逛。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/nanjing/xuanwuhu.jpg"></p><p>然后去欧拉艺术空间踩个点，怕晚上找不到。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/nanjing/ola.jpg"></p><p>演出前<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/nanjing/ola2.jpg"><br>暖场的南京本地金属核乐队很nb，气氛带的很好。<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/nanjing/ola3.jpg"><br>现场总是很真实的，pogo，死墙，开火车，跳水。<br>演出一直到十一点，南京牛逼。<br>第二天起床去汽车东站接从镇江来的同学一起去南工大找同学，路过南京艺术学院，不得不说艺校的气质在校门口就能感觉到。随后在南工大蹭了一节课。<br>早上坐公交准备离开了。路过应天大街，热河路，盐仓桥，挹江门.</p><blockquote><p>32路还是穿过挹江门。</p></blockquote><p>第一次来南京，南京，下次见。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解PHP变量覆盖漏洞</title>
    <link href="/2018/Web%E5%AE%89%E5%85%A8/php-audit-cover/"/>
    <url>/2018/Web%E5%AE%89%E5%85%A8/php-audit-cover/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>变量覆盖漏洞是指攻击者使用自定义的变量去覆盖源代码中的变量，从而改变代码逻辑，实现攻击目的的一种漏洞。</p><p>通常造成变量覆盖的往往是以下几种情况：</p><ul><li>register_globals&#x3D;On （PHP5.3废弃，PHP5.4中已经正式移除此功能）</li><li>可变变量</li><li>extract()</li><li>parse_str()</li><li>import_request_variables()<br>下面正式介绍变量覆盖的具体利用方法与原理。</li></ul><h2 id="0x02-正文"><a href="#0x02-正文" class="headerlink" title="0x02 正文"></a>0x02 正文</h2><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="$可变变量"></a>$可变变量</h3><p>看下面一段代码：</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;_COOKIE&#x27;</span>,<span class="hljs-string">&#x27;_POST&#x27;</span>,<span class="hljs-string">&#x27;_GET&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$_request</span>)  &#123;    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$$_request</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$_key</span>=&gt;<span class="hljs-variable">$_value</span>)      &#123;        <span class="hljs-variable">$$_key</span>=  <span class="hljs-variable">$_value</span>;    &#125;&#125;<span class="hljs-variable">$id</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$id</span>) ? <span class="hljs-variable">$id</span> : <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(<span class="hljs-variable">$id</span> == <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;flag&#123;xx&#125;&quot;</span>;    <span class="hljs-keyword">die</span>();&#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>使用foreach遍历COOKIE，POST，GET数组，然后将数组键名作为变量名，键值作为变量值。上述代码传入id&#x3D;1即可得到flag。</p><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>首先看看手册中对该函数的定义<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/php-cover/cover1.jpg"></p><p>下面从实例讲起:</p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$flag</span>=<span class="hljs-string">&#x27;flag&#123;xxxxx&#125;&#x27;</span>; <span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$_GET</span>); <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>)) &#123;     <span class="hljs-variable">$content</span>=<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$flag</span>));    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$a</span>==<span class="hljs-variable">$content</span>)    &#123;         <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;     &#125;   <span class="hljs-keyword">else</span>   &#123;     <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Oh.no&#x27;</span>;   &#125;    &#125;<span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;input a value&quot;</span>;   &#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>首先extract函数将所有GET方法得到的数组键名与键值转化为内部变量与值，接可以看到content变量使用file_get_contents()读入一个文件，由于trim()函数处理后，content变量变为一个空字符串，代码逻辑只需要<strong>a &#x3D;&#x3D; content</strong>即可。</p><p>传入 <strong>?a&#x3D;</strong> 即可得到flag。</p><h3 id="parse-str"><a href="#parse-str" class="headerlink" title="parse_str()"></a>parse_str()</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/cover3.jpg"></p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-title function_ invoke__">parse_str</span>(<span class="hljs-string">&quot;a=1&quot;</span>);<span class="hljs-keyword">echo</span> <span class="hljs-variable">$a</span>.<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>;      <span class="hljs-comment">//$a=1</span><span class="hljs-title function_ invoke__">parse_str</span>(<span class="hljs-string">&quot;b=1&amp;c=2&quot;</span>,<span class="hljs-variable">$myArray</span>);<span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$myArray</span>);   <span class="hljs-comment">//Array ( [b] =&gt; 1 [c] =&gt; 2 ) </span><span class="hljs-meta">?&gt;</span></code></pre></div><p>这个简单的实例中可以看出parse_str可以将字符串解析为变量与值。</p><h3 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h3><p><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/import.jpg"></p><div class="code-wrapper"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// 此处将导入 GET 和 POST 变量</span><span class="hljs-comment">// 使用&quot;rvar_&quot;作为前缀</span><span class="hljs-variable">$rvar_foo</span> = <span class="hljs-number">1</span>;<span class="hljs-title function_ invoke__">import_request_variables</span>(<span class="hljs-string">&quot;gP&quot;</span>, <span class="hljs-string">&quot;rvar_&quot;</span>);<span class="hljs-keyword">echo</span> <span class="hljs-variable">$rvar_foo</span>;<span class="hljs-meta">?&gt;</span></code></pre></div><p>通过import_request_variables函数作用后，可以对原变量值进行覆盖。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>博客文章以后会在公众号上同步发布，欢迎师傅们关注。微信号：coding_lin</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
      <tag>安全</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析文件上传漏洞</title>
    <link href="/2018/Web%E5%AE%89%E5%85%A8/uploadvul/"/>
    <url>/2018/Web%E5%AE%89%E5%85%A8/uploadvul/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="0x01简介"><a href="#0x01简介" class="headerlink" title="0x01简介"></a>0x01简介</h1><p>文件上传漏洞简而言之就是攻击者可以通过某些手段上传非法文件到服务器端的一种漏洞，攻击者往往会以此得到webshell，从而进一步提权。为此开发者也会想出各种方法去防止上传漏洞的产生。以下列出几种常见的校验方式：</p><ul><li><p>前端JS校验</p></li><li><p>content-type字段校验</p></li><li><p>服务器端后缀名校验</p></li><li><p>文件头校验</p></li><li><p>服务器端扩展名校验</p><p>下面从几个实例来详细解释上传漏洞的原理与突破方法。</p></li></ul><h1 id="0x02正文"><a href="#0x02正文" class="headerlink" title="0x02正文"></a>0x02正文</h1><h3 id="一、前端JS校验"><a href="#一、前端JS校验" class="headerlink" title="一、前端JS校验"></a>一、前端JS校验</h3><p>JS校验往往只是通过脚本获得文件的后缀名，再通过白名单验证，以下列出JS代码供参考：</p><div class="code-wrapper"><pre><code class="hljs JavaScript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkFile</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">var</span> file = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByName</span>(<span class="hljs-string">&#x27;upload_file&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>;        <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">null</span> || file == <span class="hljs-string">&quot;&quot;</span>) &#123;            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;请选择要上传的文件!&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//定义允许上传的文件类型</span>        <span class="hljs-keyword">var</span> allow_ext = <span class="hljs-string">&quot;.jpg|.png|.gif&quot;</span>;        <span class="hljs-comment">//提取上传文件的类型</span>        <span class="hljs-keyword">var</span> ext_name = file.<span class="hljs-title function_">substring</span>(file.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;.&quot;</span>));        <span class="hljs-comment">//判断上传文件类型是否允许上传</span>        <span class="hljs-keyword">if</span> (allow_ext.<span class="hljs-title function_">indexOf</span>(ext_name) == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">var</span> errMsg = <span class="hljs-string">&quot;该文件不允许上传，请上传&quot;</span> + allow_ext + <span class="hljs-string">&quot;类型的文件,当前文件类型为：&quot;</span> + ext_name;            <span class="hljs-title function_">alert</span>(errMsg);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;&lt;/script&gt;</code></pre></div><p>此种校验方式往往很容易突破，一种是通过抓取HTTP数据包，修改重放便可以突破。或者通过浏览器修改前端代码，从而改变代码逻辑。</p><h3 id="二、content-type字段校验"><a href="#二、content-type字段校验" class="headerlink" title="二、content-type字段校验"></a>二、content-type字段校验</h3><p>首先对MIME进行简单的知识普及</p><blockquote><p><a href="http://www.cnblogs.com/jsean/articles/1610265.html">http://www.cnblogs.com/jsean/articles/1610265.html</a></p></blockquote><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types</a></p></blockquote><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;userfile&#x27;</span>][<span class="hljs-string">&#x27;type&#x27;</span>] != <span class="hljs-string">&quot;image/gif&quot;</span>)  <span class="hljs-comment">#这里对上传的文件类型进行判断，如果不是image/gif类型便返回错误。</span>                &#123;                    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Sorry, we only allow uploading GIF images&quot;</span>;                 <span class="hljs-keyword">exit</span>;                 &#125;         <span class="hljs-variable">$uploaddir</span> = <span class="hljs-string">&#x27;uploads/&#x27;</span>;         <span class="hljs-variable">$uploadfile</span> = <span class="hljs-variable">$uploaddir</span> . <span class="hljs-title function_ invoke__">basename</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;userfile&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);         <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;userfile&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>], <span class="hljs-variable">$uploadfile</span>))             &#123;                 <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;File is valid, and was successfully uploaded.\n&quot;</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;File uploading failed.\n&quot;</span>;    &#125;     <span class="hljs-meta">?&gt;</span></code></pre></div><p>此类校验方式绕过也十分简单，burpsuite截取数据包，修改content-type值，发送数据包即可。</p><h3 id="三、文件头校验"><a href="#三、文件头校验" class="headerlink" title="三、文件头校验"></a>三、文件头校验</h3><p>文件头基本概念：</p><blockquote><p><a href="https://www.cnblogs.com/mq0036/p/3912355.html">https://www.cnblogs.com/mq0036/p/3912355.html</a></p></blockquote><p>上传webshell的过程中,添加文件头便可以突破此类校验。例如</p><div class="code-wrapper"><pre><code class="hljs php">GIF89a<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>(); <span class="hljs-meta">?&gt;</span></code></pre></div><h3 id="四、服务器端扩展名校验"><a href="#四、服务器端扩展名校验" class="headerlink" title="四、服务器端扩展名校验"></a>四、服务器端扩展名校验</h3><p>此类校验的上传绕过往往较为复杂，常常与其他漏洞搭配使用，如解析漏洞，文件包含漏洞。</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-variable">$type</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;php&quot;</span>,<span class="hljs-string">&quot;php3&quot;</span>);<span class="hljs-comment">//判断上传文件类型</span><span class="hljs-variable">$fileext</span> = <span class="hljs-title function_ invoke__">fileext</span>(<span class="hljs-variable">$_FILE</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);<span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$fileext</span>,<span class="hljs-variable">$type</span>))&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;upload success!&quot;</span>;&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sorry&quot;</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>Apache解析漏洞，IIS6.0解析漏洞在此不再过多阐述。</p><h3 id="五、编辑器上传漏洞"><a href="#五、编辑器上传漏洞" class="headerlink" title="五、编辑器上传漏洞"></a>五、编辑器上传漏洞</h3><p>早期编辑器例如FCK,eWeb编辑器正在逐渐淡出市场，但是并没有使富文本编辑器的占用率变低，因此在渗透测试的过程中，一般可以查找编辑器漏洞从而获得webshell。</p><h1 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h1><p>在渗透测试的过程中,遇到上传点，通常情况下截取数据包，再通过各种姿势进行bypass。关于防护的几点建议：</p><ul><li>在服务器端进行校验</li><li>上传的文件可以进行时间戳md5进行命名</li><li>上传的路径隐藏</li><li>文件存储目录权限控制</li></ul><p>当然最重要的是，维持网站中间件的安全，杜绝旧版解析漏洞的存在。</p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
      <tag>安全</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京邮电大学CTF平台Web系列WriteUp</title>
    <link href="/2018/Web%E5%AE%89%E5%85%A8/nctf/"/>
    <url>/2018/Web%E5%AE%89%E5%85%A8/nctf/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="签到1"><a href="#签到1" class="headerlink" title="签到1"></a>签到1</h2><p>直接查看源代码，得到flag<br>nctf{flag_admiaanaaaaaaaaaaa}</p><h2 id="签到2"><a href="#签到2" class="headerlink" title="签到2"></a>签到2</h2><p>要求输入zhimakaimen<br>审查元素更改输入框type为text 长度改为11<br>提交得到nctf{follow_me_to_exploit}</p><h2 id="这题不是Web"><a href="#这题不是Web" class="headerlink" title="这题不是Web"></a>这题不是Web</h2><p>这题真的不是Web<br>下载图片，以文本方式打开，最后一行即为flag</p><h2 id="层层递进"><a href="#层层递进" class="headerlink" title="层层递进"></a>层层递进</h2><p>burpsuite抓包之后，扫出一个404.html<br>源代码如下</p><!-- more --><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">HTML</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">HEAD</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">TITLE</span>&gt;</span>有人偷偷先做题，哈哈飞了吧？<span class="hljs-tag">&lt;/<span class="hljs-name">TITLE</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">META</span> <span class="hljs-attr">HTTP-EQUIV</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;text/html; charset=GB2312&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">STYLE</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-tag">BODY</span> &#123; <span class="hljs-attribute">font</span>: <span class="hljs-number">9pt</span>/<span class="hljs-number">12pt</span> 宋体 &#125;</span><span class="language-css">  <span class="hljs-selector-tag">H1</span> &#123; <span class="hljs-attribute">font</span>: <span class="hljs-number">12pt</span>/<span class="hljs-number">15pt</span> 宋体 &#125;</span><span class="language-css">  <span class="hljs-selector-tag">H2</span> &#123; <span class="hljs-attribute">font</span>: <span class="hljs-number">9pt</span>/<span class="hljs-number">12pt</span> 宋体 &#125;</span><span class="language-css">  <span class="hljs-selector-tag">A</span><span class="hljs-selector-pseudo">:link</span> &#123; <span class="hljs-attribute">color</span>: red &#125;</span><span class="language-css">  <span class="hljs-selector-tag">A</span><span class="hljs-selector-pseudo">:visited</span> &#123; <span class="hljs-attribute">color</span>: maroon &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">STYLE</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HEAD</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">BODY</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">TABLE</span> <span class="hljs-attr">width</span>=<span class="hljs-string">500</span> <span class="hljs-attr">border</span>=<span class="hljs-string">0</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">10</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">TR</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">TD</span>&gt;</span><span class="hljs-comment">&lt;!-- Placed at the end of the document so the pages load faster --&gt;</span><span class="hljs-comment">&lt;!--  </span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-n.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-c.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-t.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-f.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-&#123;.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-t.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-h.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-i.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-s.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-_.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-i.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-s.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-_.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-a.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-_.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-f.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-l.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-4.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-g.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">&lt;script src=&quot;./js/jquery-&#125;.7.2.min.js&quot;&gt;&lt;/script&gt;</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>来来来，听我讲个故事：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>从前，我是一个好女孩，我喜欢上了一个男孩小A。<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有一天，我终于决定要和他表白了！话到嘴边，鼓起勇气...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>可是我却又害怕的<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:history.back(1)&quot;</span>&gt;</span>后退<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>了。。。<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>为什么？<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>为什么我这么懦弱？<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>最后，他居然向我表白了，好开森...说只要骗足够多的笨蛋来这里听这个蠢故事浪费时间，<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>他就同意和我交往！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>谢谢你给出的一份支持！哇哈哈\(^o^)/~！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TD</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TR</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TABLE</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">BODY</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HTML</span>&gt;</span></code></pre></div><p>注意引入的js文件名</p><h2 id="单身二十年"><a href="#单身二十年" class="headerlink" title="单身二十年"></a>单身二十年</h2><p>burpsuite爬行出一个search_key.php，flag藏在Response里面</p><h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2><p>打开首先提示robots.txt，打开发现以下代码</p><div class="code-wrapper"><pre><code class="hljs php">TIP:sql.php<span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[id]) &#123;   <span class="hljs-title function_ invoke__">mysql_connect</span>(SAE_MYSQL_HOST_M . <span class="hljs-string">&#x27;:&#x27;</span> . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);  <span class="hljs-title function_ invoke__">mysql_select_db</span>(SAE_MYSQL_DB);  <span class="hljs-variable">$id</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$_GET</span>[id]);  <span class="hljs-variable">$query</span> = @<span class="hljs-title function_ invoke__">mysql_fetch_array</span>(<span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-string">&quot;select content from ctf2 where id=&#x27;<span class="hljs-subst">$id</span>&#x27;&quot;</span>));  <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[id]==<span class="hljs-number">1024</span>) &#123;      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;</span>;  &#125;  <span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span>(<span class="hljs-variable">$query</span>[content]);  &#125;&#125;<span class="hljs-meta">?&gt;</span></code></pre></div><p>半吊子PHP水平分析一波，intval()函数是将变量转化为整数，需要得到的id变量为1024，但不允许输入的值为1024，因为有intval()函数，可以输入1024.1a，从而得到flag。</p><h2 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h2><p>TIP: 0&#x3D;&#x3D;not<br>给出的提示以上信息，题目又是cookie，查看cookie发现它的值为0，将它改成1，得到flag:nctf{cookie_is_different_from_session}<br><img src="https://blog-1251613845.cos.ap-shanghai.myqcloud.com/nctf1.png" alt="nctf"></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好世界</title>
    <link href="/2018/%E9%9A%8F%E7%AC%94/hello%20world/"/>
    <url>/2018/%E9%9A%8F%E7%AC%94/hello%20world/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>大概是从2014年开始就开始折腾各种博客系统，从Wordpress到Typecho，也尝试过Ghost，从虚拟空间到自己的VPS，以前就喜欢折腾各种功能，流量统计，阅读量统计等等，然而干货分享类的文章却少之又少，现在换成Hexo+Github，主要的原因就是因为它简单方便。希望自己能坚持写下去，希望新博客能够见证自己的成长，包括生活与技术:)</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
